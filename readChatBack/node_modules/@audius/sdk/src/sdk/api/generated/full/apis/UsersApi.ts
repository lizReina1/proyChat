/* tslint:disable */
// @ts-nocheck
/* eslint-disable */
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CollectionLibraryResponseFull,
  FollowingResponseFull,
  FullBulkSubscribersResponse,
  FullFollowersResponse,
  FullGetSupporter,
  FullGetSupporters,
  FullGetSupporting,
  FullReposts,
  FullSubscribersResponse,
  FullTracks,
  FullUserResponse,
  HistoryResponseFull,
  PurchasesResponse,
  RelatedArtistResponseFull,
  TopGenreUsersResponseFull,
  TopUsersResponseFull,
  TrackLibraryResponseFull,
  UsersByContentNode,
} from '../models';
import {
    CollectionLibraryResponseFullFromJSON,
    CollectionLibraryResponseFullToJSON,
    FollowingResponseFullFromJSON,
    FollowingResponseFullToJSON,
    FullBulkSubscribersResponseFromJSON,
    FullBulkSubscribersResponseToJSON,
    FullFollowersResponseFromJSON,
    FullFollowersResponseToJSON,
    FullGetSupporterFromJSON,
    FullGetSupporterToJSON,
    FullGetSupportersFromJSON,
    FullGetSupportersToJSON,
    FullGetSupportingFromJSON,
    FullGetSupportingToJSON,
    FullRepostsFromJSON,
    FullRepostsToJSON,
    FullSubscribersResponseFromJSON,
    FullSubscribersResponseToJSON,
    FullTracksFromJSON,
    FullTracksToJSON,
    FullUserResponseFromJSON,
    FullUserResponseToJSON,
    HistoryResponseFullFromJSON,
    HistoryResponseFullToJSON,
    PurchasesResponseFromJSON,
    PurchasesResponseToJSON,
    RelatedArtistResponseFullFromJSON,
    RelatedArtistResponseFullToJSON,
    TopGenreUsersResponseFullFromJSON,
    TopGenreUsersResponseFullToJSON,
    TopUsersResponseFullFromJSON,
    TopUsersResponseFullToJSON,
    TrackLibraryResponseFullFromJSON,
    TrackLibraryResponseFullToJSON,
    UsersByContentNodeFromJSON,
    UsersByContentNodeToJSON,
} from '../models';

export interface BulkGetSubscribersRequest {
    ids: Array<string>;
}

export interface BulkGetSubscribersViaJSONRequestRequest {
    ids: Array<string>;
}

export interface GetAIAttributedTracksByUserHandleRequest {
    handle: string;
    offset?: number;
    limit?: number;
    userId?: string;
    sort?: GetAIAttributedTracksByUserHandleSortEnum;
    query?: string;
    sortMethod?: GetAIAttributedTracksByUserHandleSortMethodEnum;
    sortDirection?: GetAIAttributedTracksByUserHandleSortDirectionEnum;
    filterTracks?: GetAIAttributedTracksByUserHandleFilterTracksEnum;
}

export interface GetFavoritesRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
    query?: string;
    sortMethod?: GetFavoritesSortMethodEnum;
    sortDirection?: GetFavoritesSortDirectionEnum;
}

export interface GetFollowersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetFollowingRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetPurchasesRequest {
    id: string;
    encodedDataMessage: string;
    encodedDataSignature: string;
    offset?: number;
    limit?: number;
    userId?: string;
    sortMethod?: GetPurchasesSortMethodEnum;
    sortDirection?: GetPurchasesSortDirectionEnum;
}

export interface GetRelatedUsersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetRepostsRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetRepostsByHandleRequest {
    handle: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetSalesRequest {
    id: string;
    encodedDataMessage: string;
    encodedDataSignature: string;
    offset?: number;
    limit?: number;
    userId?: string;
    sortMethod?: GetSalesSortMethodEnum;
    sortDirection?: GetSalesSortDirectionEnum;
}

export interface GetSubscribersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetSupporterRequest {
    id: string;
    supporterUserId: string;
    userId?: string;
}

export interface GetSupportersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetSupportingRequest {
    id: string;
    supportedUserId: string;
    userId?: string;
}

export interface GetSupportingsRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetTopUsersRequest {
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetTopUsersInGenreRequest {
    offset?: number;
    limit?: number;
    genre?: Array<string>;
}

export interface GetTracksByUserRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
    sort?: GetTracksByUserSortEnum;
    query?: string;
    sortMethod?: GetTracksByUserSortMethodEnum;
    sortDirection?: GetTracksByUserSortDirectionEnum;
    filterTracks?: GetTracksByUserFilterTracksEnum;
}

export interface GetTracksByUserHandleRequest {
    handle: string;
    offset?: number;
    limit?: number;
    userId?: string;
    sort?: GetTracksByUserHandleSortEnum;
    query?: string;
    sortMethod?: GetTracksByUserHandleSortMethodEnum;
    sortDirection?: GetTracksByUserHandleSortDirectionEnum;
    filterTracks?: GetTracksByUserHandleFilterTracksEnum;
}

export interface GetUserRequest {
    id: string;
    userId?: string;
}

export interface GetUserByHandleRequest {
    handle: string;
    userId?: string;
}

export interface GetUserLibraryAlbumsRequest {
    id: string;
    encodedDataMessage: string;
    encodedDataSignature: string;
    offset?: number;
    limit?: number;
    userId?: string;
    query?: string;
    sortDirection?: GetUserLibraryAlbumsSortDirectionEnum;
    type?: GetUserLibraryAlbumsTypeEnum;
    sortMethod?: GetUserLibraryAlbumsSortMethodEnum;
}

export interface GetUserLibraryPlaylistsRequest {
    id: string;
    encodedDataMessage: string;
    encodedDataSignature: string;
    offset?: number;
    limit?: number;
    userId?: string;
    query?: string;
    sortDirection?: GetUserLibraryPlaylistsSortDirectionEnum;
    type?: GetUserLibraryPlaylistsTypeEnum;
    sortMethod?: GetUserLibraryPlaylistsSortMethodEnum;
}

export interface GetUserLibraryTracksRequest {
    id: string;
    encodedDataMessage: string;
    encodedDataSignature: string;
    offset?: number;
    limit?: number;
    userId?: string;
    query?: string;
    sortMethod?: GetUserLibraryTracksSortMethodEnum;
    sortDirection?: GetUserLibraryTracksSortDirectionEnum;
    type?: GetUserLibraryTracksTypeEnum;
}

export interface GetUserReplicaSetRequest {
    id: string;
    userId?: string;
}

export interface GetUsersTrackHistoryRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
    query?: string;
    sortMethod?: GetUsersTrackHistorySortMethodEnum;
    sortDirection?: GetUsersTrackHistorySortDirectionEnum;
}

/**
 * 
 */
export class UsersApi extends runtime.BaseAPI {

    /** @hidden
     * All users that subscribe to the provided users
     */
    async bulkGetSubscribersRaw(params: BulkGetSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullBulkSubscribersResponse>> {
        if (params.ids === null || params.ids === undefined) {
            throw new runtime.RequiredError('ids','Required parameter params.ids was null or undefined when calling bulkGetSubscribers.');
        }

        const queryParameters: any = {};

        if (params.ids) {
            queryParameters['ids'] = params.ids.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/subscribers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullBulkSubscribersResponseFromJSON(jsonValue));
    }

    /**
     * All users that subscribe to the provided users
     */
    async bulkGetSubscribers(params: BulkGetSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullBulkSubscribersResponse> {
        const response = await this.bulkGetSubscribersRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Get all users that subscribe to the users listed in the JSON request
     */
    async bulkGetSubscribersViaJSONRequestRaw(params: BulkGetSubscribersViaJSONRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullBulkSubscribersResponse>> {
        if (params.ids === null || params.ids === undefined) {
            throw new runtime.RequiredError('ids','Required parameter params.ids was null or undefined when calling bulkGetSubscribersViaJSONRequest.');
        }

        const queryParameters: any = {};

        if (params.ids) {
            queryParameters['ids'] = params.ids.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/subscribers`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullBulkSubscribersResponseFromJSON(jsonValue));
    }

    /**
     * Get all users that subscribe to the users listed in the JSON request
     */
    async bulkGetSubscribersViaJSONRequest(params: BulkGetSubscribersViaJSONRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullBulkSubscribersResponse> {
        const response = await this.bulkGetSubscribersViaJSONRequestRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */
    async getAIAttributedTracksByUserHandleRaw(params: GetAIAttributedTracksByUserHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullTracks>> {
        if (params.handle === null || params.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter params.handle was null or undefined when calling getAIAttributedTracksByUserHandle.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.sort !== undefined) {
            queryParameters['sort'] = params.sort;
        }

        if (params.query !== undefined) {
            queryParameters['query'] = params.query;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        if (params.sortDirection !== undefined) {
            queryParameters['sort_direction'] = params.sortDirection;
        }

        if (params.filterTracks !== undefined) {
            queryParameters['filter_tracks'] = params.filterTracks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/handle/{handle}/tracks/ai_attributed`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTracksFromJSON(jsonValue));
    }

    /**
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */
    async getAIAttributedTracksByUserHandle(params: GetAIAttributedTracksByUserHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullTracks> {
        const response = await this.getAIAttributedTracksByUserHandleRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a user\'s favorite tracks
     */
    async getFavoritesRaw(params: GetFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TrackLibraryResponseFull>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getFavorites.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.query !== undefined) {
            queryParameters['query'] = params.query;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        if (params.sortDirection !== undefined) {
            queryParameters['sort_direction'] = params.sortDirection;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/favorites/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TrackLibraryResponseFullFromJSON(jsonValue));
    }

    /**
     * Gets a user\'s favorite tracks
     */
    async getFavorites(params: GetFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TrackLibraryResponseFull> {
        const response = await this.getFavoritesRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * All users that follow the provided user
     */
    async getFollowersRaw(params: GetFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullFollowersResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getFollowers.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/followers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullFollowersResponseFromJSON(jsonValue));
    }

    /**
     * All users that follow the provided user
     */
    async getFollowers(params: GetFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullFollowersResponse> {
        const response = await this.getFollowersRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * All users that the provided user follows
     */
    async getFollowingRaw(params: GetFollowingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FollowingResponseFull>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getFollowing.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/following`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FollowingResponseFullFromJSON(jsonValue));
    }

    /**
     * All users that the provided user follows
     */
    async getFollowing(params: GetFollowingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FollowingResponseFull> {
        const response = await this.getFollowingRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the purchases the user has made
     */
    async getPurchasesRaw(params: GetPurchasesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PurchasesResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getPurchases.');
        }

        if (params.encodedDataMessage === null || params.encodedDataMessage === undefined) {
            throw new runtime.RequiredError('encodedDataMessage','Required parameter params.encodedDataMessage was null or undefined when calling getPurchases.');
        }

        if (params.encodedDataSignature === null || params.encodedDataSignature === undefined) {
            throw new runtime.RequiredError('encodedDataSignature','Required parameter params.encodedDataSignature was null or undefined when calling getPurchases.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        if (params.sortDirection !== undefined) {
            queryParameters['sort_direction'] = params.sortDirection;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/purchases`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PurchasesResponseFromJSON(jsonValue));
    }

    /**
     * Gets the purchases the user has made
     */
    async getPurchases(params: GetPurchasesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PurchasesResponse> {
        const response = await this.getPurchasesRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a list of users that might be of interest to followers of this user.
     */
    async getRelatedUsersRaw(params: GetRelatedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RelatedArtistResponseFull>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getRelatedUsers.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/related`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RelatedArtistResponseFullFromJSON(jsonValue));
    }

    /**
     * Gets a list of users that might be of interest to followers of this user.
     */
    async getRelatedUsers(params: GetRelatedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RelatedArtistResponseFull> {
        const response = await this.getRelatedUsersRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the given user\'s reposts
     */
    async getRepostsRaw(params: GetRepostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullReposts>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getReposts.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/reposts`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullRepostsFromJSON(jsonValue));
    }

    /**
     * Gets the given user\'s reposts
     */
    async getReposts(params: GetRepostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullReposts> {
        const response = await this.getRepostsRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the user\'s reposts by the user handle
     */
    async getRepostsByHandleRaw(params: GetRepostsByHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullReposts>> {
        if (params.handle === null || params.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter params.handle was null or undefined when calling getRepostsByHandle.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/handle/{handle}/reposts`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullRepostsFromJSON(jsonValue));
    }

    /**
     * Gets the user\'s reposts by the user handle
     */
    async getRepostsByHandle(params: GetRepostsByHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullReposts> {
        const response = await this.getRepostsByHandleRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the sales the user has made
     */
    async getSalesRaw(params: GetSalesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PurchasesResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getSales.');
        }

        if (params.encodedDataMessage === null || params.encodedDataMessage === undefined) {
            throw new runtime.RequiredError('encodedDataMessage','Required parameter params.encodedDataMessage was null or undefined when calling getSales.');
        }

        if (params.encodedDataSignature === null || params.encodedDataSignature === undefined) {
            throw new runtime.RequiredError('encodedDataSignature','Required parameter params.encodedDataSignature was null or undefined when calling getSales.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        if (params.sortDirection !== undefined) {
            queryParameters['sort_direction'] = params.sortDirection;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/sales`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PurchasesResponseFromJSON(jsonValue));
    }

    /**
     * Gets the sales the user has made
     */
    async getSales(params: GetSalesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PurchasesResponse> {
        const response = await this.getSalesRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * All users that subscribe to the provided user
     */
    async getSubscribersRaw(params: GetSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullSubscribersResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getSubscribers.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/subscribers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullSubscribersResponseFromJSON(jsonValue));
    }

    /**
     * All users that subscribe to the provided user
     */
    async getSubscribers(params: GetSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullSubscribersResponse> {
        const response = await this.getSubscribersRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the specified supporter of the given user
     */
    async getSupporterRaw(params: GetSupporterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullGetSupporter>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getSupporter.');
        }

        if (params.supporterUserId === null || params.supporterUserId === undefined) {
            throw new runtime.RequiredError('supporterUserId','Required parameter params.supporterUserId was null or undefined when calling getSupporter.');
        }

        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/supporters/{supporter_user_id}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))).replace(`{${"supporter_user_id"}}`, encodeURIComponent(String(params.supporterUserId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullGetSupporterFromJSON(jsonValue));
    }

    /**
     * Gets the specified supporter of the given user
     */
    async getSupporter(params: GetSupporterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullGetSupporter> {
        const response = await this.getSupporterRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the supporters of the given user
     */
    async getSupportersRaw(params: GetSupportersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullGetSupporters>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getSupporters.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/supporters`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullGetSupportersFromJSON(jsonValue));
    }

    /**
     * Gets the supporters of the given user
     */
    async getSupporters(params: GetSupportersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullGetSupporters> {
        const response = await this.getSupportersRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the support from the given user to the supported user
     */
    async getSupportingRaw(params: GetSupportingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullGetSupporting>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getSupporting.');
        }

        if (params.supportedUserId === null || params.supportedUserId === undefined) {
            throw new runtime.RequiredError('supportedUserId','Required parameter params.supportedUserId was null or undefined when calling getSupporting.');
        }

        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/supporting/{supported_user_id}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))).replace(`{${"supported_user_id"}}`, encodeURIComponent(String(params.supportedUserId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullGetSupportingFromJSON(jsonValue));
    }

    /**
     * Gets the support from the given user to the supported user
     */
    async getSupporting(params: GetSupportingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullGetSupporting> {
        const response = await this.getSupportingRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the users that the given user supports
     */
    async getSupportingsRaw(params: GetSupportingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullGetSupporting>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getSupportings.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/supporting`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullGetSupportingFromJSON(jsonValue));
    }

    /**
     * Gets the users that the given user supports
     */
    async getSupportings(params: GetSupportingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullGetSupporting> {
        const response = await this.getSupportingsRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Get the Top Users having at least one track by follower count
     */
    async getTopUsersRaw(params: GetTopUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TopUsersResponseFull>> {
        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/top`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopUsersResponseFullFromJSON(jsonValue));
    }

    /**
     * Get the Top Users having at least one track by follower count
     */
    async getTopUsers(params: GetTopUsersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TopUsersResponseFull> {
        const response = await this.getTopUsersRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Get the Top Users for a Given Genre
     */
    async getTopUsersInGenreRaw(params: GetTopUsersInGenreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TopGenreUsersResponseFull>> {
        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.genre) {
            queryParameters['genre'] = params.genre;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/genre/top`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopGenreUsersResponseFullFromJSON(jsonValue));
    }

    /**
     * Get the Top Users for a Given Genre
     */
    async getTopUsersInGenre(params: GetTopUsersInGenreRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TopGenreUsersResponseFull> {
        const response = await this.getTopUsersInGenreRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the tracks created by a user using their user ID
     */
    async getTracksByUserRaw(params: GetTracksByUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullTracks>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getTracksByUser.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.sort !== undefined) {
            queryParameters['sort'] = params.sort;
        }

        if (params.query !== undefined) {
            queryParameters['query'] = params.query;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        if (params.sortDirection !== undefined) {
            queryParameters['sort_direction'] = params.sortDirection;
        }

        if (params.filterTracks !== undefined) {
            queryParameters['filter_tracks'] = params.filterTracks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTracksFromJSON(jsonValue));
    }

    /**
     * Gets the tracks created by a user using their user ID
     */
    async getTracksByUser(params: GetTracksByUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullTracks> {
        const response = await this.getTracksByUserRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the tracks created by a user using the user\'s handle
     */
    async getTracksByUserHandleRaw(params: GetTracksByUserHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullTracks>> {
        if (params.handle === null || params.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter params.handle was null or undefined when calling getTracksByUserHandle.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.sort !== undefined) {
            queryParameters['sort'] = params.sort;
        }

        if (params.query !== undefined) {
            queryParameters['query'] = params.query;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        if (params.sortDirection !== undefined) {
            queryParameters['sort_direction'] = params.sortDirection;
        }

        if (params.filterTracks !== undefined) {
            queryParameters['filter_tracks'] = params.filterTracks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/handle/{handle}/tracks`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTracksFromJSON(jsonValue));
    }

    /**
     * Gets the tracks created by a user using the user\'s handle
     */
    async getTracksByUserHandle(params: GetTracksByUserHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullTracks> {
        const response = await this.getTracksByUserHandleRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a single user by their user ID
     */
    async getUserRaw(params: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullUserResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getUser.');
        }

        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullUserResponseFromJSON(jsonValue));
    }

    /**
     * Gets a single user by their user ID
     */
    async getUser(params: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullUserResponse> {
        const response = await this.getUserRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a single user by their handle
     */
    async getUserByHandleRaw(params: GetUserByHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullUserResponse>> {
        if (params.handle === null || params.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter params.handle was null or undefined when calling getUserByHandle.');
        }

        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/handle/{handle}`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullUserResponseFromJSON(jsonValue));
    }

    /**
     * Gets a single user by their handle
     */
    async getUserByHandle(params: GetUserByHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullUserResponse> {
        const response = await this.getUserByHandleRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a user\'s saved/reposted/purchased/all albums
     * Fetch a user\'s full library playlists
     */
    async getUserLibraryAlbumsRaw(params: GetUserLibraryAlbumsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectionLibraryResponseFull>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getUserLibraryAlbums.');
        }

        if (params.encodedDataMessage === null || params.encodedDataMessage === undefined) {
            throw new runtime.RequiredError('encodedDataMessage','Required parameter params.encodedDataMessage was null or undefined when calling getUserLibraryAlbums.');
        }

        if (params.encodedDataSignature === null || params.encodedDataSignature === undefined) {
            throw new runtime.RequiredError('encodedDataSignature','Required parameter params.encodedDataSignature was null or undefined when calling getUserLibraryAlbums.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.query !== undefined) {
            queryParameters['query'] = params.query;
        }

        if (params.sortDirection !== undefined) {
            queryParameters['sort_direction'] = params.sortDirection;
        }

        if (params.type !== undefined) {
            queryParameters['type'] = params.type;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/library/albums`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CollectionLibraryResponseFullFromJSON(jsonValue));
    }

    /**
     * Gets a user\'s saved/reposted/purchased/all albums
     * Fetch a user\'s full library playlists
     */
    async getUserLibraryAlbums(params: GetUserLibraryAlbumsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectionLibraryResponseFull> {
        const response = await this.getUserLibraryAlbumsRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a user\'s saved/reposted/purchased/all playlists
     * Fetch a user\'s full library playlists
     */
    async getUserLibraryPlaylistsRaw(params: GetUserLibraryPlaylistsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectionLibraryResponseFull>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getUserLibraryPlaylists.');
        }

        if (params.encodedDataMessage === null || params.encodedDataMessage === undefined) {
            throw new runtime.RequiredError('encodedDataMessage','Required parameter params.encodedDataMessage was null or undefined when calling getUserLibraryPlaylists.');
        }

        if (params.encodedDataSignature === null || params.encodedDataSignature === undefined) {
            throw new runtime.RequiredError('encodedDataSignature','Required parameter params.encodedDataSignature was null or undefined when calling getUserLibraryPlaylists.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.query !== undefined) {
            queryParameters['query'] = params.query;
        }

        if (params.sortDirection !== undefined) {
            queryParameters['sort_direction'] = params.sortDirection;
        }

        if (params.type !== undefined) {
            queryParameters['type'] = params.type;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/library/playlists`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CollectionLibraryResponseFullFromJSON(jsonValue));
    }

    /**
     * Gets a user\'s saved/reposted/purchased/all playlists
     * Fetch a user\'s full library playlists
     */
    async getUserLibraryPlaylists(params: GetUserLibraryPlaylistsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectionLibraryResponseFull> {
        const response = await this.getUserLibraryPlaylistsRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a user\'s saved/reposted/purchased/all tracks
     * Fetch a user\'s full library tracks
     */
    async getUserLibraryTracksRaw(params: GetUserLibraryTracksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TrackLibraryResponseFull>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getUserLibraryTracks.');
        }

        if (params.encodedDataMessage === null || params.encodedDataMessage === undefined) {
            throw new runtime.RequiredError('encodedDataMessage','Required parameter params.encodedDataMessage was null or undefined when calling getUserLibraryTracks.');
        }

        if (params.encodedDataSignature === null || params.encodedDataSignature === undefined) {
            throw new runtime.RequiredError('encodedDataSignature','Required parameter params.encodedDataSignature was null or undefined when calling getUserLibraryTracks.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.query !== undefined) {
            queryParameters['query'] = params.query;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        if (params.sortDirection !== undefined) {
            queryParameters['sort_direction'] = params.sortDirection;
        }

        if (params.type !== undefined) {
            queryParameters['type'] = params.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/library/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TrackLibraryResponseFullFromJSON(jsonValue));
    }

    /**
     * Gets a user\'s saved/reposted/purchased/all tracks
     * Fetch a user\'s full library tracks
     */
    async getUserLibraryTracks(params: GetUserLibraryTracksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TrackLibraryResponseFull> {
        const response = await this.getUserLibraryTracksRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the user\'s replica set
     */
    async getUserReplicaSetRaw(params: GetUserReplicaSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsersByContentNode>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getUserReplicaSet.');
        }

        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/replica_set`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersByContentNodeFromJSON(jsonValue));
    }

    /**
     * Gets the user\'s replica set
     */
    async getUserReplicaSet(params: GetUserReplicaSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsersByContentNode> {
        const response = await this.getUserReplicaSetRaw(params, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Get the tracks the user recently listened to.
     */
    async getUsersTrackHistoryRaw(params: GetUsersTrackHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HistoryResponseFull>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getUsersTrackHistory.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.query !== undefined) {
            queryParameters['query'] = params.query;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        if (params.sortDirection !== undefined) {
            queryParameters['sort_direction'] = params.sortDirection;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/history/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HistoryResponseFullFromJSON(jsonValue));
    }

    /**
     * Get the tracks the user recently listened to.
     */
    async getUsersTrackHistory(params: GetUsersTrackHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HistoryResponseFull> {
        const response = await this.getUsersTrackHistoryRaw(params, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortEnum = {
    Date: 'date',
    Plays: 'plays'
} as const;
export type GetAIAttributedTracksByUserHandleSortEnum = typeof GetAIAttributedTracksByUserHandleSortEnum[keyof typeof GetAIAttributedTracksByUserHandleSortEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetAIAttributedTracksByUserHandleSortMethodEnum = typeof GetAIAttributedTracksByUserHandleSortMethodEnum[keyof typeof GetAIAttributedTracksByUserHandleSortMethodEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetAIAttributedTracksByUserHandleSortDirectionEnum = typeof GetAIAttributedTracksByUserHandleSortDirectionEnum[keyof typeof GetAIAttributedTracksByUserHandleSortDirectionEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleFilterTracksEnum = {
    All: 'all',
    Public: 'public',
    Unlisted: 'unlisted'
} as const;
export type GetAIAttributedTracksByUserHandleFilterTracksEnum = typeof GetAIAttributedTracksByUserHandleFilterTracksEnum[keyof typeof GetAIAttributedTracksByUserHandleFilterTracksEnum];
/**
 * @export
 */
export const GetFavoritesSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetFavoritesSortMethodEnum = typeof GetFavoritesSortMethodEnum[keyof typeof GetFavoritesSortMethodEnum];
/**
 * @export
 */
export const GetFavoritesSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetFavoritesSortDirectionEnum = typeof GetFavoritesSortDirectionEnum[keyof typeof GetFavoritesSortDirectionEnum];
/**
 * @export
 */
export const GetPurchasesSortMethodEnum = {
    ContentTitle: 'content_title',
    ArtistName: 'artist_name',
    Date: 'date'
} as const;
export type GetPurchasesSortMethodEnum = typeof GetPurchasesSortMethodEnum[keyof typeof GetPurchasesSortMethodEnum];
/**
 * @export
 */
export const GetPurchasesSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetPurchasesSortDirectionEnum = typeof GetPurchasesSortDirectionEnum[keyof typeof GetPurchasesSortDirectionEnum];
/**
 * @export
 */
export const GetSalesSortMethodEnum = {
    ContentTitle: 'content_title',
    ArtistName: 'artist_name',
    Date: 'date'
} as const;
export type GetSalesSortMethodEnum = typeof GetSalesSortMethodEnum[keyof typeof GetSalesSortMethodEnum];
/**
 * @export
 */
export const GetSalesSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetSalesSortDirectionEnum = typeof GetSalesSortDirectionEnum[keyof typeof GetSalesSortDirectionEnum];
/**
 * @export
 */
export const GetTracksByUserSortEnum = {
    Date: 'date',
    Plays: 'plays'
} as const;
export type GetTracksByUserSortEnum = typeof GetTracksByUserSortEnum[keyof typeof GetTracksByUserSortEnum];
/**
 * @export
 */
export const GetTracksByUserSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetTracksByUserSortMethodEnum = typeof GetTracksByUserSortMethodEnum[keyof typeof GetTracksByUserSortMethodEnum];
/**
 * @export
 */
export const GetTracksByUserSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetTracksByUserSortDirectionEnum = typeof GetTracksByUserSortDirectionEnum[keyof typeof GetTracksByUserSortDirectionEnum];
/**
 * @export
 */
export const GetTracksByUserFilterTracksEnum = {
    All: 'all',
    Public: 'public',
    Unlisted: 'unlisted'
} as const;
export type GetTracksByUserFilterTracksEnum = typeof GetTracksByUserFilterTracksEnum[keyof typeof GetTracksByUserFilterTracksEnum];
/**
 * @export
 */
export const GetTracksByUserHandleSortEnum = {
    Date: 'date',
    Plays: 'plays'
} as const;
export type GetTracksByUserHandleSortEnum = typeof GetTracksByUserHandleSortEnum[keyof typeof GetTracksByUserHandleSortEnum];
/**
 * @export
 */
export const GetTracksByUserHandleSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetTracksByUserHandleSortMethodEnum = typeof GetTracksByUserHandleSortMethodEnum[keyof typeof GetTracksByUserHandleSortMethodEnum];
/**
 * @export
 */
export const GetTracksByUserHandleSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetTracksByUserHandleSortDirectionEnum = typeof GetTracksByUserHandleSortDirectionEnum[keyof typeof GetTracksByUserHandleSortDirectionEnum];
/**
 * @export
 */
export const GetTracksByUserHandleFilterTracksEnum = {
    All: 'all',
    Public: 'public',
    Unlisted: 'unlisted'
} as const;
export type GetTracksByUserHandleFilterTracksEnum = typeof GetTracksByUserHandleFilterTracksEnum[keyof typeof GetTracksByUserHandleFilterTracksEnum];
/**
 * @export
 */
export const GetUserLibraryAlbumsSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetUserLibraryAlbumsSortDirectionEnum = typeof GetUserLibraryAlbumsSortDirectionEnum[keyof typeof GetUserLibraryAlbumsSortDirectionEnum];
/**
 * @export
 */
export const GetUserLibraryAlbumsTypeEnum = {
    All: 'all',
    Repost: 'repost',
    Favorite: 'favorite',
    Purchase: 'purchase'
} as const;
export type GetUserLibraryAlbumsTypeEnum = typeof GetUserLibraryAlbumsTypeEnum[keyof typeof GetUserLibraryAlbumsTypeEnum];
/**
 * @export
 */
export const GetUserLibraryAlbumsSortMethodEnum = {
    AddedDate: 'added_date',
    Reposts: 'reposts',
    Saves: 'saves'
} as const;
export type GetUserLibraryAlbumsSortMethodEnum = typeof GetUserLibraryAlbumsSortMethodEnum[keyof typeof GetUserLibraryAlbumsSortMethodEnum];
/**
 * @export
 */
export const GetUserLibraryPlaylistsSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetUserLibraryPlaylistsSortDirectionEnum = typeof GetUserLibraryPlaylistsSortDirectionEnum[keyof typeof GetUserLibraryPlaylistsSortDirectionEnum];
/**
 * @export
 */
export const GetUserLibraryPlaylistsTypeEnum = {
    All: 'all',
    Repost: 'repost',
    Favorite: 'favorite',
    Purchase: 'purchase'
} as const;
export type GetUserLibraryPlaylistsTypeEnum = typeof GetUserLibraryPlaylistsTypeEnum[keyof typeof GetUserLibraryPlaylistsTypeEnum];
/**
 * @export
 */
export const GetUserLibraryPlaylistsSortMethodEnum = {
    AddedDate: 'added_date',
    Reposts: 'reposts',
    Saves: 'saves'
} as const;
export type GetUserLibraryPlaylistsSortMethodEnum = typeof GetUserLibraryPlaylistsSortMethodEnum[keyof typeof GetUserLibraryPlaylistsSortMethodEnum];
/**
 * @export
 */
export const GetUserLibraryTracksSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetUserLibraryTracksSortMethodEnum = typeof GetUserLibraryTracksSortMethodEnum[keyof typeof GetUserLibraryTracksSortMethodEnum];
/**
 * @export
 */
export const GetUserLibraryTracksSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetUserLibraryTracksSortDirectionEnum = typeof GetUserLibraryTracksSortDirectionEnum[keyof typeof GetUserLibraryTracksSortDirectionEnum];
/**
 * @export
 */
export const GetUserLibraryTracksTypeEnum = {
    All: 'all',
    Repost: 'repost',
    Favorite: 'favorite',
    Purchase: 'purchase'
} as const;
export type GetUserLibraryTracksTypeEnum = typeof GetUserLibraryTracksTypeEnum[keyof typeof GetUserLibraryTracksTypeEnum];
/**
 * @export
 */
export const GetUsersTrackHistorySortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetUsersTrackHistorySortMethodEnum = typeof GetUsersTrackHistorySortMethodEnum[keyof typeof GetUsersTrackHistorySortMethodEnum];
/**
 * @export
 */
export const GetUsersTrackHistorySortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetUsersTrackHistorySortDirectionEnum = typeof GetUsersTrackHistorySortDirectionEnum[keyof typeof GetUsersTrackHistorySortDirectionEnum];
