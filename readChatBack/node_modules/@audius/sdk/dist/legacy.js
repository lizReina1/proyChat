'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var browserOrNode = require('browser-or-node');
var zod = require('zod');
var Hashids = require('hashids');
var snakecaseKeys = require('snakecase-keys');
var fileType = require('file-type');
var retry = require('async-retry');
var lodash = require('lodash');
var aes = require('micro-aes-gcm');
var base$1 = require('@scure/base');
var ulid = require('ulid');
var secp = require('@noble/secp256k1');
var WebSocket = require('isomorphic-ws');
var EventEmitter = require('events');
var fetch$1 = require('cross-fetch');
var semver = require('semver');
var nodeAbortController = require('node-abort-controller');
var bs58 = require('bs58');
var require$$0$1 = require('web3');
var axios = require('axios');
var util = require('util');
var ipfsUnixfsImporter = require('ipfs-unixfs-importer');
var fs = require('fs');
var stream = require('stream');
var crypto = require('crypto');
require('assert');
var ethereumjsUtil = require('ethereumjs-util');
var solidity = require('@ethersproject/solidity');
var solanaWeb3 = require('@solana/web3.js');
var buffer = require('buffer');
var FormData$1 = require('form-data');
var sigUtil = require('eth-sig-util');
var ethereumjsTx = require('ethereumjs-tx');
var abiDecoder = require('abi-decoder');
var EthereumWallet = require('ethereumjs-wallet');
var urlJoin = require('proper-url-join');
var BN = require('bn.js');
var splToken = require('@solana/spl-token');
var borsh = require('borsh');
var keccak256 = require('keccak256');
var secp256k1 = require('secp256k1');
var safeBuffer = require('safe-buffer');
var hedgehog = require('@audius/hedgehog');
var jsonschema = require('jsonschema');
var utils = require('ethers/lib/utils');
var index$1 = require('ethers/lib/index');
var wormholeSDK = require('@certusone/wormhole-sdk');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var Hashids__default = /*#__PURE__*/_interopDefaultLegacy(Hashids);
var snakecaseKeys__default = /*#__PURE__*/_interopDefaultLegacy(snakecaseKeys);
var fileType__namespace = /*#__PURE__*/_interopNamespace(fileType);
var retry__default = /*#__PURE__*/_interopDefaultLegacy(retry);
var aes__namespace = /*#__PURE__*/_interopNamespace(aes);
var secp__namespace = /*#__PURE__*/_interopNamespace(secp);
var WebSocket__default = /*#__PURE__*/_interopDefaultLegacy(WebSocket);
var EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch$1);
var semver__default = /*#__PURE__*/_interopDefaultLegacy(semver);
var bs58__default = /*#__PURE__*/_interopDefaultLegacy(bs58);
var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);
var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);
var solanaWeb3__default = /*#__PURE__*/_interopDefaultLegacy(solanaWeb3);
var FormData__default = /*#__PURE__*/_interopDefaultLegacy(FormData$1);
var sigUtil__default = /*#__PURE__*/_interopDefaultLegacy(sigUtil);
var abiDecoder__default = /*#__PURE__*/_interopDefaultLegacy(abiDecoder);
var EthereumWallet__default = /*#__PURE__*/_interopDefaultLegacy(EthereumWallet);
var urlJoin__default = /*#__PURE__*/_interopDefaultLegacy(urlJoin);
var BN__default = /*#__PURE__*/_interopDefaultLegacy(BN);
var splToken__default = /*#__PURE__*/_interopDefaultLegacy(splToken);
var keccak256__default = /*#__PURE__*/_interopDefaultLegacy(keccak256);
var secp256k1__default = /*#__PURE__*/_interopDefaultLegacy(secp256k1);
var wormholeSDK__default = /*#__PURE__*/_interopDefaultLegacy(wormholeSDK);

function _asyncIterator(iterable) {
  var method,
      async,
      sync,
      retry = 2;

  for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {
    if (async && null != (method = iterable[async])) return method.call(iterable);
    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
    async = "@@asyncIterator", sync = "@@iterator";
  }

  throw new TypeError("Object is not async iterable");
}

function AsyncFromSyncIterator(s) {
  function AsyncFromSyncIteratorContinuation(r) {
    if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
    var done = r.done;
    return Promise.resolve(r.value).then(function (value) {
      return {
        value: value,
        done: done
      };
    });
  }

  return AsyncFromSyncIterator = function (s) {
    this.s = s, this.n = s.next;
  }, AsyncFromSyncIterator.prototype = {
    s: null,
    n: null,
    next: function () {
      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
    },
    return: function (value) {
      var ret = this.s.return;
      return void 0 === ret ? Promise.resolve({
        value: value,
        done: !0
      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
    },
    throw: function (value) {
      var thr = this.s.return;
      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
    }
  }, new AsyncFromSyncIterator(s);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _wrapRegExp() {
  _wrapRegExp = function (re, groups) {
    return new BabelRegExp(re, void 0, groups);
  };

  var _super = RegExp.prototype,
      _groups = new WeakMap();

  function BabelRegExp(re, flags, groups) {
    var _this = new RegExp(re, flags);

    return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype);
  }

  function buildGroups(result, re) {
    var g = _groups.get(re);

    return Object.keys(g).reduce(function (groups, name) {
      return groups[name] = result[g[name]], groups;
    }, Object.create(null));
  }

  return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) {
    var result = _super.exec.call(this, str);

    return result && (result.groups = buildGroups(result, this)), result;
  }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
    if ("string" == typeof substitution) {
      var groups = _groups.get(this);

      return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
        return "$" + groups[name];
      }));
    }

    if ("function" == typeof substitution) {
      var _this = this;

      return _super[Symbol.replace].call(this, str, function () {
        var args = arguments;
        return "object" != typeof args[args.length - 1] && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);
      });
    }

    return _super[Symbol.replace].call(this, str, substitution);
  }, _wrapRegExp.apply(this, arguments);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    };
  }

  return _get.apply(this, arguments);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var isOAuthScopeValid = function isOAuthScopeValid(scope) {
  var validScopes = new Set(OAUTH_SCOPE_OPTIONS);
  return scope.findIndex(function (s) {
    return !validScopes.has(s);
  }) === -1;
};

var ParseRequestError = /*#__PURE__*/function (_Error) {
  _inherits(ParseRequestError, _Error);

  var _super = _createSuper(ParseRequestError);

  function ParseRequestError(method, innerError) {
    var _this;

    _classCallCheck(this, ParseRequestError);

    _this = _super.call(this, "'".concat(method, "' => ").concat(innerError.message));

    _defineProperty$1(_assertThisInitialized(_this), "method", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "innerError", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "name", 'ParseRequestError');

    _this.method = method;
    _this.innerError = innerError;
    return _this;
  }

  return _createClass(ParseRequestError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * @param name Name of the method for which the parameters are being parsed
 * @param schema Zod schema that defines the shape of the request parameters
 * @returns The parsed data or throws an error
 */

var parseParams = function parseParams(name, schema) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
      var result;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return schema.safeParseAsync(params);

            case 2:
              result = _context.sent;

              if (result.success) {
                _context.next = 5;
                break;
              }

              throw new ParseRequestError(name, result.error);

            case 5:
              return _context.abrupt("return", result.data);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

var isApiKeyValid = function isApiKeyValid(apiKey) {
  try {
    if (apiKey.length !== 40) {
      return false;
    }

    var hexadecimalRegex = /^[0-9a-fA-F]+$/;
    return hexadecimalRegex.test(apiKey);
  } catch (_e) {
    return false;
  }
};

var IsWriteAccessGrantedSchema = zod.z.object({
  userId: zod.z.string(),
  apiKey: zod.z.optional(zod.z.custom(function (data) {
    return isApiKeyValid(data);
  }))
});
var OAUTH_SCOPE_OPTIONS = ['read', 'write'];

var CSS = "\n.audiusLoginButton {\n  cursor: pointer;\n  font-family: Helvetica, Arial, sans-serif;\n  text-align: center;\n  color: #FFFFFF;\n  font-weight: 700;\n  font-size: 14px;\n  line-height: 100%;\n  align-items: center;\n  display: flex;\n  border: 0;\n  height: 28px;\n  justify-content: center;\n  padding: 0px 16px;\n  background: #CC0FE0;\n  border-radius: 4px;\n  transition: all 0.07s ease-in-out;\n}\n\n.audiusLoginButton:hover {\n  background: #D127E3;\n  transform: perspective(1px) scale3d(1.04, 1.04, 1.04);\n}\n\n.audiusLoginButton.disableHoverGrow:hover {\n  transform: none;\n}\n\n.audiusLoginButton:active {\n  background: #A30CB3;\n}\n\n.audiusLoginButton.pill {\n  border-radius: 99px;\n}\n\n.audiusLoginButton.fullWidth {\n  width: 100%;\n}\n\n.audiusLoginButton.small {\n  height: 20px;\n  font-size: 11px;\n  padding: 0px 32px;\n}\n\n.audiusLoginButton.large {\n  height: 40px;\n  font-size: 18px;\n  padding: 0px 18px;\n}\n"; // From https://stackoverflow.com/a/27747377

var generateId = function generateId() {
  var arr = new Uint8Array(40 / 2) // Result of function will be 40 chars long
  ;
  (window.crypto || window.msCrypto).getRandomValues(arr);
  return Array.from(arr, function dec2hex(dec) {
    return dec.toString(16).padStart(2, '0');
  }).join('');
};

var generateAudiusLogoSvg = function generateAudiusLogoSvg(size) {
  var height;
  var paddingRight;

  if (size === 'small') {
    height = 16;
    paddingRight = 5;
  } else if (size === 'medium') {
    height = 18;
    paddingRight = 5;
  } else {
    height = 24;
    paddingRight = 10;
  }

  return "<svg width=\"".concat(height, "px\" height=\"").concat(height, "px\" viewBox=\"0 0 56 48\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"padding-right: ").concat(paddingRight, "px;\">\n<g id=\"Assets\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n    <g id=\"assets\" transform=\"translate(-1555.000000, -2588.000000)\">\n        <g id=\"audiusLogoGlyph\" transform=\"translate(1555.000000, 2588.000000)\">\n            <path d=\"M55.8191698,46.0362519 L42.4551012,23.3458831 L36.1870263,12.7036635 L29.0910326,0.65551431 C28.5766233,-0.217848954 27.2890668,-0.218676884 26.7734944,0.654065432 L13.3787621,23.3270477 L7.90582764,32.5909699 C7.39025522,33.4637122 8.03324043,34.5553386 9.06332791,34.5560631 L19.4031138,34.56279 C19.881044,34.5631005 20.3230236,34.3136864 20.5623059,33.9087249 L25.9362708,24.8122516 L26.7580568,23.4212248 C26.790518,23.3662709 26.8260456,23.3149392 26.8641108,23.2669192 C27.4325516,22.5520012 28.5935412,22.6041608 29.0755951,23.4226737 L34.6514114,32.8894388 L35.682239,34.6396841 C35.7412402,34.7399672 35.7843808,34.8430445 35.813987,34.9470533 C36.0430129,35.7492145 35.4339691,36.6039494 34.5220954,36.6034319 L22.3586676,36.5954631 C21.8806317,36.5951526 21.4387578,36.8445667 21.1994756,37.2496317 L16.0236614,46.0105861 C15.5080889,46.8833284 16.1510741,47.9749548 17.1810559,47.9756793 L27.9002253,47.9827167 L41.2664086,47.9913065 L54.6590261,47.9999997 C55.6892193,48.0006207 56.3335791,46.9096152 55.8191698,46.0362519\" id=\"Audius-Logo\" fill=\"#ffffff\" fill-rule=\"evenodd\"></path>\n            <rect id=\"bound\" x=\"0\" y=\"0\" width=\"56\" height=\"48\"></rect>\n        </g>\n    </g>\n</g>\n</svg>");
};

var CSRF_TOKEN_KEY = 'audiusOauthState';
var OAUTH_URL = {
  production: 'https://audius.co/oauth/auth',
  staging: 'https://staging.audius.co/oauth/auth'
};
var OAuth = /*#__PURE__*/function () {
  function OAuth(config) {
    var _config$apiKey;

    _classCallCheck(this, OAuth);

    _defineProperty$1(this, "config", void 0);

    _defineProperty$1(this, "activePopupWindow", void 0);

    _defineProperty$1(this, "popupCheckInterval", void 0);

    _defineProperty$1(this, "loginSuccessCallback", void 0);

    _defineProperty$1(this, "loginErrorCallback", void 0);

    _defineProperty$1(this, "apiKey", void 0);

    _defineProperty$1(this, "env", 'production');

    _defineProperty$1(this, "logger", void 0);

    this.config = config;

    if (typeof window === 'undefined') {
      throw new Error('Audius OAuth SDK functions are only available in browser. Refer to our documentation to learn how to implement Audius OAuth manually: https://docs.audius.org/developers/log-in-with-audius#manual-implementation.');
    }

    this.apiKey = (_config$apiKey = config.apiKey) !== null && _config$apiKey !== void 0 ? _config$apiKey : null;
    this.activePopupWindow = null;
    this.loginSuccessCallback = null;
    this.loginErrorCallback = null;
    this.popupCheckInterval = null;
    this.logger = config.logger.createPrefixedLogger('[oauth]');
  }

  _createClass(OAuth, [{
    key: "init",
    value: function init(_ref) {
      var _this = this;

      var successCallback = _ref.successCallback,
          errorCallback = _ref.errorCallback,
          _ref$env = _ref.env,
          env = _ref$env === void 0 ? 'production' : _ref$env;
      this.loginSuccessCallback = successCallback;
      this.loginErrorCallback = errorCallback !== null && errorCallback !== void 0 ? errorCallback : null;
      this.env = env;
      window.addEventListener('message', function (e) {
        _this._receiveMessage(e);
      }, false);
    }
  }, {
    key: "isWriteAccessGranted",
    value: function () {
      var _isWriteAccessGranted = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var _authorizedApps$data,
            _this2 = this;

        var _yield$parseParams, userId, apiKey, authorizedApps, foundIndex;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return parseParams('isWriteAccessGranted', IsWriteAccessGrantedSchema)(params);

              case 2:
                _yield$parseParams = _context.sent;
                userId = _yield$parseParams.userId;
                apiKey = _yield$parseParams.apiKey;

                if (!this.apiKey && !apiKey) {
                  this._surfaceError('Need to init Audius SDK with API key or pass in API Key directly to oauth.isWriteAccessGranted.');
                }

                _context.next = 8;
                return this.config.usersApi.getAuthorizedApps({
                  id: userId
                });

              case 8:
                authorizedApps = _context.sent;
                foundIndex = (_authorizedApps$data = authorizedApps.data) === null || _authorizedApps$data === void 0 ? void 0 : _authorizedApps$data.findIndex(function (a) {
                  return a.address.toLowerCase() === "0x".concat((apiKey || _this2.apiKey).toLowerCase());
                });
                return _context.abrupt("return", foundIndex !== undefined && foundIndex > -1);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function isWriteAccessGranted(_x) {
        return _isWriteAccessGranted.apply(this, arguments);
      }

      return isWriteAccessGranted;
    }()
  }, {
    key: "login",
    value: function login(_ref2) {
      var _this3 = this;

      var _ref2$scope = _ref2.scope,
          scope = _ref2$scope === void 0 ? 'read' : _ref2$scope;
      var scopeFormatted = typeof scope === 'string' ? [scope] : scope;

      if (!this.config.appName && !this.apiKey) {
        this._surfaceError('App name not set (set with `init` method).');

        return;
      }

      if (scope.includes('write') && !this.apiKey) {
        this._surfaceError("The 'write' scope requires Audius SDK to be initialized with an API key");
      }

      if (!this.loginSuccessCallback) {
        this._surfaceError('Login success callback not set (set with `init` method).');

        return;
      }

      if (!isOAuthScopeValid(scopeFormatted)) {
        this._surfaceError('Scope must be `read` or `write`.');

        return;
      }

      var csrfToken = generateId();
      window.localStorage.setItem(CSRF_TOKEN_KEY, csrfToken);
      var windowOptions = 'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=375, height=720, top=100, left=100';
      var originURISafe = encodeURIComponent(window.location.origin);
      var appIdURISafe = encodeURIComponent(this.apiKey || this.config.appName);
      var appIdURIParam = "".concat(this.apiKey ? 'api_key' : 'app_name', "=").concat(appIdURISafe);
      var scopeUriParam = scope.includes('write') ? 'write' : 'read';
      var fullOauthUrl = "".concat(OAUTH_URL[this.env], "?scope=").concat(scopeUriParam, "&state=").concat(csrfToken, "&redirect_uri=postMessage&origin=").concat(originURISafe, "&").concat(appIdURIParam);
      this.activePopupWindow = window.open(fullOauthUrl, '', windowOptions);

      this._clearPopupCheckInterval();

      this.popupCheckInterval = setInterval(function () {
        var _this3$activePopupWin;

        if ((_this3$activePopupWin = _this3.activePopupWindow) !== null && _this3$activePopupWin !== void 0 && _this3$activePopupWin.closed) {
          _this3._surfaceError('The login popup was closed prematurely.');

          if (_this3.popupCheckInterval) {
            clearInterval(_this3.popupCheckInterval);
          }
        }
      }, 500);
    }
  }, {
    key: "renderButton",
    value: function renderButton(_ref3) {
      var _buttonOptions$size,
          _buttonOptions$custom,
          _this4 = this;

      var element = _ref3.element,
          _ref3$scope = _ref3.scope,
          scope = _ref3$scope === void 0 ? 'read' : _ref3$scope,
          buttonOptions = _ref3.buttonOptions;

      if (!element) {
        this.logger.error('Target element for Audius OAuth button is empty.');
      }

      var style = document.createElement('style');
      style.textContent = CSS;
      document.head.appendChild(style);
      var button = document.createElement('button');
      button.id = 'audius-login-button';
      button.classList.add('audiusLoginButton');

      if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.corners) === 'pill') {
        button.classList.add('pill');
      }

      if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) === 'small') {
        button.classList.add('small');
      }

      if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) === 'large') {
        button.classList.add('large');
      }

      if (buttonOptions !== null && buttonOptions !== void 0 && buttonOptions.fullWidth) {
        button.classList.add('fullWidth');
      }

      if (buttonOptions !== null && buttonOptions !== void 0 && buttonOptions.disableHoverGrow) {
        button.classList.add('disableHoverGrow');
      }

      button.innerHTML = "".concat(generateAudiusLogoSvg((_buttonOptions$size = buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) !== null && _buttonOptions$size !== void 0 ? _buttonOptions$size : 'medium'), " ").concat((_buttonOptions$custom = buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.customText) !== null && _buttonOptions$custom !== void 0 ? _buttonOptions$custom : 'Continue With Audius');

      button.onclick = function () {
        _this4.login({
          scope: scope
        });
      };

      element.replaceWith(button);
    }
    /**
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     * @deprecated see `UsersApi.verifyIDToken`
     * @param token the token to verify
     * @returns
     */

  }, {
    key: "verifyToken",
    value: function () {
      var _verifyToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(token) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.config.usersApi.verifyIDToken({
                  token: token
                });

              case 2:
                return _context2.abrupt("return", _context2.sent);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function verifyToken(_x2) {
        return _verifyToken.apply(this, arguments);
      }

      return verifyToken;
    }()
    /* ------- INTERNAL FUNCTIONS ------- */

  }, {
    key: "_surfaceError",
    value: function _surfaceError(errorMessage) {
      if (this.loginErrorCallback) {
        this.loginErrorCallback(errorMessage);
      } else {
        this.logger.error(errorMessage);
      }
    }
  }, {
    key: "_clearPopupCheckInterval",
    value: function _clearPopupCheckInterval() {
      if (this.popupCheckInterval) {
        clearInterval(this.popupCheckInterval);
      }
    }
  }, {
    key: "_receiveMessage",
    value: function () {
      var _receiveMessage2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(event) {
        var oauthOrigin, decodedJwt;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                oauthOrigin = new URL(OAUTH_URL[this.env]).origin;

                if (!(event.origin !== oauthOrigin || event.source !== this.activePopupWindow || !event.data.state || !event.data.token)) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt("return");

              case 3:
                this._clearPopupCheckInterval();

                if (this.activePopupWindow) {
                  if (!this.activePopupWindow.closed) {
                    this.activePopupWindow.close();
                  }

                  this.activePopupWindow = null;
                }

                if (window.localStorage.getItem(CSRF_TOKEN_KEY) !== event.data.state) {
                  this._surfaceError('State mismatch.');
                } // Verify token and decode


                _context3.next = 8;
                return this.verifyToken(event.data.token);

              case 8:
                decodedJwt = _context3.sent;

                if (decodedJwt !== null && decodedJwt !== void 0 && decodedJwt.data) {
                  if (this.loginSuccessCallback) {
                    this.loginSuccessCallback(decodedJwt.data);
                  }
                } else {
                  this._surfaceError('The token was invalid.');
                }

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _receiveMessage(_x3) {
        return _receiveMessage2.apply(this, arguments);
      }

      return _receiveMessage;
    }()
  }]);

  return OAuth;
}();

var Action$1;

(function (Action) {
  Action["CREATE"] = "Create";
  Action["UPDATE"] = "Update";
  Action["DELETE"] = "Delete";
  Action["VERIFY"] = "Verify";
  Action["FOLLOW"] = "Follow";
  Action["UNFOLLOW"] = "Unfollow";
  Action["SAVE"] = "Save";
  Action["UNSAVE"] = "Unsave";
  Action["REPOST"] = "Repost";
  Action["UNREPOST"] = "Unrepost";
  Action["SUBSCRIBE"] = "Subscribe";
  Action["UNSUBSCRIBE"] = "Unsubscribe";
  Action["VIEW"] = "View";
  Action["VIEW_PLAYLIST"] = "ViewPlaylist";
})(Action$1 || (Action$1 = {}));

var EntityType$1;

(function (EntityType) {
  EntityType["PLAYLIST"] = "Playlist";
  EntityType["TRACK"] = "Track";
  EntityType["USER"] = "User";
  EntityType["USER_REPLICA_SET"] = "UserReplicaSet";
  EntityType["NOTIFICATION"] = "Notification";
  EntityType["DEVELOPER_APP"] = "DeveloperApp";
  EntityType["GRANT"] = "Grant";
})(EntityType$1 || (EntityType$1 = {}));

var BlockConfirmation;

(function (BlockConfirmation) {
  BlockConfirmation["CONFIRMED"] = "CONFIRMED";
  BlockConfirmation["DENIED"] = "DENIED";
  BlockConfirmation["UNKNOWN"] = "UNKNOWN";
})(BlockConfirmation || (BlockConfirmation = {}));

var HASH_SALT$1 = 'azowernasdfoia';
var MIN_LENGTH$1 = 5;
var hashids$1 = new Hashids__default["default"](HASH_SALT$1, MIN_LENGTH$1);
/**
 * Decodes a string id into an int. Returns null if an invalid ID.
 */

var decodeHashId$4 = function decodeHashId(id) {
  try {
    var ids = hashids$1.decode(id);
    if (!ids.length) return null;
    var num = Number(ids[0]);
    if (isNaN(num)) return null;
    return num;
  } catch (e) {
    return null;
  }
};
/**
 * Encodes an int to a string based hashid
 */

var encodeHashId = function encodeHashId(id) {
  try {
    if (id === null) return null;
    var encodedId = hashids$1.encode(id);
    return encodedId;
  } catch (e) {
    return null;
  }
};

var HashId = zod.z.string().transform(function (data, context) {
  var id = decodeHashId$4(data);

  if (id === null) {
    context.addIssue({
      code: zod.z.ZodIssueCode.custom,
      message: 'Hash id is invalid'
    });
    return zod.z.NEVER;
  }

  return id;
});

var CreateGrantSchema = zod.z.object({
  userId: HashId,
  appApiKey: zod.z.custom(function (data) {
    return isApiKeyValid(data);
  })
});
var RevokeGrantSchema = zod.z.object({
  userId: HashId,
  appApiKey: zod.z.custom(function (data) {
    return isApiKeyValid(data);
  })
});

var GrantsApi = /*#__PURE__*/function () {
  function GrantsApi(_config, entityManager, auth) {
    _classCallCheck(this, GrantsApi);

    _defineProperty$1(this, "entityManager", void 0);

    _defineProperty$1(this, "auth", void 0);

    this.entityManager = entityManager;
    this.auth = auth;
  }
  /**
   * When user authorizes app to perform actions on their behalf
   */


  _createClass(GrantsApi, [{
    key: "createGrant",
    value: function () {
      var _createGrant = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var _yield$parseParams, userId, appApiKey;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return parseParams('createGrant', CreateGrantSchema)(params);

              case 2:
                _yield$parseParams = _context.sent;
                userId = _yield$parseParams.userId;
                appApiKey = _yield$parseParams.appApiKey;
                _context.next = 7;
                return this.entityManager.manageEntity({
                  userId: userId,
                  entityType: EntityType$1.GRANT,
                  entityId: 0,
                  action: Action$1.CREATE,
                  metadata: JSON.stringify({
                    grantee_address: "0x".concat(appApiKey)
                  }),
                  auth: this.auth
                });

              case 7:
                return _context.abrupt("return", _context.sent);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function createGrant(_x) {
        return _createGrant.apply(this, arguments);
      }

      return createGrant;
    }()
    /**
     * When user revokes an app's authorization to perform actions on their behalf
     */

  }, {
    key: "revokeGrant",
    value: function () {
      var _revokeGrant = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        var _yield$parseParams2, userId, appApiKey;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return parseParams('revokeGrant', RevokeGrantSchema)(params);

              case 2:
                _yield$parseParams2 = _context2.sent;
                userId = _yield$parseParams2.userId;
                appApiKey = _yield$parseParams2.appApiKey;
                _context2.next = 7;
                return this.entityManager.manageEntity({
                  userId: userId,
                  entityType: EntityType$1.GRANT,
                  entityId: 0,
                  action: Action$1.DELETE,
                  metadata: JSON.stringify({
                    grantee_address: "0x".concat(appApiKey)
                  }),
                  auth: this.auth
                });

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function revokeGrant(_x2) {
        return _revokeGrant.apply(this, arguments);
      }

      return revokeGrant;
    }()
  }]);

  return GrantsApi;
}();

var web3;

if (typeof window !== 'undefined' && window && window.Web3) {
  web3 = window.Web3;
} else {
  web3 = require('web3');
}

var Web3$1 = web3;

/* tslint:disable */

/* eslint-disable */

/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var BASE_PATH$1 = "/v1".replace(/\/+$/, "");
var Configuration$1 = /*#__PURE__*/function () {
  function Configuration() {
    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Configuration);

    _defineProperty$1(this, "configuration", void 0);

    this.configuration = configuration;
  }

  _createClass(Configuration, [{
    key: "config",
    set: function set(configuration) {
      this.configuration = configuration;
    }
  }, {
    key: "basePath",
    get: function get() {
      return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH$1;
    }
  }, {
    key: "fetchApi",
    get: function get() {
      return this.configuration.fetchApi;
    }
  }, {
    key: "middleware",
    get: function get() {
      return this.configuration.middleware || [];
    }
  }, {
    key: "queryParamsStringify",
    get: function get() {
      return this.configuration.queryParamsStringify || querystring$1;
    }
  }, {
    key: "username",
    get: function get() {
      return this.configuration.username;
    }
  }, {
    key: "password",
    get: function get() {
      return this.configuration.password;
    }
  }, {
    key: "apiKey",
    get: function get() {
      var apiKey = this.configuration.apiKey;

      if (apiKey) {
        return typeof apiKey === 'function' ? apiKey : function () {
          return apiKey;
        };
      }

      return undefined;
    }
  }, {
    key: "accessToken",
    get: function get() {
      var accessToken = this.configuration.accessToken;

      if (accessToken) {
        return typeof accessToken === 'function' ? accessToken : /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", accessToken);

                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
      }

      return undefined;
    }
  }, {
    key: "headers",
    get: function get() {
      return this.configuration.headers;
    }
  }, {
    key: "credentials",
    get: function get() {
      return this.configuration.credentials;
    }
  }]);

  return Configuration;
}();
var DefaultConfig$1 = new Configuration$1();
/**
 * This is the base class for all generated API classes.
 */

var BaseAPI$1 = /*#__PURE__*/function () {
  function BaseAPI() {
    var _this = this;

    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultConfig$1;

    _classCallCheck(this, BaseAPI);

    _defineProperty$1(this, "configuration", void 0);

    _defineProperty$1(this, "middleware", void 0);

    _defineProperty$1(this, "fetchApi", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url, init) {
        var fetchParams, _iterator, _step, _middleware, response, _iterator2, _step2, middleware, _iterator3, _step3, _middleware2;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                fetchParams = {
                  url: url,
                  init: init
                };
                _iterator = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 2;

                _iterator.s();

              case 4:
                if ((_step = _iterator.n()).done) {
                  _context2.next = 15;
                  break;
                }

                _middleware = _step.value;

                if (!_middleware.pre) {
                  _context2.next = 13;
                  break;
                }

                _context2.next = 9;
                return _middleware.pre(_objectSpread2({
                  fetch: _this.fetchApi
                }, fetchParams));

              case 9:
                _context2.t0 = _context2.sent;

                if (_context2.t0) {
                  _context2.next = 12;
                  break;
                }

                _context2.t0 = fetchParams;

              case 12:
                fetchParams = _context2.t0;

              case 13:
                _context2.next = 4;
                break;

              case 15:
                _context2.next = 20;
                break;

              case 17:
                _context2.prev = 17;
                _context2.t1 = _context2["catch"](2);

                _iterator.e(_context2.t1);

              case 20:
                _context2.prev = 20;

                _iterator.f();

                return _context2.finish(20);

              case 23:
                response = undefined;
                _context2.prev = 24;
                _context2.next = 27;
                return (_this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);

              case 27:
                response = _context2.sent;
                _context2.next = 60;
                break;

              case 30:
                _context2.prev = 30;
                _context2.t2 = _context2["catch"](24);
                _iterator2 = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 33;

                _iterator2.s();

              case 35:
                if ((_step2 = _iterator2.n()).done) {
                  _context2.next = 46;
                  break;
                }

                middleware = _step2.value;

                if (!middleware.onError) {
                  _context2.next = 44;
                  break;
                }

                _context2.next = 40;
                return middleware.onError({
                  fetch: _this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  error: _context2.t2,
                  response: response ? response.clone() : undefined
                });

              case 40:
                _context2.t3 = _context2.sent;

                if (_context2.t3) {
                  _context2.next = 43;
                  break;
                }

                _context2.t3 = response;

              case 43:
                response = _context2.t3;

              case 44:
                _context2.next = 35;
                break;

              case 46:
                _context2.next = 51;
                break;

              case 48:
                _context2.prev = 48;
                _context2.t4 = _context2["catch"](33);

                _iterator2.e(_context2.t4);

              case 51:
                _context2.prev = 51;

                _iterator2.f();

                return _context2.finish(51);

              case 54:
                if (!(response === undefined)) {
                  _context2.next = 60;
                  break;
                }

                if (!(_context2.t2 instanceof Error)) {
                  _context2.next = 59;
                  break;
                }

                throw new FetchError$1(_context2.t2, 'The request failed and the interceptors did not return an alternative response');

              case 59:
                throw _context2.t2;

              case 60:
                _iterator3 = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 61;

                _iterator3.s();

              case 63:
                if ((_step3 = _iterator3.n()).done) {
                  _context2.next = 74;
                  break;
                }

                _middleware2 = _step3.value;

                if (!_middleware2.post) {
                  _context2.next = 72;
                  break;
                }

                _context2.next = 68;
                return _middleware2.post({
                  fetch: _this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  response: response.clone()
                });

              case 68:
                _context2.t5 = _context2.sent;

                if (_context2.t5) {
                  _context2.next = 71;
                  break;
                }

                _context2.t5 = response;

              case 71:
                response = _context2.t5;

              case 72:
                _context2.next = 63;
                break;

              case 74:
                _context2.next = 79;
                break;

              case 76:
                _context2.prev = 76;
                _context2.t6 = _context2["catch"](61);

                _iterator3.e(_context2.t6);

              case 79:
                _context2.prev = 79;

                _iterator3.f();

                return _context2.finish(79);

              case 82:
                return _context2.abrupt("return", response);

              case 83:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[2, 17, 20, 23], [24, 30], [33, 48, 51, 54], [61, 76, 79, 82]]);
      }));

      return function (_x, _x2) {
        return _ref2.apply(this, arguments);
      };
    }());

    this.configuration = configuration;
    this.middleware = configuration.middleware;
  }
  /** @hidden */


  _createClass(BaseAPI, [{
    key: "withMiddleware",
    value: function withMiddleware() {
      var _next$middleware;

      var next = this.clone();
      next.middleware = (_next$middleware = next.middleware).concat.apply(_next$middleware, arguments);
      return next;
    }
    /** @hidden */

  }, {
    key: "withPreMiddleware",
    value: function withPreMiddleware() {
      for (var _len = arguments.length, preMiddlewares = new Array(_len), _key = 0; _key < _len; _key++) {
        preMiddlewares[_key] = arguments[_key];
      }

      var middlewares = preMiddlewares.map(function (pre) {
        return {
          pre: pre
        };
      });
      return this.withMiddleware.apply(this, _toConsumableArray(middlewares));
    }
    /** @hidden */

  }, {
    key: "withPostMiddleware",
    value: function withPostMiddleware() {
      for (var _len2 = arguments.length, postMiddlewares = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        postMiddlewares[_key2] = arguments[_key2];
      }

      var middlewares = postMiddlewares.map(function (post) {
        return {
          post: post
        };
      });
      return this.withMiddleware.apply(this, _toConsumableArray(middlewares));
    }
    /** @hidden */

  }, {
    key: "request",
    value: function () {
      var _request = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(context, initOverrides) {
        var _yield$this$createFet, url, init, response;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.createFetchParams(context, initOverrides);

              case 2:
                _yield$this$createFet = _context3.sent;
                url = _yield$this$createFet.url;
                init = _yield$this$createFet.init;
                _context3.next = 7;
                return this.fetchApi(url, init);

              case 7:
                response = _context3.sent;

                if (!(response && response.status >= 200 && response.status < 300)) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt("return", response);

              case 10:
                throw new ResponseError$1(response, 'Response returned an error code');

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function request(_x3, _x4) {
        return _request.apply(this, arguments);
      }

      return request;
    }()
  }, {
    key: "createFetchParams",
    value: function () {
      var _createFetchParams = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(context, initOverrides) {
        var url, headers, initOverrideFn, initParams, overriddenInit, init;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                url = this.configuration.basePath + context.path;

                if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                  // only add the querystring to the URL if there are query parameters.
                  // this is done to avoid urls ending with a "?" character which buggy webservers
                  // do not handle correctly sometimes.
                  url += '?' + this.configuration.queryParamsStringify(context.query);
                }

                headers = Object.assign({}, this.configuration.headers, context.headers);
                Object.keys(headers).forEach(function (key) {
                  return headers[key] === undefined ? delete headers[key] : {};
                });
                initOverrideFn = typeof initOverrides === "function" ? initOverrides : /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                  return regeneratorRuntime.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          return _context4.abrupt("return", initOverrides);

                        case 1:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                }));
                initParams = {
                  method: context.method,
                  headers: headers,
                  body: context.body,
                  credentials: this.configuration.credentials
                };
                _context5.t0 = _objectSpread2;
                _context5.t1 = _objectSpread2({}, initParams);
                _context5.next = 10;
                return initOverrideFn({
                  init: initParams,
                  context: context
                });

              case 10:
                _context5.t2 = _context5.sent;
                overriddenInit = (0, _context5.t0)(_context5.t1, _context5.t2);
                init = _objectSpread2(_objectSpread2({}, overriddenInit), {}, {
                  body: isFormData$1(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob$1(overriddenInit.body) || isString$1(overriddenInit.body) ? overriddenInit.body : JSON.stringify(overriddenInit.body)
                });
                return _context5.abrupt("return", {
                  url: url,
                  init: init
                });

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function createFetchParams(_x5, _x6) {
        return _createFetchParams.apply(this, arguments);
      }

      return createFetchParams;
    }()
  }, {
    key: "clone",
    value:
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    function clone() {
      var constructor = this.constructor;
      var next = new constructor(this.configuration);
      next.middleware = this.middleware.slice();
      return next;
    }
  }]);

  return BaseAPI;
}();

function isBlob$1(value) {
  return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData$1(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}

function isString$1(value) {
  return typeof value === 'string';
}

var ResponseError$1 = /*#__PURE__*/function (_Error) {
  _inherits(ResponseError, _Error);

  var _super = _createSuper(ResponseError);

  function ResponseError(response, msg) {
    var _this2;

    _classCallCheck(this, ResponseError);

    _this2 = _super.call(this, msg);

    _defineProperty$1(_assertThisInitialized(_this2), "response", void 0);

    _defineProperty$1(_assertThisInitialized(_this2), "name", "ResponseError");

    _this2.response = response;
    return _this2;
  }

  return _createClass(ResponseError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var FetchError$1 = /*#__PURE__*/function (_Error2) {
  _inherits(FetchError, _Error2);

  var _super2 = _createSuper(FetchError);

  function FetchError(cause, msg) {
    var _this3;

    _classCallCheck(this, FetchError);

    _this3 = _super2.call(this, msg);

    _defineProperty$1(_assertThisInitialized(_this3), "cause", void 0);

    _defineProperty$1(_assertThisInitialized(_this3), "name", "FetchError");

    _this3.cause = cause;
    return _this3;
  }

  return _createClass(FetchError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var RequiredError$1 = /*#__PURE__*/function (_Error3) {
  _inherits(RequiredError, _Error3);

  var _super3 = _createSuper(RequiredError);

  function RequiredError(field, msg) {
    var _this4;

    _classCallCheck(this, RequiredError);

    _this4 = _super3.call(this, msg);

    _defineProperty$1(_assertThisInitialized(_this4), "field", void 0);

    _defineProperty$1(_assertThisInitialized(_this4), "name", "RequiredError");

    _this4.field = field;
    return _this4;
  }

  return _createClass(RequiredError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var COLLECTION_FORMATS$1 = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|"
};
function exists$1(json, key) {
  var value = json[key];
  return value !== null && value !== undefined;
}
function querystring$1(params) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return Object.keys(params).sort().map(function (key) {
    return querystringSingleKey$1(key, params[key], prefix);
  }).filter(function (part) {
    return part.length > 0;
  }).join('&');
}

function querystringSingleKey$1(key, value) {
  var keyPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);

  if (value instanceof Array) {
    var multiValue = value.map(function (singleValue) {
      return encodeURIComponent(String(singleValue));
    }).join("&".concat(encodeURIComponent(fullKey), "="));
    return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
  }

  if (value instanceof Set) {
    var valueAsArray = Array.from(value);
    return querystringSingleKey$1(key, valueAsArray, keyPrefix);
  }

  if (value instanceof Date) {
    return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
  }

  if (value instanceof Object) {
    return querystring$1(value, fullKey);
  }

  return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
}

function mapValues$1(data, fn) {
  return Object.keys(data).reduce(function (acc, key) {
    return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty$1({}, key, fn(data[key])));
  }, {});
}
function canConsumeForm$1(consumes) {
  var _iterator4 = _createForOfIteratorHelper(consumes),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var consume = _step4.value;

      if ('multipart/form-data' === consume.contentType) {
        return true;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return false;
}
var JSONApiResponse$1 = /*#__PURE__*/function () {
  function JSONApiResponse(raw) {
    var transformer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (jsonValue) {
      return jsonValue;
    };

    _classCallCheck(this, JSONApiResponse);

    _defineProperty$1(this, "raw", void 0);

    _defineProperty$1(this, "transformer", void 0);

    this.raw = raw;
    this.transformer = transformer;
  }

  _createClass(JSONApiResponse, [{
    key: "value",
    value: function () {
      var _value = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.t0 = this;
                _context6.next = 3;
                return this.raw.json();

              case 3:
                _context6.t1 = _context6.sent;
                return _context6.abrupt("return", _context6.t0.transformer.call(_context6.t0, _context6.t1));

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function value() {
        return _value.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return JSONApiResponse;
}();
var VoidApiResponse$1 = /*#__PURE__*/function () {
  function VoidApiResponse(raw) {
    _classCallCheck(this, VoidApiResponse);

    _defineProperty$1(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass(VoidApiResponse, [{
    key: "value",
    value: function () {
      var _value2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", undefined);

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function value() {
        return _value2.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return VoidApiResponse;
}();
var BlobApiResponse$1 = /*#__PURE__*/function () {
  function BlobApiResponse(raw) {
    _classCallCheck(this, BlobApiResponse);

    _defineProperty$1(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass(BlobApiResponse, [{
    key: "value",
    value: function () {
      var _value3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.raw.blob();

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function value() {
        return _value3.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return BlobApiResponse;
}();
var TextApiResponse$1 = /*#__PURE__*/function () {
  function TextApiResponse(raw) {
    _classCallCheck(this, TextApiResponse);

    _defineProperty$1(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass(TextApiResponse, [{
    key: "value",
    value: function () {
      var _value4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.raw.text();

              case 2:
                return _context9.abrupt("return", _context9.sent);

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function value() {
        return _value4.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return TextApiResponse;
}();

/* tslint:disable */
/**
 * Check if a given object implements the Activity interface.
 */

function instanceOfActivity(value) {
  var isInstance = true;
  return isInstance;
}
function ActivityFromJSON(json) {
  return ActivityFromJSONTyped(json);
}
function ActivityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'timestamp': !exists$1(json, 'timestamp') ? undefined : json['timestamp'],
    'itemType': !exists$1(json, 'item_type') ? undefined : json['item_type'],
    'item': !exists$1(json, 'item') ? undefined : json['item']
  };
}
function ActivityToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': value.item
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AuthorizedApp interface.
 */

function instanceOfAuthorizedApp(value) {
  var isInstance = true;
  isInstance = isInstance && "address" in value;
  isInstance = isInstance && "name" in value;
  isInstance = isInstance && "grantorUserId" in value;
  isInstance = isInstance && "grantCreatedAt" in value;
  isInstance = isInstance && "grantUpdatedAt" in value;
  return isInstance;
}
function AuthorizedAppFromJSON(json) {
  return AuthorizedAppFromJSONTyped(json);
}
function AuthorizedAppFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'address': json['address'],
    'name': json['name'],
    'description': !exists$1(json, 'description') ? undefined : json['description'],
    'grantorUserId': json['grantor_user_id'],
    'grantCreatedAt': json['grant_created_at'],
    'grantUpdatedAt': json['grant_updated_at']
  };
}
function AuthorizedAppToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'address': value.address,
    'name': value.name,
    'description': value.description,
    'grantor_user_id': value.grantorUserId,
    'grant_created_at': value.grantCreatedAt,
    'grant_updated_at': value.grantUpdatedAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AuthorizedApps interface.
 */

function instanceOfAuthorizedApps(value) {
  var isInstance = true;
  return isInstance;
}
function AuthorizedAppsFromJSON(json) {
  return AuthorizedAppsFromJSONTyped(json);
}
function AuthorizedAppsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(AuthorizedAppFromJSON)
  };
}
function AuthorizedAppsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(AuthorizedAppToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ConnectedWallets interface.
 */

function instanceOfConnectedWallets(value) {
  var isInstance = true;
  isInstance = isInstance && "ercWallets" in value;
  isInstance = isInstance && "splWallets" in value;
  return isInstance;
}
function ConnectedWalletsFromJSON(json) {
  return ConnectedWalletsFromJSONTyped(json);
}
function ConnectedWalletsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'ercWallets': json['erc_wallets'],
    'splWallets': json['spl_wallets']
  };
}
function ConnectedWalletsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'erc_wallets': value.ercWallets,
    'spl_wallets': value.splWallets
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ConnectedWalletsResponse interface.
 */

function instanceOfConnectedWalletsResponse(value) {
  var isInstance = true;
  return isInstance;
}
function ConnectedWalletsResponseFromJSON(json) {
  return ConnectedWalletsResponseFromJSONTyped(json);
}
function ConnectedWalletsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : ConnectedWalletsFromJSON(json['data'])
  };
}
function ConnectedWalletsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': ConnectedWalletsToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoverPhoto interface.
 */

function instanceOfCoverPhoto$1(value) {
  var isInstance = true;
  return isInstance;
}
function CoverPhotoFromJSON$1(json) {
  return CoverPhotoFromJSONTyped$1(json);
}
function CoverPhotoFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_640x': !exists$1(json, '640x') ? undefined : json['640x'],
    '_2000x': !exists$1(json, '2000x') ? undefined : json['2000x']
  };
}
function CoverPhotoToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '640x': value._640x,
    '2000x': value._2000x
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ProfilePicture interface.
 */

function instanceOfProfilePicture$1(value) {
  var isInstance = true;
  return isInstance;
}
function ProfilePictureFromJSON$1(json) {
  return ProfilePictureFromJSONTyped$1(json);
}
function ProfilePictureFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists$1(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists$1(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists$1(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function ProfilePictureToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DecodedUserToken interface.
 */

function instanceOfDecodedUserToken(value) {
  var isInstance = true;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "email" in value;
  isInstance = isInstance && "name" in value;
  isInstance = isInstance && "handle" in value;
  isInstance = isInstance && "verified" in value;
  isInstance = isInstance && "sub" in value;
  isInstance = isInstance && "iat" in value;
  return isInstance;
}
function DecodedUserTokenFromJSON(json) {
  return DecodedUserTokenFromJSONTyped(json);
}
function DecodedUserTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': json['userId'],
    'email': json['email'],
    'name': json['name'],
    'handle': json['handle'],
    'verified': json['verified'],
    'profilePicture': !exists$1(json, 'profilePicture') ? undefined : ProfilePictureFromJSON$1(json['profilePicture']),
    'sub': json['sub'],
    'iat': json['iat']
  };
}
function DecodedUserTokenToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'userId': value.userId,
    'email': value.email,
    'name': value.name,
    'handle': value.handle,
    'verified': value.verified,
    'profilePicture': ProfilePictureToJSON$1(value.profilePicture),
    'sub': value.sub,
    'iat': value.iat
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DeveloperApp interface.
 */

function instanceOfDeveloperApp(value) {
  var isInstance = true;
  isInstance = isInstance && "address" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "name" in value;
  return isInstance;
}
function DeveloperAppFromJSON(json) {
  return DeveloperAppFromJSONTyped(json);
}
function DeveloperAppFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'address': json['address'],
    'userId': json['user_id'],
    'name': json['name'],
    'description': !exists$1(json, 'description') ? undefined : json['description']
  };
}
function DeveloperAppToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'address': value.address,
    'user_id': value.userId,
    'name': value.name,
    'description': value.description
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DeveloperAppResponse interface.
 */

function instanceOfDeveloperAppResponse(value) {
  var isInstance = true;
  return isInstance;
}
function DeveloperAppResponseFromJSON(json) {
  return DeveloperAppResponseFromJSONTyped(json);
}
function DeveloperAppResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : DeveloperAppFromJSON(json['data'])
  };
}
function DeveloperAppResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': DeveloperAppToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DeveloperApps interface.
 */

function instanceOfDeveloperApps(value) {
  var isInstance = true;
  return isInstance;
}
function DeveloperAppsFromJSON(json) {
  return DeveloperAppsFromJSONTyped(json);
}
function DeveloperAppsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(DeveloperAppFromJSON)
  };
}
function DeveloperAppsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(DeveloperAppToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the EncodedUserId interface.
 */

function instanceOfEncodedUserId(value) {
  var isInstance = true;
  return isInstance;
}
function EncodedUserIdFromJSON(json) {
  return EncodedUserIdFromJSONTyped(json);
}
function EncodedUserIdFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': !exists$1(json, 'user_id') ? undefined : json['user_id']
  };
}
function EncodedUserIdToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'user_id': value.userId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Favorite interface.
 */

function instanceOfFavorite$1(value) {
  var isInstance = true;
  isInstance = isInstance && "favoriteItemId" in value;
  isInstance = isInstance && "favoriteType" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "createdAt" in value;
  return isInstance;
}
function FavoriteFromJSON$1(json) {
  return FavoriteFromJSONTyped$1(json);
}
function FavoriteFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'favoriteItemId': json['favorite_item_id'],
    'favoriteType': json['favorite_type'],
    'userId': json['user_id'],
    'createdAt': json['created_at']
  };
}
function FavoriteToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'favorite_item_id': value.favoriteItemId,
    'favorite_type': value.favoriteType,
    'user_id': value.userId,
    'created_at': value.createdAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FavoritesResponse interface.
 */

function instanceOfFavoritesResponse(value) {
  var isInstance = true;
  return isInstance;
}
function FavoritesResponseFromJSON(json) {
  return FavoritesResponseFromJSONTyped(json);
}
function FavoritesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(FavoriteFromJSON$1)
  };
}
function FavoritesResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(FavoriteToJSON$1)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the User interface.
 */

function instanceOfUser(value) {
  var isInstance = true;
  isInstance = isInstance && "albumCount" in value;
  isInstance = isInstance && "followeeCount" in value;
  isInstance = isInstance && "followerCount" in value;
  isInstance = isInstance && "handle" in value;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isVerified" in value;
  isInstance = isInstance && "name" in value;
  isInstance = isInstance && "playlistCount" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "trackCount" in value;
  isInstance = isInstance && "isDeactivated" in value;
  isInstance = isInstance && "isAvailable" in value;
  isInstance = isInstance && "ercWallet" in value;
  isInstance = isInstance && "splWallet" in value;
  isInstance = isInstance && "supporterCount" in value;
  isInstance = isInstance && "supportingCount" in value;
  isInstance = isInstance && "totalAudioBalance" in value;
  return isInstance;
}
function UserFromJSON(json) {
  return UserFromJSONTyped(json);
}
function UserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'albumCount': json['album_count'],
    'artistPickTrackId': !exists$1(json, 'artist_pick_track_id') ? undefined : json['artist_pick_track_id'],
    'bio': !exists$1(json, 'bio') ? undefined : json['bio'],
    'coverPhoto': !exists$1(json, 'cover_photo') ? undefined : CoverPhotoFromJSON$1(json['cover_photo']),
    'followeeCount': json['followee_count'],
    'followerCount': json['follower_count'],
    'doesFollowCurrentUser': !exists$1(json, 'does_follow_current_user') ? undefined : json['does_follow_current_user'],
    'handle': json['handle'],
    'id': json['id'],
    'isVerified': json['is_verified'],
    'location': !exists$1(json, 'location') ? undefined : json['location'],
    'name': json['name'],
    'playlistCount': json['playlist_count'],
    'profilePicture': !exists$1(json, 'profile_picture') ? undefined : ProfilePictureFromJSON$1(json['profile_picture']),
    'repostCount': json['repost_count'],
    'trackCount': json['track_count'],
    'isDeactivated': json['is_deactivated'],
    'isAvailable': json['is_available'],
    'ercWallet': json['erc_wallet'],
    'splWallet': json['spl_wallet'],
    'supporterCount': json['supporter_count'],
    'supportingCount': json['supporting_count'],
    'totalAudioBalance': json['total_audio_balance']
  };
}
function UserToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'album_count': value.albumCount,
    'artist_pick_track_id': value.artistPickTrackId,
    'bio': value.bio,
    'cover_photo': CoverPhotoToJSON$1(value.coverPhoto),
    'followee_count': value.followeeCount,
    'follower_count': value.followerCount,
    'does_follow_current_user': value.doesFollowCurrentUser,
    'handle': value.handle,
    'id': value.id,
    'is_verified': value.isVerified,
    'location': value.location,
    'name': value.name,
    'playlist_count': value.playlistCount,
    'profile_picture': ProfilePictureToJSON$1(value.profilePicture),
    'repost_count': value.repostCount,
    'track_count': value.trackCount,
    'is_deactivated': value.isDeactivated,
    'is_available': value.isAvailable,
    'erc_wallet': value.ercWallet,
    'spl_wallet': value.splWallet,
    'supporter_count': value.supporterCount,
    'supporting_count': value.supportingCount,
    'total_audio_balance': value.totalAudioBalance
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowersResponse interface.
 */

function instanceOfFollowersResponse(value) {
  var isInstance = true;
  return isInstance;
}
function FollowersResponseFromJSON(json) {
  return FollowersResponseFromJSONTyped(json);
}
function FollowersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function FollowersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowingResponse interface.
 */

function instanceOfFollowingResponse$1(value) {
  var isInstance = true;
  return isInstance;
}
function FollowingResponseFromJSON$1(json) {
  return FollowingResponseFromJSONTyped$1(json);
}
function FollowingResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function FollowingResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Supporter interface.
 */

function instanceOfSupporter(value) {
  var isInstance = true;
  isInstance = isInstance && "rank" in value;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "sender" in value;
  return isInstance;
}
function SupporterFromJSON(json) {
  return SupporterFromJSONTyped(json);
}
function SupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'sender': UserFromJSON(json['sender'])
  };
}
function SupporterToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'rank': value.rank,
    'amount': value.amount,
    'sender': UserToJSON(value.sender)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetSupporters interface.
 */

function instanceOfGetSupporters(value) {
  var isInstance = true;
  return isInstance;
}
function GetSupportersFromJSON(json) {
  return GetSupportersFromJSONTyped(json);
}
function GetSupportersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(SupporterFromJSON)
  };
}
function GetSupportersToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(SupporterToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Supporting interface.
 */

function instanceOfSupporting(value) {
  var isInstance = true;
  isInstance = isInstance && "rank" in value;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "receiver" in value;
  return isInstance;
}
function SupportingFromJSON(json) {
  return SupportingFromJSONTyped(json);
}
function SupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'receiver': UserFromJSON(json['receiver'])
  };
}
function SupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'rank': value.rank,
    'amount': value.amount,
    'receiver': UserToJSON(value.receiver)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetSupporting interface.
 */

function instanceOfGetSupporting(value) {
  var isInstance = true;
  return isInstance;
}
function GetSupportingFromJSON(json) {
  return GetSupportingFromJSONTyped(json);
}
function GetSupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(SupportingFromJSON)
  };
}
function GetSupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(SupportingToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Tip interface.
 */

function instanceOfTip(value) {
  var isInstance = true;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "createdAt" in value;
  return isInstance;
}
function TipFromJSON(json) {
  return TipFromJSONTyped(json);
}
function TipFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'amount': json['amount'],
    'sender': !exists$1(json, 'sender') ? undefined : UserFromJSON(json['sender']),
    'receiver': !exists$1(json, 'receiver') ? undefined : UserFromJSON(json['receiver']),
    'createdAt': json['created_at']
  };
}
function TipToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'amount': value.amount,
    'sender': UserToJSON(value.sender),
    'receiver': UserToJSON(value.receiver),
    'created_at': value.createdAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetTipsResponse interface.
 */

function instanceOfGetTipsResponse$1(value) {
  var isInstance = true;
  return isInstance;
}
function GetTipsResponseFromJSON$1(json) {
  return GetTipsResponseFromJSONTyped$1(json);
}
function GetTipsResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(TipFromJSON)
  };
}
function GetTipsResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(TipToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistAddedTimestamp interface.
 */

function instanceOfPlaylistAddedTimestamp$1(value) {
  var isInstance = true;
  isInstance = isInstance && "metadataTimestamp" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "trackId" in value;
  return isInstance;
}
function PlaylistAddedTimestampFromJSON$1(json) {
  return PlaylistAddedTimestampFromJSONTyped$1(json);
}
function PlaylistAddedTimestampFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'metadataTimestamp': json['metadata_timestamp'],
    'timestamp': json['timestamp'],
    'trackId': json['track_id']
  };
}
function PlaylistAddedTimestampToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'metadata_timestamp': value.metadataTimestamp,
    'timestamp': value.timestamp,
    'track_id': value.trackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistArtwork interface.
 */

function instanceOfPlaylistArtwork$1(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistArtworkFromJSON$1(json) {
  return PlaylistArtworkFromJSONTyped$1(json);
}
function PlaylistArtworkFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists$1(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists$1(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists$1(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function PlaylistArtworkToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Playlist interface.
 */

function instanceOfPlaylist(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isAlbum" in value;
  isInstance = isInstance && "isImageAutogenerated" in value;
  isInstance = isInstance && "playlistName" in value;
  isInstance = isInstance && "playlistContents" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "totalPlayCount" in value;
  isInstance = isInstance && "user" in value;
  return isInstance;
}
function PlaylistFromJSON(json) {
  return PlaylistFromJSONTyped(json);
}
function PlaylistFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists$1(json, 'artwork') ? undefined : PlaylistArtworkFromJSON$1(json['artwork']),
    'description': !exists$1(json, 'description') ? undefined : json['description'],
    'permalink': !exists$1(json, 'permalink') ? undefined : json['permalink'],
    'id': json['id'],
    'isAlbum': json['is_album'],
    'isImageAutogenerated': json['is_image_autogenerated'],
    'playlistName': json['playlist_name'],
    'playlistContents': json['playlist_contents'].map(PlaylistAddedTimestampFromJSON$1),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'totalPlayCount': json['total_play_count'],
    'user': UserFromJSON(json['user'])
  };
}
function PlaylistToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': PlaylistArtworkToJSON$1(value.artwork),
    'description': value.description,
    'permalink': value.permalink,
    'id': value.id,
    'is_album': value.isAlbum,
    'is_image_autogenerated': value.isImageAutogenerated,
    'playlist_name': value.playlistName,
    'playlist_contents': value.playlistContents.map(PlaylistAddedTimestampToJSON$1),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'total_play_count': value.totalPlayCount,
    'user': UserToJSON(value.user)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistResponse interface.
 */

function instanceOfPlaylistResponse(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistResponseFromJSON(json) {
  return PlaylistResponseFromJSONTyped(json);
}
function PlaylistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(PlaylistFromJSON)
  };
}
function PlaylistResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(PlaylistToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistSearchResult interface.
 */

function instanceOfPlaylistSearchResult(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistSearchResultFromJSON(json) {
  return PlaylistSearchResultFromJSONTyped(json);
}
function PlaylistSearchResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(PlaylistFromJSON)
  };
}
function PlaylistSearchResultToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(PlaylistToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackElement interface.
 */

function instanceOfTrackElement(value) {
  var isInstance = true;
  isInstance = isInstance && "parentTrackId" in value;
  return isInstance;
}
function TrackElementFromJSON(json) {
  return TrackElementFromJSONTyped(json);
}
function TrackElementFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'parentTrackId': json['parent_track_id']
  };
}
function TrackElementToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'parent_track_id': value.parentTrackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixParent interface.
 */

function instanceOfRemixParent(value) {
  var isInstance = true;
  return isInstance;
}
function RemixParentFromJSON(json) {
  return RemixParentFromJSONTyped(json);
}
function RemixParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'tracks': !exists$1(json, 'tracks') ? undefined : json['tracks'].map(TrackElementFromJSON)
  };
}
function RemixParentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackElementToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackArtwork interface.
 */

function instanceOfTrackArtwork$1(value) {
  var isInstance = true;
  return isInstance;
}
function TrackArtworkFromJSON$1(json) {
  return TrackArtworkFromJSONTyped$1(json);
}
function TrackArtworkFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists$1(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists$1(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists$1(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function TrackArtworkToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Track interface.
 */

function instanceOfTrack(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "title" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "duration" in value;
  isInstance = isInstance && "playCount" in value;
  return isInstance;
}
function TrackFromJSON(json) {
  return TrackFromJSONTyped(json);
}
function TrackFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists$1(json, 'artwork') ? undefined : TrackArtworkFromJSON$1(json['artwork']),
    'description': !exists$1(json, 'description') ? undefined : json['description'],
    'genre': !exists$1(json, 'genre') ? undefined : json['genre'],
    'id': json['id'],
    'trackCid': !exists$1(json, 'track_cid') ? undefined : json['track_cid'],
    'previewCid': !exists$1(json, 'preview_cid') ? undefined : json['preview_cid'],
    'mood': !exists$1(json, 'mood') ? undefined : json['mood'],
    'releaseDate': !exists$1(json, 'release_date') ? undefined : json['release_date'],
    'remixOf': !exists$1(json, 'remix_of') ? undefined : RemixParentFromJSON(json['remix_of']),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'tags': !exists$1(json, 'tags') ? undefined : json['tags'],
    'title': json['title'],
    'user': UserFromJSON(json['user']),
    'duration': json['duration'],
    'downloadable': !exists$1(json, 'downloadable') ? undefined : json['downloadable'],
    'playCount': json['play_count'],
    'permalink': !exists$1(json, 'permalink') ? undefined : json['permalink'],
    'isStreamable': !exists$1(json, 'is_streamable') ? undefined : json['is_streamable']
  };
}
function TrackToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': TrackArtworkToJSON$1(value.artwork),
    'description': value.description,
    'genre': value.genre,
    'id': value.id,
    'track_cid': value.trackCid,
    'preview_cid': value.previewCid,
    'mood': value.mood,
    'release_date': value.releaseDate,
    'remix_of': RemixParentToJSON(value.remixOf),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'tags': value.tags,
    'title': value.title,
    'user': UserToJSON(value.user),
    'duration': value.duration,
    'downloadable': value.downloadable,
    'play_count': value.playCount,
    'permalink': value.permalink,
    'is_streamable': value.isStreamable
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistTracksResponse interface.
 */

function instanceOfPlaylistTracksResponse(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistTracksResponseFromJSON(json) {
  return PlaylistTracksResponseFromJSONTyped(json);
}
function PlaylistTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(TrackFromJSON)
  };
}
function PlaylistTracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(TrackToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RelatedArtistResponse interface.
 */

function instanceOfRelatedArtistResponse(value) {
  var isInstance = true;
  return isInstance;
}
function RelatedArtistResponseFromJSON(json) {
  return RelatedArtistResponseFromJSONTyped(json);
}
function RelatedArtistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function RelatedArtistResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Reposts interface.
 */

function instanceOfReposts(value) {
  var isInstance = true;
  return isInstance;
}
function RepostsFromJSON(json) {
  return RepostsFromJSONTyped(json);
}
function RepostsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(ActivityFromJSON)
  };
}
function RepostsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(ActivityToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SubscribersResponse interface.
 */

function instanceOfSubscribersResponse(value) {
  var isInstance = true;
  return isInstance;
}
function SubscribersResponseFromJSON(json) {
  return SubscribersResponseFromJSONTyped(json);
}
function SubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function SubscribersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TagsResponse interface.
 */

function instanceOfTagsResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TagsResponseFromJSON(json) {
  return TagsResponseFromJSONTyped(json);
}
function TagsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data']
  };
}
function TagsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackResponse interface.
 */

function instanceOfTrackResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TrackResponseFromJSON(json) {
  return TrackResponseFromJSONTyped(json);
}
function TrackResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : TrackFromJSON(json['data'])
  };
}
function TrackResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': TrackToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackSearch interface.
 */

function instanceOfTrackSearch(value) {
  var isInstance = true;
  return isInstance;
}
function TrackSearchFromJSON(json) {
  return TrackSearchFromJSONTyped(json);
}
function TrackSearchFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(TrackFromJSON)
  };
}
function TrackSearchToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(TrackToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TracksResponse interface.
 */

function instanceOfTracksResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TracksResponseFromJSON(json) {
  return TracksResponseFromJSONTyped(json);
}
function TracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(TrackFromJSON)
  };
}
function TracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(TrackToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingPlaylistsResponse interface.
 */

function instanceOfTrendingPlaylistsResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TrendingPlaylistsResponseFromJSON(json) {
  return TrendingPlaylistsResponseFromJSONTyped(json);
}
function TrendingPlaylistsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(PlaylistFromJSON)
  };
}
function TrendingPlaylistsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(PlaylistToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserAssociatedWalletResponse interface.
 */

function instanceOfUserAssociatedWalletResponse(value) {
  var isInstance = true;
  return isInstance;
}
function UserAssociatedWalletResponseFromJSON(json) {
  return UserAssociatedWalletResponseFromJSONTyped(json);
}
function UserAssociatedWalletResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : EncodedUserIdFromJSON(json['data'])
  };
}
function UserAssociatedWalletResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': EncodedUserIdToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserResponse interface.
 */

function instanceOfUserResponse(value) {
  var isInstance = true;
  return isInstance;
}
function UserResponseFromJSON(json) {
  return UserResponseFromJSONTyped(json);
}
function UserResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : UserFromJSON(json['data'])
  };
}
function UserResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': UserToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserSearch interface.
 */

function instanceOfUserSearch(value) {
  var isInstance = true;
  return isInstance;
}
function UserSearchFromJSON(json) {
  return UserSearchFromJSONTyped(json);
}
function UserSearchFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function UserSearchToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the VerifyToken interface.
 */

function instanceOfVerifyToken(value) {
  var isInstance = true;
  return isInstance;
}
function VerifyTokenFromJSON(json) {
  return VerifyTokenFromJSONTyped(json);
}
function VerifyTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : DecodedUserTokenFromJSON(json['data'])
  };
}
function VerifyTokenToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': DecodedUserTokenToJSON(value.data)
  };
}

/**
 *
 */

var DeveloperAppsApi$1 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(DeveloperAppsApi, _runtime$BaseAPI);

  var _super = _createSuper(DeveloperAppsApi);

  function DeveloperAppsApi() {
    _classCallCheck(this, DeveloperAppsApi);

    return _super.apply(this, arguments);
  }

  _createClass(DeveloperAppsApi, [{
    key: "getDeveloperAppRaw",
    value:
    /** @hidden
     * Gets developer app matching given address (API key)
     */
    function () {
      var _getDeveloperAppRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.address === null || params.address === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('address', 'Required parameter params.address was null or undefined when calling getDeveloperApp.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context.next = 6;
                return this.request({
                  path: "/developer_apps/{address}".replace("{".concat("address", "}"), encodeURIComponent(String(params.address))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return DeveloperAppResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getDeveloperAppRaw(_x, _x2) {
        return _getDeveloperAppRaw.apply(this, arguments);
      }

      return getDeveloperAppRaw;
    }()
    /**
     * Gets developer app matching given address (API key)
     */

  }, {
    key: "getDeveloperApp",
    value: function () {
      var _getDeveloperApp = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getDeveloperAppRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getDeveloperApp(_x3, _x4) {
        return _getDeveloperApp.apply(this, arguments);
      }

      return getDeveloperApp;
    }()
  }]);

  return DeveloperAppsApi;
}(BaseAPI$1);

/**
 *
 */

var PlaylistsApi$2 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(PlaylistsApi, _runtime$BaseAPI);

  var _super = _createSuper(PlaylistsApi);

  function PlaylistsApi() {
    _classCallCheck(this, PlaylistsApi);

    return _super.apply(this, arguments);
  }

  _createClass(PlaylistsApi, [{
    key: "getPlaylistRaw",
    value:
    /** @hidden
     * Get a playlist by ID
     */
    function () {
      var _getPlaylistRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylist.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context.next = 7;
                return this.request({
                  path: "/playlists/{playlist_id}".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return PlaylistResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getPlaylistRaw(_x, _x2) {
        return _getPlaylistRaw.apply(this, arguments);
      }

      return getPlaylistRaw;
    }()
    /**
     * Get a playlist by ID
     */

  }, {
    key: "getPlaylist",
    value: function () {
      var _getPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getPlaylistRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getPlaylist(_x3, _x4) {
        return _getPlaylist.apply(this, arguments);
      }

      return getPlaylist;
    }()
    /** @hidden
     * Fetch tracks within a playlist.
     */

  }, {
    key: "getPlaylistTracksRaw",
    value: function () {
      var _getPlaylistTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError$1('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylistTracks.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context3.next = 6;
                return this.request({
                  path: "/playlists/{playlist_id}/tracks".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return PlaylistTracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getPlaylistTracksRaw(_x5, _x6) {
        return _getPlaylistTracksRaw.apply(this, arguments);
      }

      return getPlaylistTracksRaw;
    }()
    /**
     * Fetch tracks within a playlist.
     */

  }, {
    key: "getPlaylistTracks",
    value: function () {
      var _getPlaylistTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getPlaylistTracksRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getPlaylistTracks(_x7, _x8) {
        return _getPlaylistTracks.apply(this, arguments);
      }

      return getPlaylistTracks;
    }()
    /** @hidden
     * Gets trending playlists for a time period
     */

  }, {
    key: "getTrendingPlaylistsRaw",
    value: function () {
      var _getTrendingPlaylistsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                queryParameters = {};

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context5.next = 5;
                return this.request({
                  path: "/playlists/trending",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 5:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TrendingPlaylistsResponseFromJSON(jsonValue);
                }));

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getTrendingPlaylistsRaw(_x9, _x10) {
        return _getTrendingPlaylistsRaw.apply(this, arguments);
      }

      return getTrendingPlaylistsRaw;
    }()
    /**
     * Gets trending playlists for a time period
     */

  }, {
    key: "getTrendingPlaylists",
    value: function () {
      var _getTrendingPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var params,
            initOverrides,
            response,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                params = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
                initOverrides = _args6.length > 1 ? _args6[1] : undefined;
                _context6.next = 4;
                return this.getTrendingPlaylistsRaw(params, initOverrides);

              case 4:
                response = _context6.sent;
                _context6.next = 7;
                return response.value();

              case 7:
                return _context6.abrupt("return", _context6.sent);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getTrendingPlaylists() {
        return _getTrendingPlaylists.apply(this, arguments);
      }

      return getTrendingPlaylists;
    }()
    /** @hidden
     * Search for a playlist
     */

  }, {
    key: "searchPlaylistsRaw",
    value: function () {
      var _searchPlaylistsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context7.next = 2;
                  break;
                }

                throw new RequiredError$1('query', 'Required parameter params.query was null or undefined when calling searchPlaylists.');

              case 2:
                queryParameters = {};

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                headerParameters = {};
                _context7.next = 7;
                return this.request({
                  path: "/playlists/search",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return PlaylistSearchResultFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function searchPlaylistsRaw(_x11, _x12) {
        return _searchPlaylistsRaw.apply(this, arguments);
      }

      return searchPlaylistsRaw;
    }()
    /**
     * Search for a playlist
     */

  }, {
    key: "searchPlaylists",
    value: function () {
      var _searchPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.searchPlaylistsRaw(params, initOverrides);

              case 2:
                response = _context8.sent;
                _context8.next = 5;
                return response.value();

              case 5:
                return _context8.abrupt("return", _context8.sent);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function searchPlaylists(_x13, _x14) {
        return _searchPlaylists.apply(this, arguments);
      }

      return searchPlaylists;
    }()
  }]);

  return PlaylistsApi;
}(BaseAPI$1);
/**
 * @export
 */

var GetTrendingPlaylistsTimeEnum$1 = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};

/**
 *
 */

var TipsApi$1 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TipsApi, _runtime$BaseAPI);

  var _super = _createSuper(TipsApi);

  function TipsApi() {
    _classCallCheck(this, TipsApi);

    return _super.apply(this, arguments);
  }

  _createClass(TipsApi, [{
    key: "getTipsRaw",
    value:
    /** @hidden
     * Gets the most recent tips on the network
     */
    function () {
      var _getTipsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.receiverMinFollowers !== undefined) {
                  queryParameters['receiver_min_followers'] = params.receiverMinFollowers;
                }

                if (params.receiverIsVerified !== undefined) {
                  queryParameters['receiver_is_verified'] = params.receiverIsVerified;
                }

                if (params.currentUserFollows !== undefined) {
                  queryParameters['current_user_follows'] = params.currentUserFollows;
                }

                if (params.uniqueBy !== undefined) {
                  queryParameters['unique_by'] = params.uniqueBy;
                }

                headerParameters = {};
                _context.next = 11;
                return this.request({
                  path: "/tips",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return GetTipsResponseFromJSON$1(jsonValue);
                }));

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getTipsRaw(_x, _x2) {
        return _getTipsRaw.apply(this, arguments);
      }

      return getTipsRaw;
    }()
    /**
     * Gets the most recent tips on the network
     */

  }, {
    key: "getTips",
    value: function () {
      var _getTips = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var params,
            initOverrides,
            response,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                params = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                initOverrides = _args2.length > 1 ? _args2[1] : undefined;
                _context2.next = 4;
                return this.getTipsRaw(params, initOverrides);

              case 4:
                response = _context2.sent;
                _context2.next = 7;
                return response.value();

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getTips() {
        return _getTips.apply(this, arguments);
      }

      return getTips;
    }()
  }]);

  return TipsApi;
}(BaseAPI$1);
/**
 * @export
 */

var GetTipsCurrentUserFollowsEnum$1 = {
  Sender: 'sender',
  Receiver: 'receiver',
  SenderOrReceiver: 'sender_or_receiver'
};
/**
 * @export
 */

var GetTipsUniqueByEnum$1 = {
  Sender: 'sender',
  Receiver: 'receiver'
};

/**
 *
 */

var TracksApi$2 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TracksApi, _runtime$BaseAPI);

  var _super = _createSuper(TracksApi);

  function TracksApi() {
    _classCallCheck(this, TracksApi);

    return _super.apply(this, arguments);
  }

  _createClass(TracksApi, [{
    key: "getBulkTracksRaw",
    value:
    /** @hidden
     * Gets a list of tracks using their IDs or permalinks
     */
    function () {
      var _getBulkTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                queryParameters = {};

                if (params.permalink) {
                  queryParameters['permalink'] = params.permalink;
                }

                if (params.id) {
                  queryParameters['id'] = params.id;
                }

                headerParameters = {};
                _context.next = 6;
                return this.request({
                  path: "/tracks",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getBulkTracksRaw(_x, _x2) {
        return _getBulkTracksRaw.apply(this, arguments);
      }

      return getBulkTracksRaw;
    }()
    /**
     * Gets a list of tracks using their IDs or permalinks
     */

  }, {
    key: "getBulkTracks",
    value: function () {
      var _getBulkTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var params,
            initOverrides,
            response,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                params = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                initOverrides = _args2.length > 1 ? _args2[1] : undefined;
                _context2.next = 4;
                return this.getBulkTracksRaw(params, initOverrides);

              case 4:
                response = _context2.sent;
                _context2.next = 7;
                return response.value();

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getBulkTracks() {
        return _getBulkTracks.apply(this, arguments);
      }

      return getBulkTracks;
    }()
    /** @hidden
     * Gets a track by ID
     */

  }, {
    key: "getTrackRaw",
    value: function () {
      var _getTrackRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrack.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context3.next = 6;
                return this.request({
                  path: "/tracks/{track_id}".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TrackResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getTrackRaw(_x3, _x4) {
        return _getTrackRaw.apply(this, arguments);
      }

      return getTrackRaw;
    }()
    /**
     * Gets a track by ID
     */

  }, {
    key: "getTrack",
    value: function () {
      var _getTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getTrackRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getTrack(_x5, _x6) {
        return _getTrack.apply(this, arguments);
      }

      return getTrack;
    }()
    /** @hidden
     * Gets the top 100 trending (most popular) tracks on Audius
     */

  }, {
    key: "getTrendingTracksRaw",
    value: function () {
      var _getTrendingTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                queryParameters = {};

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context5.next = 6;
                return this.request({
                  path: "/tracks/trending",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getTrendingTracksRaw(_x7, _x8) {
        return _getTrendingTracksRaw.apply(this, arguments);
      }

      return getTrendingTracksRaw;
    }()
    /**
     * Gets the top 100 trending (most popular) tracks on Audius
     */

  }, {
    key: "getTrendingTracks",
    value: function () {
      var _getTrendingTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var params,
            initOverrides,
            response,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                params = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
                initOverrides = _args6.length > 1 ? _args6[1] : undefined;
                _context6.next = 4;
                return this.getTrendingTracksRaw(params, initOverrides);

              case 4:
                response = _context6.sent;
                _context6.next = 7;
                return response.value();

              case 7:
                return _context6.abrupt("return", _context6.sent);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getTrendingTracks() {
        return _getTrendingTracks.apply(this, arguments);
      }

      return getTrendingTracks;
    }()
    /** @hidden
     * Gets the top 100 trending underground tracks on Audius
     */

  }, {
    key: "getUndergroundTrendingTracksRaw",
    value: function () {
      var _getUndergroundTrendingTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                headerParameters = {};
                _context7.next = 6;
                return this.request({
                  path: "/tracks/trending/underground",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getUndergroundTrendingTracksRaw(_x9, _x10) {
        return _getUndergroundTrendingTracksRaw.apply(this, arguments);
      }

      return getUndergroundTrendingTracksRaw;
    }()
    /**
     * Gets the top 100 trending underground tracks on Audius
     */

  }, {
    key: "getUndergroundTrendingTracks",
    value: function () {
      var _getUndergroundTrendingTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var params,
            initOverrides,
            response,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                params = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};
                initOverrides = _args8.length > 1 ? _args8[1] : undefined;
                _context8.next = 4;
                return this.getUndergroundTrendingTracksRaw(params, initOverrides);

              case 4:
                response = _context8.sent;
                _context8.next = 7;
                return response.value();

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getUndergroundTrendingTracks() {
        return _getUndergroundTrendingTracks.apply(this, arguments);
      }

      return getUndergroundTrendingTracks;
    }()
    /** @hidden
     * Search for a track or tracks
     */

  }, {
    key: "searchTracksRaw",
    value: function () {
      var _searchTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError$1('query', 'Required parameter params.query was null or undefined when calling searchTracks.');

              case 2:
                queryParameters = {};

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.onlyDownloadable !== undefined) {
                  queryParameters['only_downloadable'] = params.onlyDownloadable;
                }

                headerParameters = {};
                _context9.next = 8;
                return this.request({
                  path: "/tracks/search",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context9.sent;
                return _context9.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TrackSearchFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function searchTracksRaw(_x11, _x12) {
        return _searchTracksRaw.apply(this, arguments);
      }

      return searchTracksRaw;
    }()
    /**
     * Search for a track or tracks
     */

  }, {
    key: "searchTracks",
    value: function () {
      var _searchTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.searchTracksRaw(params, initOverrides);

              case 2:
                response = _context10.sent;
                _context10.next = 5;
                return response.value();

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function searchTracks(_x13, _x14) {
        return _searchTracks.apply(this, arguments);
      }

      return searchTracks;
    }()
    /** @hidden
     * This endpoint accepts the Range header for streaming. https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests
     * Get the streamable MP3 file of a track
     */

  }, {
    key: "streamTrackRaw",
    value: function () {
      var _streamTrackRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context11.next = 2;
                  break;
                }

                throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling streamTrack.');

              case 2:
                queryParameters = {};

                if (params.preview !== undefined) {
                  queryParameters['preview'] = params.preview;
                }

                if (params.userSignature !== undefined) {
                  queryParameters['user_signature'] = params.userSignature;
                }

                if (params.userData !== undefined) {
                  queryParameters['user_data'] = params.userData;
                }

                if (params.premiumContentSignature !== undefined) {
                  queryParameters['premium_content_signature'] = params.premiumContentSignature;
                }

                if (params.filename !== undefined) {
                  queryParameters['filename'] = params.filename;
                }

                if (params.skipPlayCount !== undefined) {
                  queryParameters['skip_play_count'] = params.skipPlayCount;
                }

                headerParameters = {};
                _context11.next = 12;
                return this.request({
                  path: "/tracks/{track_id}/stream".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 12:
                response = _context11.sent;
                return _context11.abrupt("return", new VoidApiResponse$1(response));

              case 14:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function streamTrackRaw(_x15, _x16) {
        return _streamTrackRaw.apply(this, arguments);
      }

      return streamTrackRaw;
    }()
    /**
     * This endpoint accepts the Range header for streaming. https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests
     * Get the streamable MP3 file of a track
     */

  }, {
    key: "streamTrack",
    value: function () {
      var _streamTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.streamTrackRaw(params, initOverrides);

              case 2:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function streamTrack(_x17, _x18) {
        return _streamTrack.apply(this, arguments);
      }

      return streamTrack;
    }()
  }]);

  return TracksApi;
}(BaseAPI$1);
/**
 * @export
 */

var GetTrendingTracksTimeEnum$1 = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};

/**
 *
 */

var UsersApi$2 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(UsersApi, _runtime$BaseAPI);

  var _super = _createSuper(UsersApi);

  function UsersApi() {
    _classCallCheck(this, UsersApi);

    return _super.apply(this, arguments);
  }

  _createClass(UsersApi, [{
    key: "getAIAttributedTracksByUserHandleRaw",
    value:
    /** @hidden
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */
    function () {
      var _getAIAttributedTracksByUserHandleRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('handle', 'Required parameter params.handle was null or undefined when calling getAIAttributedTracksByUserHandle.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context.next = 14;
                return this.request({
                  path: "/users/handle/{handle}/tracks/ai_attributed".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAIAttributedTracksByUserHandleRaw(_x, _x2) {
        return _getAIAttributedTracksByUserHandleRaw.apply(this, arguments);
      }

      return getAIAttributedTracksByUserHandleRaw;
    }()
    /**
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */

  }, {
    key: "getAIAttributedTracksByUserHandle",
    value: function () {
      var _getAIAttributedTracksByUserHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getAIAttributedTracksByUserHandleRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getAIAttributedTracksByUserHandle(_x3, _x4) {
        return _getAIAttributedTracksByUserHandle.apply(this, arguments);
      }

      return getAIAttributedTracksByUserHandle;
    }()
    /** @hidden
     * Get the apps that user has authorized to write to their account
     */

  }, {
    key: "getAuthorizedAppsRaw",
    value: function () {
      var _getAuthorizedAppsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getAuthorizedApps.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context3.next = 6;
                return this.request({
                  path: "/users/{id}/authorized_apps".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return AuthorizedAppsFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getAuthorizedAppsRaw(_x5, _x6) {
        return _getAuthorizedAppsRaw.apply(this, arguments);
      }

      return getAuthorizedAppsRaw;
    }()
    /**
     * Get the apps that user has authorized to write to their account
     */

  }, {
    key: "getAuthorizedApps",
    value: function () {
      var _getAuthorizedApps = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getAuthorizedAppsRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAuthorizedApps(_x7, _x8) {
        return _getAuthorizedApps.apply(this, arguments);
      }

      return getAuthorizedApps;
    }()
    /** @hidden
     * Get the User\'s ERC and SPL connected wallets
     */

  }, {
    key: "getConnectedWalletsRaw",
    value: function () {
      var _getConnectedWalletsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context5.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getConnectedWallets.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context5.next = 6;
                return this.request({
                  path: "/users/{id}/connected_wallets".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return ConnectedWalletsResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getConnectedWalletsRaw(_x9, _x10) {
        return _getConnectedWalletsRaw.apply(this, arguments);
      }

      return getConnectedWalletsRaw;
    }()
    /**
     * Get the User\'s ERC and SPL connected wallets
     */

  }, {
    key: "getConnectedWallets",
    value: function () {
      var _getConnectedWallets = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getConnectedWalletsRaw(params, initOverrides);

              case 2:
                response = _context6.sent;
                _context6.next = 5;
                return response.value();

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getConnectedWallets(_x11, _x12) {
        return _getConnectedWallets.apply(this, arguments);
      }

      return getConnectedWallets;
    }()
    /** @hidden
     * Gets the developer apps that the user owns
     */

  }, {
    key: "getDeveloperAppsRaw",
    value: function () {
      var _getDeveloperAppsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context7.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getDeveloperApps.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context7.next = 6;
                return this.request({
                  path: "/users/{id}/developer_apps".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return DeveloperAppsFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getDeveloperAppsRaw(_x13, _x14) {
        return _getDeveloperAppsRaw.apply(this, arguments);
      }

      return getDeveloperAppsRaw;
    }()
    /**
     * Gets the developer apps that the user owns
     */

  }, {
    key: "getDeveloperApps",
    value: function () {
      var _getDeveloperApps = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getDeveloperAppsRaw(params, initOverrides);

              case 2:
                response = _context8.sent;
                _context8.next = 5;
                return response.value();

              case 5:
                return _context8.abrupt("return", _context8.sent);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getDeveloperApps(_x15, _x16) {
        return _getDeveloperApps.apply(this, arguments);
      }

      return getDeveloperApps;
    }()
    /** @hidden
     * Gets a user\'s favorite tracks
     */

  }, {
    key: "getFavoritesRaw",
    value: function () {
      var _getFavoritesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getFavorites.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context9.next = 6;
                return this.request({
                  path: "/users/{id}/favorites".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context9.sent;
                return _context9.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return FavoritesResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getFavoritesRaw(_x17, _x18) {
        return _getFavoritesRaw.apply(this, arguments);
      }

      return getFavoritesRaw;
    }()
    /**
     * Gets a user\'s favorite tracks
     */

  }, {
    key: "getFavorites",
    value: function () {
      var _getFavorites = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getFavoritesRaw(params, initOverrides);

              case 2:
                response = _context10.sent;
                _context10.next = 5;
                return response.value();

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getFavorites(_x19, _x20) {
        return _getFavorites.apply(this, arguments);
      }

      return getFavorites;
    }()
    /** @hidden
     * All users that follow the provided user
     */

  }, {
    key: "getFollowersRaw",
    value: function () {
      var _getFollowersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context11.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getFollowers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context11.next = 9;
                return this.request({
                  path: "/users/{id}/followers".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context11.sent;
                return _context11.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return FollowersResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getFollowersRaw(_x21, _x22) {
        return _getFollowersRaw.apply(this, arguments);
      }

      return getFollowersRaw;
    }()
    /**
     * All users that follow the provided user
     */

  }, {
    key: "getFollowers",
    value: function () {
      var _getFollowers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getFollowersRaw(params, initOverrides);

              case 2:
                response = _context12.sent;
                _context12.next = 5;
                return response.value();

              case 5:
                return _context12.abrupt("return", _context12.sent);

              case 6:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getFollowers(_x23, _x24) {
        return _getFollowers.apply(this, arguments);
      }

      return getFollowers;
    }()
    /** @hidden
     * All users that the provided user follows
     */

  }, {
    key: "getFollowingRaw",
    value: function () {
      var _getFollowingRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context13.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getFollowing.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context13.next = 9;
                return this.request({
                  path: "/users/{id}/following".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context13.sent;
                return _context13.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return FollowingResponseFromJSON$1(jsonValue);
                }));

              case 11:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getFollowingRaw(_x25, _x26) {
        return _getFollowingRaw.apply(this, arguments);
      }

      return getFollowingRaw;
    }()
    /**
     * All users that the provided user follows
     */

  }, {
    key: "getFollowing",
    value: function () {
      var _getFollowing = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getFollowingRaw(params, initOverrides);

              case 2:
                response = _context14.sent;
                _context14.next = 5;
                return response.value();

              case 5:
                return _context14.abrupt("return", _context14.sent);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getFollowing(_x27, _x28) {
        return _getFollowing.apply(this, arguments);
      }

      return getFollowing;
    }()
    /** @hidden
     * Gets a list of users that might be of interest to followers of this user.
     */

  }, {
    key: "getRelatedUsersRaw",
    value: function () {
      var _getRelatedUsersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context15.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getRelatedUsers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context15.next = 9;
                return this.request({
                  path: "/users/{id}/related".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context15.sent;
                return _context15.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return RelatedArtistResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getRelatedUsersRaw(_x29, _x30) {
        return _getRelatedUsersRaw.apply(this, arguments);
      }

      return getRelatedUsersRaw;
    }()
    /**
     * Gets a list of users that might be of interest to followers of this user.
     */

  }, {
    key: "getRelatedUsers",
    value: function () {
      var _getRelatedUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.getRelatedUsersRaw(params, initOverrides);

              case 2:
                response = _context16.sent;
                _context16.next = 5;
                return response.value();

              case 5:
                return _context16.abrupt("return", _context16.sent);

              case 6:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getRelatedUsers(_x31, _x32) {
        return _getRelatedUsers.apply(this, arguments);
      }

      return getRelatedUsers;
    }()
    /** @hidden
     * Gets the given user\'s reposts
     */

  }, {
    key: "getRepostsRaw",
    value: function () {
      var _getRepostsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context17.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getReposts.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context17.next = 9;
                return this.request({
                  path: "/users/{id}/reposts".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context17.sent;
                return _context17.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return RepostsFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getRepostsRaw(_x33, _x34) {
        return _getRepostsRaw.apply(this, arguments);
      }

      return getRepostsRaw;
    }()
    /**
     * Gets the given user\'s reposts
     */

  }, {
    key: "getReposts",
    value: function () {
      var _getReposts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.getRepostsRaw(params, initOverrides);

              case 2:
                response = _context18.sent;
                _context18.next = 5;
                return response.value();

              case 5:
                return _context18.abrupt("return", _context18.sent);

              case 6:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getReposts(_x35, _x36) {
        return _getReposts.apply(this, arguments);
      }

      return getReposts;
    }()
    /** @hidden
     * All users that subscribe to the provided user
     */

  }, {
    key: "getSubscribersRaw",
    value: function () {
      var _getSubscribersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context19.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getSubscribers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context19.next = 9;
                return this.request({
                  path: "/users/{id}/subscribers".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context19.sent;
                return _context19.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return SubscribersResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getSubscribersRaw(_x37, _x38) {
        return _getSubscribersRaw.apply(this, arguments);
      }

      return getSubscribersRaw;
    }()
    /**
     * All users that subscribe to the provided user
     */

  }, {
    key: "getSubscribers",
    value: function () {
      var _getSubscribers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getSubscribersRaw(params, initOverrides);

              case 2:
                response = _context20.sent;
                _context20.next = 5;
                return response.value();

              case 5:
                return _context20.abrupt("return", _context20.sent);

              case 6:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getSubscribers(_x39, _x40) {
        return _getSubscribers.apply(this, arguments);
      }

      return getSubscribers;
    }()
    /** @hidden
     * Gets the supporters of the given user
     */

  }, {
    key: "getSupportersRaw",
    value: function () {
      var _getSupportersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context21.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getSupporters.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                headerParameters = {};
                _context21.next = 8;
                return this.request({
                  path: "/users/{id}/supporters".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context21.sent;
                return _context21.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return GetSupportersFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getSupportersRaw(_x41, _x42) {
        return _getSupportersRaw.apply(this, arguments);
      }

      return getSupportersRaw;
    }()
    /**
     * Gets the supporters of the given user
     */

  }, {
    key: "getSupporters",
    value: function () {
      var _getSupporters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getSupportersRaw(params, initOverrides);

              case 2:
                response = _context22.sent;
                _context22.next = 5;
                return response.value();

              case 5:
                return _context22.abrupt("return", _context22.sent);

              case 6:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getSupporters(_x43, _x44) {
        return _getSupporters.apply(this, arguments);
      }

      return getSupporters;
    }()
    /** @hidden
     * Gets the users that the given user supports
     */

  }, {
    key: "getSupportingsRaw",
    value: function () {
      var _getSupportingsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context23.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getSupportings.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                headerParameters = {};
                _context23.next = 8;
                return this.request({
                  path: "/users/{id}/supporting".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context23.sent;
                return _context23.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return GetSupportingFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getSupportingsRaw(_x45, _x46) {
        return _getSupportingsRaw.apply(this, arguments);
      }

      return getSupportingsRaw;
    }()
    /**
     * Gets the users that the given user supports
     */

  }, {
    key: "getSupportings",
    value: function () {
      var _getSupportings = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.getSupportingsRaw(params, initOverrides);

              case 2:
                response = _context24.sent;
                _context24.next = 5;
                return response.value();

              case 5:
                return _context24.abrupt("return", _context24.sent);

              case 6:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getSupportings(_x47, _x48) {
        return _getSupportings.apply(this, arguments);
      }

      return getSupportings;
    }()
    /** @hidden
     * Gets the most used track tags by a user.
     * Fetch most used tags in a user\'s tracks
     */

  }, {
    key: "getTopTrackTagsRaw",
    value: function () {
      var _getTopTrackTagsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context25.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getTopTrackTags.');

              case 2:
                queryParameters = {};

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context25.next = 8;
                return this.request({
                  path: "/users/{id}/tags".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context25.sent;
                return _context25.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TagsResponseFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getTopTrackTagsRaw(_x49, _x50) {
        return _getTopTrackTagsRaw.apply(this, arguments);
      }

      return getTopTrackTagsRaw;
    }()
    /**
     * Gets the most used track tags by a user.
     * Fetch most used tags in a user\'s tracks
     */

  }, {
    key: "getTopTrackTags",
    value: function () {
      var _getTopTrackTags = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.getTopTrackTagsRaw(params, initOverrides);

              case 2:
                response = _context26.sent;
                _context26.next = 5;
                return response.value();

              case 5:
                return _context26.abrupt("return", _context26.sent);

              case 6:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function getTopTrackTags(_x51, _x52) {
        return _getTopTrackTags.apply(this, arguments);
      }

      return getTopTrackTags;
    }()
    /** @hidden
     * Gets the tracks created by a user using their user ID
     */

  }, {
    key: "getTracksByUserRaw",
    value: function () {
      var _getTracksByUserRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context27.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getTracksByUser.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context27.next = 14;
                return this.request({
                  path: "/users/{id}/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context27.sent;
                return _context27.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getTracksByUserRaw(_x53, _x54) {
        return _getTracksByUserRaw.apply(this, arguments);
      }

      return getTracksByUserRaw;
    }()
    /**
     * Gets the tracks created by a user using their user ID
     */

  }, {
    key: "getTracksByUser",
    value: function () {
      var _getTracksByUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.getTracksByUserRaw(params, initOverrides);

              case 2:
                response = _context28.sent;
                _context28.next = 5;
                return response.value();

              case 5:
                return _context28.abrupt("return", _context28.sent);

              case 6:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getTracksByUser(_x55, _x56) {
        return _getTracksByUser.apply(this, arguments);
      }

      return getTracksByUser;
    }()
    /** @hidden
     * Gets a single user by their user ID
     */

  }, {
    key: "getUserRaw",
    value: function () {
      var _getUserRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context29.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getUser.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context29.next = 6;
                return this.request({
                  path: "/users/{id}".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context29.sent;
                return _context29.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return UserResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getUserRaw(_x57, _x58) {
        return _getUserRaw.apply(this, arguments);
      }

      return getUserRaw;
    }()
    /**
     * Gets a single user by their user ID
     */

  }, {
    key: "getUser",
    value: function () {
      var _getUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this.getUserRaw(params, initOverrides);

              case 2:
                response = _context30.sent;
                _context30.next = 5;
                return response.value();

              case 5:
                return _context30.abrupt("return", _context30.sent);

              case 6:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getUser(_x59, _x60) {
        return _getUser.apply(this, arguments);
      }

      return getUser;
    }()
    /** @hidden
     * Gets a single user by their handle
     */

  }, {
    key: "getUserByHandleRaw",
    value: function () {
      var _getUserByHandleRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context31.next = 2;
                  break;
                }

                throw new RequiredError$1('handle', 'Required parameter params.handle was null or undefined when calling getUserByHandle.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context31.next = 7;
                return this.request({
                  path: "/users/handle/{handle}".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context31.sent;
                return _context31.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return UserResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getUserByHandleRaw(_x61, _x62) {
        return _getUserByHandleRaw.apply(this, arguments);
      }

      return getUserByHandleRaw;
    }()
    /**
     * Gets a single user by their handle
     */

  }, {
    key: "getUserByHandle",
    value: function () {
      var _getUserByHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.getUserByHandleRaw(params, initOverrides);

              case 2:
                response = _context32.sent;
                _context32.next = 5;
                return response.value();

              case 5:
                return _context32.abrupt("return", _context32.sent);

              case 6:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getUserByHandle(_x63, _x64) {
        return _getUserByHandle.apply(this, arguments);
      }

      return getUserByHandle;
    }()
    /** @hidden
     * Gets a User ID from an associated wallet address
     */

  }, {
    key: "getUserIDFromWalletRaw",
    value: function () {
      var _getUserIDFromWalletRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                if (!(params.associatedWallet === null || params.associatedWallet === undefined)) {
                  _context33.next = 2;
                  break;
                }

                throw new RequiredError$1('associatedWallet', 'Required parameter params.associatedWallet was null or undefined when calling getUserIDFromWallet.');

              case 2:
                queryParameters = {};

                if (params.associatedWallet !== undefined) {
                  queryParameters['associated_wallet'] = params.associatedWallet;
                }

                headerParameters = {};
                _context33.next = 7;
                return this.request({
                  path: "/users/id",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context33.sent;
                return _context33.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return UserAssociatedWalletResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getUserIDFromWalletRaw(_x65, _x66) {
        return _getUserIDFromWalletRaw.apply(this, arguments);
      }

      return getUserIDFromWalletRaw;
    }()
    /**
     * Gets a User ID from an associated wallet address
     */

  }, {
    key: "getUserIDFromWallet",
    value: function () {
      var _getUserIDFromWallet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                _context34.next = 2;
                return this.getUserIDFromWalletRaw(params, initOverrides);

              case 2:
                response = _context34.sent;
                _context34.next = 5;
                return response.value();

              case 5:
                return _context34.abrupt("return", _context34.sent);

              case 6:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function getUserIDFromWallet(_x67, _x68) {
        return _getUserIDFromWallet.apply(this, arguments);
      }

      return getUserIDFromWallet;
    }()
    /** @hidden
     * Search for users that match the given query
     */

  }, {
    key: "searchUsersRaw",
    value: function () {
      var _searchUsersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context35.next = 2;
                  break;
                }

                throw new RequiredError$1('query', 'Required parameter params.query was null or undefined when calling searchUsers.');

              case 2:
                queryParameters = {};

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                headerParameters = {};
                _context35.next = 7;
                return this.request({
                  path: "/users/search",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context35.sent;
                return _context35.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return UserSearchFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function searchUsersRaw(_x69, _x70) {
        return _searchUsersRaw.apply(this, arguments);
      }

      return searchUsersRaw;
    }()
    /**
     * Search for users that match the given query
     */

  }, {
    key: "searchUsers",
    value: function () {
      var _searchUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                _context36.next = 2;
                return this.searchUsersRaw(params, initOverrides);

              case 2:
                response = _context36.sent;
                _context36.next = 5;
                return response.value();

              case 5:
                return _context36.abrupt("return", _context36.sent);

              case 6:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function searchUsers(_x71, _x72) {
        return _searchUsers.apply(this, arguments);
      }

      return searchUsers;
    }()
    /** @hidden
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     */

  }, {
    key: "verifyIDTokenRaw",
    value: function () {
      var _verifyIDTokenRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                if (!(params.token === null || params.token === undefined)) {
                  _context37.next = 2;
                  break;
                }

                throw new RequiredError$1('token', 'Required parameter params.token was null or undefined when calling verifyIDToken.');

              case 2:
                queryParameters = {};

                if (params.token !== undefined) {
                  queryParameters['token'] = params.token;
                }

                headerParameters = {};
                _context37.next = 7;
                return this.request({
                  path: "/users/verify_token",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context37.sent;
                return _context37.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return VerifyTokenFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function verifyIDTokenRaw(_x73, _x74) {
        return _verifyIDTokenRaw.apply(this, arguments);
      }

      return verifyIDTokenRaw;
    }()
    /**
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     */

  }, {
    key: "verifyIDToken",
    value: function () {
      var _verifyIDToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                _context38.next = 2;
                return this.verifyIDTokenRaw(params, initOverrides);

              case 2:
                response = _context38.sent;
                _context38.next = 5;
                return response.value();

              case 5:
                return _context38.abrupt("return", _context38.sent);

              case 6:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function verifyIDToken(_x75, _x76) {
        return _verifyIDToken.apply(this, arguments);
      }

      return verifyIDToken;
    }()
  }]);

  return UsersApi;
}(BaseAPI$1);
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortEnum$1 = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortMethodEnum$1 = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Length: 'length',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortDirectionEnum$1 = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleFilterTracksEnum$1 = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */

var GetTracksByUserSortEnum$1 = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetTracksByUserSortMethodEnum$1 = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Length: 'length',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetTracksByUserSortDirectionEnum$1 = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetTracksByUserFilterTracksEnum$1 = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};

var CreateDeveloperAppSchema = zod.z.object({
  name: zod.z.string(),
  description: zod.z.optional(zod.z.string().max(128)),
  userId: HashId
});
var DeleteDeveloperAppSchema = zod.z.object({
  userId: HashId,
  appApiKey: zod.z.custom(function (data) {
    return isApiKeyValid(data);
  })
});

var DeveloperAppsApi = /*#__PURE__*/function (_GeneratedDeveloperAp) {
  _inherits(DeveloperAppsApi, _GeneratedDeveloperAp);

  var _super = _createSuper(DeveloperAppsApi);

  function DeveloperAppsApi(config, entityManager, auth) {
    var _this;

    _classCallCheck(this, DeveloperAppsApi);

    _this = _super.call(this, config);

    _defineProperty$1(_assertThisInitialized(_this), "entityManager", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "web3", void 0);

    _this.entityManager = entityManager;
    _this.auth = auth;
    _this.web3 = new Web3$1();
    return _this;
  }
  /**
   * Create a developer app
   */


  _createClass(DeveloperAppsApi, [{
    key: "createDeveloperApp",
    value: function () {
      var _createDeveloperApp = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, advancedOptions) {
        var _yield$parseParams, name, userId, description, wallet, privateKey, address, unixTs, message, signature, response, apiKey, apiSecret;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return parseParams('createDeveloperApp', CreateDeveloperAppSchema)(params);

              case 2:
                _yield$parseParams = _context.sent;
                name = _yield$parseParams.name;
                userId = _yield$parseParams.userId;
                description = _yield$parseParams.description;
                wallet = this.web3.eth.accounts.create();
                privateKey = wallet.privateKey;
                address = wallet.address;
                unixTs = Math.round(new Date().getTime() / 1000); // current unix timestamp (sec)

                message = "Creating Audius developer app at ".concat(unixTs);
                signature = wallet.sign(message).signature;
                _context.next = 14;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.DEVELOPER_APP,
                  entityId: 0,
                  action: Action$1.CREATE,
                  metadata: JSON.stringify({
                    name: name,
                    description: description,
                    app_signature: {
                      message: message,
                      signature: signature
                    }
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 14:
                response = _context.sent;
                apiKey = address.slice(2).toLowerCase();
                apiSecret = privateKey.slice(2).toLowerCase();
                return _context.abrupt("return", _objectSpread2(_objectSpread2({}, response), {}, {
                  apiKey: apiKey,
                  apiSecret: apiSecret
                }));

              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function createDeveloperApp(_x, _x2) {
        return _createDeveloperApp.apply(this, arguments);
      }

      return createDeveloperApp;
    }()
    /**
     * Delete a developer app
     */

  }, {
    key: "deleteDeveloperApp",
    value: function () {
      var _deleteDeveloperApp = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        var _yield$parseParams2, userId, appApiKey;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return parseParams('deleteDeveloperApp', DeleteDeveloperAppSchema)(params);

              case 2:
                _yield$parseParams2 = _context2.sent;
                userId = _yield$parseParams2.userId;
                appApiKey = _yield$parseParams2.appApiKey;
                _context2.next = 7;
                return this.entityManager.manageEntity({
                  userId: userId,
                  entityType: EntityType$1.DEVELOPER_APP,
                  entityId: 0,
                  action: Action$1.DELETE,
                  metadata: JSON.stringify({
                    address: "0x".concat(appApiKey)
                  }),
                  auth: this.auth
                });

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function deleteDeveloperApp(_x3) {
        return _deleteDeveloperApp.apply(this, arguments);
      }

      return deleteDeveloperApp;
    }()
  }]);

  return DeveloperAppsApi;
}(DeveloperAppsApi$1);

var fileTypeBrowser;

if (typeof window !== 'undefined' && window) {
  fileTypeBrowser = require('file-type/browser');
}
/**
 * Type representing a file in Node environment
 */


var NodeFileSchema = zod.z.object({
  buffer: zod.z.custom(function (data) {
    return data;
  }),
  name: zod.z.optional(zod.z.string())
});
var BrowserFileSchema = zod.z.custom(function (data) {
  return data;
});
/**
 * Type representing a file in Node and browser environments
 */

var CrossPlatformFileSchema = zod.z.union([NodeFileSchema, BrowserFileSchema]);
var isNodeFile = function isNodeFile(file) {
  if (file && file.buffer) {
    return true;
  }

  return false;
};
var ALLOWED_IMAGE_MIME_TYPES = ['image/jpeg', 'image/png', 'image/bmp', 'image/tiff', 'image/gif', 'image/webp'];
var ALLOWED_AUDIO_MIME_TYPES = ['audio/mpeg', 'audio/mp3', 'audio/aiff', 'audio/flac', 'audio/ogg', 'audio/wav', 'audio/vnd.wave'];

var getFileType = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(file) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!isNodeFile(file)) {
              _context.next = 6;
              break;
            }

            _context.next = 3;
            return fileType__namespace.fromBuffer(file.buffer);

          case 3:
            _context.t0 = _context.sent;
            _context.next = 9;
            break;

          case 6:
            _context.next = 8;
            return fileTypeBrowser.fromBlob(file);

          case 8:
            _context.t0 = _context.sent;

          case 9:
            return _context.abrupt("return", _context.t0);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getFileType(_x) {
    return _ref.apply(this, arguments);
  };
}();

var ImageFile = CrossPlatformFileSchema.refine( /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(file) {
    var fileType;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getFileType(file);

          case 2:
            fileType = _context2.sent;
            return _context2.abrupt("return", fileType && ALLOWED_IMAGE_MIME_TYPES.includes(fileType.mime));

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}(), "Image file has invalid file type. Supported file types are: ".concat(ALLOWED_IMAGE_MIME_TYPES.join(', ')));
var AudioFile = CrossPlatformFileSchema.refine( /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(file) {
    var fileType;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return getFileType(file);

          case 2:
            fileType = _context3.sent;
            return _context3.abrupt("return", fileType && ALLOWED_AUDIO_MIME_TYPES.includes(fileType.mime));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
}(), "Audio file has invalid file type. Supported file types are: ".concat(ALLOWED_AUDIO_MIME_TYPES.join(', ')));

exports.Mood = void 0;

(function (Mood) {
  Mood["PEACEFUL"] = "Peaceful";
  Mood["ROMANTIC"] = "Romantic";
  Mood["SENTIMENTAL"] = "Sentimental";
  Mood["TENDER"] = "Tender";
  Mood["EASYGOING"] = "Easygoing";
  Mood["YEARNING"] = "Yearning";
  Mood["SOPHISTICATED"] = "Sophisticated";
  Mood["SENSUAL"] = "Sensual";
  Mood["COOL"] = "Cool";
  Mood["GRITTY"] = "Gritty";
  Mood["MELANCHOLY"] = "Melancholy";
  Mood["SERIOUS"] = "Serious";
  Mood["BROODING"] = "Brooding";
  Mood["FIERY"] = "Fiery";
  Mood["DEFIANT"] = "Defiant";
  Mood["AGGRESSIVE"] = "Aggressive";
  Mood["ROWDY"] = "Rowdy";
  Mood["EXCITED"] = "Excited";
  Mood["ENERGIZING"] = "Energizing";
  Mood["EMPOWERING"] = "Empowering";
  Mood["STIRRING"] = "Stirring";
  Mood["UPBEAT"] = "Upbeat";
  Mood["OTHER"] = "Other";
})(exports.Mood || (exports.Mood = {}));

exports.Genre = void 0;

(function (Genre) {
  Genre["ALL"] = "All Genres";
  Genre["ELECTRONIC"] = "Electronic";
  Genre["ROCK"] = "Rock";
  Genre["METAL"] = "Metal";
  Genre["ALTERNATIVE"] = "Alternative";
  Genre["HIP_HOP_RAP"] = "Hip-Hop/Rap";
  Genre["EXPERIMENTAL"] = "Experimental";
  Genre["PUNK"] = "Punk";
  Genre["FOLK"] = "Folk";
  Genre["POP"] = "Pop";
  Genre["AMBIENT"] = "Ambient";
  Genre["SOUNDTRACK"] = "Soundtrack";
  Genre["WORLD"] = "World";
  Genre["JAZZ"] = "Jazz";
  Genre["ACOUSTIC"] = "Acoustic";
  Genre["FUNK"] = "Funk";
  Genre["R_AND_B_SOUL"] = "R&B/Soul";
  Genre["DEVOTIONAL"] = "Devotional";
  Genre["CLASSICAL"] = "Classical";
  Genre["REGGAE"] = "Reggae";
  Genre["PODCASTS"] = "Podcasts";
  Genre["COUNTRY"] = "Country";
  Genre["SPOKEN_WORK"] = "Spoken Word";
  Genre["COMEDY"] = "Comedy";
  Genre["BLUES"] = "Blues";
  Genre["KIDS"] = "Kids";
  Genre["AUDIOBOOKS"] = "Audiobooks";
  Genre["LATIN"] = "Latin";
  Genre["LOFI"] = "Lo-Fi";
  Genre["HYPERPOP"] = "Hyperpop"; // Electronic Subgenres

  Genre["TECHNO"] = "Techno";
  Genre["TRAP"] = "Trap";
  Genre["HOUSE"] = "House";
  Genre["TECH_HOUSE"] = "Tech House";
  Genre["DEEP_HOUSE"] = "Deep House";
  Genre["DISCO"] = "Disco";
  Genre["ELECTRO"] = "Electro";
  Genre["JUNGLE"] = "Jungle";
  Genre["PROGRESSIVE_HOUSE"] = "Progressive House";
  Genre["HARDSTYLE"] = "Hardstyle";
  Genre["GLITCH_HOP"] = "Glitch Hop";
  Genre["TRANCE"] = "Trance";
  Genre["FUTURE_BASS"] = "Future Bass";
  Genre["FUTURE_HOUSE"] = "Future House";
  Genre["TROPICAL_HOUSE"] = "Tropical House";
  Genre["DOWNTEMPO"] = "Downtempo";
  Genre["DRUM_AND_BASS"] = "Drum & Bass";
  Genre["DUBSTEP"] = "Dubstep";
  Genre["JERSEY_CLUB"] = "Jersey Club";
  Genre["VAPORWAVE"] = "Vaporwave";
  Genre["MOOMBAHTON"] = "Moombahton";
})(exports.Genre || (exports.Genre = {}));

var messages = {
  titleRequiredError: 'Your track must have a name',
  artworkRequiredError: 'Artwork is required',
  genreRequiredError: 'Genre is required',
  invalidReleaseDateError: 'Release date should not be in the future'
};
var PremiumConditionsEthNFTCollection = zod.z.object({
  chain: zod.z.literal('eth'),
  address: zod.z.string(),
  standard: zod.z.union([zod.z.literal('ERC721'), zod.z.literal('ERC1155')]),
  name: zod.z.string(),
  slug: zod.z.string(),
  imageUrl: zod.z.optional(zod.z.string()),
  externalLink: zod.z.optional(zod.z.string())
}).strict();
var PremiumConditionsSolNFTCollection = zod.z.object({
  chain: zod.z.literal('sol'),
  address: zod.z.string(),
  name: zod.z.string(),
  imageUrl: zod.z.optional(zod.z.string()),
  externalLink: zod.z.optional(zod.z.string())
}).strict();
var PremiumConditionsNFTCollection = zod.z.union([PremiumConditionsEthNFTCollection, PremiumConditionsSolNFTCollection]);
var PremiumConditionsFollowUserId = zod.z.object({
  followUserId: HashId
}).strict();
var PremiumConditionsTipUserId = zod.z.object({
  tipUserId: HashId
}).strict();
var createUploadTrackMetadataSchema = function createUploadTrackMetadataSchema() {
  return zod.z.object({
    aiAttributionUserId: zod.z.optional(HashId),
    description: zod.z.optional(zod.z.string().max(1000)),
    download: zod.z.optional(zod.z.object({
      cid: zod.z.string(),
      isDownloadable: zod.z["boolean"](),
      requiresFollow: zod.z["boolean"]()
    }).strict().nullable()),
    fieldVisibility: zod.z.optional(zod.z.object({
      mood: zod.z.optional(zod.z["boolean"]()),
      tags: zod.z.optional(zod.z["boolean"]()),
      genre: zod.z.optional(zod.z["boolean"]()),
      share: zod.z.optional(zod.z["boolean"]()),
      playCount: zod.z.optional(zod.z["boolean"]()),
      remixes: zod.z.optional(zod.z["boolean"]())
    })),
    genre: zod.z["enum"](Object.values(exports.Genre)).nullable().refine(function (val) {
      return val !== null;
    }, {
      message: messages.genreRequiredError
    }),
    isPremium: zod.z.optional(zod.z["boolean"]()),
    isrc: zod.z.optional(zod.z.string().nullable()),
    isUnlisted: zod.z.optional(zod.z["boolean"]()),
    iswc: zod.z.optional(zod.z.string().nullable()),
    license: zod.z.optional(zod.z.string().nullable()),
    mood: zod.z.optional(zod.z["enum"](Object.values(exports.Mood))).nullable(),
    premiumConditions: zod.z.optional(zod.z.union([PremiumConditionsNFTCollection, PremiumConditionsFollowUserId, PremiumConditionsTipUserId])),
    releaseDate: zod.z.optional(zod.z.date().max(new Date(), {
      message: messages.invalidReleaseDateError
    })),
    remixOf: zod.z.optional(zod.z.object({
      tracks: zod.z.array(zod.z.object({
        parentTrackId: HashId
      })).min(1)
    }).strict()),
    tags: zod.z.optional(zod.z.string()),
    title: zod.z.string({
      required_error: messages.titleRequiredError
    }),
    previewStartSeconds: zod.z.optional(zod.z.number()),
    audioUploadId: zod.z.optional(zod.z.string()),
    previewCid: zod.z.optional(zod.z.string())
  });
};
var createUploadTrackSchema = function createUploadTrackSchema() {
  return zod.z.object({
    userId: HashId,
    coverArtFile: ImageFile,
    metadata: createUploadTrackMetadataSchema().strict(),
    onProgress: zod.z.optional(zod.z["function"]().args(zod.z.number())),
    trackFile: AudioFile
  }).strict();
};
var createUpdateTrackSchema = function createUpdateTrackSchema() {
  return zod.z.object({
    userId: HashId,
    trackId: HashId,
    metadata: createUploadTrackMetadataSchema().strict().partial(),
    transcodePreview: zod.z.optional(zod.z["boolean"]()),
    coverArtFile: zod.z.optional(ImageFile),
    onProgress: zod.z.optional(zod.z["function"]().args(zod.z.number()))
  }).strict();
};
var DeleteTrackSchema = zod.z.object({
  userId: HashId,
  trackId: HashId
}).strict();
var FavoriteTrackSchema = zod.z.object({
  userId: HashId,
  trackId: HashId,
  metadata: zod.z.optional(zod.z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: zod.z["boolean"]()
  }).strict())
}).strict();
var UnfavoriteTrackSchema = zod.z.object({
  userId: HashId,
  trackId: HashId
}).strict();
var RepostTrackSchema = zod.z.object({
  userId: HashId,
  trackId: HashId,
  metadata: zod.z.optional(zod.z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: zod.z["boolean"]()
  }).strict())
}).strict();
var UnrepostTrackSchema = zod.z.object({
  userId: HashId,
  trackId: HashId
}).strict();

var CreatePlaylistMetadataSchema = zod.z.object({
  description: zod.z.optional(zod.z.string().max(1000)),
  playlistName: zod.z.string(),
  isPrivate: zod.z.optional(zod.z["boolean"]())
}).strict();
var CreatePlaylistSchema = zod.z.object({
  coverArtFile: zod.z.optional(ImageFile),
  metadata: CreatePlaylistMetadataSchema,
  onProgress: zod.z.optional(zod.z["function"]().args(zod.z.number())),
  trackIds: zod.z.optional(zod.z.array(HashId)),
  userId: HashId
}).strict();
var createUpdatePlaylistMetadataSchema = function createUpdatePlaylistMetadataSchema() {
  return createUploadPlaylistMetadataSchema().partial().merge(zod.z.object({
    isPrivate: zod.z.optional(zod.z["boolean"]()),
    playlistContents: zod.z.optional(zod.z.array(zod.z.object({
      timestamp: zod.z.number(),
      metadataTimestamp: zod.z.optional(zod.z.number()),
      trackId: HashId
    })))
  })).strict();
};
var createUpdatePlaylistSchema = function createUpdatePlaylistSchema() {
  return zod.z.object({
    userId: HashId,
    playlistId: HashId,
    coverArtFile: zod.z.optional(ImageFile),
    metadata: createUpdatePlaylistMetadataSchema(),
    onProgress: zod.z.optional(zod.z["function"]().args(zod.z.number()))
  }).strict();
};

var createUploadPlaylistMetadataSchema = function createUploadPlaylistMetadataSchema() {
  return zod.z.object({
    description: zod.z.optional(zod.z.string().max(1000)),
    genre: zod.z["enum"](Object.values(exports.Genre)),
    license: zod.z.optional(zod.z.string()),
    mood: zod.z.optional(zod.z["enum"](Object.values(exports.Mood))),
    playlistName: zod.z.string(),
    releaseDate: zod.z.optional(zod.z.date().max(new Date(), {
      message: 'should not be in the future'
    })),
    tags: zod.z.optional(zod.z.string()),
    upc: zod.z.optional(zod.z.string())
  }).strict();
};

var createPlaylistTrackMetadataSchema = function createPlaylistTrackMetadataSchema() {
  return createUploadTrackMetadataSchema().partial({
    genre: true,
    mood: true,
    tags: true
  });
};

var createUploadPlaylistSchema = function createUploadPlaylistSchema() {
  return zod.z.object({
    userId: HashId,
    coverArtFile: ImageFile,
    metadata: createUploadPlaylistMetadataSchema(),
    onProgress: zod.z.optional(zod.z["function"]().args(zod.z.number())),

    /**
     * Track metadata is populated from the playlist if fields are missing
     */
    trackMetadatas: zod.z.array(createPlaylistTrackMetadataSchema()),
    trackFiles: zod.z.array(AudioFile)
  }).strict();
};
var PublishPlaylistSchema = zod.z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
var AddTrackToPlaylistSchema = zod.z.object({
  userId: HashId,
  playlistId: HashId,
  trackId: HashId
}).strict();
var RemoveTrackFromPlaylistSchema = zod.z.object({
  userId: HashId,
  playlistId: HashId,
  trackIndex: zod.z.number()
}).strict();
var DeletePlaylistSchema = zod.z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
var FavoritePlaylistSchema = zod.z.object({
  userId: HashId,
  playlistId: HashId,
  metadata: zod.z.optional(zod.z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: zod.z["boolean"]()
  }).strict())
}).strict();
var UnfavoritePlaylistSchema = zod.z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
var RepostPlaylistSchema = zod.z.object({
  userId: HashId,
  playlistId: HashId,
  metadata: zod.z.optional(zod.z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: zod.z["boolean"]()
  }).strict())
}).strict();
var UnrepostPlaylistSchema = zod.z.object({
  userId: HashId,
  playlistId: HashId
}).strict();

/**
 * Calls fn and then retries once after 500ms, again after 1500ms, and again after 4000ms
 */

var retry3 = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(fn) {
    var onRetry,
        _args = arguments;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            onRetry = _args.length > 1 && _args[1] !== undefined ? _args[1] : function (_err) {};
            _context.next = 3;
            return retry__default["default"](fn, {
              minTimeout: 500,
              maxTimeout: 4000,
              factor: 3,
              retries: 3,
              onRetry: onRetry
            });

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function retry3(_x) {
    return _ref.apply(this, arguments);
  };
}();

var TrackUploadHelper = /*#__PURE__*/function (_BaseAPI) {
  _inherits(TrackUploadHelper, _BaseAPI);

  var _super = _createSuper(TrackUploadHelper);

  function TrackUploadHelper() {
    _classCallCheck(this, TrackUploadHelper);

    return _super.apply(this, arguments);
  }

  _createClass(TrackUploadHelper, [{
    key: "generateId",
    value: function () {
      var _generateId = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(type) {
        var response, _yield$response$json, data, id;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.request({
                  path: "/".concat(type, "s/unclaimed_id"),
                  method: 'GET',
                  headers: {},
                  query: {
                    noCache: Math.floor(Math.random() * 1000).toString()
                  }
                });

              case 2:
                response = _context.sent;
                _context.next = 5;
                return response.json();

              case 5:
                _yield$response$json = _context.sent;
                data = _yield$response$json.data;
                id = decodeHashId$4(data);

                if (!(id === null)) {
                  _context.next = 10;
                  break;
                }

                throw new Error("Could not generate ".concat(type, " id"));

              case 10:
                return _context.abrupt("return", id);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function generateId(_x) {
        return _generateId.apply(this, arguments);
      }

      return generateId;
    }()
  }, {
    key: "transformTrackUploadMetadata",
    value: function transformTrackUploadMetadata(inputMetadata, userId) {
      var metadata = _objectSpread2(_objectSpread2({}, inputMetadata), {}, {
        ownerId: userId
      });

      var isPremium = metadata.isPremium;
      var isUnlisted = metadata.isUnlisted; // If track is premium, set remixes to false

      if (isPremium && metadata.fieldVisibility) {
        metadata.fieldVisibility.remixes = false;
      } // If track is public, set required visibility fields to true


      if (!isUnlisted) {
        metadata.fieldVisibility = _objectSpread2(_objectSpread2({}, metadata.fieldVisibility), {}, {
          genre: true,
          mood: true,
          tags: true,
          share: true,
          playCount: true
        });
      }

      return metadata;
    }
  }, {
    key: "populateTrackMetadataWithUploadResponse",
    value: function populateTrackMetadataWithUploadResponse(trackMetadata, audioResponse, coverArtResponse) {
      var _trackMetadata$downlo;

      return _objectSpread2(_objectSpread2({}, trackMetadata), {}, {
        trackSegments: [],
        trackCid: audioResponse.results['320'],
        previewCid: trackMetadata.previewStartSeconds ? audioResponse.results["320_preview|".concat(trackMetadata.previewStartSeconds)] : trackMetadata.previewCid,
        audioUploadId: audioResponse.id,
        download: (_trackMetadata$downlo = trackMetadata.download) !== null && _trackMetadata$downlo !== void 0 && _trackMetadata$downlo.isDownloadable ? _objectSpread2(_objectSpread2({}, trackMetadata.download), {}, {
          cid: audioResponse.results['320']
        }) : trackMetadata.download,
        coverArtSizes: coverArtResponse.id,
        duration: parseInt(audioResponse.probe.format.duration, 10)
      });
    }
  }]);

  return TrackUploadHelper;
}(BaseAPI$1);

var PlaylistsApi$1 = /*#__PURE__*/function (_GeneratedPlaylistsAp) {
  _inherits(PlaylistsApi, _GeneratedPlaylistsAp);

  var _super = _createSuper(PlaylistsApi);

  function PlaylistsApi(configuration, storage, entityManager, auth, logger) {
    var _this;

    _classCallCheck(this, PlaylistsApi);

    _this = _super.call(this, configuration);

    _defineProperty$1(_assertThisInitialized(_this), "storage", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "entityManager", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "logger", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "trackUploadHelper", void 0);

    _this.storage = storage;
    _this.entityManager = entityManager;
    _this.auth = auth;
    _this.logger = logger;
    _this.trackUploadHelper = new TrackUploadHelper(configuration);
    _this.logger = logger.createPrefixedLogger('[playlists-api]');
    return _this;
  }
  /** @hidden
   * Create a playlist from existing tracks
   */


  _createClass(PlaylistsApi, [{
    key: "createPlaylist",
    value: function () {
      var _createPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, advancedOptions) {
        var _this2 = this;

        var _yield$parseParams, userId, coverArtFile, metadata, onProgress, trackIds, coverArtResponse, playlistId, currentBlock, updatedMetadata, response;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return parseParams('createPlaylist', CreatePlaylistSchema)(params);

              case 2:
                _yield$parseParams = _context2.sent;
                userId = _yield$parseParams.userId;
                coverArtFile = _yield$parseParams.coverArtFile;
                metadata = _yield$parseParams.metadata;
                onProgress = _yield$parseParams.onProgress;
                trackIds = _yield$parseParams.trackIds;
                _context2.t0 = coverArtFile;

                if (!_context2.t0) {
                  _context2.next = 13;
                  break;
                }

                _context2.next = 12;
                return retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.next = 2;
                          return _this2.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context.abrupt("return", _context.sent);

                        case 3:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                })), function (e) {
                  _this2.logger.info('Retrying uploadPlaylistCoverArt', e);
                });

              case 12:
                _context2.t0 = _context2.sent;

              case 13:
                coverArtResponse = _context2.t0;
                _context2.next = 16;
                return this.trackUploadHelper.generateId('playlist');

              case 16:
                playlistId = _context2.sent;
                _context2.next = 19;
                return this.entityManager.getCurrentBlock();

              case 19:
                currentBlock = _context2.sent;
                // Update metadata to include track ids
                updatedMetadata = _objectSpread2(_objectSpread2({}, metadata), {}, {
                  playlistContents: {
                    trackIds: (trackIds !== null && trackIds !== void 0 ? trackIds : []).map(function (trackId) {
                      return {
                        track: trackId,
                        time: currentBlock.timestamp
                      };
                    })
                  },
                  playlistImageSizesMultihash: coverArtResponse === null || coverArtResponse === void 0 ? void 0 : coverArtResponse.id
                }); // Write playlist metadata to chain

                _context2.next = 23;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.PLAYLIST,
                  entityId: playlistId,
                  action: Action$1.CREATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys__default["default"](updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 23:
                response = _context2.sent;
                return _context2.abrupt("return", _objectSpread2(_objectSpread2({}, response), {}, {
                  playlistId: encodeHashId(playlistId)
                }));

              case 25:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function createPlaylist(_x, _x2) {
        return _createPlaylist.apply(this, arguments);
      }

      return createPlaylist;
    }()
    /** @hidden
     * Upload a playlist
     * Uploads the specified tracks and combines them into a playlist
     */

  }, {
    key: "uploadPlaylist",
    value: function () {
      var _uploadPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, advancedOptions) {
        var parsedParameters;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return parseParams('uploadPlaylist', createUploadPlaylistSchema())(params);

              case 2:
                parsedParameters = _context3.sent;
                _context3.next = 5;
                return this.uploadPlaylistInternal(parsedParameters, advancedOptions);

              case 5:
                return _context3.abrupt("return", _context3.sent);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function uploadPlaylist(_x3, _x4) {
        return _uploadPlaylist.apply(this, arguments);
      }

      return uploadPlaylist;
    }()
    /** @hidden
     * Publish a playlist
     * Changes a playlist from private to public
     */

  }, {
    key: "publishPlaylist",
    value: function () {
      var _publishPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, advancedOptions) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('publishPlaylist', PublishPlaylistSchema)(params);

              case 2:
                _context4.next = 4;
                return this.fetchAndUpdatePlaylist({
                  userId: params.userId,
                  playlistId: params.playlistId,
                  updateMetadata: function updateMetadata(playlist) {
                    return _objectSpread2(_objectSpread2({}, playlist), {}, {
                      isPrivate: false
                    });
                  }
                }, advancedOptions);

              case 4:
                return _context4.abrupt("return", _context4.sent);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function publishPlaylist(_x5, _x6) {
        return _publishPlaylist.apply(this, arguments);
      }

      return publishPlaylist;
    }()
    /** @hidden
     * Add a single track to the end of a playlist
     * For more control use updatePlaylist
     */

  }, {
    key: "addTrackToPlaylist",
    value: function () {
      var _addTrackToPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, advancedOptions) {
        var currentBlock;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return parseParams('addTrackToPlaylist', AddTrackToPlaylistSchema)(params);

              case 2:
                _context5.next = 4;
                return this.entityManager.getCurrentBlock();

              case 4:
                currentBlock = _context5.sent;
                _context5.next = 7;
                return this.fetchAndUpdatePlaylist({
                  userId: params.userId,
                  playlistId: params.playlistId,
                  updateMetadata: function updateMetadata(playlist) {
                    var _playlist$playlistCon;

                    return _objectSpread2(_objectSpread2({}, playlist), {}, {
                      playlistContents: [].concat(_toConsumableArray((_playlist$playlistCon = playlist.playlistContents) !== null && _playlist$playlistCon !== void 0 ? _playlist$playlistCon : []), [{
                        trackId: params.trackId,
                        timestamp: currentBlock.timestamp
                      }])
                    });
                  }
                }, advancedOptions);

              case 7:
                return _context5.abrupt("return", _context5.sent);

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function addTrackToPlaylist(_x7, _x8) {
        return _addTrackToPlaylist.apply(this, arguments);
      }

      return addTrackToPlaylist;
    }()
    /** @hidden
     * Removes a single track at the given index of playlist
     * For more control use updatePlaylist
     */

  }, {
    key: "removeTrackFromPlaylist",
    value: function () {
      var _removeTrackFromPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, advancedOptions) {
        var _yield$parseParams2, trackIndex;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return parseParams('removeTrackFromPlaylist', RemoveTrackFromPlaylistSchema)(params);

              case 2:
                _yield$parseParams2 = _context6.sent;
                trackIndex = _yield$parseParams2.trackIndex;
                _context6.next = 6;
                return this.fetchAndUpdatePlaylist({
                  userId: params.userId,
                  playlistId: params.playlistId,
                  updateMetadata: function updateMetadata(playlist) {
                    if (!playlist.playlistContents || playlist.playlistContents.length <= trackIndex) {
                      throw new Error("No track exists at index ".concat(trackIndex));
                    }

                    playlist.playlistContents.splice(trackIndex, 1);
                    return _objectSpread2(_objectSpread2({}, playlist), {}, {
                      playlistContents: playlist.playlistContents
                    });
                  }
                }, advancedOptions);

              case 6:
                return _context6.abrupt("return", _context6.sent);

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function removeTrackFromPlaylist(_x9, _x10) {
        return _removeTrackFromPlaylist.apply(this, arguments);
      }

      return removeTrackFromPlaylist;
    }()
    /** @hidden
     * Update a playlist
     */

  }, {
    key: "updatePlaylist",
    value: function () {
      var _updatePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, advancedOptions) {
        var parsedParameters;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('updatePlaylist', createUpdatePlaylistSchema())(params);

              case 2:
                parsedParameters = _context7.sent;
                _context7.next = 5;
                return this.updatePlaylistInternal(parsedParameters, advancedOptions);

              case 5:
                return _context7.abrupt("return", _context7.sent);

              case 6:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function updatePlaylist(_x11, _x12) {
        return _updatePlaylist.apply(this, arguments);
      }

      return updatePlaylist;
    }()
    /** @hidden
     * Delete a playlist
     */

  }, {
    key: "deletePlaylist",
    value: function () {
      var _deletePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, advancedOptions) {
        var _yield$parseParams3, userId, playlistId;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return parseParams('deletePlaylist', DeletePlaylistSchema)(params);

              case 2:
                _yield$parseParams3 = _context8.sent;
                userId = _yield$parseParams3.userId;
                playlistId = _yield$parseParams3.playlistId;
                _context8.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.PLAYLIST,
                  entityId: playlistId,
                  action: Action$1.DELETE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function deletePlaylist(_x13, _x14) {
        return _deletePlaylist.apply(this, arguments);
      }

      return deletePlaylist;
    }()
    /** @hidden
     * Favorite a playlist
     */

  }, {
    key: "favoritePlaylist",
    value: function () {
      var _favoritePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, advancedOptions) {
        var _yield$parseParams4, userId, playlistId, metadata;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return parseParams('favoritePlaylist', FavoritePlaylistSchema)(params);

              case 2:
                _yield$parseParams4 = _context9.sent;
                userId = _yield$parseParams4.userId;
                playlistId = _yield$parseParams4.playlistId;
                metadata = _yield$parseParams4.metadata;
                _context9.next = 8;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.PLAYLIST,
                  entityId: playlistId,
                  action: Action$1.SAVE,
                  metadata: metadata && JSON.stringify(snakecaseKeys__default["default"](metadata)),
                  auth: this.auth
                }, advancedOptions));

              case 8:
                return _context9.abrupt("return", _context9.sent);

              case 9:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function favoritePlaylist(_x15, _x16) {
        return _favoritePlaylist.apply(this, arguments);
      }

      return favoritePlaylist;
    }()
    /** @hidden
     * Unfavorite a playlist
     */

  }, {
    key: "unfavoritePlaylist",
    value: function () {
      var _unfavoritePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, advancedOptions) {
        var _yield$parseParams5, userId, playlistId;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return parseParams('unfavoritePlaylist', UnfavoritePlaylistSchema)(params);

              case 2:
                _yield$parseParams5 = _context10.sent;
                userId = _yield$parseParams5.userId;
                playlistId = _yield$parseParams5.playlistId;
                _context10.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.PLAYLIST,
                  entityId: playlistId,
                  action: Action$1.UNSAVE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context10.abrupt("return", _context10.sent);

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function unfavoritePlaylist(_x17, _x18) {
        return _unfavoritePlaylist.apply(this, arguments);
      }

      return unfavoritePlaylist;
    }()
    /** @hidden
     * Repost a playlist
     */

  }, {
    key: "repostPlaylist",
    value: function () {
      var _repostPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, advancedOptions) {
        var _yield$parseParams6, userId, playlistId, metadata;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return parseParams('respostPlaylist', RepostPlaylistSchema)(params);

              case 2:
                _yield$parseParams6 = _context11.sent;
                userId = _yield$parseParams6.userId;
                playlistId = _yield$parseParams6.playlistId;
                metadata = _yield$parseParams6.metadata;
                _context11.next = 8;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.PLAYLIST,
                  entityId: playlistId,
                  action: Action$1.REPOST,
                  metadata: metadata && JSON.stringify(snakecaseKeys__default["default"](metadata)),
                  auth: this.auth
                }, advancedOptions));

              case 8:
                return _context11.abrupt("return", _context11.sent);

              case 9:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function repostPlaylist(_x19, _x20) {
        return _repostPlaylist.apply(this, arguments);
      }

      return repostPlaylist;
    }()
    /** @hidden
     * Unrepost a playlist
     */

  }, {
    key: "unrepostPlaylist",
    value: function () {
      var _unrepostPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, advancedOptions) {
        var _yield$parseParams7, userId, playlistId;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return parseParams('unrepostPlaylist', UnrepostPlaylistSchema)(params);

              case 2:
                _yield$parseParams7 = _context12.sent;
                userId = _yield$parseParams7.userId;
                playlistId = _yield$parseParams7.playlistId;
                _context12.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.PLAYLIST,
                  entityId: playlistId,
                  action: Action$1.UNREPOST,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context12.abrupt("return", _context12.sent);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function unrepostPlaylist(_x21, _x22) {
        return _unrepostPlaylist.apply(this, arguments);
      }

      return unrepostPlaylist;
    }()
    /** @internal
     * Combines the metadata for a track and a collection (playlist or album),
     * taking the metadata from the playlist when the track is missing it.
     */

  }, {
    key: "combineMetadata",
    value: function combineMetadata(trackMetadata, playlistMetadata) {
      var metadata = trackMetadata;
      if (!metadata.mood) metadata.mood = playlistMetadata.mood;

      if (playlistMetadata.tags) {
        if (!metadata.tags) {
          // Take playlist tags
          metadata.tags = playlistMetadata.tags;
        } else {
          // Combine tags and dedupe
          metadata.tags = _toConsumableArray(new Set([].concat(_toConsumableArray(metadata.tags.split(',')), _toConsumableArray(playlistMetadata.tags.split(','))))).join(',');
        }
      }

      return trackMetadata;
    }
    /** @internal
     * Update helper method that first fetches a playlist and then updates it
     */

  }, {
    key: "fetchAndUpdatePlaylist",
    value: function () {
      var _fetchAndUpdatePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref2, advancedOptions) {
        var _playlistResponse$dat;

        var userId, playlistId, updateMetadata, playlistResponse, playlist, supportedUpdateFields;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                userId = _ref2.userId, playlistId = _ref2.playlistId, updateMetadata = _ref2.updateMetadata;
                _context13.next = 3;
                return this.getPlaylist({
                  playlistId: playlistId,
                  userId: userId
                });

              case 3:
                playlistResponse = _context13.sent;
                playlist = (_playlistResponse$dat = playlistResponse.data) === null || _playlistResponse$dat === void 0 ? void 0 : _playlistResponse$dat[0];

                if (playlist) {
                  _context13.next = 7;
                  break;
                }

                throw new Error("Could not fetch playlist: ".concat(playlistId));

              case 7:
                supportedUpdateFields = Object.keys(createUpdatePlaylistMetadataSchema().shape);
                _context13.next = 10;
                return this.updatePlaylist({
                  userId: userId,
                  playlistId: playlistId,
                  metadata: updateMetadata(lodash.pick(playlist, supportedUpdateFields))
                }, advancedOptions);

              case 10:
                return _context13.abrupt("return", _context13.sent);

              case 11:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function fetchAndUpdatePlaylist(_x23, _x24) {
        return _fetchAndUpdatePlaylist.apply(this, arguments);
      }

      return fetchAndUpdatePlaylist;
    }()
    /** @internal
     * Method to upload a playlist with already parsed inputs
     * This is used for both playlists and albums
     */

  }, {
    key: "uploadPlaylistInternal",
    value: function () {
      var _uploadPlaylistInternal = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(_ref3, advancedOptions) {
        var _this3 = this;

        var userId, coverArtFile, trackFiles, onProgress, metadata, trackMetadatas, _yield$Promise$all, _yield$Promise$all2, coverArtResponse, audioResponses, trackIds, playlistId, currentBlock, updatedMetadata, response;

        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                userId = _ref3.userId, coverArtFile = _ref3.coverArtFile, trackFiles = _ref3.trackFiles, onProgress = _ref3.onProgress, metadata = _ref3.metadata, trackMetadatas = _ref3.trackMetadatas;
                _context18.next = 3;
                return Promise.all([retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
                  return regeneratorRuntime.wrap(function _callee14$(_context14) {
                    while (1) {
                      switch (_context14.prev = _context14.next) {
                        case 0:
                          _context14.next = 2;
                          return _this3.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context14.abrupt("return", _context14.sent);

                        case 3:
                        case "end":
                          return _context14.stop();
                      }
                    }
                  }, _callee14);
                })), function (e) {
                  _this3.logger.info('Retrying uploadPlaylistCoverArt', e);
                })].concat(_toConsumableArray(trackFiles.map( /*#__PURE__*/function () {
                  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(trackFile) {
                    return regeneratorRuntime.wrap(function _callee16$(_context16) {
                      while (1) {
                        switch (_context16.prev = _context16.next) {
                          case 0:
                            _context16.next = 2;
                            return retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
                              return regeneratorRuntime.wrap(function _callee15$(_context15) {
                                while (1) {
                                  switch (_context15.prev = _context15.next) {
                                    case 0:
                                      _context15.next = 2;
                                      return _this3.storage.uploadFile({
                                        file: trackFile,
                                        onProgress: onProgress,
                                        template: 'audio'
                                      });

                                    case 2:
                                      return _context15.abrupt("return", _context15.sent);

                                    case 3:
                                    case "end":
                                      return _context15.stop();
                                  }
                                }
                              }, _callee15);
                            })), function (e) {
                              _this3.logger.info('Retrying uploadTrackAudio', e);
                            });

                          case 2:
                            return _context16.abrupt("return", _context16.sent);

                          case 3:
                          case "end":
                            return _context16.stop();
                        }
                      }
                    }, _callee16);
                  }));

                  return function (_x27) {
                    return _ref5.apply(this, arguments);
                  };
                }()))));

              case 3:
                _yield$Promise$all = _context18.sent;
                _yield$Promise$all2 = _toArray(_yield$Promise$all);
                coverArtResponse = _yield$Promise$all2[0];
                audioResponses = _yield$Promise$all2.slice(1);
                _context18.next = 9;
                return Promise.all(trackMetadatas.map( /*#__PURE__*/function () {
                  var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(parsedTrackMetadata, i) {
                    var trackMetadata, audioResponse, updatedMetadata, trackId;
                    return regeneratorRuntime.wrap(function _callee17$(_context17) {
                      while (1) {
                        switch (_context17.prev = _context17.next) {
                          case 0:
                            // Transform track metadata
                            trackMetadata = _this3.combineMetadata(_this3.trackUploadHelper.transformTrackUploadMetadata(parsedTrackMetadata, userId), metadata);
                            audioResponse = audioResponses[i];

                            if (audioResponse) {
                              _context17.next = 4;
                              break;
                            }

                            throw new Error("Failed to upload track: ".concat(trackMetadata.title));

                          case 4:
                            // Update metadata to include uploaded CIDs
                            updatedMetadata = _this3.trackUploadHelper.populateTrackMetadataWithUploadResponse(trackMetadata, audioResponse, coverArtResponse);
                            _context17.next = 7;
                            return _this3.trackUploadHelper.generateId('track');

                          case 7:
                            trackId = _context17.sent;
                            _context17.next = 10;
                            return _this3.entityManager.manageEntity(_objectSpread2({
                              userId: userId,
                              entityType: EntityType$1.TRACK,
                              entityId: trackId,
                              action: Action$1.CREATE,
                              metadata: JSON.stringify({
                                cid: '',
                                data: snakecaseKeys__default["default"](updatedMetadata)
                              }),
                              auth: _this3.auth
                            }, advancedOptions));

                          case 10:
                            return _context17.abrupt("return", trackId);

                          case 11:
                          case "end":
                            return _context17.stop();
                        }
                      }
                    }, _callee17);
                  }));

                  return function (_x28, _x29) {
                    return _ref7.apply(this, arguments);
                  };
                }()));

              case 9:
                trackIds = _context18.sent;
                _context18.next = 12;
                return this.trackUploadHelper.generateId('playlist');

              case 12:
                playlistId = _context18.sent;
                _context18.next = 15;
                return this.entityManager.getCurrentBlock();

              case 15:
                currentBlock = _context18.sent;
                // Update metadata to include track ids and cover art cid
                updatedMetadata = _objectSpread2(_objectSpread2({}, metadata), {}, {
                  isPrivate: false,
                  playlistContents: {
                    trackIds: trackIds.map(function (trackId) {
                      return {
                        track: trackId,
                        time: currentBlock.timestamp
                      };
                    })
                  },
                  playlistImageSizesMultihash: coverArtResponse.id
                }); // Write playlist metadata to chain

                _context18.next = 19;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.PLAYLIST,
                  entityId: playlistId,
                  action: Action$1.CREATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys__default["default"](updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 19:
                response = _context18.sent;
                return _context18.abrupt("return", _objectSpread2(_objectSpread2({}, response), {}, {
                  playlistId: encodeHashId(playlistId)
                }));

              case 21:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function uploadPlaylistInternal(_x25, _x26) {
        return _uploadPlaylistInternal.apply(this, arguments);
      }

      return uploadPlaylistInternal;
    }()
    /** @internal
     * Method to update a playlist with already parsed inputs
     * This is used for both playlists and albums
     */

  }, {
    key: "updatePlaylistInternal",
    value: function () {
      var _updatePlaylistInternal = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(_ref8, advancedOptions) {
        var _this4 = this;

        var userId, playlistId, coverArtFile, onProgress, metadata, coverArtResponse, updatedMetadata;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                userId = _ref8.userId, playlistId = _ref8.playlistId, coverArtFile = _ref8.coverArtFile, onProgress = _ref8.onProgress, metadata = _ref8.metadata;
                _context20.t0 = coverArtFile;

                if (!_context20.t0) {
                  _context20.next = 6;
                  break;
                }

                _context20.next = 5;
                return retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
                  return regeneratorRuntime.wrap(function _callee19$(_context19) {
                    while (1) {
                      switch (_context19.prev = _context19.next) {
                        case 0:
                          _context19.next = 2;
                          return _this4.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context19.abrupt("return", _context19.sent);

                        case 3:
                        case "end":
                          return _context19.stop();
                      }
                    }
                  }, _callee19);
                })), function (e) {
                  _this4.logger.info('Retrying uploadPlaylistCoverArt', e);
                });

              case 5:
                _context20.t0 = _context20.sent;

              case 6:
                coverArtResponse = _context20.t0;
                updatedMetadata = _objectSpread2(_objectSpread2(_objectSpread2({}, metadata), metadata.playlistContents ? {
                  playlistContents: {
                    trackIds: metadata.playlistContents.map(function (_ref10) {
                      var trackId = _ref10.trackId,
                          metadataTimestamp = _ref10.metadataTimestamp,
                          timestamp = _ref10.timestamp;
                      return {
                        track: trackId,
                        // default to timestamp for legacy playlists
                        time: metadataTimestamp !== null && metadataTimestamp !== void 0 ? metadataTimestamp : timestamp
                      };
                    })
                  }
                } : {}), coverArtResponse ? {
                  playlistImageSizesMultihash: coverArtResponse.id
                } : {});
                _context20.next = 10;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.PLAYLIST,
                  entityId: playlistId,
                  action: Action$1.UPDATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys__default["default"](updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 10:
                return _context20.abrupt("return", _context20.sent);

              case 11:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function updatePlaylistInternal(_x30, _x31) {
        return _updatePlaylistInternal.apply(this, arguments);
      }

      return updatePlaylistInternal;
    }()
  }]);

  return PlaylistsApi;
}(PlaylistsApi$2);

var getAlbumSchema = zod.z.object({
  userId: zod.z.string(),
  albumId: zod.z.string()
});
var getAlbumTracksSchema = zod.z.object({
  albumId: zod.z.string()
});
var createUploadAlbumMetadataSchema = function createUploadAlbumMetadataSchema() {
  return zod.z.object({
    albumName: zod.z.string(),
    description: zod.z.optional(zod.z.string().max(1000)),
    genre: zod.z["enum"](Object.values(exports.Genre)),
    license: zod.z.optional(zod.z.string()),
    mood: zod.z.optional(zod.z["enum"](Object.values(exports.Mood))),
    releaseDate: zod.z.optional(zod.z.date().max(new Date(), {
      message: 'should not be in the future'
    })),
    tags: zod.z.optional(zod.z.string()),
    upc: zod.z.optional(zod.z.string())
  }).strict();
};

var createAlbumTrackMetadataSchema = function createAlbumTrackMetadataSchema() {
  return createUploadTrackMetadataSchema().partial({
    genre: true,
    mood: true,
    tags: true
  });
};

var createUploadAlbumSchema = function createUploadAlbumSchema() {
  return zod.z.object({
    userId: HashId,
    coverArtFile: ImageFile,
    metadata: createUploadAlbumMetadataSchema(),
    onProgress: zod.z.optional(zod.z["function"]().args(zod.z.number())),

    /**
     * Track metadata is populated from the album if fields are missing
     */
    trackMetadatas: zod.z.array(createAlbumTrackMetadataSchema()),
    trackFiles: zod.z.array(AudioFile)
  }).strict();
};
var createUpdateAlbumSchema = function createUpdateAlbumSchema() {
  return zod.z.object({
    userId: HashId,
    albumId: HashId,
    coverArtFile: zod.z.optional(ImageFile),
    metadata: createUploadAlbumMetadataSchema().partial(),
    onProgress: zod.z.optional(zod.z["function"]().args(zod.z.number()))
  }).strict();
};
var DeleteAlbumSchema = zod.z.object({
  userId: HashId,
  albumId: HashId
}).strict();
var FavoriteAlbumSchema = zod.z.object({
  userId: HashId,
  albumId: HashId,
  metadata: zod.z.optional(zod.z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: zod.z["boolean"]()
  }))
}).strict();
var UnfavoriteAlbumSchema = zod.z.object({
  userId: HashId,
  albumId: HashId
}).strict();
var RepostAlbumSchema = zod.z.object({
  userId: HashId,
  albumId: HashId,
  metadata: zod.z.optional(zod.z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: zod.z["boolean"]()
  }))
}).strict();
var UnrepostAlbumSchema = zod.z.object({
  userId: HashId,
  albumId: HashId
}).strict();

var _excluded$1 = ["metadata"],
    _excluded2 = ["albumName"],
    _excluded3 = ["albumId", "metadata"],
    _excluded4 = ["albumName"];
var AlbumsApi = /*#__PURE__*/function () {
  function AlbumsApi(configuration, storage, entityManager, auth, logger) {
    _classCallCheck(this, AlbumsApi);

    _defineProperty$1(this, "playlistsApi", void 0);

    this.playlistsApi = new PlaylistsApi$1(configuration, storage, entityManager, auth, logger);
  } // READS


  _createClass(AlbumsApi, [{
    key: "getAlbum",
    value: function () {
      var _getAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var userId, albumId;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                userId = params.userId, albumId = params.albumId;
                _context.next = 3;
                return this.playlistsApi.getPlaylist({
                  userId: userId,
                  playlistId: albumId
                });

              case 3:
                return _context.abrupt("return", _context.sent);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAlbum(_x) {
        return _getAlbum.apply(this, arguments);
      }

      return getAlbum;
    }()
  }, {
    key: "getAlbumTracks",
    value: function () {
      var _getAlbumTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        var albumId;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                albumId = params.albumId;
                _context2.next = 3;
                return this.playlistsApi.getPlaylistTracks({
                  playlistId: albumId
                });

              case 3:
                return _context2.abrupt("return", _context2.sent);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getAlbumTracks(_x2) {
        return _getAlbumTracks.apply(this, arguments);
      }

      return getAlbumTracks;
    }() // WRITES

    /** @hidden
     * Upload an album
     * Uploads the specified tracks and combines them into an album
     */

  }, {
    key: "uploadAlbum",
    value: function () {
      var _uploadAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, advancedOptions) {
        var _yield$parseParams, metadata, parsedParameters, albumName, playlistMetadata, response;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return parseParams('uploadAlbum', createUploadAlbumSchema())(params);

              case 2:
                _yield$parseParams = _context3.sent;
                metadata = _yield$parseParams.metadata;
                parsedParameters = _objectWithoutProperties(_yield$parseParams, _excluded$1);
                albumName = metadata.albumName, playlistMetadata = _objectWithoutProperties(metadata, _excluded2); // Call uploadPlaylistInternal with parsed inputs

                _context3.next = 8;
                return this.playlistsApi.uploadPlaylistInternal(_objectSpread2(_objectSpread2({}, parsedParameters), {}, {
                  metadata: _objectSpread2(_objectSpread2({}, playlistMetadata), {}, {
                    playlistName: albumName,
                    isAlbum: true
                  })
                }), advancedOptions);

              case 8:
                response = _context3.sent;
                return _context3.abrupt("return", {
                  blockHash: response.blockHash,
                  blockNumber: response.blockNumber,
                  albumId: response.playlistId
                });

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function uploadAlbum(_x3, _x4) {
        return _uploadAlbum.apply(this, arguments);
      }

      return uploadAlbum;
    }()
    /** @hidden
     * Update an album
     */

  }, {
    key: "updateAlbum",
    value: function () {
      var _updateAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, advancedOptions) {
        var _yield$parseParams2, albumId, metadata, parsedParameters, albumName, playlistMetadata;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('updateAlbum', createUpdateAlbumSchema())(params);

              case 2:
                _yield$parseParams2 = _context4.sent;
                albumId = _yield$parseParams2.albumId;
                metadata = _yield$parseParams2.metadata;
                parsedParameters = _objectWithoutProperties(_yield$parseParams2, _excluded3);
                albumName = metadata.albumName, playlistMetadata = _objectWithoutProperties(metadata, _excluded4); // Call updatePlaylistInternal with parsed inputs

                _context4.next = 9;
                return this.playlistsApi.updatePlaylistInternal(_objectSpread2(_objectSpread2({}, parsedParameters), {}, {
                  playlistId: albumId,
                  metadata: _objectSpread2(_objectSpread2({}, playlistMetadata), {}, {
                    playlistName: albumName
                  })
                }), advancedOptions);

              case 9:
                return _context4.abrupt("return", _context4.sent);

              case 10:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function updateAlbum(_x5, _x6) {
        return _updateAlbum.apply(this, arguments);
      }

      return updateAlbum;
    }()
    /** @hidden
     * Delete an album
     */

  }, {
    key: "deleteAlbum",
    value: function () {
      var _deleteAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, advancedOptions) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return parseParams('deleteAlbum', DeleteAlbumSchema)(params);

              case 2:
                _context5.next = 4;
                return this.playlistsApi.deletePlaylist({
                  userId: params.userId,
                  playlistId: params.albumId
                }, advancedOptions);

              case 4:
                return _context5.abrupt("return", _context5.sent);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function deleteAlbum(_x7, _x8) {
        return _deleteAlbum.apply(this, arguments);
      }

      return deleteAlbum;
    }()
    /** @hidden
     * Favorite an album
     */

  }, {
    key: "favoriteAlbum",
    value: function () {
      var _favoriteAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, advancedOptions) {
        var _yield$parseParams3, metadata;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return parseParams('favoriteAlbum', FavoriteAlbumSchema)(params);

              case 2:
                _yield$parseParams3 = _context6.sent;
                metadata = _yield$parseParams3.metadata;
                _context6.next = 6;
                return this.playlistsApi.favoritePlaylist({
                  userId: params.userId,
                  playlistId: params.albumId,
                  metadata: metadata
                }, advancedOptions);

              case 6:
                return _context6.abrupt("return", _context6.sent);

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function favoriteAlbum(_x9, _x10) {
        return _favoriteAlbum.apply(this, arguments);
      }

      return favoriteAlbum;
    }()
    /** @hidden
     * Unfavorite an album
     */

  }, {
    key: "unfavoriteAlbum",
    value: function () {
      var _unfavoriteAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, advancedOptions) {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('unfavoriteAlbum', UnfavoriteAlbumSchema)(params);

              case 2:
                _context7.next = 4;
                return this.playlistsApi.unfavoritePlaylist({
                  userId: params.userId,
                  playlistId: params.albumId
                }, advancedOptions);

              case 4:
                return _context7.abrupt("return", _context7.sent);

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function unfavoriteAlbum(_x11, _x12) {
        return _unfavoriteAlbum.apply(this, arguments);
      }

      return unfavoriteAlbum;
    }()
    /** @hidden
     * Repost an album
     */

  }, {
    key: "repostAlbum",
    value: function () {
      var _repostAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, advancedOptions) {
        var _yield$parseParams4, metadata;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return parseParams('repostAlbum', RepostAlbumSchema)(params);

              case 2:
                _yield$parseParams4 = _context8.sent;
                metadata = _yield$parseParams4.metadata;
                _context8.next = 6;
                return this.playlistsApi.repostPlaylist({
                  userId: params.userId,
                  playlistId: params.albumId,
                  metadata: metadata
                }, advancedOptions);

              case 6:
                return _context8.abrupt("return", _context8.sent);

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function repostAlbum(_x13, _x14) {
        return _repostAlbum.apply(this, arguments);
      }

      return repostAlbum;
    }()
    /** @hidden
     * Unrepost an album
     */

  }, {
    key: "unrepostAlbum",
    value: function () {
      var _unrepostAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, advancedOptions) {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return parseParams('unrepostAlbum', UnrepostAlbumSchema)(params);

              case 2:
                _context9.next = 4;
                return this.playlistsApi.unrepostPlaylist({
                  userId: params.userId,
                  playlistId: params.albumId
                }, advancedOptions);

              case 4:
                return _context9.abrupt("return", _context9.sent);

              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function unrepostAlbum(_x15, _x16) {
        return _unrepostAlbum.apply(this, arguments);
      }

      return unrepostAlbum;
    }()
  }]);

  return AlbumsApi;
}();

var TracksApi$1 = /*#__PURE__*/function (_GeneratedTracksApi) {
  _inherits(TracksApi, _GeneratedTracksApi);

  var _super = _createSuper(TracksApi);

  function TracksApi(configuration, discoveryNodeSelectorService, storage, entityManager, auth, logger) {
    var _this;

    _classCallCheck(this, TracksApi);

    _this = _super.call(this, configuration);

    _defineProperty$1(_assertThisInitialized(_this), "discoveryNodeSelectorService", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "storage", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "entityManager", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "logger", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "trackUploadHelper", void 0);

    _this.discoveryNodeSelectorService = discoveryNodeSelectorService;
    _this.storage = storage;
    _this.entityManager = entityManager;
    _this.auth = auth;
    _this.logger = logger;
    _this.trackUploadHelper = new TrackUploadHelper(configuration);
    _this.logger = logger.createPrefixedLogger('[tracks-api]');
    return _this;
  }
  /**
   * Get the url of the track's streamable mp3 file
   */
  // @ts-expect-error


  _createClass(TracksApi, [{
    key: "streamTrack",
    value: function () {
      var _streamTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var path, host;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrack.');

              case 2:
                path = "/tracks/{track_id}/stream".replace("{".concat('track_id', "}"), encodeURIComponent(String(params.trackId)));
                _context.next = 5;
                return this.discoveryNodeSelectorService.getSelectedEndpoint();

              case 5:
                host = _context.sent;
                return _context.abrupt("return", "".concat(host).concat(BASE_PATH$1).concat(path));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function streamTrack(_x) {
        return _streamTrack.apply(this, arguments);
      }

      return streamTrack;
    }()
    /** @hidden
     * Upload a track
     */

  }, {
    key: "uploadTrack",
    value: function () {
      var _uploadTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, advancedOptions) {
        var _this2 = this;

        var _yield$parseParams, userId, trackFile, coverArtFile, parsedMetadata, onProgress, metadata, uploadOptions, _yield$Promise$all, _yield$Promise$all2, coverArtResponse, audioResponse, updatedMetadata, trackId, response;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('uploadTrack', createUploadTrackSchema())(params);

              case 2:
                _yield$parseParams = _context4.sent;
                userId = _yield$parseParams.userId;
                trackFile = _yield$parseParams.trackFile;
                coverArtFile = _yield$parseParams.coverArtFile;
                parsedMetadata = _yield$parseParams.metadata;
                onProgress = _yield$parseParams.onProgress;
                // Transform metadata
                metadata = this.trackUploadHelper.transformTrackUploadMetadata(parsedMetadata, userId);
                uploadOptions = {};

                if (metadata.previewStartSeconds) {
                  uploadOptions['previewStartSeconds'] = metadata.previewStartSeconds.toString();
                } // Upload track audio and cover art to storage node


                _context4.next = 13;
                return Promise.all([retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                  return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.next = 2;
                          return _this2.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context2.abrupt("return", _context2.sent);

                        case 3:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                })), function (e) {
                  _this2.logger.info('Retrying uploadTrackCoverArt', e);
                }), retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                  return regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 2;
                          return _this2.storage.uploadFile({
                            file: trackFile,
                            onProgress: onProgress,
                            template: 'audio',
                            options: uploadOptions
                          });

                        case 2:
                          return _context3.abrupt("return", _context3.sent);

                        case 3:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                })), function (e) {
                  _this2.logger.info('Retrying uploadTrackAudio', e);
                })]);

              case 13:
                _yield$Promise$all = _context4.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                coverArtResponse = _yield$Promise$all2[0];
                audioResponse = _yield$Promise$all2[1];
                // Update metadata to include uploaded CIDs
                updatedMetadata = this.trackUploadHelper.populateTrackMetadataWithUploadResponse(metadata, audioResponse, coverArtResponse); // Write metadata to chain

                _context4.next = 20;
                return this.trackUploadHelper.generateId('track');

              case 20:
                trackId = _context4.sent;
                _context4.next = 23;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.TRACK,
                  entityId: trackId,
                  action: Action$1.CREATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys__default["default"](updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 23:
                response = _context4.sent;
                return _context4.abrupt("return", _objectSpread2(_objectSpread2({}, response), {}, {
                  trackId: encodeHashId(trackId)
                }));

              case 25:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function uploadTrack(_x2, _x3) {
        return _uploadTrack.apply(this, arguments);
      }

      return uploadTrack;
    }()
    /** @hidden
     * Update a track
     */

  }, {
    key: "updateTrack",
    value: function () {
      var _updateTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, advancedOptions) {
        var _this3 = this;

        var _yield$parseParams2, userId, trackId, coverArtFile, parsedMetadata, onProgress, transcodePreview, metadata, coverArtResp, updatedMetadata, editFileData, updatePreviewResp, previewKey;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('updateTrack', createUpdateTrackSchema())(params);

              case 2:
                _yield$parseParams2 = _context7.sent;
                userId = _yield$parseParams2.userId;
                trackId = _yield$parseParams2.trackId;
                coverArtFile = _yield$parseParams2.coverArtFile;
                parsedMetadata = _yield$parseParams2.metadata;
                onProgress = _yield$parseParams2.onProgress;
                transcodePreview = _yield$parseParams2.transcodePreview;
                // Transform metadata
                metadata = this.trackUploadHelper.transformTrackUploadMetadata(parsedMetadata, userId); // Upload track cover art to storage node

                _context7.t0 = coverArtFile;

                if (!_context7.t0) {
                  _context7.next = 15;
                  break;
                }

                _context7.next = 14;
                return retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
                  return regeneratorRuntime.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return _this3.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context5.abrupt("return", _context5.sent);

                        case 3:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                })), function (e) {
                  _this3.logger.info('Retrying uploadTrackCoverArt', e);
                });

              case 14:
                _context7.t0 = _context7.sent;

              case 15:
                coverArtResp = _context7.t0;
                // Update metadata to include uploaded CIDs
                updatedMetadata = _objectSpread2(_objectSpread2({}, metadata), coverArtResp ? {
                  coverArtSizes: coverArtResp.id
                } : {});

                if (!transcodePreview) {
                  _context7.next = 28;
                  break;
                }

                if (updatedMetadata.previewStartSeconds) {
                  _context7.next = 20;
                  break;
                }

                throw new Error('No track preview start time specified');

              case 20:
                if (updatedMetadata.audioUploadId) {
                  _context7.next = 22;
                  break;
                }

                throw new Error('Missing required audio_upload_id');

              case 22:
                // Transocde track preview
                editFileData = {
                  previewStartSeconds: updatedMetadata.previewStartSeconds.toString()
                };
                _context7.next = 25;
                return retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
                  return regeneratorRuntime.wrap(function _callee6$(_context6) {
                    while (1) {
                      switch (_context6.prev = _context6.next) {
                        case 0:
                          _context6.next = 2;
                          return _this3.storage.editFile({
                            uploadId: updatedMetadata.audioUploadId,
                            data: editFileData,
                            auth: _this3.auth
                          });

                        case 2:
                          return _context6.abrupt("return", _context6.sent);

                        case 3:
                        case "end":
                          return _context6.stop();
                      }
                    }
                  }, _callee6);
                })), function (e) {
                  _this3.logger.info('Retrying editFileV2', e);
                });

              case 25:
                updatePreviewResp = _context7.sent;
                // Update metadata to include updated preview CID
                previewKey = "320_preview|".concat(updatedMetadata.previewStartSeconds);
                updatedMetadata.previewCid = updatePreviewResp.results[previewKey];

              case 28:
                _context7.next = 30;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.TRACK,
                  entityId: trackId,
                  action: Action$1.UPDATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys__default["default"](updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 30:
                return _context7.abrupt("return", _context7.sent);

              case 31:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function updateTrack(_x4, _x5) {
        return _updateTrack.apply(this, arguments);
      }

      return updateTrack;
    }()
    /** @hidden
     * Delete a track
     */

  }, {
    key: "deleteTrack",
    value: function () {
      var _deleteTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, advancedOptions) {
        var _yield$parseParams3, userId, trackId;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return parseParams('deleteTrack', DeleteTrackSchema)(params);

              case 2:
                _yield$parseParams3 = _context8.sent;
                userId = _yield$parseParams3.userId;
                trackId = _yield$parseParams3.trackId;
                _context8.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.TRACK,
                  entityId: trackId,
                  action: Action$1.DELETE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function deleteTrack(_x6, _x7) {
        return _deleteTrack.apply(this, arguments);
      }

      return deleteTrack;
    }()
    /** @hidden
     * Favorite a track
     */

  }, {
    key: "favoriteTrack",
    value: function () {
      var _favoriteTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, advancedOptions) {
        var _yield$parseParams4, userId, trackId, metadata;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return parseParams('favoriteTrack', FavoriteTrackSchema)(params);

              case 2:
                _yield$parseParams4 = _context9.sent;
                userId = _yield$parseParams4.userId;
                trackId = _yield$parseParams4.trackId;
                metadata = _yield$parseParams4.metadata;
                _context9.next = 8;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.TRACK,
                  entityId: trackId,
                  action: Action$1.SAVE,
                  metadata: metadata && JSON.stringify(snakecaseKeys__default["default"](metadata)),
                  auth: this.auth
                }, advancedOptions));

              case 8:
                return _context9.abrupt("return", _context9.sent);

              case 9:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function favoriteTrack(_x8, _x9) {
        return _favoriteTrack.apply(this, arguments);
      }

      return favoriteTrack;
    }()
    /** @hidden
     * Unfavorite a track
     */

  }, {
    key: "unfavoriteTrack",
    value: function () {
      var _unfavoriteTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, advancedOptions) {
        var _yield$parseParams5, userId, trackId;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return parseParams('unfavoriteTrack', UnfavoriteTrackSchema)(params);

              case 2:
                _yield$parseParams5 = _context10.sent;
                userId = _yield$parseParams5.userId;
                trackId = _yield$parseParams5.trackId;
                _context10.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.TRACK,
                  entityId: trackId,
                  action: Action$1.UNSAVE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context10.abrupt("return", _context10.sent);

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function unfavoriteTrack(_x10, _x11) {
        return _unfavoriteTrack.apply(this, arguments);
      }

      return unfavoriteTrack;
    }()
    /** @hidden
     * Repost a track
     */

  }, {
    key: "repostTrack",
    value: function () {
      var _repostTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, advancedOptions) {
        var _yield$parseParams6, userId, trackId, metadata;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return parseParams('respostTrack', RepostTrackSchema)(params);

              case 2:
                _yield$parseParams6 = _context11.sent;
                userId = _yield$parseParams6.userId;
                trackId = _yield$parseParams6.trackId;
                metadata = _yield$parseParams6.metadata;
                _context11.next = 8;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.TRACK,
                  entityId: trackId,
                  action: Action$1.REPOST,
                  metadata: metadata && JSON.stringify(snakecaseKeys__default["default"](metadata)),
                  auth: this.auth
                }, advancedOptions));

              case 8:
                return _context11.abrupt("return", _context11.sent);

              case 9:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function repostTrack(_x12, _x13) {
        return _repostTrack.apply(this, arguments);
      }

      return repostTrack;
    }()
    /** @hidden
     * Unrepost a track
     */

  }, {
    key: "unrepostTrack",
    value: function () {
      var _unrepostTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, advancedOptions) {
        var _yield$parseParams7, userId, trackId;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return parseParams('unrepostTrack', UnrepostTrackSchema)(params);

              case 2:
                _yield$parseParams7 = _context12.sent;
                userId = _yield$parseParams7.userId;
                trackId = _yield$parseParams7.trackId;
                _context12.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.TRACK,
                  entityId: trackId,
                  action: Action$1.UNREPOST,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context12.abrupt("return", _context12.sent);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function unrepostTrack(_x14, _x15) {
        return _unrepostTrack.apply(this, arguments);
      }

      return unrepostTrack;
    }()
  }]);

  return TracksApi;
}(TracksApi$2);

var UpdateProfileSchema = zod.z.object({
  userId: HashId,
  profilePictureFile: zod.z.optional(ImageFile),
  coverArtFile: zod.z.optional(ImageFile),
  onProgress: zod.z.optional(zod.z["function"]().args(zod.z.number())),
  metadata: zod.z.object({
    name: zod.z.optional(zod.z.string()),
    bio: zod.z.optional(zod.z.string()),
    location: zod.z.optional(zod.z.string()),
    isDeactivated: zod.z.optional(zod.z["boolean"]()),
    artistPickTrackId: zod.z.optional(HashId)
  }).strict()
}).strict();
var FollowUserSchema = zod.z.object({
  userId: HashId,
  followeeUserId: HashId
}).strict();
var UnfollowUserSchema = zod.z.object({
  userId: HashId,
  followeeUserId: HashId
}).strict();
var SubscribeToUserSchema = zod.z.object({
  userId: HashId,
  subscribeeUserId: HashId
}).strict();
var UnsubscribeFromUserSchema = zod.z.object({
  userId: HashId,
  subscribeeUserId: HashId
}).strict();

var UsersApi$1 = /*#__PURE__*/function (_GeneratedUsersApi) {
  _inherits(UsersApi, _GeneratedUsersApi);

  var _super = _createSuper(UsersApi);

  function UsersApi(configuration, storage, entityManager, auth, logger) {
    var _this;

    _classCallCheck(this, UsersApi);

    _this = _super.call(this, configuration);

    _defineProperty$1(_assertThisInitialized(_this), "storage", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "entityManager", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "logger", void 0);

    _this.storage = storage;
    _this.entityManager = entityManager;
    _this.auth = auth;
    _this.logger = logger;
    _this.logger = logger.createPrefixedLogger('[users-api]');
    return _this;
  }
  /** @hidden
   * Update a user profile
   */


  _createClass(UsersApi, [{
    key: "updateProfile",
    value: function () {
      var _updateProfile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, advancedOptions) {
        var _this2 = this;

        var _yield$parseParams, onProgress, profilePictureFile, coverArtFile, userId, metadata, _yield$Promise$all, _yield$Promise$all2, profilePictureResp, coverArtResp, updatedMetadata;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return parseParams('updateProfile', UpdateProfileSchema)(params);

              case 2:
                _yield$parseParams = _context3.sent;
                onProgress = _yield$parseParams.onProgress;
                profilePictureFile = _yield$parseParams.profilePictureFile;
                coverArtFile = _yield$parseParams.coverArtFile;
                userId = _yield$parseParams.userId;
                metadata = _yield$parseParams.metadata;
                _context3.next = 10;
                return Promise.all([profilePictureFile && retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.next = 2;
                          return _this2.storage.uploadFile({
                            file: profilePictureFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context.abrupt("return", _context.sent);

                        case 3:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                })), function (e) {
                  _this2.logger.info('Retrying uploadProfilePicture', e);
                }), coverArtFile && retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                  return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.next = 2;
                          return _this2.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_backdrop'
                          });

                        case 2:
                          return _context2.abrupt("return", _context2.sent);

                        case 3:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                })), function (e) {
                  _this2.logger.info('Retrying uploadProfileCoverArt', e);
                })]);

              case 10:
                _yield$Promise$all = _context3.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                profilePictureResp = _yield$Promise$all2[0];
                coverArtResp = _yield$Promise$all2[1];
                updatedMetadata = _objectSpread2(_objectSpread2(_objectSpread2({}, metadata), profilePictureResp ? {
                  profilePicture: profilePictureResp === null || profilePictureResp === void 0 ? void 0 : profilePictureResp.id
                } : {}), coverArtResp ? {
                  coverPhoto: coverArtResp === null || coverArtResp === void 0 ? void 0 : coverArtResp.id
                } : {}); // Write metadata to chain

                _context3.next = 17;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.USER,
                  entityId: userId,
                  action: Action$1.UPDATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys__default["default"](updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 17:
                return _context3.abrupt("return", _context3.sent);

              case 18:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function updateProfile(_x, _x2) {
        return _updateProfile.apply(this, arguments);
      }

      return updateProfile;
    }()
    /** @hidden
     * Follow a user
     */

  }, {
    key: "followUser",
    value: function () {
      var _followUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, advancedOptions) {
        var _yield$parseParams2, userId, followeeUserId;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('followUser', FollowUserSchema)(params);

              case 2:
                _yield$parseParams2 = _context4.sent;
                userId = _yield$parseParams2.userId;
                followeeUserId = _yield$parseParams2.followeeUserId;
                _context4.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.USER,
                  entityId: followeeUserId,
                  action: Action$1.FOLLOW,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context4.abrupt("return", _context4.sent);

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function followUser(_x3, _x4) {
        return _followUser.apply(this, arguments);
      }

      return followUser;
    }()
    /** @hidden
     * Unfollow a user
     */

  }, {
    key: "unfollowUser",
    value: function () {
      var _unfollowUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, advancedOptions) {
        var _yield$parseParams3, userId, followeeUserId;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return parseParams('unfollowUser', UnfollowUserSchema)(params);

              case 2:
                _yield$parseParams3 = _context5.sent;
                userId = _yield$parseParams3.userId;
                followeeUserId = _yield$parseParams3.followeeUserId;
                _context5.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.USER,
                  entityId: followeeUserId,
                  action: Action$1.UNFOLLOW,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context5.abrupt("return", _context5.sent);

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function unfollowUser(_x5, _x6) {
        return _unfollowUser.apply(this, arguments);
      }

      return unfollowUser;
    }()
    /** @hidden
     * Subscribe to a user
     */

  }, {
    key: "subscribeToUser",
    value: function () {
      var _subscribeToUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, advancedOptions) {
        var _yield$parseParams4, userId, subscribeeUserId;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return parseParams('subscribeToUser', SubscribeToUserSchema)(params);

              case 2:
                _yield$parseParams4 = _context6.sent;
                userId = _yield$parseParams4.userId;
                subscribeeUserId = _yield$parseParams4.subscribeeUserId;
                _context6.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.USER,
                  entityId: subscribeeUserId,
                  action: Action$1.SUBSCRIBE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context6.abrupt("return", _context6.sent);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function subscribeToUser(_x7, _x8) {
        return _subscribeToUser.apply(this, arguments);
      }

      return subscribeToUser;
    }()
    /** @hidden
     * Unsubscribe from a user
     */

  }, {
    key: "unsubscribeFromUser",
    value: function () {
      var _unsubscribeFromUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, advancedOptions) {
        var _yield$parseParams5, userId, subscribeeUserId;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('unsubscribeFromUser', UnsubscribeFromUserSchema)(params);

              case 2:
                _yield$parseParams5 = _context7.sent;
                userId = _yield$parseParams5.userId;
                subscribeeUserId = _yield$parseParams5.subscribeeUserId;
                _context7.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType$1.USER,
                  entityId: subscribeeUserId,
                  action: Action$1.UNSUBSCRIBE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context7.abrupt("return", _context7.sent);

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function unsubscribeFromUser(_x9, _x10) {
        return _unsubscribeFromUser.apply(this, arguments);
      }

      return unsubscribeFromUser;
    }()
  }]);

  return UsersApi;
}(UsersApi$2);

var ResolveApi = /*#__PURE__*/function (_BaseAPI) {
  _inherits(ResolveApi, _BaseAPI);

  var _super = _createSuper(ResolveApi);

  function ResolveApi() {
    _classCallCheck(this, ResolveApi);

    return _super.apply(this, arguments);
  }

  _createClass(ResolveApi, [{
    key: "resolveRaw",
    value:
    /**
     * Resolves a provided Audius app URL to the API resource it represents
     */
    function () {
      var _resolveRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.url === null || params.url === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('url', 'Required parameter params.url was null or undefined when calling resolve.');

              case 2:
                queryParameters = {};

                if (params.url !== undefined) {
                  queryParameters.url = params.url;
                }

                headerParameters = {};
                _context.next = 7;
                return this.request({
                  path: "/resolve",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                });

              case 7:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (json) {
                  {
                    return TrackResponseFromJSON(json);
                  }
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function resolveRaw(_x) {
        return _resolveRaw.apply(this, arguments);
      }

      return resolveRaw;
    }()
  }, {
    key: "resolve",
    value: function () {
      var _resolve = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.resolveRaw(params);

              case 2:
                _context2.next = 4;
                return _context2.sent.value();

              case 4:
                return _context2.abrupt("return", _context2.sent);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function resolve(_x2) {
        return _resolve.apply(this, arguments);
      }

      return resolve;
    }()
  }]);

  return ResolveApi;
}(BaseAPI$1);

// NOTE: No imports allowed - quicktype is not yet able to track imports!

/**
 * Defines who the user allows to message them
 */
exports.ChatPermission = void 0;

(function (ChatPermission) {
  /**
   * Messages are allowed for everyone
   */
  ChatPermission["ALL"] = "all";
  /**
   * Messages are only allowed for users that have tipped me
   */

  ChatPermission["TIPPERS"] = "tippers";
  /**
   * Messages are only allowed for users I follow
   */

  ChatPermission["FOLLOWEES"] = "followees";
  /**
   * Messages are not allowed
   */

  ChatPermission["NONE"] = "none";
})(exports.ChatPermission || (exports.ChatPermission = {}));

var ChatListenRequestSchema = zod.z.optional(zod.z.object({
  currentUserId: zod.z.optional(zod.z.string())
}));
var ChatGetAllRequestSchema = zod.z.object({
  currentUserId: zod.z.optional(zod.z.string()),
  limit: zod.z.optional(zod.z.number()),
  before: zod.z.optional(zod.z.string()),
  after: zod.z.optional(zod.z.string())
});
var ChatGetRequestSchema = zod.z.object({
  currentUserId: zod.z.optional(zod.z.string()),
  chatId: zod.z.string()
});
var ChatGetMessagesRequestSchema = zod.z.object({
  currentUserId: zod.z.optional(zod.z.string()),
  chatId: zod.z.string(),
  limit: zod.z.optional(zod.z.number()),
  before: zod.z.optional(zod.z.string()),
  after: zod.z.optional(zod.z.string())
});
var ChatGetUnreadCountRequestSchema = zod.z.optional(zod.z.object({
  currentUserId: zod.z.optional(zod.z.string())
}));
var ChatGetBlockersRequestSchema = zod.z.optional(zod.z.object({
  currentUserId: zod.z.optional(zod.z.string())
}));
var ChatCreateRequestSchema = zod.z.object({
  currentUserId: zod.z.optional(zod.z.string()),
  userId: zod.z.string(),
  invitedUserIds: zod.z.array(zod.z.string()).min(1)
});
var ChatInviteRequestSchema = zod.z.object({
  currentUserId: zod.z.optional(zod.z.string()),
  chatId: zod.z.string(),
  userId: zod.z.string(),
  invitedUserIds: zod.z.array(zod.z.string()).min(1)
});
var ChatMessageRequestSchema = zod.z.object({
  currentUserId: zod.z.optional(zod.z.string()),
  chatId: zod.z.string(),
  messageId: zod.z.optional(zod.z.string()),
  message: zod.z.string()
});
var ChatReactRequestSchema = zod.z.object({
  currentUserId: zod.z.optional(zod.z.string()),
  chatId: zod.z.string(),
  messageId: zod.z.string(),
  reaction: zod.z.nullable(zod.z.string())
});
var ChatReadRequestSchema = zod.z.object({
  currentUserId: zod.z.optional(zod.z.string()),
  chatId: zod.z.string()
});
var ChatBlockRequestSchema = zod.z.object({
  currentUserId: zod.z.optional(zod.z.string()),
  userId: zod.z.string()
});
var ChatDeleteRequestSchema = zod.z.object({
  currentUserId: zod.z.optional(zod.z.string()),
  chatId: zod.z.string()
});
var ChatPermitRequestSchema = zod.z.object({
  currentUserId: zod.z.optional(zod.z.string()),
  permit: zod.z.nativeEnum(exports.ChatPermission)
});
var ChatValidateCanCreateRequestSchema = zod.z.object({
  currentUserId: zod.z.optional(zod.z.string()),
  userIds: zod.z.array(zod.z.string()).min(1)
});
var ChatGetPermissionRequestSchema = zod.z.object({
  currentUserId: zod.z.optional(zod.z.string()),
  userIds: zod.z.array(zod.z.string()).min(1)
});
var ChatUnfurlRequestSchema = zod.z.object({
  urls: zod.z.array(zod.z.string()).min(1)
});

var GENERIC_MESSAGE_ERROR = 'Error: this message can not be displayed';
var ChatsApi = /*#__PURE__*/function (_BaseAPI) {
  _inherits(ChatsApi, _BaseAPI);

  var _super = _createSuper(ChatsApi);

  /**
   * A map of chatId => chatSecret so we don't have to repeatedly fetch it
   */

  /**
   * An event emitter that's used for consumers to listen for chat events
   */

  /**
   * The websocket currently in use
   */

  /**
   * The current user ID to use when connecting/reconnecting the websocket
   */

  /**
   * Proxy to the event emitter addListener
   */

  /**
   * Proxy to the event emitter removeListener
   */
  function ChatsApi(config, auth, discoveryNodeSelectorService, logger) {
    var _this;

    _classCallCheck(this, ChatsApi);

    _this = _super.call(this, config);

    _defineProperty$1(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "discoveryNodeSelectorService", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "logger", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "chatSecrets", {});

    _defineProperty$1(_assertThisInitialized(_this), "eventEmitter", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "websocket", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "listenUserId", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "addEventListener", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "removeEventListener", void 0);

    _this.auth = auth;
    _this.discoveryNodeSelectorService = discoveryNodeSelectorService;
    _this.logger = logger;
    _this.eventEmitter = new EventEmitter__default["default"]();
    _this.addEventListener = _this.eventEmitter.addListener.bind(_this.eventEmitter);
    _this.removeEventListener = _this.eventEmitter.removeListener.bind(_this.eventEmitter); // Listen for discovery node selection changes and reinit websocket

    _this.discoveryNodeSelectorService.addEventListener('change', function (endpoint) {
      if (_this.websocket) {
        _this.websocket.close();

        _this.createWebsocket(endpoint).then(function (ws) {
          _this.websocket = ws;
        });
      }
    });

    _this.logger = logger.createPrefixedLogger('[chats-api]');
    return _this;
  } // #region QUERY

  /**
   * Establishes a websocket connection for listening to chat events.
   * @param params.currentUserId the user to listen for chat events for
   */


  _createClass(ChatsApi, [{
    key: "listen",
    value: function () {
      var _listen = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var parsedArgs, endpoint;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return parseParams('listen', ChatListenRequestSchema)(params);

              case 2:
                parsedArgs = _context.sent;
                this.listenUserId = parsedArgs === null || parsedArgs === void 0 ? void 0 : parsedArgs.currentUserId;
                _context.next = 6;
                return this.discoveryNodeSelectorService.getSelectedEndpoint();

              case 6:
                endpoint = _context.sent;

                if (!endpoint) {
                  _context.next = 13;
                  break;
                }

                _context.next = 10;
                return this.createWebsocket(endpoint);

              case 10:
                this.websocket = _context.sent;
                _context.next = 14;
                break;

              case 13:
                throw new Error('No services available to listen to');

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function listen(_x) {
        return _listen.apply(this, arguments);
      }

      return listen;
    }()
    /**
     * Gets a single chat
     * @param params.chatId the chat to get
     * @param params.currentUserId the user to act on behalf of
     * @returns the chat response
     */

  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        var _yield$parseParams, chatId, currentUserId, response;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return parseParams('get', ChatGetRequestSchema)(params);

              case 2:
                _yield$parseParams = _context2.sent;
                chatId = _yield$parseParams.chatId;
                currentUserId = _yield$parseParams.currentUserId;
                _context2.next = 7;
                return this.getRaw(chatId, currentUserId);

              case 7:
                response = _context2.sent;
                _context2.t0 = _objectSpread2;
                _context2.t1 = _objectSpread2({}, response);
                _context2.t2 = {};

                if (!response.data) {
                  _context2.next = 17;
                  break;
                }

                _context2.next = 14;
                return this.decryptLastChatMessage(response.data);

              case 14:
                _context2.t3 = _context2.sent;
                _context2.next = 18;
                break;

              case 17:
                _context2.t3 = response.data;

              case 18:
                _context2.t4 = _context2.t3;
                _context2.t5 = {
                  data: _context2.t4
                };
                return _context2.abrupt("return", (0, _context2.t0)(_context2.t1, _context2.t2, _context2.t5));

              case 21:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function get(_x2) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
    /**
     * Gets a list of chats
     * @param params.limit the max number of chats to get
     * @param params.before a timestamp cursor for pagination
     * @param params.after a timestamp cursor for pagination
     * @param params.currentUserId the user to act on behalf of
     * @returns the chat list response
     */

  }, {
    key: "getAll",
    value: function () {
      var _getAll = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params) {
        var _this2 = this;

        var _yield$parseParams2, currentUserId, limit, before, after, path, query, response, json, decrypted;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('getAll', ChatGetAllRequestSchema)(params);

              case 2:
                _yield$parseParams2 = _context4.sent;
                currentUserId = _yield$parseParams2.currentUserId;
                limit = _yield$parseParams2.limit;
                before = _yield$parseParams2.before;
                after = _yield$parseParams2.after;
                path = "/comms/chats";
                query = {
                  timestamp: new Date().getTime()
                };

                if (limit) {
                  query['limit'] = limit;
                }

                if (before) {
                  query['before'] = before;
                }

                if (after) {
                  query['after'] = after;
                }

                if (currentUserId) {
                  query['current_user_id'] = currentUserId;
                }

                _context4.next = 15;
                return this.signAndSendRequest({
                  method: 'GET',
                  headers: {},
                  path: path,
                  query: query
                });

              case 15:
                response = _context4.sent;
                _context4.next = 18;
                return response.json();

              case 18:
                json = _context4.sent;
                _context4.next = 21;
                return Promise.all(json.data.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(c) {
                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.next = 2;
                            return _this2.decryptLastChatMessage(c);

                          case 2:
                            return _context3.abrupt("return", _context3.sent);

                          case 3:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function (_x4) {
                    return _ref.apply(this, arguments);
                  };
                }()));

              case 21:
                decrypted = _context4.sent;
                return _context4.abrupt("return", _objectSpread2(_objectSpread2({}, json), {}, {
                  data: decrypted
                }));

              case 23:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAll(_x3) {
        return _getAll.apply(this, arguments);
      }

      return getAll;
    }()
    /**
     * Gets a list of messages
     * @param params.chatId the chat to get messages for
     * @param params.before a timestamp cursor for pagination
     * @param params.after a timestamp cursor for pagination
     * @param params.currentUserId the user to act on behalf of
     * @returns the messages list response
     */

  }, {
    key: "getMessages",
    value: function () {
      var _getMessages = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params) {
        var _this3 = this;

        var _yield$parseParams3, currentUserId, chatId, limit, before, after, sharedSecret, path, query, response, json, decrypted;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return parseParams('getMessages', ChatGetMessagesRequestSchema)(params);

              case 2:
                _yield$parseParams3 = _context6.sent;
                currentUserId = _yield$parseParams3.currentUserId;
                chatId = _yield$parseParams3.chatId;
                limit = _yield$parseParams3.limit;
                before = _yield$parseParams3.before;
                after = _yield$parseParams3.after;
                _context6.prev = 8;
                _context6.next = 11;
                return this.getChatSecret(chatId);

              case 11:
                sharedSecret = _context6.sent;
                _context6.next = 18;
                break;

              case 14:
                _context6.prev = 14;
                _context6.t0 = _context6["catch"](8);
                this.logger.error("[audius-sdk] Couldn't get chat secret", _context6.t0);
                throw new Error("[audius-sdk] Couldn't get chat secret");

              case 18:
                path = "/comms/chats/".concat(chatId, "/messages");
                query = {
                  timestamp: new Date().getTime()
                };

                if (limit) {
                  query['limit'] = limit;
                }

                if (before) {
                  query['before'] = before;
                }

                if (after) {
                  query['after'] = after;
                }

                if (currentUserId) {
                  query['current_user_id'] = currentUserId;
                }

                _context6.next = 26;
                return this.signAndSendRequest({
                  method: 'GET',
                  headers: {},
                  path: path,
                  query: query
                });

              case 26:
                response = _context6.sent;
                _context6.next = 29;
                return response.json();

              case 29:
                json = _context6.sent;
                _context6.next = 32;
                return Promise.all(json.data.map( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(m) {
                    return regeneratorRuntime.wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            _context5.t0 = _objectSpread2;
                            _context5.t1 = _objectSpread2({}, m);
                            _context5.t2 = {};
                            _context5.next = 5;
                            return _this3.decryptString(sharedSecret, base$1.base64.decode(m.message))["catch"](function (e) {
                              _this3.logger.error("[audius-sdk]: Error: Couldn't decrypt chat message", m, e);

                              return GENERIC_MESSAGE_ERROR;
                            });

                          case 5:
                            _context5.t3 = _context5.sent;
                            _context5.t4 = {
                              message: _context5.t3
                            };
                            return _context5.abrupt("return", (0, _context5.t0)(_context5.t1, _context5.t2, _context5.t4));

                          case 8:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function (_x6) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 32:
                decrypted = _context6.sent;
                return _context6.abrupt("return", _objectSpread2(_objectSpread2({}, json), {}, {
                  data: decrypted
                }));

              case 34:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[8, 14]]);
      }));

      function getMessages(_x5) {
        return _getMessages.apply(this, arguments);
      }

      return getMessages;
    }()
    /**
     * Gets the total unread message count for a user
     * @param params.currentUserId the user to act on behalf of
     * @returns the unread count response
     */

  }, {
    key: "getUnreadCount",
    value: function () {
      var _getUnreadCount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params) {
        var parsedArgs, query, res;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('getUnreadCount', ChatGetUnreadCountRequestSchema)(params);

              case 2:
                parsedArgs = _context7.sent;
                query = {
                  timestamp: new Date().getTime()
                };

                if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
                  query['current_user_id'] = parsedArgs.currentUserId;
                }

                _context7.next = 7;
                return this.signAndSendRequest({
                  method: 'GET',
                  path: "/comms/chats/unread",
                  headers: {},
                  query: query
                });

              case 7:
                res = _context7.sent;
                _context7.next = 10;
                return res.json();

              case 10:
                return _context7.abrupt("return", _context7.sent);

              case 11:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getUnreadCount(_x7) {
        return _getUnreadCount.apply(this, arguments);
      }

      return getUnreadCount;
    }()
    /**
     * Gets the permission settings of the given users
     * @param params.userIds the users to fetch permissions of
     * @param params.currentUserId the user to act on behalf of
     * @returns the permissions response
     */

  }, {
    key: "getPermissions",
    value: function () {
      var _getPermissions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params) {
        var query, _yield$parseParams4, userIds, currentUserId, res;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                query = {
                  timestamp: new Date().getTime()
                };
                _context8.next = 3;
                return parseParams('getPermissions', ChatGetPermissionRequestSchema)(params);

              case 3:
                _yield$parseParams4 = _context8.sent;
                userIds = _yield$parseParams4.userIds;
                currentUserId = _yield$parseParams4.currentUserId;
                query['id'] = userIds;

                if (currentUserId) {
                  query['current_user_id'] = currentUserId;
                }

                _context8.next = 10;
                return this.signAndSendRequest({
                  method: 'GET',
                  path: '/comms/chats/permissions',
                  headers: {},
                  query: query
                });

              case 10:
                res = _context8.sent;
                _context8.next = 13;
                return res.json();

              case 13:
                return _context8.abrupt("return", _context8.sent);

              case 14:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getPermissions(_x8) {
        return _getPermissions.apply(this, arguments);
      }

      return getPermissions;
    }()
    /**
     * Gets the user ids that have blocked the current user
     * @param params.currentUserId the user to act on behalf of
     * @returns the blockers response
     */

  }, {
    key: "getBlockers",
    value: function () {
      var _getBlockers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params) {
        var parsedArgs, query, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return parseParams('getBlockers', ChatGetBlockersRequestSchema)(params);

              case 2:
                parsedArgs = _context9.sent;
                query = {
                  timestamp: new Date().getTime()
                };

                if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
                  query['current_user_id'] = parsedArgs.currentUserId;
                }

                _context9.next = 7;
                return this.signAndSendRequest({
                  method: 'GET',
                  path: "/comms/chats/blockers",
                  headers: {},
                  query: query
                });

              case 7:
                response = _context9.sent;
                _context9.next = 10;
                return response.json();

              case 10:
                return _context9.abrupt("return", _context9.sent);

              case 11:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getBlockers(_x9) {
        return _getBlockers.apply(this, arguments);
      }

      return getBlockers;
    }()
    /**
     * Gets the user ids the current user has blocked
     * @param params.currentUserId the user to act on behalf of
     * @returns
     */

  }, {
    key: "getBlockees",
    value: function () {
      var _getBlockees = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params) {
        var parsedArgs, query, response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return parseParams('getBlockees', ChatGetBlockersRequestSchema)(params);

              case 2:
                parsedArgs = _context10.sent;
                query = {
                  timestamp: new Date().getTime()
                };

                if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
                  query['current_user_id'] = parsedArgs.currentUserId;
                }

                _context10.next = 7;
                return this.signAndSendRequest({
                  method: 'GET',
                  path: "/comms/chats/blockees",
                  headers: {},
                  query: query
                });

              case 7:
                response = _context10.sent;
                _context10.next = 10;
                return response.json();

              case 10:
                return _context10.abrupt("return", _context10.sent);

              case 11:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getBlockees(_x10) {
        return _getBlockees.apply(this, arguments);
      }

      return getBlockees;
    }()
    /**
     * Gets URL metadata useful for link previews
     * @param params.content the urls to get metadata for
     * @returns the unfurl response
     */

  }, {
    key: "unfurl",
    value: function () {
      var _unfurl = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params) {
        var _yield$parseParams5, urls, query, res;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return parseParams('unfurl', ChatUnfurlRequestSchema)(params);

              case 2:
                _yield$parseParams5 = _context11.sent;
                urls = _yield$parseParams5.urls;
                query = {
                  content: urls
                };
                _context11.next = 7;
                return this.request({
                  method: 'GET',
                  path: '/comms/unfurl',
                  query: query,
                  headers: {}
                });

              case 7:
                res = _context11.sent;
                _context11.next = 10;
                return res.json();

              case 10:
                return _context11.abrupt("return", _context11.sent);

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function unfurl(_x11) {
        return _unfurl.apply(this, arguments);
      }

      return unfurl;
    }() // #endregion
    // #region MUTATE

    /**
     * Creates a chat between users
     * @param params.userId the user id who is creating the chat
     * @param params.invitedUserIds the user ids to add to the chat
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "create",
    value: function () {
      var _create = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params) {
        var _yield$parseParams6, currentUserId, userId, invitedUserIds, chatId, chatSecret, invites;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return parseParams('create', ChatCreateRequestSchema)(params);

              case 2:
                _yield$parseParams6 = _context12.sent;
                currentUserId = _yield$parseParams6.currentUserId;
                userId = _yield$parseParams6.userId;
                invitedUserIds = _yield$parseParams6.invitedUserIds;
                chatId = [userId].concat(_toConsumableArray(invitedUserIds)).sort().join(':');
                chatSecret = secp__namespace.utils.randomPrivateKey();
                _context12.next = 10;
                return this.createInvites(userId, invitedUserIds, chatSecret);

              case 10:
                invites = _context12.sent;
                _context12.next = 13;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.create',
                  params: {
                    chat_id: chatId,
                    invites: invites
                  }
                });

              case 13:
                return _context12.abrupt("return", _context12.sent);

              case 14:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function create(_x12) {
        return _create.apply(this, arguments);
      }

      return create;
    }()
    /**
     * Invites other users to an existing chat
     * @param params.chatId the chat id of the chat to invite to
     * @param params.userId the user id who is creating the chat
     * @param params.invitedUserIds the user ids to add to the chat
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "invite",
    value: function () {
      var _invite = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params) {
        var _yield$parseParams7, currentUserId, chatId, userId, invitedUserIds, chatSecret, invites;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return parseParams('invite', ChatInviteRequestSchema)(params);

              case 2:
                _yield$parseParams7 = _context13.sent;
                currentUserId = _yield$parseParams7.currentUserId;
                chatId = _yield$parseParams7.chatId;
                userId = _yield$parseParams7.userId;
                invitedUserIds = _yield$parseParams7.invitedUserIds;
                _context13.next = 9;
                return this.getChatSecret(chatId);

              case 9:
                chatSecret = _context13.sent;
                _context13.next = 12;
                return this.createInvites(userId, invitedUserIds, chatSecret);

              case 12:
                invites = _context13.sent;
                _context13.next = 15;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.invite',
                  params: {
                    chat_id: chatId,
                    invites: invites
                  }
                });

              case 15:
                return _context13.abrupt("return", _context13.sent);

              case 16:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function invite(_x13) {
        return _invite.apply(this, arguments);
      }

      return invite;
    }()
    /**
     * Sends a message to a user in a chat
     * @param params.message the message
     * @param params.chatId the chat to send a message in
     * @param params.messageId the id of the message
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "message",
    value: function () {
      var _message = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params) {
        var _yield$parseParams8, currentUserId, chatId, message, messageId, chatSecret, encrypted, encodedMessage;

        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return parseParams('message', ChatMessageRequestSchema)(params);

              case 2:
                _yield$parseParams8 = _context14.sent;
                currentUserId = _yield$parseParams8.currentUserId;
                chatId = _yield$parseParams8.chatId;
                message = _yield$parseParams8.message;
                messageId = _yield$parseParams8.messageId;
                _context14.next = 9;
                return this.getChatSecret(chatId);

              case 9:
                chatSecret = _context14.sent;
                _context14.next = 12;
                return this.encryptString(chatSecret, message);

              case 12:
                encrypted = _context14.sent;
                encodedMessage = base$1.base64.encode(encrypted);
                _context14.next = 16;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.message',
                  params: {
                    chat_id: chatId,
                    message_id: messageId !== null && messageId !== void 0 ? messageId : ulid.ulid(),
                    message: encodedMessage
                  }
                });

              case 16:
                return _context14.abrupt("return", _context14.sent);

              case 17:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function message(_x14) {
        return _message.apply(this, arguments);
      }

      return message;
    }()
    /**
     * Reacts to a message
     * @param params.reaction the reaction
     * @param params.chatId the chat to send a reaction in
     * @param params.messageId the id of the message to react to
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "react",
    value: function () {
      var _react = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(params) {
        var _yield$parseParams9, currentUserId, chatId, messageId, reaction;

        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return parseParams('react', ChatReactRequestSchema)(params);

              case 2:
                _yield$parseParams9 = _context15.sent;
                currentUserId = _yield$parseParams9.currentUserId;
                chatId = _yield$parseParams9.chatId;
                messageId = _yield$parseParams9.messageId;
                reaction = _yield$parseParams9.reaction;
                _context15.next = 9;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.react',
                  params: {
                    chat_id: chatId,
                    message_id: messageId,
                    reaction: reaction
                  }
                });

              case 9:
                return _context15.abrupt("return", _context15.sent);

              case 10:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function react(_x15) {
        return _react.apply(this, arguments);
      }

      return react;
    }()
    /**
     * Marks a chat as read
     * @param params.chatId the chat to mark as read
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "read",
    value: function () {
      var _read = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(params) {
        var _yield$parseParams10, currentUserId, chatId;

        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return parseParams('read', ChatReadRequestSchema)(params);

              case 2:
                _yield$parseParams10 = _context16.sent;
                currentUserId = _yield$parseParams10.currentUserId;
                chatId = _yield$parseParams10.chatId;
                _context16.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.read',
                  params: {
                    chat_id: chatId
                  }
                });

              case 7:
                return _context16.abrupt("return", _context16.sent);

              case 8:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function read(_x16) {
        return _read.apply(this, arguments);
      }

      return read;
    }()
    /**
     * Blocks a user from sending messages to the current user
     * @param params.userId the user to block
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "block",
    value: function () {
      var _block = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(params) {
        var _yield$parseParams11, currentUserId, userId;

        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return parseParams('block', ChatBlockRequestSchema)(params);

              case 2:
                _yield$parseParams11 = _context17.sent;
                currentUserId = _yield$parseParams11.currentUserId;
                userId = _yield$parseParams11.userId;
                _context17.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.block',
                  params: {
                    user_id: userId
                  }
                });

              case 7:
                return _context17.abrupt("return", _context17.sent);

              case 8:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function block(_x17) {
        return _block.apply(this, arguments);
      }

      return block;
    }()
    /**
     * Unblocks a user from sending messages to the current user
     * @param params.userId the user to unblock
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "unblock",
    value: function () {
      var _unblock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(params) {
        var _yield$parseParams12, currentUserId, userId;

        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return parseParams('unblock', ChatBlockRequestSchema)(params);

              case 2:
                _yield$parseParams12 = _context18.sent;
                currentUserId = _yield$parseParams12.currentUserId;
                userId = _yield$parseParams12.userId;
                _context18.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.unblock',
                  params: {
                    user_id: userId
                  }
                });

              case 7:
                return _context18.abrupt("return", _context18.sent);

              case 8:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function unblock(_x18) {
        return _unblock.apply(this, arguments);
      }

      return unblock;
    }()
    /**
     * Clears a chat's history for the current user
     * @param params.chatId the chat to clear
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(params) {
        var _yield$parseParams13, currentUserId, chatId;

        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return parseParams('delete', ChatDeleteRequestSchema)(params);

              case 2:
                _yield$parseParams13 = _context19.sent;
                currentUserId = _yield$parseParams13.currentUserId;
                chatId = _yield$parseParams13.chatId;
                _context19.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.delete',
                  params: {
                    chat_id: chatId
                  }
                });

              case 7:
                return _context19.abrupt("return", _context19.sent);

              case 8:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function _delete(_x19) {
        return _delete2.apply(this, arguments);
      }

      return _delete;
    }()
    /**
     * Sets the inbox settings permissions of the current user
     * @param params.permit the permission to set
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "permit",
    value: function () {
      var _permit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(params) {
        var _yield$parseParams14, currentUserId, permit;

        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return parseParams('permit', ChatPermitRequestSchema)(params);

              case 2:
                _yield$parseParams14 = _context20.sent;
                currentUserId = _yield$parseParams14.currentUserId;
                permit = _yield$parseParams14.permit;
                _context20.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.permit',
                  params: {
                    permit: permit
                  }
                });

              case 7:
                return _context20.abrupt("return", _context20.sent);

              case 8:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function permit(_x20) {
        return _permit.apply(this, arguments);
      }

      return permit;
    }() // #endregion
    // #region PRIVATE

  }, {
    key: "createInvites",
    value: function () {
      var _createInvites = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(userId, invitedUserIds, chatSecret) {
        var _this4 = this;

        var userPublicKey;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getPublicKey(userId);

              case 2:
                userPublicKey = _context22.sent;
                _context22.next = 5;
                return Promise.all([userId].concat(_toConsumableArray(invitedUserIds)).map( /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(userId) {
                    var inviteePublicKey, inviteCode;
                    return regeneratorRuntime.wrap(function _callee21$(_context21) {
                      while (1) {
                        switch (_context21.prev = _context21.next) {
                          case 0:
                            _context21.next = 2;
                            return _this4.getPublicKey(userId);

                          case 2:
                            inviteePublicKey = _context21.sent;
                            _context21.next = 5;
                            return _this4.createInviteCode(userPublicKey, inviteePublicKey, chatSecret);

                          case 5:
                            inviteCode = _context21.sent;
                            return _context21.abrupt("return", {
                              user_id: userId,
                              invite_code: base$1.base64.encode(inviteCode)
                            });

                          case 7:
                          case "end":
                            return _context21.stop();
                        }
                      }
                    }, _callee21);
                  }));

                  return function (_x24) {
                    return _ref3.apply(this, arguments);
                  };
                }()));

              case 5:
                return _context22.abrupt("return", _context22.sent);

              case 6:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function createInvites(_x21, _x22, _x23) {
        return _createInvites.apply(this, arguments);
      }

      return createInvites;
    }()
  }, {
    key: "createInviteCode",
    value: function () {
      var _createInviteCode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(userPublicKey, inviteePublicKey, chatSecret) {
        var sharedSecret, encryptedChatSecret, inviteCode;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.auth.getSharedSecret(inviteePublicKey);

              case 2:
                sharedSecret = _context23.sent;
                _context23.next = 5;
                return this.encrypt(sharedSecret, chatSecret);

              case 5:
                encryptedChatSecret = _context23.sent;
                inviteCode = new Uint8Array(65 + encryptedChatSecret.length);
                inviteCode.set(userPublicKey);
                inviteCode.set(encryptedChatSecret, 65);
                return _context23.abrupt("return", inviteCode);

              case 10:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function createInviteCode(_x25, _x26, _x27) {
        return _createInviteCode.apply(this, arguments);
      }

      return createInviteCode;
    }()
  }, {
    key: "readInviteCode",
    value: function () {
      var _readInviteCode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(inviteCode) {
        var friendPublicKey, chatSecretEncrypted, sharedSecret;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                friendPublicKey = inviteCode.slice(0, 65);
                chatSecretEncrypted = inviteCode.slice(65);
                _context24.next = 4;
                return this.auth.getSharedSecret(friendPublicKey);

              case 4:
                sharedSecret = _context24.sent;
                _context24.next = 7;
                return this.decrypt(sharedSecret, chatSecretEncrypted);

              case 7:
                return _context24.abrupt("return", _context24.sent);

              case 8:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function readInviteCode(_x28) {
        return _readInviteCode.apply(this, arguments);
      }

      return readInviteCode;
    }()
  }, {
    key: "encrypt",
    value: function () {
      var _encrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(secret, payload) {
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return aes__namespace.encrypt(secret.slice(secret.length - 32), payload);

              case 2:
                return _context25.abrupt("return", _context25.sent);

              case 3:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25);
      }));

      function encrypt(_x29, _x30) {
        return _encrypt.apply(this, arguments);
      }

      return encrypt;
    }()
  }, {
    key: "encryptString",
    value: function () {
      var _encryptString = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(secret, payload) {
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.encrypt(secret, new TextEncoder().encode(payload));

              case 2:
                return _context26.abrupt("return", _context26.sent);

              case 3:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function encryptString(_x31, _x32) {
        return _encryptString.apply(this, arguments);
      }

      return encryptString;
    }()
  }, {
    key: "decrypt",
    value: function () {
      var _decrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(secret, payload) {
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                _context27.next = 2;
                return aes__namespace.decrypt(secret.slice(secret.length - 32), payload);

              case 2:
                return _context27.abrupt("return", _context27.sent);

              case 3:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27);
      }));

      function decrypt(_x33, _x34) {
        return _decrypt.apply(this, arguments);
      }

      return decrypt;
    }()
  }, {
    key: "decryptString",
    value: function () {
      var _decryptString = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(secret, payload) {
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.t0 = new TextDecoder();
                _context28.next = 3;
                return this.decrypt(secret, payload);

              case 3:
                _context28.t1 = _context28.sent;
                return _context28.abrupt("return", _context28.t0.decode.call(_context28.t0, _context28.t1));

              case 5:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function decryptString(_x35, _x36) {
        return _decryptString.apply(this, arguments);
      }

      return decryptString;
    }()
  }, {
    key: "decryptLastChatMessage",
    value: function () {
      var _decryptLastChatMessage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(c) {
        var lastMessage, sharedSecret;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                lastMessage = '';
                _context29.prev = 1;
                _context29.next = 4;
                return this.getChatSecret(c.chat_id);

              case 4:
                sharedSecret = _context29.sent;

                if (!(c.last_message && c.last_message.length > 0)) {
                  _context29.next = 9;
                  break;
                }

                _context29.next = 8;
                return this.decryptString(sharedSecret, base$1.base64.decode(c.last_message));

              case 8:
                lastMessage = _context29.sent;

              case 9:
                _context29.next = 15;
                break;

              case 11:
                _context29.prev = 11;
                _context29.t0 = _context29["catch"](1);
                this.logger.error("[audius-sdk]: Error: Couldn't decrypt last chat message", c, _context29.t0);
                lastMessage = GENERIC_MESSAGE_ERROR;

              case 15:
                return _context29.abrupt("return", _objectSpread2(_objectSpread2({}, c), {}, {
                  last_message: lastMessage
                }));

              case 16:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this, [[1, 11]]);
      }));

      function decryptLastChatMessage(_x37) {
        return _decryptLastChatMessage.apply(this, arguments);
      }

      return decryptLastChatMessage;
    }()
  }, {
    key: "getRaw",
    value: function () {
      var _getRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(chatId, currentUserId) {
        var path, queryParameters, response;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                path = "/comms/chats/".concat(chatId);
                queryParameters = {
                  timestamp: new Date().getTime()
                };

                if (currentUserId) {
                  queryParameters['current_user_id'] = currentUserId;
                }

                _context30.next = 5;
                return this.signAndSendRequest({
                  method: 'GET',
                  headers: {},
                  path: path,
                  query: queryParameters
                });

              case 5:
                response = _context30.sent;
                _context30.next = 8;
                return response.json();

              case 8:
                return _context30.abrupt("return", _context30.sent);

              case 9:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getRaw(_x38, _x39) {
        return _getRaw.apply(this, arguments);
      }

      return getRaw;
    }()
  }, {
    key: "getChatSecret",
    value: function () {
      var _getChatSecret = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(chatId) {
        var existingChatSecret, response, chatSecret;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                existingChatSecret = this.chatSecrets[chatId];

                if (existingChatSecret) {
                  _context31.next = 10;
                  break;
                }

                _context31.next = 4;
                return this.getRaw(chatId);

              case 4:
                response = _context31.sent;
                _context31.next = 7;
                return this.readInviteCode(base$1.base64.decode(response.data.invite_code));

              case 7:
                chatSecret = _context31.sent;
                this.chatSecrets[chatId] = chatSecret;
                return _context31.abrupt("return", chatSecret);

              case 10:
                return _context31.abrupt("return", existingChatSecret);

              case 11:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getChatSecret(_x40) {
        return _getChatSecret.apply(this, arguments);
      }

      return getChatSecret;
    }()
  }, {
    key: "getPublicKey",
    value: function () {
      var _getPublicKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(userId) {
        var response, json;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.request({
                  path: "/comms/pubkey/".concat(userId),
                  method: 'GET',
                  headers: {}
                });

              case 2:
                response = _context32.sent;
                _context32.next = 5;
                return response.json();

              case 5:
                json = _context32.sent;
                return _context32.abrupt("return", base$1.base64.decode(json.data));

              case 7:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getPublicKey(_x41) {
        return _getPublicKey.apply(this, arguments);
      }

      return getPublicKey;
    }()
  }, {
    key: "getSignatureHeader",
    value: function () {
      var _getSignatureHeader = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(payload) {
        var _yield$this$auth$sign, _yield$this$auth$sign2, allSignatureBytes, recoveryByte, signatureBytes;

        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                _context33.next = 2;
                return this.auth.sign(payload);

              case 2:
                _yield$this$auth$sign = _context33.sent;
                _yield$this$auth$sign2 = _slicedToArray(_yield$this$auth$sign, 2);
                allSignatureBytes = _yield$this$auth$sign2[0];
                recoveryByte = _yield$this$auth$sign2[1];
                signatureBytes = new Uint8Array(65);
                signatureBytes.set(allSignatureBytes, 0);
                signatureBytes[64] = recoveryByte;
                return _context33.abrupt("return", {
                  'x-sig': base$1.base64.encode(signatureBytes)
                });

              case 10:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getSignatureHeader(_x42) {
        return _getSignatureHeader.apply(this, arguments);
      }

      return getSignatureHeader;
    }()
  }, {
    key: "signAndSendRequest",
    value: function () {
      var _signAndSendRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(request) {
        var payload;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                payload = request.method === 'GET' ? request.query ? "".concat(request.path, "?").concat(this.configuration.queryParamsStringify(request.query)) : request.path : request.body;
                _context34.t0 = this;
                _context34.t1 = _objectSpread2;
                _context34.t2 = _objectSpread2({}, request);
                _context34.t3 = {};
                _context34.t4 = _objectSpread2;
                _context34.t5 = _objectSpread2({}, request.headers);
                _context34.next = 9;
                return this.getSignatureHeader(payload);

              case 9:
                _context34.t6 = _context34.sent;
                _context34.t7 = (0, _context34.t4)(_context34.t5, _context34.t6);
                _context34.t8 = {
                  headers: _context34.t7
                };
                _context34.t9 = (0, _context34.t1)(_context34.t2, _context34.t3, _context34.t8);
                _context34.next = 15;
                return _context34.t0.request.call(_context34.t0, _context34.t9);

              case 15:
                return _context34.abrupt("return", _context34.sent);

              case 16:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function signAndSendRequest(_x43) {
        return _signAndSendRequest.apply(this, arguments);
      }

      return signAndSendRequest;
    }()
  }, {
    key: "sendRpc",
    value: function () {
      var _sendRpc = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(args) {
        var payload;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                payload = JSON.stringify(_objectSpread2(_objectSpread2({}, args), {}, {
                  timestamp: new Date().getTime()
                }));
                _context35.next = 3;
                return this.signAndSendRequest({
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  path: "/comms/mutate",
                  body: payload
                });

              case 3:
                return _context35.abrupt("return", args);

              case 4:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function sendRpc(_x44) {
        return _sendRpc.apply(this, arguments);
      }

      return sendRpc;
    }()
  }, {
    key: "createWebsocket",
    value: function () {
      var _createWebsocket = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(endpoint) {
        var _this5 = this;

        var timestamp, originalUrl, signatureHeader, host, url, ws;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                timestamp = new Date().getTime();
                originalUrl = "/comms/chats/ws?timestamp=".concat(timestamp);

                if (this.listenUserId) {
                  originalUrl = "".concat(originalUrl, "&current_user_id=").concat(this.listenUserId);
                }

                _context37.next = 5;
                return this.getSignatureHeader(originalUrl);

              case 5:
                signatureHeader = _context37.sent;
                host = endpoint.replace(/http(s?)/g, 'ws$1');
                url = "".concat(host).concat(originalUrl, "&signature=").concat(encodeURIComponent(signatureHeader['x-sig']));
                ws = new WebSocket__default["default"](url);
                ws.addEventListener('message', function (messageEvent) {
                  var handleAsync = /*#__PURE__*/function () {
                    var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36() {
                      var data, sharedSecret;
                      return regeneratorRuntime.wrap(function _callee36$(_context36) {
                        while (1) {
                          switch (_context36.prev = _context36.next) {
                            case 0:
                              data = JSON.parse(messageEvent.data);

                              if (!(data.rpc.method === 'chat.message')) {
                                _context36.next = 19;
                                break;
                              }

                              _context36.next = 4;
                              return _this5.getChatSecret(data.rpc.params.chat_id);

                            case 4:
                              sharedSecret = _context36.sent;
                              _context36.t0 = _this5.eventEmitter;
                              _context36.t1 = data.rpc.params.chat_id;
                              _context36.t2 = data.rpc.params.message_id;
                              _context36.next = 10;
                              return _this5.decryptString(sharedSecret, base$1.base64.decode(data.rpc.params.message))["catch"](function (e) {
                                _this5.logger.error("[audius-sdk]: Error: Couldn't decrypt websocket chat message", data, e);

                                return GENERIC_MESSAGE_ERROR;
                              });

                            case 10:
                              _context36.t3 = _context36.sent;
                              _context36.t4 = data.metadata.userId;
                              _context36.t5 = data.metadata.timestamp;
                              _context36.t6 = [];
                              _context36.t7 = {
                                message_id: _context36.t2,
                                message: _context36.t3,
                                sender_user_id: _context36.t4,
                                created_at: _context36.t5,
                                reactions: _context36.t6
                              };
                              _context36.t8 = {
                                chatId: _context36.t1,
                                message: _context36.t7
                              };

                              _context36.t0.emit.call(_context36.t0, 'message', _context36.t8);

                              _context36.next = 20;
                              break;

                            case 19:
                              if (data.rpc.method === 'chat.react') {
                                _this5.eventEmitter.emit('reaction', {
                                  chatId: data.rpc.params.chat_id,
                                  messageId: data.rpc.params.message_id,
                                  reaction: {
                                    reaction: data.rpc.params.reaction,
                                    user_id: data.metadata.userId,
                                    created_at: data.metadata.timestamp
                                  }
                                });
                              }

                            case 20:
                            case "end":
                              return _context36.stop();
                          }
                        }
                      }, _callee36);
                    }));

                    return function handleAsync() {
                      return _ref4.apply(this, arguments);
                    };
                  }();

                  handleAsync();
                });
                ws.addEventListener('open', function () {
                  _this5.eventEmitter.emit('open');
                });
                ws.addEventListener('close', function () {
                  _this5.eventEmitter.emit('close');
                });
                ws.addEventListener('error', function (e) {
                  _this5.eventEmitter.emit('error', e);
                });
                return _context37.abrupt("return", ws);

              case 14:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function createWebsocket(_x45) {
        return _createWebsocket.apply(this, arguments);
      }

      return createWebsocket;
    }()
  }]);

  return ChatsApi;
}(BaseAPI$1);

/* tslint:disable */

/* eslint-disable */

/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var BASE_PATH = "/v1/full".replace(/\/+$/, "");
var Configuration = /*#__PURE__*/function () {
  function Configuration() {
    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Configuration);

    _defineProperty$1(this, "configuration", void 0);

    this.configuration = configuration;
  }

  _createClass(Configuration, [{
    key: "config",
    set: function set(configuration) {
      this.configuration = configuration;
    }
  }, {
    key: "basePath",
    get: function get() {
      return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }
  }, {
    key: "fetchApi",
    get: function get() {
      return this.configuration.fetchApi;
    }
  }, {
    key: "middleware",
    get: function get() {
      return this.configuration.middleware || [];
    }
  }, {
    key: "queryParamsStringify",
    get: function get() {
      return this.configuration.queryParamsStringify || querystring;
    }
  }, {
    key: "username",
    get: function get() {
      return this.configuration.username;
    }
  }, {
    key: "password",
    get: function get() {
      return this.configuration.password;
    }
  }, {
    key: "apiKey",
    get: function get() {
      var apiKey = this.configuration.apiKey;

      if (apiKey) {
        return typeof apiKey === 'function' ? apiKey : function () {
          return apiKey;
        };
      }

      return undefined;
    }
  }, {
    key: "accessToken",
    get: function get() {
      var accessToken = this.configuration.accessToken;

      if (accessToken) {
        return typeof accessToken === 'function' ? accessToken : /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", accessToken);

                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
      }

      return undefined;
    }
  }, {
    key: "headers",
    get: function get() {
      return this.configuration.headers;
    }
  }, {
    key: "credentials",
    get: function get() {
      return this.configuration.credentials;
    }
  }]);

  return Configuration;
}();
var DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */

var BaseAPI = /*#__PURE__*/function () {
  function BaseAPI() {
    var _this = this;

    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultConfig;

    _classCallCheck(this, BaseAPI);

    _defineProperty$1(this, "configuration", void 0);

    _defineProperty$1(this, "middleware", void 0);

    _defineProperty$1(this, "fetchApi", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url, init) {
        var fetchParams, _iterator, _step, _middleware, response, _iterator2, _step2, middleware, _iterator3, _step3, _middleware2;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                fetchParams = {
                  url: url,
                  init: init
                };
                _iterator = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 2;

                _iterator.s();

              case 4:
                if ((_step = _iterator.n()).done) {
                  _context2.next = 15;
                  break;
                }

                _middleware = _step.value;

                if (!_middleware.pre) {
                  _context2.next = 13;
                  break;
                }

                _context2.next = 9;
                return _middleware.pre(_objectSpread2({
                  fetch: _this.fetchApi
                }, fetchParams));

              case 9:
                _context2.t0 = _context2.sent;

                if (_context2.t0) {
                  _context2.next = 12;
                  break;
                }

                _context2.t0 = fetchParams;

              case 12:
                fetchParams = _context2.t0;

              case 13:
                _context2.next = 4;
                break;

              case 15:
                _context2.next = 20;
                break;

              case 17:
                _context2.prev = 17;
                _context2.t1 = _context2["catch"](2);

                _iterator.e(_context2.t1);

              case 20:
                _context2.prev = 20;

                _iterator.f();

                return _context2.finish(20);

              case 23:
                response = undefined;
                _context2.prev = 24;
                _context2.next = 27;
                return (_this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);

              case 27:
                response = _context2.sent;
                _context2.next = 60;
                break;

              case 30:
                _context2.prev = 30;
                _context2.t2 = _context2["catch"](24);
                _iterator2 = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 33;

                _iterator2.s();

              case 35:
                if ((_step2 = _iterator2.n()).done) {
                  _context2.next = 46;
                  break;
                }

                middleware = _step2.value;

                if (!middleware.onError) {
                  _context2.next = 44;
                  break;
                }

                _context2.next = 40;
                return middleware.onError({
                  fetch: _this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  error: _context2.t2,
                  response: response ? response.clone() : undefined
                });

              case 40:
                _context2.t3 = _context2.sent;

                if (_context2.t3) {
                  _context2.next = 43;
                  break;
                }

                _context2.t3 = response;

              case 43:
                response = _context2.t3;

              case 44:
                _context2.next = 35;
                break;

              case 46:
                _context2.next = 51;
                break;

              case 48:
                _context2.prev = 48;
                _context2.t4 = _context2["catch"](33);

                _iterator2.e(_context2.t4);

              case 51:
                _context2.prev = 51;

                _iterator2.f();

                return _context2.finish(51);

              case 54:
                if (!(response === undefined)) {
                  _context2.next = 60;
                  break;
                }

                if (!(_context2.t2 instanceof Error)) {
                  _context2.next = 59;
                  break;
                }

                throw new FetchError(_context2.t2, 'The request failed and the interceptors did not return an alternative response');

              case 59:
                throw _context2.t2;

              case 60:
                _iterator3 = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 61;

                _iterator3.s();

              case 63:
                if ((_step3 = _iterator3.n()).done) {
                  _context2.next = 74;
                  break;
                }

                _middleware2 = _step3.value;

                if (!_middleware2.post) {
                  _context2.next = 72;
                  break;
                }

                _context2.next = 68;
                return _middleware2.post({
                  fetch: _this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  response: response.clone()
                });

              case 68:
                _context2.t5 = _context2.sent;

                if (_context2.t5) {
                  _context2.next = 71;
                  break;
                }

                _context2.t5 = response;

              case 71:
                response = _context2.t5;

              case 72:
                _context2.next = 63;
                break;

              case 74:
                _context2.next = 79;
                break;

              case 76:
                _context2.prev = 76;
                _context2.t6 = _context2["catch"](61);

                _iterator3.e(_context2.t6);

              case 79:
                _context2.prev = 79;

                _iterator3.f();

                return _context2.finish(79);

              case 82:
                return _context2.abrupt("return", response);

              case 83:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[2, 17, 20, 23], [24, 30], [33, 48, 51, 54], [61, 76, 79, 82]]);
      }));

      return function (_x, _x2) {
        return _ref2.apply(this, arguments);
      };
    }());

    this.configuration = configuration;
    this.middleware = configuration.middleware;
  }
  /** @hidden */


  _createClass(BaseAPI, [{
    key: "withMiddleware",
    value: function withMiddleware() {
      var _next$middleware;

      var next = this.clone();
      next.middleware = (_next$middleware = next.middleware).concat.apply(_next$middleware, arguments);
      return next;
    }
    /** @hidden */

  }, {
    key: "withPreMiddleware",
    value: function withPreMiddleware() {
      for (var _len = arguments.length, preMiddlewares = new Array(_len), _key = 0; _key < _len; _key++) {
        preMiddlewares[_key] = arguments[_key];
      }

      var middlewares = preMiddlewares.map(function (pre) {
        return {
          pre: pre
        };
      });
      return this.withMiddleware.apply(this, _toConsumableArray(middlewares));
    }
    /** @hidden */

  }, {
    key: "withPostMiddleware",
    value: function withPostMiddleware() {
      for (var _len2 = arguments.length, postMiddlewares = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        postMiddlewares[_key2] = arguments[_key2];
      }

      var middlewares = postMiddlewares.map(function (post) {
        return {
          post: post
        };
      });
      return this.withMiddleware.apply(this, _toConsumableArray(middlewares));
    }
    /** @hidden */

  }, {
    key: "request",
    value: function () {
      var _request = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(context, initOverrides) {
        var _yield$this$createFet, url, init, response;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.createFetchParams(context, initOverrides);

              case 2:
                _yield$this$createFet = _context3.sent;
                url = _yield$this$createFet.url;
                init = _yield$this$createFet.init;
                _context3.next = 7;
                return this.fetchApi(url, init);

              case 7:
                response = _context3.sent;

                if (!(response && response.status >= 200 && response.status < 300)) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt("return", response);

              case 10:
                throw new ResponseError(response, 'Response returned an error code');

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function request(_x3, _x4) {
        return _request.apply(this, arguments);
      }

      return request;
    }()
  }, {
    key: "createFetchParams",
    value: function () {
      var _createFetchParams = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(context, initOverrides) {
        var url, headers, initOverrideFn, initParams, overriddenInit, init;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                url = this.configuration.basePath + context.path;

                if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                  // only add the querystring to the URL if there are query parameters.
                  // this is done to avoid urls ending with a "?" character which buggy webservers
                  // do not handle correctly sometimes.
                  url += '?' + this.configuration.queryParamsStringify(context.query);
                }

                headers = Object.assign({}, this.configuration.headers, context.headers);
                Object.keys(headers).forEach(function (key) {
                  return headers[key] === undefined ? delete headers[key] : {};
                });
                initOverrideFn = typeof initOverrides === "function" ? initOverrides : /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                  return regeneratorRuntime.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          return _context4.abrupt("return", initOverrides);

                        case 1:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                }));
                initParams = {
                  method: context.method,
                  headers: headers,
                  body: context.body,
                  credentials: this.configuration.credentials
                };
                _context5.t0 = _objectSpread2;
                _context5.t1 = _objectSpread2({}, initParams);
                _context5.next = 10;
                return initOverrideFn({
                  init: initParams,
                  context: context
                });

              case 10:
                _context5.t2 = _context5.sent;
                overriddenInit = (0, _context5.t0)(_context5.t1, _context5.t2);
                init = _objectSpread2(_objectSpread2({}, overriddenInit), {}, {
                  body: isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body) || isString(overriddenInit.body) ? overriddenInit.body : JSON.stringify(overriddenInit.body)
                });
                return _context5.abrupt("return", {
                  url: url,
                  init: init
                });

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function createFetchParams(_x5, _x6) {
        return _createFetchParams.apply(this, arguments);
      }

      return createFetchParams;
    }()
  }, {
    key: "clone",
    value:
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    function clone() {
      var constructor = this.constructor;
      var next = new constructor(this.configuration);
      next.middleware = this.middleware.slice();
      return next;
    }
  }]);

  return BaseAPI;
}();

function isBlob(value) {
  return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}

function isString(value) {
  return typeof value === 'string';
}

var ResponseError = /*#__PURE__*/function (_Error) {
  _inherits(ResponseError, _Error);

  var _super = _createSuper(ResponseError);

  function ResponseError(response, msg) {
    var _this2;

    _classCallCheck(this, ResponseError);

    _this2 = _super.call(this, msg);

    _defineProperty$1(_assertThisInitialized(_this2), "response", void 0);

    _defineProperty$1(_assertThisInitialized(_this2), "name", "ResponseError");

    _this2.response = response;
    return _this2;
  }

  return _createClass(ResponseError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var FetchError = /*#__PURE__*/function (_Error2) {
  _inherits(FetchError, _Error2);

  var _super2 = _createSuper(FetchError);

  function FetchError(cause, msg) {
    var _this3;

    _classCallCheck(this, FetchError);

    _this3 = _super2.call(this, msg);

    _defineProperty$1(_assertThisInitialized(_this3), "cause", void 0);

    _defineProperty$1(_assertThisInitialized(_this3), "name", "FetchError");

    _this3.cause = cause;
    return _this3;
  }

  return _createClass(FetchError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var RequiredError = /*#__PURE__*/function (_Error3) {
  _inherits(RequiredError, _Error3);

  var _super3 = _createSuper(RequiredError);

  function RequiredError(field, msg) {
    var _this4;

    _classCallCheck(this, RequiredError);

    _this4 = _super3.call(this, msg);

    _defineProperty$1(_assertThisInitialized(_this4), "field", void 0);

    _defineProperty$1(_assertThisInitialized(_this4), "name", "RequiredError");

    _this4.field = field;
    return _this4;
  }

  return _createClass(RequiredError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|"
};
function exists(json, key) {
  var value = json[key];
  return value !== null && value !== undefined;
}
function querystring(params) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return Object.keys(params).sort().map(function (key) {
    return querystringSingleKey(key, params[key], prefix);
  }).filter(function (part) {
    return part.length > 0;
  }).join('&');
}

function querystringSingleKey(key, value) {
  var keyPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);

  if (value instanceof Array) {
    var multiValue = value.map(function (singleValue) {
      return encodeURIComponent(String(singleValue));
    }).join("&".concat(encodeURIComponent(fullKey), "="));
    return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
  }

  if (value instanceof Set) {
    var valueAsArray = Array.from(value);
    return querystringSingleKey(key, valueAsArray, keyPrefix);
  }

  if (value instanceof Date) {
    return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
  }

  if (value instanceof Object) {
    return querystring(value, fullKey);
  }

  return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
}

function mapValues(data, fn) {
  return Object.keys(data).reduce(function (acc, key) {
    return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty$1({}, key, fn(data[key])));
  }, {});
}
function canConsumeForm(consumes) {
  var _iterator4 = _createForOfIteratorHelper(consumes),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var consume = _step4.value;

      if ('multipart/form-data' === consume.contentType) {
        return true;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return false;
}
var JSONApiResponse = /*#__PURE__*/function () {
  function JSONApiResponse(raw) {
    var transformer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (jsonValue) {
      return jsonValue;
    };

    _classCallCheck(this, JSONApiResponse);

    _defineProperty$1(this, "raw", void 0);

    _defineProperty$1(this, "transformer", void 0);

    this.raw = raw;
    this.transformer = transformer;
  }

  _createClass(JSONApiResponse, [{
    key: "value",
    value: function () {
      var _value = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.t0 = this;
                _context6.next = 3;
                return this.raw.json();

              case 3:
                _context6.t1 = _context6.sent;
                return _context6.abrupt("return", _context6.t0.transformer.call(_context6.t0, _context6.t1));

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function value() {
        return _value.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return JSONApiResponse;
}();
var VoidApiResponse = /*#__PURE__*/function () {
  function VoidApiResponse(raw) {
    _classCallCheck(this, VoidApiResponse);

    _defineProperty$1(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass(VoidApiResponse, [{
    key: "value",
    value: function () {
      var _value2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", undefined);

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function value() {
        return _value2.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return VoidApiResponse;
}();
var BlobApiResponse = /*#__PURE__*/function () {
  function BlobApiResponse(raw) {
    _classCallCheck(this, BlobApiResponse);

    _defineProperty$1(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass(BlobApiResponse, [{
    key: "value",
    value: function () {
      var _value3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.raw.blob();

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function value() {
        return _value3.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return BlobApiResponse;
}();
var TextApiResponse = /*#__PURE__*/function () {
  function TextApiResponse(raw) {
    _classCallCheck(this, TextApiResponse);

    _defineProperty$1(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass(TextApiResponse, [{
    key: "value",
    value: function () {
      var _value4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.raw.text();

              case 2:
                return _context9.abrupt("return", _context9.sent);

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function value() {
        return _value4.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return TextApiResponse;
}();

/* tslint:disable */
/**
 * Check if a given object implements the ActivityFull interface.
 */

function instanceOfActivityFull(value) {
  var isInstance = true;
  return isInstance;
}
function ActivityFullFromJSON(json) {
  return ActivityFullFromJSONTyped(json);
}
function ActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'timestamp': !exists(json, 'timestamp') ? undefined : json['timestamp'],
    'itemType': !exists(json, 'item_type') ? undefined : json['item_type'],
    'item': !exists(json, 'item') ? undefined : json['item']
  };
}
function ActivityFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': value.item
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Favorite interface.
 */

function instanceOfFavorite(value) {
  var isInstance = true;
  isInstance = isInstance && "favoriteItemId" in value;
  isInstance = isInstance && "favoriteType" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "createdAt" in value;
  return isInstance;
}
function FavoriteFromJSON(json) {
  return FavoriteFromJSONTyped(json);
}
function FavoriteFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'favoriteItemId': json['favorite_item_id'],
    'favoriteType': json['favorite_type'],
    'userId': json['user_id'],
    'createdAt': json['created_at']
  };
}
function FavoriteToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'favorite_item_id': value.favoriteItemId,
    'favorite_type': value.favoriteType,
    'user_id': value.userId,
    'created_at': value.createdAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistAddedTimestamp interface.
 */

function instanceOfPlaylistAddedTimestamp(value) {
  var isInstance = true;
  isInstance = isInstance && "metadataTimestamp" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "trackId" in value;
  return isInstance;
}
function PlaylistAddedTimestampFromJSON(json) {
  return PlaylistAddedTimestampFromJSONTyped(json);
}
function PlaylistAddedTimestampFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'metadataTimestamp': json['metadata_timestamp'],
    'timestamp': json['timestamp'],
    'trackId': json['track_id']
  };
}
function PlaylistAddedTimestampToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'metadata_timestamp': value.metadataTimestamp,
    'timestamp': value.timestamp,
    'track_id': value.trackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistArtwork interface.
 */

function instanceOfPlaylistArtwork(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistArtworkFromJSON(json) {
  return PlaylistArtworkFromJSONTyped(json);
}
function PlaylistArtworkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function PlaylistArtworkToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Repost interface.
 */

function instanceOfRepost(value) {
  var isInstance = true;
  isInstance = isInstance && "repostItemId" in value;
  isInstance = isInstance && "repostType" in value;
  isInstance = isInstance && "userId" in value;
  return isInstance;
}
function RepostFromJSON(json) {
  return RepostFromJSONTyped(json);
}
function RepostFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'repostItemId': json['repost_item_id'],
    'repostType': json['repost_type'],
    'userId': json['user_id']
  };
}
function RepostToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'repost_item_id': value.repostItemId,
    'repost_type': value.repostType,
    'user_id': value.userId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoverArt interface.
 */

function instanceOfCoverArt(value) {
  var isInstance = true;
  return isInstance;
}
function CoverArtFromJSON(json) {
  return CoverArtFromJSONTyped(json);
}
function CoverArtFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function CoverArtToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DownloadMetadata interface.
 */

function instanceOfDownloadMetadata(value) {
  var isInstance = true;
  isInstance = isInstance && "isDownloadable" in value;
  isInstance = isInstance && "requiresFollow" in value;
  return isInstance;
}
function DownloadMetadataFromJSON(json) {
  return DownloadMetadataFromJSONTyped(json);
}
function DownloadMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'cid': !exists(json, 'cid') ? undefined : json['cid'],
    'isDownloadable': json['is_downloadable'],
    'requiresFollow': json['requires_follow']
  };
}
function DownloadMetadataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'cid': value.cid,
    'is_downloadable': value.isDownloadable,
    'requires_follow': value.requiresFollow
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FieldVisibility interface.
 */

function instanceOfFieldVisibility(value) {
  var isInstance = true;
  return isInstance;
}
function FieldVisibilityFromJSON(json) {
  return FieldVisibilityFromJSONTyped(json);
}
function FieldVisibilityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'mood': !exists(json, 'mood') ? undefined : json['mood'],
    'tags': !exists(json, 'tags') ? undefined : json['tags'],
    'genre': !exists(json, 'genre') ? undefined : json['genre'],
    'share': !exists(json, 'share') ? undefined : json['share'],
    'playCount': !exists(json, 'play_count') ? undefined : json['play_count'],
    'remixes': !exists(json, 'remixes') ? undefined : json['remixes']
  };
}
function FieldVisibilityToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'mood': value.mood,
    'tags': value.tags,
    'genre': value.genre,
    'share': value.share,
    'play_count': value.playCount,
    'remixes': value.remixes
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoverPhoto interface.
 */

function instanceOfCoverPhoto(value) {
  var isInstance = true;
  return isInstance;
}
function CoverPhotoFromJSON(json) {
  return CoverPhotoFromJSONTyped(json);
}
function CoverPhotoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_640x': !exists(json, '640x') ? undefined : json['640x'],
    '_2000x': !exists(json, '2000x') ? undefined : json['2000x']
  };
}
function CoverPhotoToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '640x': value._640x,
    '2000x': value._2000x
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistLibrary interface.
 */

function instanceOfPlaylistLibrary(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistLibraryFromJSON(json) {
  return PlaylistLibraryFromJSONTyped(json);
}
function PlaylistLibraryFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'contents': !exists(json, 'contents') ? undefined : json['contents']
  };
}
function PlaylistLibraryToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'contents': value.contents
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ProfilePicture interface.
 */

function instanceOfProfilePicture(value) {
  var isInstance = true;
  return isInstance;
}
function ProfilePictureFromJSON(json) {
  return ProfilePictureFromJSONTyped(json);
}
function ProfilePictureFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function ProfilePictureToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserFull interface.
 */

function instanceOfUserFull(value) {
  var isInstance = true;
  isInstance = isInstance && "albumCount" in value;
  isInstance = isInstance && "followeeCount" in value;
  isInstance = isInstance && "followerCount" in value;
  isInstance = isInstance && "handle" in value;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isVerified" in value;
  isInstance = isInstance && "name" in value;
  isInstance = isInstance && "playlistCount" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "trackCount" in value;
  isInstance = isInstance && "isDeactivated" in value;
  isInstance = isInstance && "isAvailable" in value;
  isInstance = isInstance && "ercWallet" in value;
  isInstance = isInstance && "splWallet" in value;
  isInstance = isInstance && "supporterCount" in value;
  isInstance = isInstance && "supportingCount" in value;
  isInstance = isInstance && "totalAudioBalance" in value;
  isInstance = isInstance && "balance" in value;
  isInstance = isInstance && "associatedWalletsBalance" in value;
  isInstance = isInstance && "totalBalance" in value;
  isInstance = isInstance && "waudioBalance" in value;
  isInstance = isInstance && "associatedSolWalletsBalance" in value;
  isInstance = isInstance && "blocknumber" in value;
  isInstance = isInstance && "wallet" in value;
  isInstance = isInstance && "createdAt" in value;
  isInstance = isInstance && "isStorageV2" in value;
  isInstance = isInstance && "currentUserFolloweeFollowCount" in value;
  isInstance = isInstance && "doesCurrentUserFollow" in value;
  isInstance = isInstance && "handleLc" in value;
  isInstance = isInstance && "updatedAt" in value;
  isInstance = isInstance && "hasCollectibles" in value;
  isInstance = isInstance && "allowAiAttribution" in value;
  return isInstance;
}
function UserFullFromJSON(json) {
  return UserFullFromJSONTyped(json);
}
function UserFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'albumCount': json['album_count'],
    'artistPickTrackId': !exists(json, 'artist_pick_track_id') ? undefined : json['artist_pick_track_id'],
    'bio': !exists(json, 'bio') ? undefined : json['bio'],
    'coverPhoto': !exists(json, 'cover_photo') ? undefined : CoverPhotoFromJSON(json['cover_photo']),
    'followeeCount': json['followee_count'],
    'followerCount': json['follower_count'],
    'doesFollowCurrentUser': !exists(json, 'does_follow_current_user') ? undefined : json['does_follow_current_user'],
    'handle': json['handle'],
    'id': json['id'],
    'isVerified': json['is_verified'],
    'location': !exists(json, 'location') ? undefined : json['location'],
    'name': json['name'],
    'playlistCount': json['playlist_count'],
    'profilePicture': !exists(json, 'profile_picture') ? undefined : ProfilePictureFromJSON(json['profile_picture']),
    'repostCount': json['repost_count'],
    'trackCount': json['track_count'],
    'isDeactivated': json['is_deactivated'],
    'isAvailable': json['is_available'],
    'ercWallet': json['erc_wallet'],
    'splWallet': json['spl_wallet'],
    'supporterCount': json['supporter_count'],
    'supportingCount': json['supporting_count'],
    'totalAudioBalance': json['total_audio_balance'],
    'balance': json['balance'],
    'associatedWalletsBalance': json['associated_wallets_balance'],
    'totalBalance': json['total_balance'],
    'waudioBalance': json['waudio_balance'],
    'associatedSolWalletsBalance': json['associated_sol_wallets_balance'],
    'blocknumber': json['blocknumber'],
    'wallet': json['wallet'],
    'createdAt': json['created_at'],
    'isStorageV2': json['is_storage_v2'],
    'creatorNodeEndpoint': !exists(json, 'creator_node_endpoint') ? undefined : json['creator_node_endpoint'],
    'currentUserFolloweeFollowCount': json['current_user_followee_follow_count'],
    'doesCurrentUserFollow': json['does_current_user_follow'],
    'handleLc': json['handle_lc'],
    'updatedAt': json['updated_at'],
    'coverPhotoSizes': !exists(json, 'cover_photo_sizes') ? undefined : json['cover_photo_sizes'],
    'coverPhotoCids': !exists(json, 'cover_photo_cids') ? undefined : CoverPhotoFromJSON(json['cover_photo_cids']),
    'coverPhotoLegacy': !exists(json, 'cover_photo_legacy') ? undefined : json['cover_photo_legacy'],
    'profilePictureSizes': !exists(json, 'profile_picture_sizes') ? undefined : json['profile_picture_sizes'],
    'profilePictureCids': !exists(json, 'profile_picture_cids') ? undefined : ProfilePictureFromJSON(json['profile_picture_cids']),
    'profilePictureLegacy': !exists(json, 'profile_picture_legacy') ? undefined : json['profile_picture_legacy'],
    'metadataMultihash': !exists(json, 'metadata_multihash') ? undefined : json['metadata_multihash'],
    'hasCollectibles': json['has_collectibles'],
    'playlistLibrary': !exists(json, 'playlist_library') ? undefined : PlaylistLibraryFromJSON(json['playlist_library']),
    'allowAiAttribution': json['allow_ai_attribution']
  };
}
function UserFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'album_count': value.albumCount,
    'artist_pick_track_id': value.artistPickTrackId,
    'bio': value.bio,
    'cover_photo': CoverPhotoToJSON(value.coverPhoto),
    'followee_count': value.followeeCount,
    'follower_count': value.followerCount,
    'does_follow_current_user': value.doesFollowCurrentUser,
    'handle': value.handle,
    'id': value.id,
    'is_verified': value.isVerified,
    'location': value.location,
    'name': value.name,
    'playlist_count': value.playlistCount,
    'profile_picture': ProfilePictureToJSON(value.profilePicture),
    'repost_count': value.repostCount,
    'track_count': value.trackCount,
    'is_deactivated': value.isDeactivated,
    'is_available': value.isAvailable,
    'erc_wallet': value.ercWallet,
    'spl_wallet': value.splWallet,
    'supporter_count': value.supporterCount,
    'supporting_count': value.supportingCount,
    'total_audio_balance': value.totalAudioBalance,
    'balance': value.balance,
    'associated_wallets_balance': value.associatedWalletsBalance,
    'total_balance': value.totalBalance,
    'waudio_balance': value.waudioBalance,
    'associated_sol_wallets_balance': value.associatedSolWalletsBalance,
    'blocknumber': value.blocknumber,
    'wallet': value.wallet,
    'created_at': value.createdAt,
    'is_storage_v2': value.isStorageV2,
    'creator_node_endpoint': value.creatorNodeEndpoint,
    'current_user_followee_follow_count': value.currentUserFolloweeFollowCount,
    'does_current_user_follow': value.doesCurrentUserFollow,
    'handle_lc': value.handleLc,
    'updated_at': value.updatedAt,
    'cover_photo_sizes': value.coverPhotoSizes,
    'cover_photo_cids': CoverPhotoToJSON(value.coverPhotoCids),
    'cover_photo_legacy': value.coverPhotoLegacy,
    'profile_picture_sizes': value.profilePictureSizes,
    'profile_picture_cids': ProfilePictureToJSON(value.profilePictureCids),
    'profile_picture_legacy': value.profilePictureLegacy,
    'metadata_multihash': value.metadataMultihash,
    'has_collectibles': value.hasCollectibles,
    'playlist_library': PlaylistLibraryToJSON(value.playlistLibrary),
    'allow_ai_attribution': value.allowAiAttribution
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullRemix interface.
 */

function instanceOfFullRemix(value) {
  var isInstance = true;
  isInstance = isInstance && "parentTrackId" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "hasRemixAuthorReposted" in value;
  isInstance = isInstance && "hasRemixAuthorSaved" in value;
  return isInstance;
}
function FullRemixFromJSON(json) {
  return FullRemixFromJSONTyped(json);
}
function FullRemixFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'parentTrackId': json['parent_track_id'],
    'user': UserFullFromJSON(json['user']),
    'hasRemixAuthorReposted': json['has_remix_author_reposted'],
    'hasRemixAuthorSaved': json['has_remix_author_saved']
  };
}
function FullRemixToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'parent_track_id': value.parentTrackId,
    'user': UserFullToJSON(value.user),
    'has_remix_author_reposted': value.hasRemixAuthorReposted,
    'has_remix_author_saved': value.hasRemixAuthorSaved
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullRemixParent interface.
 */

function instanceOfFullRemixParent(value) {
  var isInstance = true;
  return isInstance;
}
function FullRemixParentFromJSON(json) {
  return FullRemixParentFromJSONTyped(json);
}
function FullRemixParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(FullRemixFromJSON)
  };
}
function FullRemixParentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(FullRemixToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PremiumContentSignature interface.
 */

function instanceOfPremiumContentSignature(value) {
  var isInstance = true;
  return isInstance;
}
function PremiumContentSignatureFromJSON(json) {
  return PremiumContentSignatureFromJSONTyped(json);
}
function PremiumContentSignatureFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists(json, 'data') ? undefined : json['data'],
    'signature': !exists(json, 'signature') ? undefined : json['signature']
  };
}
function PremiumContentSignatureToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data,
    'signature': value.signature
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the StemParent interface.
 */

function instanceOfStemParent(value) {
  var isInstance = true;
  isInstance = isInstance && "category" in value;
  isInstance = isInstance && "parentTrackId" in value;
  return isInstance;
}
function StemParentFromJSON(json) {
  return StemParentFromJSONTyped(json);
}
function StemParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'category': json['category'],
    'parentTrackId': json['parent_track_id']
  };
}
function StemParentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'category': value.category,
    'parent_track_id': value.parentTrackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackArtwork interface.
 */

function instanceOfTrackArtwork(value) {
  var isInstance = true;
  return isInstance;
}
function TrackArtworkFromJSON(json) {
  return TrackArtworkFromJSONTyped(json);
}
function TrackArtworkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function TrackArtworkToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackSegment interface.
 */

function instanceOfTrackSegment(value) {
  var isInstance = true;
  isInstance = isInstance && "duration" in value;
  isInstance = isInstance && "multihash" in value;
  return isInstance;
}
function TrackSegmentFromJSON(json) {
  return TrackSegmentFromJSONTyped(json);
}
function TrackSegmentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'duration': json['duration'],
    'multihash': json['multihash']
  };
}
function TrackSegmentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'duration': value.duration,
    'multihash': value.multihash
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackFull interface.
 */

function instanceOfTrackFull(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "title" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "duration" in value;
  isInstance = isInstance && "playCount" in value;
  isInstance = isInstance && "blocknumber" in value;
  isInstance = isInstance && "followeeReposts" in value;
  isInstance = isInstance && "hasCurrentUserReposted" in value;
  isInstance = isInstance && "isUnlisted" in value;
  isInstance = isInstance && "hasCurrentUserSaved" in value;
  isInstance = isInstance && "followeeFavorites" in value;
  isInstance = isInstance && "routeId" in value;
  isInstance = isInstance && "userId" in value;
  return isInstance;
}
function TrackFullFromJSON(json) {
  return TrackFullFromJSONTyped(json);
}
function TrackFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists(json, 'artwork') ? undefined : TrackArtworkFromJSON(json['artwork']),
    'description': !exists(json, 'description') ? undefined : json['description'],
    'genre': !exists(json, 'genre') ? undefined : json['genre'],
    'id': json['id'],
    'trackCid': !exists(json, 'track_cid') ? undefined : json['track_cid'],
    'previewCid': !exists(json, 'preview_cid') ? undefined : json['preview_cid'],
    'mood': !exists(json, 'mood') ? undefined : json['mood'],
    'releaseDate': !exists(json, 'release_date') ? undefined : json['release_date'],
    'remixOf': !exists(json, 'remix_of') ? undefined : FullRemixParentFromJSON(json['remix_of']),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'tags': !exists(json, 'tags') ? undefined : json['tags'],
    'title': json['title'],
    'user': UserFullFromJSON(json['user']),
    'duration': json['duration'],
    'downloadable': !exists(json, 'downloadable') ? undefined : json['downloadable'],
    'playCount': json['play_count'],
    'permalink': !exists(json, 'permalink') ? undefined : json['permalink'],
    'isStreamable': !exists(json, 'is_streamable') ? undefined : json['is_streamable'],
    'blocknumber': json['blocknumber'],
    'createDate': !exists(json, 'create_date') ? undefined : json['create_date'],
    'coverArtSizes': !exists(json, 'cover_art_sizes') ? undefined : json['cover_art_sizes'],
    'coverArtCids': !exists(json, 'cover_art_cids') ? undefined : CoverArtFromJSON(json['cover_art_cids']),
    'createdAt': !exists(json, 'created_at') ? undefined : json['created_at'],
    'creditsSplits': !exists(json, 'credits_splits') ? undefined : json['credits_splits'],
    'download': !exists(json, 'download') ? undefined : DownloadMetadataFromJSON(json['download']),
    'isrc': !exists(json, 'isrc') ? undefined : json['isrc'],
    'license': !exists(json, 'license') ? undefined : json['license'],
    'iswc': !exists(json, 'iswc') ? undefined : json['iswc'],
    'fieldVisibility': !exists(json, 'field_visibility') ? undefined : FieldVisibilityFromJSON(json['field_visibility']),
    'followeeReposts': json['followee_reposts'].map(RepostFromJSON),
    'hasCurrentUserReposted': json['has_current_user_reposted'],
    'isUnlisted': json['is_unlisted'],
    'hasCurrentUserSaved': json['has_current_user_saved'],
    'followeeFavorites': json['followee_favorites'].map(FavoriteFromJSON),
    'routeId': json['route_id'],
    'stemOf': !exists(json, 'stem_of') ? undefined : StemParentFromJSON(json['stem_of']),
    'trackSegments': !exists(json, 'track_segments') ? undefined : json['track_segments'].map(TrackSegmentFromJSON),
    'updatedAt': !exists(json, 'updated_at') ? undefined : json['updated_at'],
    'userId': json['user_id'],
    'isDelete': !exists(json, 'is_delete') ? undefined : json['is_delete'],
    'coverArt': !exists(json, 'cover_art') ? undefined : json['cover_art'],
    'isAvailable': !exists(json, 'is_available') ? undefined : json['is_available'],
    'isPremium': !exists(json, 'is_premium') ? undefined : json['is_premium'],
    'premiumConditions': !exists(json, 'premium_conditions') ? undefined : json['premium_conditions'],
    'premiumContentSignature': !exists(json, 'premium_content_signature') ? undefined : PremiumContentSignatureFromJSON(json['premium_content_signature']),
    'aiAttributionUserId': !exists(json, 'ai_attribution_user_id') ? undefined : json['ai_attribution_user_id'],
    'audioUploadId': !exists(json, 'audio_upload_id') ? undefined : json['audio_upload_id'],
    'previewStartSeconds': !exists(json, 'preview_start_seconds') ? undefined : json['preview_start_seconds']
  };
}
function TrackFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': TrackArtworkToJSON(value.artwork),
    'description': value.description,
    'genre': value.genre,
    'id': value.id,
    'track_cid': value.trackCid,
    'preview_cid': value.previewCid,
    'mood': value.mood,
    'release_date': value.releaseDate,
    'remix_of': FullRemixParentToJSON(value.remixOf),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'tags': value.tags,
    'title': value.title,
    'user': UserFullToJSON(value.user),
    'duration': value.duration,
    'downloadable': value.downloadable,
    'play_count': value.playCount,
    'permalink': value.permalink,
    'is_streamable': value.isStreamable,
    'blocknumber': value.blocknumber,
    'create_date': value.createDate,
    'cover_art_sizes': value.coverArtSizes,
    'cover_art_cids': CoverArtToJSON(value.coverArtCids),
    'created_at': value.createdAt,
    'credits_splits': value.creditsSplits,
    'download': DownloadMetadataToJSON(value.download),
    'isrc': value.isrc,
    'license': value.license,
    'iswc': value.iswc,
    'field_visibility': FieldVisibilityToJSON(value.fieldVisibility),
    'followee_reposts': value.followeeReposts.map(RepostToJSON),
    'has_current_user_reposted': value.hasCurrentUserReposted,
    'is_unlisted': value.isUnlisted,
    'has_current_user_saved': value.hasCurrentUserSaved,
    'followee_favorites': value.followeeFavorites.map(FavoriteToJSON),
    'route_id': value.routeId,
    'stem_of': StemParentToJSON(value.stemOf),
    'track_segments': value.trackSegments === undefined ? undefined : value.trackSegments.map(TrackSegmentToJSON),
    'updated_at': value.updatedAt,
    'user_id': value.userId,
    'is_delete': value.isDelete,
    'cover_art': value.coverArt,
    'is_available': value.isAvailable,
    'is_premium': value.isPremium,
    'premium_conditions': value.premiumConditions,
    'premium_content_signature': PremiumContentSignatureToJSON(value.premiumContentSignature),
    'ai_attribution_user_id': value.aiAttributionUserId,
    'audio_upload_id': value.audioUploadId,
    'preview_start_seconds': value.previewStartSeconds
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistFullWithoutTracks interface.
 */

function instanceOfPlaylistFullWithoutTracks(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isAlbum" in value;
  isInstance = isInstance && "isImageAutogenerated" in value;
  isInstance = isInstance && "playlistName" in value;
  isInstance = isInstance && "playlistContents" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "totalPlayCount" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "blocknumber" in value;
  isInstance = isInstance && "followeeReposts" in value;
  isInstance = isInstance && "followeeFavorites" in value;
  isInstance = isInstance && "hasCurrentUserReposted" in value;
  isInstance = isInstance && "hasCurrentUserSaved" in value;
  isInstance = isInstance && "isDelete" in value;
  isInstance = isInstance && "isPrivate" in value;
  isInstance = isInstance && "addedTimestamps" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "trackCount" in value;
  return isInstance;
}
function PlaylistFullWithoutTracksFromJSON(json) {
  return PlaylistFullWithoutTracksFromJSONTyped(json);
}
function PlaylistFullWithoutTracksFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists(json, 'artwork') ? undefined : PlaylistArtworkFromJSON(json['artwork']),
    'description': !exists(json, 'description') ? undefined : json['description'],
    'permalink': !exists(json, 'permalink') ? undefined : json['permalink'],
    'id': json['id'],
    'isAlbum': json['is_album'],
    'isImageAutogenerated': json['is_image_autogenerated'],
    'playlistName': json['playlist_name'],
    'playlistContents': json['playlist_contents'].map(PlaylistAddedTimestampFromJSON),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'totalPlayCount': json['total_play_count'],
    'user': UserFullFromJSON(json['user']),
    'blocknumber': json['blocknumber'],
    'createdAt': !exists(json, 'created_at') ? undefined : json['created_at'],
    'followeeReposts': json['followee_reposts'].map(RepostFromJSON),
    'followeeFavorites': json['followee_favorites'].map(FavoriteFromJSON),
    'hasCurrentUserReposted': json['has_current_user_reposted'],
    'hasCurrentUserSaved': json['has_current_user_saved'],
    'isDelete': json['is_delete'],
    'isPrivate': json['is_private'],
    'updatedAt': !exists(json, 'updated_at') ? undefined : json['updated_at'],
    'addedTimestamps': json['added_timestamps'].map(PlaylistAddedTimestampFromJSON),
    'userId': json['user_id'],
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(TrackFullFromJSON),
    'coverArt': !exists(json, 'cover_art') ? undefined : json['cover_art'],
    'coverArtSizes': !exists(json, 'cover_art_sizes') ? undefined : json['cover_art_sizes'],
    'coverArtCids': !exists(json, 'cover_art_cids') ? undefined : PlaylistArtworkFromJSON(json['cover_art_cids']),
    'trackCount': json['track_count']
  };
}
function PlaylistFullWithoutTracksToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': PlaylistArtworkToJSON(value.artwork),
    'description': value.description,
    'permalink': value.permalink,
    'id': value.id,
    'is_album': value.isAlbum,
    'is_image_autogenerated': value.isImageAutogenerated,
    'playlist_name': value.playlistName,
    'playlist_contents': value.playlistContents.map(PlaylistAddedTimestampToJSON),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'total_play_count': value.totalPlayCount,
    'user': UserFullToJSON(value.user),
    'blocknumber': value.blocknumber,
    'created_at': value.createdAt,
    'followee_reposts': value.followeeReposts.map(RepostToJSON),
    'followee_favorites': value.followeeFavorites.map(FavoriteToJSON),
    'has_current_user_reposted': value.hasCurrentUserReposted,
    'has_current_user_saved': value.hasCurrentUserSaved,
    'is_delete': value.isDelete,
    'is_private': value.isPrivate,
    'updated_at': value.updatedAt,
    'added_timestamps': value.addedTimestamps.map(PlaylistAddedTimestampToJSON),
    'user_id': value.userId,
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackFullToJSON),
    'cover_art': value.coverArt,
    'cover_art_sizes': value.coverArtSizes,
    'cover_art_cids': PlaylistArtworkToJSON(value.coverArtCids),
    'track_count': value.trackCount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CollectionActivityFull interface.
 */

function instanceOfCollectionActivityFull(value) {
  var isInstance = true;
  return isInstance;
}
function CollectionActivityFullFromJSON(json) {
  return CollectionActivityFullFromJSONTyped(json);
}
function CollectionActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'timestamp': !exists(json, 'timestamp') ? undefined : json['timestamp'],
    'itemType': !exists(json, 'item_type') ? undefined : json['item_type'],
    'item': !exists(json, 'item') ? undefined : PlaylistFullWithoutTracksFromJSON(json['item'])
  };
}
function CollectionActivityFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': PlaylistFullWithoutTracksToJSON(value.item)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the VersionMetadata interface.
 */

function instanceOfVersionMetadata(value) {
  var isInstance = true;
  isInstance = isInstance && "service" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function VersionMetadataFromJSON(json) {
  return VersionMetadataFromJSONTyped(json);
}
function VersionMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'service': json['service'],
    'version': json['version']
  };
}
function VersionMetadataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'service': value.service,
    'version': value.version
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CollectionLibraryResponseFull interface.
 */

function instanceOfCollectionLibraryResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function CollectionLibraryResponseFullFromJSON(json) {
  return CollectionLibraryResponseFullFromJSONTyped(json);
}
function CollectionLibraryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(CollectionActivityFullFromJSON)
  };
}
function CollectionLibraryResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(CollectionActivityFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowingResponse interface.
 */

function instanceOfFollowingResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FollowingResponseFromJSON(json) {
  return FollowingResponseFromJSONTyped(json);
}
function FollowingResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FollowingResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowingResponseFull interface.
 */

function instanceOfFollowingResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FollowingResponseFullFromJSON(json) {
  return FollowingResponseFullFromJSONTyped(json);
}
function FollowingResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FollowingResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserSubscribers interface.
 */

function instanceOfUserSubscribers(value) {
  var isInstance = true;
  isInstance = isInstance && "userId" in value;
  return isInstance;
}
function UserSubscribersFromJSON(json) {
  return UserSubscribersFromJSONTyped(json);
}
function UserSubscribersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': json['user_id'],
    'subscriberIds': !exists(json, 'subscriber_ids') ? undefined : json['subscriber_ids']
  };
}
function UserSubscribersToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'user_id': value.userId,
    'subscriber_ids': value.subscriberIds
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullBulkSubscribersResponse interface.
 */

function instanceOfFullBulkSubscribersResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullBulkSubscribersResponseFromJSON(json) {
  return FullBulkSubscribersResponseFromJSONTyped(json);
}
function FullBulkSubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserSubscribersFromJSON)
  };
}
function FullBulkSubscribersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserSubscribersToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullFollowersResponse interface.
 */

function instanceOfFullFollowersResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullFollowersResponseFromJSON(json) {
  return FullFollowersResponseFromJSONTyped(json);
}
function FullFollowersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullFollowersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullSupporter interface.
 */

function instanceOfFullSupporter(value) {
  var isInstance = true;
  isInstance = isInstance && "rank" in value;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "sender" in value;
  return isInstance;
}
function FullSupporterFromJSON(json) {
  return FullSupporterFromJSONTyped(json);
}
function FullSupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'sender': UserFullFromJSON(json['sender'])
  };
}
function FullSupporterToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'rank': value.rank,
    'amount': value.amount,
    'sender': UserFullToJSON(value.sender)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullGetSupporter interface.
 */

function instanceOfFullGetSupporter(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullGetSupporterFromJSON(json) {
  return FullGetSupporterFromJSONTyped(json);
}
function FullGetSupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : FullSupporterFromJSON(json['data'])
  };
}
function FullGetSupporterToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': FullSupporterToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullGetSupporters interface.
 */

function instanceOfFullGetSupporters(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullGetSupportersFromJSON(json) {
  return FullGetSupportersFromJSONTyped(json);
}
function FullGetSupportersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(FullSupporterFromJSON)
  };
}
function FullGetSupportersToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(FullSupporterToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullSupporting interface.
 */

function instanceOfFullSupporting(value) {
  var isInstance = true;
  isInstance = isInstance && "rank" in value;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "receiver" in value;
  return isInstance;
}
function FullSupportingFromJSON(json) {
  return FullSupportingFromJSONTyped(json);
}
function FullSupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'receiver': UserFullFromJSON(json['receiver'])
  };
}
function FullSupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'rank': value.rank,
    'amount': value.amount,
    'receiver': UserFullToJSON(value.receiver)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullGetSupporting interface.
 */

function instanceOfFullGetSupporting(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullGetSupportingFromJSON(json) {
  return FullGetSupportingFromJSONTyped(json);
}
function FullGetSupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : FullSupportingFromJSON(json['data'])
  };
}
function FullGetSupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': FullSupportingToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistFull interface.
 */

function instanceOfPlaylistFull(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isAlbum" in value;
  isInstance = isInstance && "isImageAutogenerated" in value;
  isInstance = isInstance && "playlistName" in value;
  isInstance = isInstance && "playlistContents" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "totalPlayCount" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "blocknumber" in value;
  isInstance = isInstance && "followeeReposts" in value;
  isInstance = isInstance && "followeeFavorites" in value;
  isInstance = isInstance && "hasCurrentUserReposted" in value;
  isInstance = isInstance && "hasCurrentUserSaved" in value;
  isInstance = isInstance && "isDelete" in value;
  isInstance = isInstance && "isPrivate" in value;
  isInstance = isInstance && "addedTimestamps" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "tracks" in value;
  isInstance = isInstance && "trackCount" in value;
  return isInstance;
}
function PlaylistFullFromJSON(json) {
  return PlaylistFullFromJSONTyped(json);
}
function PlaylistFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists(json, 'artwork') ? undefined : PlaylistArtworkFromJSON(json['artwork']),
    'description': !exists(json, 'description') ? undefined : json['description'],
    'permalink': !exists(json, 'permalink') ? undefined : json['permalink'],
    'id': json['id'],
    'isAlbum': json['is_album'],
    'isImageAutogenerated': json['is_image_autogenerated'],
    'playlistName': json['playlist_name'],
    'playlistContents': json['playlist_contents'].map(PlaylistAddedTimestampFromJSON),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'totalPlayCount': json['total_play_count'],
    'user': UserFullFromJSON(json['user']),
    'blocknumber': json['blocknumber'],
    'createdAt': !exists(json, 'created_at') ? undefined : json['created_at'],
    'followeeReposts': json['followee_reposts'].map(RepostFromJSON),
    'followeeFavorites': json['followee_favorites'].map(FavoriteFromJSON),
    'hasCurrentUserReposted': json['has_current_user_reposted'],
    'hasCurrentUserSaved': json['has_current_user_saved'],
    'isDelete': json['is_delete'],
    'isPrivate': json['is_private'],
    'updatedAt': !exists(json, 'updated_at') ? undefined : json['updated_at'],
    'addedTimestamps': json['added_timestamps'].map(PlaylistAddedTimestampFromJSON),
    'userId': json['user_id'],
    'tracks': json['tracks'].map(TrackFullFromJSON),
    'coverArt': !exists(json, 'cover_art') ? undefined : json['cover_art'],
    'coverArtSizes': !exists(json, 'cover_art_sizes') ? undefined : json['cover_art_sizes'],
    'coverArtCids': !exists(json, 'cover_art_cids') ? undefined : PlaylistArtworkFromJSON(json['cover_art_cids']),
    'trackCount': json['track_count']
  };
}
function PlaylistFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': PlaylistArtworkToJSON(value.artwork),
    'description': value.description,
    'permalink': value.permalink,
    'id': value.id,
    'is_album': value.isAlbum,
    'is_image_autogenerated': value.isImageAutogenerated,
    'playlist_name': value.playlistName,
    'playlist_contents': value.playlistContents.map(PlaylistAddedTimestampToJSON),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'total_play_count': value.totalPlayCount,
    'user': UserFullToJSON(value.user),
    'blocknumber': value.blocknumber,
    'created_at': value.createdAt,
    'followee_reposts': value.followeeReposts.map(RepostToJSON),
    'followee_favorites': value.followeeFavorites.map(FavoriteToJSON),
    'has_current_user_reposted': value.hasCurrentUserReposted,
    'has_current_user_saved': value.hasCurrentUserSaved,
    'is_delete': value.isDelete,
    'is_private': value.isPrivate,
    'updated_at': value.updatedAt,
    'added_timestamps': value.addedTimestamps.map(PlaylistAddedTimestampToJSON),
    'user_id': value.userId,
    'tracks': value.tracks.map(TrackFullToJSON),
    'cover_art': value.coverArt,
    'cover_art_sizes': value.coverArtSizes,
    'cover_art_cids': PlaylistArtworkToJSON(value.coverArtCids),
    'track_count': value.trackCount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullPlaylistResponse interface.
 */

function instanceOfFullPlaylistResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullPlaylistResponseFromJSON(json) {
  return FullPlaylistResponseFromJSONTyped(json);
}
function FullPlaylistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(PlaylistFullFromJSON)
  };
}
function FullPlaylistResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(PlaylistFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullPlaylistTracksResponse interface.
 */

function instanceOfFullPlaylistTracksResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullPlaylistTracksResponseFromJSON(json) {
  return FullPlaylistTracksResponseFromJSONTyped(json);
}
function FullPlaylistTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function FullPlaylistTracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullReposts interface.
 */

function instanceOfFullReposts(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullRepostsFromJSON(json) {
  return FullRepostsFromJSONTyped(json);
}
function FullRepostsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(ActivityFullFromJSON)
  };
}
function FullRepostsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(ActivityFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullSubscribersResponse interface.
 */

function instanceOfFullSubscribersResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullSubscribersResponseFromJSON(json) {
  return FullSubscribersResponseFromJSONTyped(json);
}
function FullSubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullSubscribersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SupporterReference interface.
 */

function instanceOfSupporterReference(value) {
  var isInstance = true;
  isInstance = isInstance && "userId" in value;
  return isInstance;
}
function SupporterReferenceFromJSON(json) {
  return SupporterReferenceFromJSONTyped(json);
}
function SupporterReferenceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': json['user_id']
  };
}
function SupporterReferenceToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'user_id': value.userId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTip interface.
 */

function instanceOfFullTip(value) {
  var isInstance = true;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "sender" in value;
  isInstance = isInstance && "receiver" in value;
  isInstance = isInstance && "createdAt" in value;
  isInstance = isInstance && "slot" in value;
  isInstance = isInstance && "followeeSupporters" in value;
  isInstance = isInstance && "txSignature" in value;
  return isInstance;
}
function FullTipFromJSON(json) {
  return FullTipFromJSONTyped(json);
}
function FullTipFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'amount': json['amount'],
    'sender': UserFullFromJSON(json['sender']),
    'receiver': UserFullFromJSON(json['receiver']),
    'createdAt': json['created_at'],
    'slot': json['slot'],
    'followeeSupporters': json['followee_supporters'].map(SupporterReferenceFromJSON),
    'txSignature': json['tx_signature']
  };
}
function FullTipToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'amount': value.amount,
    'sender': UserFullToJSON(value.sender),
    'receiver': UserFullToJSON(value.receiver),
    'created_at': value.createdAt,
    'slot': value.slot,
    'followee_supporters': value.followeeSupporters.map(SupporterReferenceToJSON),
    'tx_signature': value.txSignature
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTrackResponse interface.
 */

function instanceOfFullTrackResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullTrackResponseFromJSON(json) {
  return FullTrackResponseFromJSONTyped(json);
}
function FullTrackResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : TrackFullFromJSON(json['data'])
  };
}
function FullTrackResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': TrackFullToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTracks interface.
 */

function instanceOfFullTracks(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullTracksFromJSON(json) {
  return FullTracksFromJSONTyped(json);
}
function FullTracksFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function FullTracksToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTracksResponse interface.
 */

function instanceOfFullTracksResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullTracksResponseFromJSON(json) {
  return FullTracksResponseFromJSONTyped(json);
}
function FullTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function FullTracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTrendingPlaylistsResponse interface.
 */

function instanceOfFullTrendingPlaylistsResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullTrendingPlaylistsResponseFromJSON(json) {
  return FullTrendingPlaylistsResponseFromJSONTyped(json);
}
function FullTrendingPlaylistsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(PlaylistFullFromJSON)
  };
}
function FullTrendingPlaylistsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(PlaylistFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullUserResponse interface.
 */

function instanceOfFullUserResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullUserResponseFromJSON(json) {
  return FullUserResponseFromJSONTyped(json);
}
function FullUserResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullUserResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetTipsResponse interface.
 */

function instanceOfGetTipsResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function GetTipsResponseFromJSON(json) {
  return GetTipsResponseFromJSONTyped(json);
}
function GetTipsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(FullTipFromJSON)
  };
}
function GetTipsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(FullTipToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the HistoryResponseFull interface.
 */

function instanceOfHistoryResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function HistoryResponseFullFromJSON(json) {
  return HistoryResponseFullFromJSONTyped(json);
}
function HistoryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(ActivityFullFromJSON)
  };
}
function HistoryResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(ActivityFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RelatedArtistResponseFull interface.
 */

function instanceOfRelatedArtistResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function RelatedArtistResponseFullFromJSON(json) {
  return RelatedArtistResponseFullFromJSONTyped(json);
}
function RelatedArtistResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function RelatedArtistResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixesResponse interface.
 */

function instanceOfRemixesResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "count" in value;
  return isInstance;
}
function RemixesResponseFromJSON(json) {
  return RemixesResponseFromJSONTyped(json);
}
function RemixesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'count': json['count'],
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(TrackFullFromJSON)
  };
}
function RemixesResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'count': value.count,
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixesResponseFull interface.
 */

function instanceOfRemixesResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function RemixesResponseFullFromJSON(json) {
  return RemixesResponseFullFromJSONTyped(json);
}
function RemixesResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : RemixesResponseFromJSON(json['data'])
  };
}
function RemixesResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': RemixesResponseToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixingResponse interface.
 */

function instanceOfRemixingResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function RemixingResponseFromJSON(json) {
  return RemixingResponseFromJSONTyped(json);
}
function RemixingResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function RemixingResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SearchModel interface.
 */

function instanceOfSearchModel(value) {
  var isInstance = true;
  isInstance = isInstance && "users" in value;
  isInstance = isInstance && "tracks" in value;
  isInstance = isInstance && "playlists" in value;
  isInstance = isInstance && "albums" in value;
  return isInstance;
}
function SearchModelFromJSON(json) {
  return SearchModelFromJSONTyped(json);
}
function SearchModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'users': json['users'].map(UserFullFromJSON),
    'followedUsers': !exists(json, 'followed_users') ? undefined : json['followed_users'].map(UserFullFromJSON),
    'tracks': json['tracks'].map(TrackFullFromJSON),
    'savedTracks': !exists(json, 'saved_tracks') ? undefined : json['saved_tracks'].map(TrackFullFromJSON),
    'playlists': json['playlists'].map(PlaylistFullFromJSON),
    'savedPlaylists': !exists(json, 'saved_playlists') ? undefined : json['saved_playlists'].map(PlaylistFullFromJSON),
    'albums': json['albums'].map(PlaylistFullFromJSON),
    'savedAlbums': !exists(json, 'saved_albums') ? undefined : json['saved_albums'].map(PlaylistFullFromJSON)
  };
}
function SearchModelToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'users': value.users.map(UserFullToJSON),
    'followed_users': value.followedUsers === undefined ? undefined : value.followedUsers.map(UserFullToJSON),
    'tracks': value.tracks.map(TrackFullToJSON),
    'saved_tracks': value.savedTracks === undefined ? undefined : value.savedTracks.map(TrackFullToJSON),
    'playlists': value.playlists.map(PlaylistFullToJSON),
    'saved_playlists': value.savedPlaylists === undefined ? undefined : value.savedPlaylists.map(PlaylistFullToJSON),
    'albums': value.albums.map(PlaylistFullToJSON),
    'saved_albums': value.savedAlbums === undefined ? undefined : value.savedAlbums.map(PlaylistFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SearchAutocompleteResponse interface.
 */

function instanceOfSearchAutocompleteResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function SearchAutocompleteResponseFromJSON(json) {
  return SearchAutocompleteResponseFromJSONTyped(json);
}
function SearchAutocompleteResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : SearchModelFromJSON(json['data'])
  };
}
function SearchAutocompleteResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': SearchModelToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SearchFullResponse interface.
 */

function instanceOfSearchFullResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function SearchFullResponseFromJSON(json) {
  return SearchFullResponseFromJSONTyped(json);
}
function SearchFullResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : SearchModelFromJSON(json['data'])
  };
}
function SearchFullResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': SearchModelToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the StemFull interface.
 */

function instanceOfStemFull(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "parentId" in value;
  isInstance = isInstance && "category" in value;
  isInstance = isInstance && "cid" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "blocknumber" in value;
  return isInstance;
}
function StemFullFromJSON(json) {
  return StemFullFromJSONTyped(json);
}
function StemFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'id': json['id'],
    'parentId': json['parent_id'],
    'category': json['category'],
    'cid': json['cid'],
    'userId': json['user_id'],
    'blocknumber': json['blocknumber']
  };
}
function StemFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'id': value.id,
    'parent_id': value.parentId,
    'category': value.category,
    'cid': value.cid,
    'user_id': value.userId,
    'blocknumber': value.blocknumber
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the StemsResponse interface.
 */

function instanceOfStemsResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function StemsResponseFromJSON(json) {
  return StemsResponseFromJSONTyped(json);
}
function StemsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(StemFullFromJSON)
  };
}
function StemsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(StemFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TopGenreUsersResponseFull interface.
 */

function instanceOfTopGenreUsersResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TopGenreUsersResponseFullFromJSON(json) {
  return TopGenreUsersResponseFullFromJSONTyped(json);
}
function TopGenreUsersResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TopGenreUsersResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TopUsersResponseFull interface.
 */

function instanceOfTopUsersResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TopUsersResponseFullFromJSON(json) {
  return TopUsersResponseFullFromJSONTyped(json);
}
function TopUsersResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TopUsersResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackActivityFull interface.
 */

function instanceOfTrackActivityFull(value) {
  var isInstance = true;
  return isInstance;
}
function TrackActivityFullFromJSON(json) {
  return TrackActivityFullFromJSONTyped(json);
}
function TrackActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'timestamp': !exists(json, 'timestamp') ? undefined : json['timestamp'],
    'itemType': !exists(json, 'item_type') ? undefined : json['item_type'],
    'item': !exists(json, 'item') ? undefined : TrackFullFromJSON(json['item'])
  };
}
function TrackActivityFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': TrackFullToJSON(value.item)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackFavoritesResponseFull interface.
 */

function instanceOfTrackFavoritesResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TrackFavoritesResponseFullFromJSON(json) {
  return TrackFavoritesResponseFullFromJSONTyped(json);
}
function TrackFavoritesResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TrackFavoritesResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackId interface.
 */

function instanceOfTrackId(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  return isInstance;
}
function TrackIdFromJSON(json) {
  return TrackIdFromJSONTyped(json);
}
function TrackIdFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'id': json['id']
  };
}
function TrackIdToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'id': value.id
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackLibraryResponseFull interface.
 */

function instanceOfTrackLibraryResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TrackLibraryResponseFullFromJSON(json) {
  return TrackLibraryResponseFullFromJSONTyped(json);
}
function TrackLibraryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackActivityFullFromJSON)
  };
}
function TrackLibraryResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackActivityFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackRepostsResponseFull interface.
 */

function instanceOfTrackRepostsResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TrackRepostsResponseFullFromJSON(json) {
  return TrackRepostsResponseFullFromJSONTyped(json);
}
function TrackRepostsResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TrackRepostsResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TransactionDetails interface.
 */

function instanceOfTransactionDetails(value) {
  var isInstance = true;
  isInstance = isInstance && "transactionDate" in value;
  isInstance = isInstance && "transactionType" in value;
  isInstance = isInstance && "method" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "userBank" in value;
  isInstance = isInstance && "change" in value;
  isInstance = isInstance && "balance" in value;
  isInstance = isInstance && "metadata" in value;
  return isInstance;
}
function TransactionDetailsFromJSON(json) {
  return TransactionDetailsFromJSONTyped(json);
}
function TransactionDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'transactionDate': json['transaction_date'],
    'transactionType': json['transaction_type'],
    'method': json['method'],
    'signature': json['signature'],
    'userBank': json['user_bank'],
    'change': json['change'],
    'balance': json['balance'],
    'metadata': json['metadata']
  };
}
function TransactionDetailsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'transaction_date': value.transactionDate,
    'transaction_type': value.transactionType,
    'method': value.method,
    'signature': value.signature,
    'user_bank': value.userBank,
    'change': value.change,
    'balance': value.balance,
    'metadata': value.metadata
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TransactionHistoryCountResponse interface.
 */

function instanceOfTransactionHistoryCountResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TransactionHistoryCountResponseFromJSON(json) {
  return TransactionHistoryCountResponseFromJSONTyped(json);
}
function TransactionHistoryCountResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data']
  };
}
function TransactionHistoryCountResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TransactionHistoryResponse interface.
 */

function instanceOfTransactionHistoryResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TransactionHistoryResponseFromJSON(json) {
  return TransactionHistoryResponseFromJSONTyped(json);
}
function TransactionHistoryResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TransactionDetailsFromJSON)
  };
}
function TransactionHistoryResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TransactionDetailsToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingTimesIds interface.
 */

function instanceOfTrendingTimesIds(value) {
  var isInstance = true;
  return isInstance;
}
function TrendingTimesIdsFromJSON(json) {
  return TrendingTimesIdsFromJSONTyped(json);
}
function TrendingTimesIdsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'week': !exists(json, 'week') ? undefined : json['week'].map(TrackIdFromJSON),
    'month': !exists(json, 'month') ? undefined : json['month'].map(TrackIdFromJSON),
    'year': !exists(json, 'year') ? undefined : json['year'].map(TrackIdFromJSON)
  };
}
function TrendingTimesIdsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'week': value.week === undefined ? undefined : value.week.map(TrackIdToJSON),
    'month': value.month === undefined ? undefined : value.month.map(TrackIdToJSON),
    'year': value.year === undefined ? undefined : value.year.map(TrackIdToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingIdsResponse interface.
 */

function instanceOfTrendingIdsResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TrendingIdsResponseFromJSON(json) {
  return TrendingIdsResponseFromJSONTyped(json);
}
function TrendingIdsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists(json, 'data') ? undefined : TrendingTimesIdsFromJSON(json['data'])
  };
}
function TrendingIdsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': TrendingTimesIdsToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserReplicaSet interface.
 */

function instanceOfUserReplicaSet(value) {
  var isInstance = true;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "wallet" in value;
  return isInstance;
}
function UserReplicaSetFromJSON(json) {
  return UserReplicaSetFromJSONTyped(json);
}
function UserReplicaSetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': json['user_id'],
    'wallet': json['wallet'],
    'primary': !exists(json, 'primary') ? undefined : json['primary'],
    'secondary1': !exists(json, 'secondary1') ? undefined : json['secondary1'],
    'secondary2': !exists(json, 'secondary2') ? undefined : json['secondary2'],
    'primarySpID': !exists(json, 'primarySpID') ? undefined : json['primarySpID'],
    'secondary1SpID': !exists(json, 'secondary1SpID') ? undefined : json['secondary1SpID'],
    'secondary2SpID': !exists(json, 'secondary2SpID') ? undefined : json['secondary2SpID']
  };
}
function UserReplicaSetToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'user_id': value.userId,
    'wallet': value.wallet,
    'primary': value.primary,
    'secondary1': value.secondary1,
    'secondary2': value.secondary2,
    'primarySpID': value.primarySpID,
    'secondary1SpID': value.secondary1SpID,
    'secondary2SpID': value.secondary2SpID
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UsersByContentNode interface.
 */

function instanceOfUsersByContentNode(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function UsersByContentNodeFromJSON(json) {
  return UsersByContentNodeFromJSONTyped(json);
}
function UsersByContentNodeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : UserReplicaSetFromJSON(json['data'])
  };
}
function UsersByContentNodeToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': UserReplicaSetToJSON(value.data)
  };
}

/**
 *
 */

var PlaylistsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(PlaylistsApi, _runtime$BaseAPI);

  var _super = _createSuper(PlaylistsApi);

  function PlaylistsApi() {
    _classCallCheck(this, PlaylistsApi);

    return _super.apply(this, arguments);
  }

  _createClass(PlaylistsApi, [{
    key: "getPlaylistRaw",
    value:
    /** @hidden
     * Get a playlist by ID
     */
    function () {
      var _getPlaylistRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylist.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context.next = 7;
                return this.request({
                  path: "/playlists/{playlist_id}".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullPlaylistResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getPlaylistRaw(_x, _x2) {
        return _getPlaylistRaw.apply(this, arguments);
      }

      return getPlaylistRaw;
    }()
    /**
     * Get a playlist by ID
     */

  }, {
    key: "getPlaylist",
    value: function () {
      var _getPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getPlaylistRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getPlaylist(_x3, _x4) {
        return _getPlaylist.apply(this, arguments);
      }

      return getPlaylist;
    }()
    /** @hidden
     * Get a playlist by handle and slug
     */

  }, {
    key: "getPlaylistByHandleAndSlugRaw",
    value: function () {
      var _getPlaylistByHandleAndSlugRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getPlaylistByHandleAndSlug.');

              case 2:
                if (!(params.slug === null || params.slug === undefined)) {
                  _context3.next = 4;
                  break;
                }

                throw new RequiredError('slug', 'Required parameter params.slug was null or undefined when calling getPlaylistByHandleAndSlug.');

              case 4:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context3.next = 9;
                return this.request({
                  path: "/playlists/by_permalink/{handle}/{slug}".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))).replace("{".concat("slug", "}"), encodeURIComponent(String(params.slug))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullPlaylistResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getPlaylistByHandleAndSlugRaw(_x5, _x6) {
        return _getPlaylistByHandleAndSlugRaw.apply(this, arguments);
      }

      return getPlaylistByHandleAndSlugRaw;
    }()
    /**
     * Get a playlist by handle and slug
     */

  }, {
    key: "getPlaylistByHandleAndSlug",
    value: function () {
      var _getPlaylistByHandleAndSlug = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getPlaylistByHandleAndSlugRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getPlaylistByHandleAndSlug(_x7, _x8) {
        return _getPlaylistByHandleAndSlug.apply(this, arguments);
      }

      return getPlaylistByHandleAndSlug;
    }()
    /** @hidden
     * Fetch tracks within a playlist.
     */

  }, {
    key: "getPlaylistTracksRaw",
    value: function () {
      var _getPlaylistTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context5.next = 2;
                  break;
                }

                throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylistTracks.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context5.next = 6;
                return this.request({
                  path: "/playlists/{playlist_id}/tracks".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullPlaylistTracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getPlaylistTracksRaw(_x9, _x10) {
        return _getPlaylistTracksRaw.apply(this, arguments);
      }

      return getPlaylistTracksRaw;
    }()
    /**
     * Fetch tracks within a playlist.
     */

  }, {
    key: "getPlaylistTracks",
    value: function () {
      var _getPlaylistTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getPlaylistTracksRaw(params, initOverrides);

              case 2:
                response = _context6.sent;
                _context6.next = 5;
                return response.value();

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getPlaylistTracks(_x11, _x12) {
        return _getPlaylistTracks.apply(this, arguments);
      }

      return getPlaylistTracks;
    }()
    /** @hidden
     * Returns trending playlists for a time period
     */

  }, {
    key: "getTrendingPlaylistsRaw",
    value: function () {
      var _getTrendingPlaylistsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context7.next = 8;
                return this.request({
                  path: "/playlists/trending",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTrendingPlaylistsResponseFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getTrendingPlaylistsRaw(_x13, _x14) {
        return _getTrendingPlaylistsRaw.apply(this, arguments);
      }

      return getTrendingPlaylistsRaw;
    }()
    /**
     * Returns trending playlists for a time period
     */

  }, {
    key: "getTrendingPlaylists",
    value: function () {
      var _getTrendingPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var params,
            initOverrides,
            response,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                params = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};
                initOverrides = _args8.length > 1 ? _args8[1] : undefined;
                _context8.next = 4;
                return this.getTrendingPlaylistsRaw(params, initOverrides);

              case 4:
                response = _context8.sent;
                _context8.next = 7;
                return response.value();

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getTrendingPlaylists() {
        return _getTrendingPlaylists.apply(this, arguments);
      }

      return getTrendingPlaylists;
    }()
    /** @hidden
     * Returns trending playlists for a time period based on the given trending version
     */

  }, {
    key: "getTrendingPlaylistsWithVersionRaw",
    value: function () {
      var _getTrendingPlaylistsWithVersionRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getTrendingPlaylistsWithVersion.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context9.next = 10;
                return this.request({
                  path: "/playlists/trending/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 10:
                response = _context9.sent;
                return _context9.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTrendingPlaylistsResponseFromJSON(jsonValue);
                }));

              case 12:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getTrendingPlaylistsWithVersionRaw(_x15, _x16) {
        return _getTrendingPlaylistsWithVersionRaw.apply(this, arguments);
      }

      return getTrendingPlaylistsWithVersionRaw;
    }()
    /**
     * Returns trending playlists for a time period based on the given trending version
     */

  }, {
    key: "getTrendingPlaylistsWithVersion",
    value: function () {
      var _getTrendingPlaylistsWithVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getTrendingPlaylistsWithVersionRaw(params, initOverrides);

              case 2:
                response = _context10.sent;
                _context10.next = 5;
                return response.value();

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getTrendingPlaylistsWithVersion(_x17, _x18) {
        return _getTrendingPlaylistsWithVersion.apply(this, arguments);
      }

      return getTrendingPlaylistsWithVersion;
    }()
    /** @hidden
     * Get users that favorited a playlist
     */

  }, {
    key: "getUsersFromPlaylistFavoritesRaw",
    value: function () {
      var _getUsersFromPlaylistFavoritesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context11.next = 2;
                  break;
                }

                throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getUsersFromPlaylistFavorites.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context11.next = 9;
                return this.request({
                  path: "/playlists/{playlist_id}/favorites".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context11.sent;
                return _context11.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FollowingResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getUsersFromPlaylistFavoritesRaw(_x19, _x20) {
        return _getUsersFromPlaylistFavoritesRaw.apply(this, arguments);
      }

      return getUsersFromPlaylistFavoritesRaw;
    }()
    /**
     * Get users that favorited a playlist
     */

  }, {
    key: "getUsersFromPlaylistFavorites",
    value: function () {
      var _getUsersFromPlaylistFavorites = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getUsersFromPlaylistFavoritesRaw(params, initOverrides);

              case 2:
                response = _context12.sent;
                _context12.next = 5;
                return response.value();

              case 5:
                return _context12.abrupt("return", _context12.sent);

              case 6:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getUsersFromPlaylistFavorites(_x21, _x22) {
        return _getUsersFromPlaylistFavorites.apply(this, arguments);
      }

      return getUsersFromPlaylistFavorites;
    }()
    /** @hidden
     * Get users that reposted a playlist
     */

  }, {
    key: "getUsersFromPlaylistRepostsRaw",
    value: function () {
      var _getUsersFromPlaylistRepostsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context13.next = 2;
                  break;
                }

                throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getUsersFromPlaylistReposts.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context13.next = 9;
                return this.request({
                  path: "/playlists/{playlist_id}/reposts".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context13.sent;
                return _context13.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FollowingResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getUsersFromPlaylistRepostsRaw(_x23, _x24) {
        return _getUsersFromPlaylistRepostsRaw.apply(this, arguments);
      }

      return getUsersFromPlaylistRepostsRaw;
    }()
    /**
     * Get users that reposted a playlist
     */

  }, {
    key: "getUsersFromPlaylistReposts",
    value: function () {
      var _getUsersFromPlaylistReposts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getUsersFromPlaylistRepostsRaw(params, initOverrides);

              case 2:
                response = _context14.sent;
                _context14.next = 5;
                return response.value();

              case 5:
                return _context14.abrupt("return", _context14.sent);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getUsersFromPlaylistReposts(_x25, _x26) {
        return _getUsersFromPlaylistReposts.apply(this, arguments);
      }

      return getUsersFromPlaylistReposts;
    }()
  }]);

  return PlaylistsApi;
}(BaseAPI);
/**
 * @export
 */

var GetTrendingPlaylistsTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetTrendingPlaylistsWithVersionTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};

/**
 *
 */

var ReactionsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(ReactionsApi, _runtime$BaseAPI);

  var _super = _createSuper(ReactionsApi);

  function ReactionsApi() {
    _classCallCheck(this, ReactionsApi);

    return _super.apply(this, arguments);
  }

  _createClass(ReactionsApi, [{
    key: "bulkGetReactionsRaw",
    value:
    /** @hidden
     * Gets reactions by reacted_to_id and type
     */
    function () {
      var _bulkGetReactionsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.reactedToIds === null || params.reactedToIds === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('reactedToIds', 'Required parameter params.reactedToIds was null or undefined when calling bulkGetReactions.');

              case 2:
                queryParameters = {};

                if (params.type !== undefined) {
                  queryParameters['type'] = params.type;
                }

                if (params.reactedToIds) {
                  queryParameters['reacted_to_ids'] = params.reactedToIds.join(COLLECTION_FORMATS["csv"]);
                }

                headerParameters = {};
                _context.next = 8;
                return this.request({
                  path: "/reactions",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context.sent;
                return _context.abrupt("return", new VoidApiResponse(response));

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function bulkGetReactionsRaw(_x, _x2) {
        return _bulkGetReactionsRaw.apply(this, arguments);
      }

      return bulkGetReactionsRaw;
    }()
    /**
     * Gets reactions by reacted_to_id and type
     */

  }, {
    key: "bulkGetReactions",
    value: function () {
      var _bulkGetReactions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.bulkGetReactionsRaw(params, initOverrides);

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function bulkGetReactions(_x3, _x4) {
        return _bulkGetReactions.apply(this, arguments);
      }

      return bulkGetReactions;
    }()
  }]);

  return ReactionsApi;
}(BaseAPI);

/**
 *
 */

var SearchApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(SearchApi, _runtime$BaseAPI);

  var _super = _createSuper(SearchApi);

  function SearchApi() {
    _classCallCheck(this, SearchApi);

    return _super.apply(this, arguments);
  }

  _createClass(SearchApi, [{
    key: "searchRaw",
    value:
    /** @hidden
     * Get Users/Tracks/Playlists/Albums that best match the search query
     */
    function () {
      var _searchRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('query', 'Required parameter params.query was null or undefined when calling search.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.kind !== undefined) {
                  queryParameters['kind'] = params.kind;
                }

                headerParameters = {};
                _context.next = 11;
                return this.request({
                  path: "/search/full",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return SearchFullResponseFromJSON(jsonValue);
                }));

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function searchRaw(_x, _x2) {
        return _searchRaw.apply(this, arguments);
      }

      return searchRaw;
    }()
    /**
     * Get Users/Tracks/Playlists/Albums that best match the search query
     */

  }, {
    key: "search",
    value: function () {
      var _search = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.searchRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function search(_x3, _x4) {
        return _search.apply(this, arguments);
      }

      return search;
    }()
    /** @hidden
     * Same as search but optimized for quicker response at the cost of some entity information.
     * Get Users/Tracks/Playlists/Albums that best match the search query
     */

  }, {
    key: "searchAutocompleteRaw",
    value: function () {
      var _searchAutocompleteRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError('query', 'Required parameter params.query was null or undefined when calling searchAutocomplete.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.kind !== undefined) {
                  queryParameters['kind'] = params.kind;
                }

                headerParameters = {};
                _context3.next = 11;
                return this.request({
                  path: "/search/autocomplete",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return SearchAutocompleteResponseFromJSON(jsonValue);
                }));

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function searchAutocompleteRaw(_x5, _x6) {
        return _searchAutocompleteRaw.apply(this, arguments);
      }

      return searchAutocompleteRaw;
    }()
    /**
     * Same as search but optimized for quicker response at the cost of some entity information.
     * Get Users/Tracks/Playlists/Albums that best match the search query
     */

  }, {
    key: "searchAutocomplete",
    value: function () {
      var _searchAutocomplete = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.searchAutocompleteRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function searchAutocomplete(_x7, _x8) {
        return _searchAutocomplete.apply(this, arguments);
      }

      return searchAutocomplete;
    }()
  }]);

  return SearchApi;
}(BaseAPI);
/**
 * @export
 */

var SearchKindEnum = {
  All: 'all',
  Users: 'users',
  Tracks: 'tracks',
  Playlists: 'playlists',
  Albums: 'albums'
};
/**
 * @export
 */

var SearchAutocompleteKindEnum = {
  All: 'all',
  Users: 'users',
  Tracks: 'tracks',
  Playlists: 'playlists',
  Albums: 'albums'
};

/**
 *
 */

var TipsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TipsApi, _runtime$BaseAPI);

  var _super = _createSuper(TipsApi);

  function TipsApi() {
    _classCallCheck(this, TipsApi);

    return _super.apply(this, arguments);
  }

  _createClass(TipsApi, [{
    key: "getTipsRaw",
    value:
    /** @hidden
     * Gets the most recent tips on the network
     */
    function () {
      var _getTipsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.receiverMinFollowers !== undefined) {
                  queryParameters['receiver_min_followers'] = params.receiverMinFollowers;
                }

                if (params.receiverIsVerified !== undefined) {
                  queryParameters['receiver_is_verified'] = params.receiverIsVerified;
                }

                if (params.currentUserFollows !== undefined) {
                  queryParameters['current_user_follows'] = params.currentUserFollows;
                }

                if (params.uniqueBy !== undefined) {
                  queryParameters['unique_by'] = params.uniqueBy;
                }

                if (params.minSlot !== undefined) {
                  queryParameters['min_slot'] = params.minSlot;
                }

                if (params.maxSlot !== undefined) {
                  queryParameters['max_slot'] = params.maxSlot;
                }

                if (params.txSignatures) {
                  queryParameters['tx_signatures'] = params.txSignatures.join(COLLECTION_FORMATS["csv"]);
                }

                headerParameters = {};
                _context.next = 14;
                return this.request({
                  path: "/tips",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return GetTipsResponseFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getTipsRaw(_x, _x2) {
        return _getTipsRaw.apply(this, arguments);
      }

      return getTipsRaw;
    }()
    /**
     * Gets the most recent tips on the network
     */

  }, {
    key: "getTips",
    value: function () {
      var _getTips = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var params,
            initOverrides,
            response,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                params = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                initOverrides = _args2.length > 1 ? _args2[1] : undefined;
                _context2.next = 4;
                return this.getTipsRaw(params, initOverrides);

              case 4:
                response = _context2.sent;
                _context2.next = 7;
                return response.value();

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getTips() {
        return _getTips.apply(this, arguments);
      }

      return getTips;
    }()
  }]);

  return TipsApi;
}(BaseAPI);
/**
 * @export
 */

var GetTipsCurrentUserFollowsEnum = {
  Sender: 'sender',
  Receiver: 'receiver',
  SenderOrReceiver: 'sender_or_receiver'
};
/**
 * @export
 */

var GetTipsUniqueByEnum = {
  Sender: 'sender',
  Receiver: 'receiver'
};

/**
 *
 */

var TracksApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TracksApi, _runtime$BaseAPI);

  var _super = _createSuper(TracksApi);

  function TracksApi() {
    _classCallCheck(this, TracksApi);

    return _super.apply(this, arguments);
  }

  _createClass(TracksApi, [{
    key: "bestNewReleasesRaw",
    value:
    /** @hidden
     * Gets the tracks found on the \"Best New Releases\" smart playlist
     */
    function () {
      var _bestNewReleasesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                queryParameters = {};
                headerParameters = {};
                _context.next = 4;
                return this.request({
                  path: "/tracks/best_new_releases",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 4:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function bestNewReleasesRaw(_x) {
        return _bestNewReleasesRaw.apply(this, arguments);
      }

      return bestNewReleasesRaw;
    }()
    /**
     * Gets the tracks found on the \"Best New Releases\" smart playlist
     */

  }, {
    key: "bestNewReleases",
    value: function () {
      var _bestNewReleases = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.bestNewReleasesRaw(initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function bestNewReleases(_x2) {
        return _bestNewReleases.apply(this, arguments);
      }

      return bestNewReleases;
    }()
    /** @hidden
     * Gets a list of tracks using their IDs or permalinks
     */

  }, {
    key: "getBulkTracksRaw",
    value: function () {
      var _getBulkTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.permalink) {
                  queryParameters['permalink'] = params.permalink;
                }

                if (params.id) {
                  queryParameters['id'] = params.id;
                }

                headerParameters = {};
                _context3.next = 7;
                return this.request({
                  path: "/tracks",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getBulkTracksRaw(_x3, _x4) {
        return _getBulkTracksRaw.apply(this, arguments);
      }

      return getBulkTracksRaw;
    }()
    /**
     * Gets a list of tracks using their IDs or permalinks
     */

  }, {
    key: "getBulkTracks",
    value: function () {
      var _getBulkTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var params,
            initOverrides,
            response,
            _args4 = arguments;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                params = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
                initOverrides = _args4.length > 1 ? _args4[1] : undefined;
                _context4.next = 4;
                return this.getBulkTracksRaw(params, initOverrides);

              case 4:
                response = _context4.sent;
                _context4.next = 7;
                return response.value();

              case 7:
                return _context4.abrupt("return", _context4.sent);

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getBulkTracks() {
        return _getBulkTracks.apply(this, arguments);
      }

      return getBulkTracks;
    }()
    /** @hidden
     * Gets random tracks found on the \"Feeling Lucky\" smart playlist
     */

  }, {
    key: "getFeelingLuckyTracksRaw",
    value: function () {
      var _getFeelingLuckyTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.withUsers !== undefined) {
                  queryParameters['with_users'] = params.withUsers;
                }

                if (params.minFollowers !== undefined) {
                  queryParameters['min_followers'] = params.minFollowers;
                }

                headerParameters = {};
                _context5.next = 8;
                return this.request({
                  path: "/tracks/feeling_lucky",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getFeelingLuckyTracksRaw(_x5, _x6) {
        return _getFeelingLuckyTracksRaw.apply(this, arguments);
      }

      return getFeelingLuckyTracksRaw;
    }()
    /**
     * Gets random tracks found on the \"Feeling Lucky\" smart playlist
     */

  }, {
    key: "getFeelingLuckyTracks",
    value: function () {
      var _getFeelingLuckyTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var params,
            initOverrides,
            response,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                params = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
                initOverrides = _args6.length > 1 ? _args6[1] : undefined;
                _context6.next = 4;
                return this.getFeelingLuckyTracksRaw(params, initOverrides);

              case 4:
                response = _context6.sent;
                _context6.next = 7;
                return response.value();

              case 7:
                return _context6.abrupt("return", _context6.sent);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getFeelingLuckyTracks() {
        return _getFeelingLuckyTracks.apply(this, arguments);
      }

      return getFeelingLuckyTracks;
    }()
    /** @hidden
     * Gets the tracks found on the \"Most Loved\" smart playlist
     */

  }, {
    key: "getMostLovedTracksRaw",
    value: function () {
      var _getMostLovedTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.withUsers !== undefined) {
                  queryParameters['with_users'] = params.withUsers;
                }

                headerParameters = {};
                _context7.next = 7;
                return this.request({
                  path: "/tracks/most_loved",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getMostLovedTracksRaw(_x7, _x8) {
        return _getMostLovedTracksRaw.apply(this, arguments);
      }

      return getMostLovedTracksRaw;
    }()
    /**
     * Gets the tracks found on the \"Most Loved\" smart playlist
     */

  }, {
    key: "getMostLovedTracks",
    value: function () {
      var _getMostLovedTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var params,
            initOverrides,
            response,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                params = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};
                initOverrides = _args8.length > 1 ? _args8[1] : undefined;
                _context8.next = 4;
                return this.getMostLovedTracksRaw(params, initOverrides);

              case 4:
                response = _context8.sent;
                _context8.next = 7;
                return response.value();

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getMostLovedTracks() {
        return _getMostLovedTracks.apply(this, arguments);
      }

      return getMostLovedTracks;
    }()
    /** @hidden
     * Gets premium track signatures for passed in premium track ids
     */

  }, {
    key: "getPremiumTrackSignaturesRaw",
    value: function () {
      var _getPremiumTrackSignaturesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.userId === null || params.userId === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError('userId', 'Required parameter params.userId was null or undefined when calling getPremiumTrackSignatures.');

              case 2:
                queryParameters = {};

                if (params.trackIds) {
                  queryParameters['track_ids'] = params.trackIds;
                }

                if (params.tokenIds) {
                  queryParameters['token_ids'] = params.tokenIds;
                }

                headerParameters = {};
                _context9.next = 8;
                return this.request({
                  path: "/tracks/{user_id}/nft-gated-signatures".replace("{".concat("user_id", "}"), encodeURIComponent(String(params.userId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context9.sent;
                return _context9.abrupt("return", new VoidApiResponse(response));

              case 10:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getPremiumTrackSignaturesRaw(_x9, _x10) {
        return _getPremiumTrackSignaturesRaw.apply(this, arguments);
      }

      return getPremiumTrackSignaturesRaw;
    }()
    /**
     * Gets premium track signatures for passed in premium track ids
     */

  }, {
    key: "getPremiumTrackSignatures",
    value: function () {
      var _getPremiumTrackSignatures = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getPremiumTrackSignaturesRaw(params, initOverrides);

              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getPremiumTrackSignatures(_x11, _x12) {
        return _getPremiumTrackSignatures.apply(this, arguments);
      }

      return getPremiumTrackSignatures;
    }()
    /** @hidden
     * Get recommended tracks
     */

  }, {
    key: "getRecommendedTracksRaw",
    value: function () {
      var _getRecommendedTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                queryParameters = {};

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                if (params.exclusionList) {
                  queryParameters['exclusion_list'] = params.exclusionList;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context11.next = 9;
                return this.request({
                  path: "/tracks/recommended",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context11.sent;
                return _context11.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getRecommendedTracksRaw(_x13, _x14) {
        return _getRecommendedTracksRaw.apply(this, arguments);
      }

      return getRecommendedTracksRaw;
    }()
    /**
     * Get recommended tracks
     */

  }, {
    key: "getRecommendedTracks",
    value: function () {
      var _getRecommendedTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var params,
            initOverrides,
            response,
            _args12 = arguments;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                params = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : {};
                initOverrides = _args12.length > 1 ? _args12[1] : undefined;
                _context12.next = 4;
                return this.getRecommendedTracksRaw(params, initOverrides);

              case 4:
                response = _context12.sent;
                _context12.next = 7;
                return response.value();

              case 7:
                return _context12.abrupt("return", _context12.sent);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getRecommendedTracks() {
        return _getRecommendedTracks.apply(this, arguments);
      }

      return getRecommendedTracks;
    }()
    /** @hidden
     * Get recommended tracks using the given trending strategy version
     */

  }, {
    key: "getRecommendedTracksWithVersionRaw",
    value: function () {
      var _getRecommendedTracksWithVersionRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context13.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getRecommendedTracksWithVersion.');

              case 2:
                queryParameters = {};

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                if (params.exclusionList) {
                  queryParameters['exclusion_list'] = params.exclusionList;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context13.next = 11;
                return this.request({
                  path: "/tracks/recommended/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context13.sent;
                return _context13.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 13:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getRecommendedTracksWithVersionRaw(_x15, _x16) {
        return _getRecommendedTracksWithVersionRaw.apply(this, arguments);
      }

      return getRecommendedTracksWithVersionRaw;
    }()
    /**
     * Get recommended tracks using the given trending strategy version
     */

  }, {
    key: "getRecommendedTracksWithVersion",
    value: function () {
      var _getRecommendedTracksWithVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getRecommendedTracksWithVersionRaw(params, initOverrides);

              case 2:
                response = _context14.sent;
                _context14.next = 5;
                return response.value();

              case 5:
                return _context14.abrupt("return", _context14.sent);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getRecommendedTracksWithVersion(_x17, _x18) {
        return _getRecommendedTracksWithVersion.apply(this, arguments);
      }

      return getRecommendedTracksWithVersion;
    }()
    /** @hidden
     * Gets a list of tracks that have stems available for remixing
     */

  }, {
    key: "getRemixableTracksRaw",
    value: function () {
      var _getRemixableTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                queryParameters = {};

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.withUsers !== undefined) {
                  queryParameters['with_users'] = params.withUsers;
                }

                headerParameters = {};
                _context15.next = 7;
                return this.request({
                  path: "/tracks/remixables",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context15.sent;
                return _context15.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTrackResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getRemixableTracksRaw(_x19, _x20) {
        return _getRemixableTracksRaw.apply(this, arguments);
      }

      return getRemixableTracksRaw;
    }()
    /**
     * Gets a list of tracks that have stems available for remixing
     */

  }, {
    key: "getRemixableTracks",
    value: function () {
      var _getRemixableTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
        var params,
            initOverrides,
            response,
            _args16 = arguments;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                params = _args16.length > 0 && _args16[0] !== undefined ? _args16[0] : {};
                initOverrides = _args16.length > 1 ? _args16[1] : undefined;
                _context16.next = 4;
                return this.getRemixableTracksRaw(params, initOverrides);

              case 4:
                response = _context16.sent;
                _context16.next = 7;
                return response.value();

              case 7:
                return _context16.abrupt("return", _context16.sent);

              case 8:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getRemixableTracks() {
        return _getRemixableTracks.apply(this, arguments);
      }

      return getRemixableTracks;
    }()
    /** @hidden
     * Gets a track by ID. If `show_unlisted` is true, then `handle` and `url_title` are required.
     */

  }, {
    key: "getTrackRaw",
    value: function () {
      var _getTrackRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context17.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrack.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.handle !== undefined) {
                  queryParameters['handle'] = params.handle;
                }

                if (params.urlTitle !== undefined) {
                  queryParameters['url_title'] = params.urlTitle;
                }

                if (params.showUnlisted !== undefined) {
                  queryParameters['show_unlisted'] = params.showUnlisted;
                }

                headerParameters = {};
                _context17.next = 10;
                return this.request({
                  path: "/tracks/{track_id}".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 10:
                response = _context17.sent;
                return _context17.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTrackResponseFromJSON(jsonValue);
                }));

              case 12:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getTrackRaw(_x21, _x22) {
        return _getTrackRaw.apply(this, arguments);
      }

      return getTrackRaw;
    }()
    /**
     * Gets a track by ID. If `show_unlisted` is true, then `handle` and `url_title` are required.
     */

  }, {
    key: "getTrack",
    value: function () {
      var _getTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.getTrackRaw(params, initOverrides);

              case 2:
                response = _context18.sent;
                _context18.next = 5;
                return response.value();

              case 5:
                return _context18.abrupt("return", _context18.sent);

              case 6:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getTrack(_x23, _x24) {
        return _getTrack.apply(this, arguments);
      }

      return getTrack;
    }()
    /** @hidden
     * Gets all the tracks that the given track remixes
     */

  }, {
    key: "getTrackRemixParentsRaw",
    value: function () {
      var _getTrackRemixParentsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context19.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackRemixParents.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context19.next = 9;
                return this.request({
                  path: "/tracks/{track_id}/remixing".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context19.sent;
                return _context19.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return RemixingResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getTrackRemixParentsRaw(_x25, _x26) {
        return _getTrackRemixParentsRaw.apply(this, arguments);
      }

      return getTrackRemixParentsRaw;
    }()
    /**
     * Gets all the tracks that the given track remixes
     */

  }, {
    key: "getTrackRemixParents",
    value: function () {
      var _getTrackRemixParents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getTrackRemixParentsRaw(params, initOverrides);

              case 2:
                response = _context20.sent;
                _context20.next = 5;
                return response.value();

              case 5:
                return _context20.abrupt("return", _context20.sent);

              case 6:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getTrackRemixParents(_x27, _x28) {
        return _getTrackRemixParents.apply(this, arguments);
      }

      return getTrackRemixParents;
    }()
    /** @hidden
     * Get all tracks that remix the given track
     */

  }, {
    key: "getTrackRemixesRaw",
    value: function () {
      var _getTrackRemixesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context21.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackRemixes.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context21.next = 9;
                return this.request({
                  path: "/tracks/{track_id}/remixes".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context21.sent;
                return _context21.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return RemixesResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getTrackRemixesRaw(_x29, _x30) {
        return _getTrackRemixesRaw.apply(this, arguments);
      }

      return getTrackRemixesRaw;
    }()
    /**
     * Get all tracks that remix the given track
     */

  }, {
    key: "getTrackRemixes",
    value: function () {
      var _getTrackRemixes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getTrackRemixesRaw(params, initOverrides);

              case 2:
                response = _context22.sent;
                _context22.next = 5;
                return response.value();

              case 5:
                return _context22.abrupt("return", _context22.sent);

              case 6:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getTrackRemixes(_x31, _x32) {
        return _getTrackRemixes.apply(this, arguments);
      }

      return getTrackRemixes;
    }()
    /** @hidden
     * Get the remixable stems of a track
     */

  }, {
    key: "getTrackStemsRaw",
    value: function () {
      var _getTrackStemsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context23.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackStems.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context23.next = 6;
                return this.request({
                  path: "/tracks/{track_id}/stems".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context23.sent;
                return _context23.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return StemsResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getTrackStemsRaw(_x33, _x34) {
        return _getTrackStemsRaw.apply(this, arguments);
      }

      return getTrackStemsRaw;
    }()
    /**
     * Get the remixable stems of a track
     */

  }, {
    key: "getTrackStems",
    value: function () {
      var _getTrackStems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.getTrackStemsRaw(params, initOverrides);

              case 2:
                response = _context24.sent;
                _context24.next = 5;
                return response.value();

              case 5:
                return _context24.abrupt("return", _context24.sent);

              case 6:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getTrackStems(_x35, _x36) {
        return _getTrackStems.apply(this, arguments);
      }

      return getTrackStems;
    }()
    /** @hidden
     * Gets the track IDs of the top trending tracks on Audius
     */

  }, {
    key: "getTrendingTrackIDsRaw",
    value: function () {
      var _getTrendingTrackIDsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                queryParameters = {};

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                headerParameters = {};
                _context25.next = 5;
                return this.request({
                  path: "/tracks/trending/ids",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 5:
                response = _context25.sent;
                return _context25.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrendingIdsResponseFromJSON(jsonValue);
                }));

              case 7:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getTrendingTrackIDsRaw(_x37, _x38) {
        return _getTrendingTrackIDsRaw.apply(this, arguments);
      }

      return getTrendingTrackIDsRaw;
    }()
    /**
     * Gets the track IDs of the top trending tracks on Audius
     */

  }, {
    key: "getTrendingTrackIDs",
    value: function () {
      var _getTrendingTrackIDs = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26() {
        var params,
            initOverrides,
            response,
            _args26 = arguments;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                params = _args26.length > 0 && _args26[0] !== undefined ? _args26[0] : {};
                initOverrides = _args26.length > 1 ? _args26[1] : undefined;
                _context26.next = 4;
                return this.getTrendingTrackIDsRaw(params, initOverrides);

              case 4:
                response = _context26.sent;
                _context26.next = 7;
                return response.value();

              case 7:
                return _context26.abrupt("return", _context26.sent);

              case 8:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function getTrendingTrackIDs() {
        return _getTrendingTrackIDs.apply(this, arguments);
      }

      return getTrendingTrackIDs;
    }()
    /** @hidden
     * Gets the top 100 trending (most popular) tracks on Audius
     */

  }, {
    key: "getTrendingTracksRaw",
    value: function () {
      var _getTrendingTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context27.next = 9;
                return this.request({
                  path: "/tracks/trending",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context27.sent;
                return _context27.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getTrendingTracksRaw(_x39, _x40) {
        return _getTrendingTracksRaw.apply(this, arguments);
      }

      return getTrendingTracksRaw;
    }()
    /**
     * Gets the top 100 trending (most popular) tracks on Audius
     */

  }, {
    key: "getTrendingTracks",
    value: function () {
      var _getTrendingTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28() {
        var params,
            initOverrides,
            response,
            _args28 = arguments;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                params = _args28.length > 0 && _args28[0] !== undefined ? _args28[0] : {};
                initOverrides = _args28.length > 1 ? _args28[1] : undefined;
                _context28.next = 4;
                return this.getTrendingTracksRaw(params, initOverrides);

              case 4:
                response = _context28.sent;
                _context28.next = 7;
                return response.value();

              case 7:
                return _context28.abrupt("return", _context28.sent);

              case 8:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getTrendingTracks() {
        return _getTrendingTracks.apply(this, arguments);
      }

      return getTrendingTracks;
    }()
    /** @hidden
     * Gets the track IDs of the top trending tracks on Audius based on the given trending strategy version
     */

  }, {
    key: "getTrendingTracksIDsWithVersionRaw",
    value: function () {
      var _getTrendingTracksIDsWithVersionRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context29.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getTrendingTracksIDsWithVersion.');

              case 2:
                queryParameters = {};

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                headerParameters = {};
                _context29.next = 7;
                return this.request({
                  path: "/tracks/trending/ids/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context29.sent;
                return _context29.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrendingIdsResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getTrendingTracksIDsWithVersionRaw(_x41, _x42) {
        return _getTrendingTracksIDsWithVersionRaw.apply(this, arguments);
      }

      return getTrendingTracksIDsWithVersionRaw;
    }()
    /**
     * Gets the track IDs of the top trending tracks on Audius based on the given trending strategy version
     */

  }, {
    key: "getTrendingTracksIDsWithVersion",
    value: function () {
      var _getTrendingTracksIDsWithVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this.getTrendingTracksIDsWithVersionRaw(params, initOverrides);

              case 2:
                response = _context30.sent;
                _context30.next = 5;
                return response.value();

              case 5:
                return _context30.abrupt("return", _context30.sent);

              case 6:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getTrendingTracksIDsWithVersion(_x43, _x44) {
        return _getTrendingTracksIDsWithVersion.apply(this, arguments);
      }

      return getTrendingTracksIDsWithVersion;
    }()
    /** @hidden
     * Gets the top 100 trending (most popular tracks on Audius using a given trending strategy version
     */

  }, {
    key: "getTrendingTracksWithVersionRaw",
    value: function () {
      var _getTrendingTracksWithVersionRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context31.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getTrendingTracksWithVersion.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context31.next = 11;
                return this.request({
                  path: "/tracks/trending/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context31.sent;
                return _context31.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 13:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getTrendingTracksWithVersionRaw(_x45, _x46) {
        return _getTrendingTracksWithVersionRaw.apply(this, arguments);
      }

      return getTrendingTracksWithVersionRaw;
    }()
    /**
     * Gets the top 100 trending (most popular tracks on Audius using a given trending strategy version
     */

  }, {
    key: "getTrendingTracksWithVersion",
    value: function () {
      var _getTrendingTracksWithVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.getTrendingTracksWithVersionRaw(params, initOverrides);

              case 2:
                response = _context32.sent;
                _context32.next = 5;
                return response.value();

              case 5:
                return _context32.abrupt("return", _context32.sent);

              case 6:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getTrendingTracksWithVersion(_x47, _x48) {
        return _getTrendingTracksWithVersion.apply(this, arguments);
      }

      return getTrendingTracksWithVersion;
    }()
    /** @hidden
     * Gets the tracks found on the \"Under the Radar\" smart playlist
     */

  }, {
    key: "getUnderTheRadarTracksRaw",
    value: function () {
      var _getUnderTheRadarTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.filter !== undefined) {
                  queryParameters['filter'] = params.filter;
                }

                if (params.tracksOnly !== undefined) {
                  queryParameters['tracks_only'] = params.tracksOnly;
                }

                if (params.withUsers !== undefined) {
                  queryParameters['with_users'] = params.withUsers;
                }

                headerParameters = {};
                _context33.next = 10;
                return this.request({
                  path: "/tracks/under_the_radar",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 10:
                response = _context33.sent;
                return _context33.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 12:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getUnderTheRadarTracksRaw(_x49, _x50) {
        return _getUnderTheRadarTracksRaw.apply(this, arguments);
      }

      return getUnderTheRadarTracksRaw;
    }()
    /**
     * Gets the tracks found on the \"Under the Radar\" smart playlist
     */

  }, {
    key: "getUnderTheRadarTracks",
    value: function () {
      var _getUnderTheRadarTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34() {
        var params,
            initOverrides,
            response,
            _args34 = arguments;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                params = _args34.length > 0 && _args34[0] !== undefined ? _args34[0] : {};
                initOverrides = _args34.length > 1 ? _args34[1] : undefined;
                _context34.next = 4;
                return this.getUnderTheRadarTracksRaw(params, initOverrides);

              case 4:
                response = _context34.sent;
                _context34.next = 7;
                return response.value();

              case 7:
                return _context34.abrupt("return", _context34.sent);

              case 8:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function getUnderTheRadarTracks() {
        return _getUnderTheRadarTracks.apply(this, arguments);
      }

      return getUnderTheRadarTracks;
    }()
    /** @hidden
     * Gets the top 100 trending underground tracks on Audius
     */

  }, {
    key: "getUndergroundTrendingTracksRaw",
    value: function () {
      var _getUndergroundTrendingTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context35.next = 7;
                return this.request({
                  path: "/tracks/trending/underground",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context35.sent;
                return _context35.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function getUndergroundTrendingTracksRaw(_x51, _x52) {
        return _getUndergroundTrendingTracksRaw.apply(this, arguments);
      }

      return getUndergroundTrendingTracksRaw;
    }()
    /**
     * Gets the top 100 trending underground tracks on Audius
     */

  }, {
    key: "getUndergroundTrendingTracks",
    value: function () {
      var _getUndergroundTrendingTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36() {
        var params,
            initOverrides,
            response,
            _args36 = arguments;
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                params = _args36.length > 0 && _args36[0] !== undefined ? _args36[0] : {};
                initOverrides = _args36.length > 1 ? _args36[1] : undefined;
                _context36.next = 4;
                return this.getUndergroundTrendingTracksRaw(params, initOverrides);

              case 4:
                response = _context36.sent;
                _context36.next = 7;
                return response.value();

              case 7:
                return _context36.abrupt("return", _context36.sent);

              case 8:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function getUndergroundTrendingTracks() {
        return _getUndergroundTrendingTracks.apply(this, arguments);
      }

      return getUndergroundTrendingTracks;
    }()
    /** @hidden
     * Gets the top 100 trending underground tracks on Audius using a given trending strategy version
     */

  }, {
    key: "getUndergroundTrendingTracksWithVersionRaw",
    value: function () {
      var _getUndergroundTrendingTracksWithVersionRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context37.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getUndergroundTrendingTracksWithVersion.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context37.next = 9;
                return this.request({
                  path: "/tracks/trending/underground/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context37.sent;
                return _context37.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function getUndergroundTrendingTracksWithVersionRaw(_x53, _x54) {
        return _getUndergroundTrendingTracksWithVersionRaw.apply(this, arguments);
      }

      return getUndergroundTrendingTracksWithVersionRaw;
    }()
    /**
     * Gets the top 100 trending underground tracks on Audius using a given trending strategy version
     */

  }, {
    key: "getUndergroundTrendingTracksWithVersion",
    value: function () {
      var _getUndergroundTrendingTracksWithVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                _context38.next = 2;
                return this.getUndergroundTrendingTracksWithVersionRaw(params, initOverrides);

              case 2:
                response = _context38.sent;
                _context38.next = 5;
                return response.value();

              case 5:
                return _context38.abrupt("return", _context38.sent);

              case 6:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function getUndergroundTrendingTracksWithVersion(_x55, _x56) {
        return _getUndergroundTrendingTracksWithVersion.apply(this, arguments);
      }

      return getUndergroundTrendingTracksWithVersion;
    }()
    /** @hidden
     * Get users that favorited a track
     */

  }, {
    key: "getUsersFromFavoritesRaw",
    value: function () {
      var _getUsersFromFavoritesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context39.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getUsersFromFavorites.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context39.next = 9;
                return this.request({
                  path: "/tracks/{track_id}/favorites".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context39.sent;
                return _context39.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrackFavoritesResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));

      function getUsersFromFavoritesRaw(_x57, _x58) {
        return _getUsersFromFavoritesRaw.apply(this, arguments);
      }

      return getUsersFromFavoritesRaw;
    }()
    /**
     * Get users that favorited a track
     */

  }, {
    key: "getUsersFromFavorites",
    value: function () {
      var _getUsersFromFavorites = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee40(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                _context40.next = 2;
                return this.getUsersFromFavoritesRaw(params, initOverrides);

              case 2:
                response = _context40.sent;
                _context40.next = 5;
                return response.value();

              case 5:
                return _context40.abrupt("return", _context40.sent);

              case 6:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));

      function getUsersFromFavorites(_x59, _x60) {
        return _getUsersFromFavorites.apply(this, arguments);
      }

      return getUsersFromFavorites;
    }()
    /** @hidden
     * Get the users that reposted a track
     */

  }, {
    key: "getUsersFromRepostsRaw",
    value: function () {
      var _getUsersFromRepostsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee41(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context41.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getUsersFromReposts.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context41.next = 9;
                return this.request({
                  path: "/tracks/{track_id}/reposts".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context41.sent;
                return _context41.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrackRepostsResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this);
      }));

      function getUsersFromRepostsRaw(_x61, _x62) {
        return _getUsersFromRepostsRaw.apply(this, arguments);
      }

      return getUsersFromRepostsRaw;
    }()
    /**
     * Get the users that reposted a track
     */

  }, {
    key: "getUsersFromReposts",
    value: function () {
      var _getUsersFromReposts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee42(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                _context42.next = 2;
                return this.getUsersFromRepostsRaw(params, initOverrides);

              case 2:
                response = _context42.sent;
                _context42.next = 5;
                return response.value();

              case 5:
                return _context42.abrupt("return", _context42.sent);

              case 6:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this);
      }));

      function getUsersFromReposts(_x63, _x64) {
        return _getUsersFromReposts.apply(this, arguments);
      }

      return getUsersFromReposts;
    }()
  }]);

  return TracksApi;
}(BaseAPI);
/**
 * @export
 */

var GetRecommendedTracksTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetRecommendedTracksWithVersionTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetTrendingTracksTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetTrendingTracksWithVersionTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetUnderTheRadarTracksFilterEnum = {
  All: 'all',
  Repost: 'repost',
  Original: 'original'
};

/**
 *
 */

var TransactionsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TransactionsApi, _runtime$BaseAPI);

  var _super = _createSuper(TransactionsApi);

  function TransactionsApi() {
    _classCallCheck(this, TransactionsApi);

    return _super.apply(this, arguments);
  }

  _createClass(TransactionsApi, [{
    key: "getAudioTransactionHistoryRaw",
    value:
    /** @hidden
     * Gets the user\'s $AUDIO transaction history within the App
     */
    function () {
      var _getAudioTransactionHistoryRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getAudioTransactionHistory.');

              case 2:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getAudioTransactionHistory.');

              case 4:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context.next = 14;
                return this.request({
                  path: "/transactions",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TransactionHistoryResponseFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAudioTransactionHistoryRaw(_x, _x2) {
        return _getAudioTransactionHistoryRaw.apply(this, arguments);
      }

      return getAudioTransactionHistoryRaw;
    }()
    /**
     * Gets the user\'s $AUDIO transaction history within the App
     */

  }, {
    key: "getAudioTransactionHistory",
    value: function () {
      var _getAudioTransactionHistory = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getAudioTransactionHistoryRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getAudioTransactionHistory(_x3, _x4) {
        return _getAudioTransactionHistory.apply(this, arguments);
      }

      return getAudioTransactionHistory;
    }()
    /** @hidden
     * Gets the count of the user\'s $AUDIO transaction history within the App
     */

  }, {
    key: "getAudioTransactionHistoryCountRaw",
    value: function () {
      var _getAudioTransactionHistoryCountRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getAudioTransactionHistoryCount.');

              case 2:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context3.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getAudioTransactionHistoryCount.');

              case 4:
                queryParameters = {};
                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context3.next = 10;
                return this.request({
                  path: "/transactions/count",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 10:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TransactionHistoryCountResponseFromJSON(jsonValue);
                }));

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getAudioTransactionHistoryCountRaw(_x5, _x6) {
        return _getAudioTransactionHistoryCountRaw.apply(this, arguments);
      }

      return getAudioTransactionHistoryCountRaw;
    }()
    /**
     * Gets the count of the user\'s $AUDIO transaction history within the App
     */

  }, {
    key: "getAudioTransactionHistoryCount",
    value: function () {
      var _getAudioTransactionHistoryCount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getAudioTransactionHistoryCountRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAudioTransactionHistoryCount(_x7, _x8) {
        return _getAudioTransactionHistoryCount.apply(this, arguments);
      }

      return getAudioTransactionHistoryCount;
    }()
  }]);

  return TransactionsApi;
}(BaseAPI);
/**
 * @export
 */

var GetAudioTransactionHistorySortMethodEnum = {
  Date: 'date',
  TransactionType: 'transaction_type'
};
/**
 * @export
 */

var GetAudioTransactionHistorySortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};

/**
 *
 */

var UsersApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(UsersApi, _runtime$BaseAPI);

  var _super = _createSuper(UsersApi);

  function UsersApi() {
    _classCallCheck(this, UsersApi);

    return _super.apply(this, arguments);
  }

  _createClass(UsersApi, [{
    key: "bulkGetSubscribersRaw",
    value:
    /** @hidden
     * All users that subscribe to the provided users
     */
    function () {
      var _bulkGetSubscribersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.ids === null || params.ids === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('ids', 'Required parameter params.ids was null or undefined when calling bulkGetSubscribers.');

              case 2:
                queryParameters = {};

                if (params.ids) {
                  queryParameters['ids'] = params.ids.join(COLLECTION_FORMATS["csv"]);
                }

                headerParameters = {};
                _context.next = 7;
                return this.request({
                  path: "/users/subscribers",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullBulkSubscribersResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function bulkGetSubscribersRaw(_x, _x2) {
        return _bulkGetSubscribersRaw.apply(this, arguments);
      }

      return bulkGetSubscribersRaw;
    }()
    /**
     * All users that subscribe to the provided users
     */

  }, {
    key: "bulkGetSubscribers",
    value: function () {
      var _bulkGetSubscribers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.bulkGetSubscribersRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function bulkGetSubscribers(_x3, _x4) {
        return _bulkGetSubscribers.apply(this, arguments);
      }

      return bulkGetSubscribers;
    }()
    /** @hidden
     * Get all users that subscribe to the users listed in the JSON request
     */

  }, {
    key: "bulkGetSubscribersViaJSONRequestRaw",
    value: function () {
      var _bulkGetSubscribersViaJSONRequestRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.ids === null || params.ids === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError('ids', 'Required parameter params.ids was null or undefined when calling bulkGetSubscribersViaJSONRequest.');

              case 2:
                queryParameters = {};

                if (params.ids) {
                  queryParameters['ids'] = params.ids.join(COLLECTION_FORMATS["csv"]);
                }

                headerParameters = {};
                _context3.next = 7;
                return this.request({
                  path: "/users/subscribers",
                  method: 'POST',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullBulkSubscribersResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function bulkGetSubscribersViaJSONRequestRaw(_x5, _x6) {
        return _bulkGetSubscribersViaJSONRequestRaw.apply(this, arguments);
      }

      return bulkGetSubscribersViaJSONRequestRaw;
    }()
    /**
     * Get all users that subscribe to the users listed in the JSON request
     */

  }, {
    key: "bulkGetSubscribersViaJSONRequest",
    value: function () {
      var _bulkGetSubscribersViaJSONRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.bulkGetSubscribersViaJSONRequestRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function bulkGetSubscribersViaJSONRequest(_x7, _x8) {
        return _bulkGetSubscribersViaJSONRequest.apply(this, arguments);
      }

      return bulkGetSubscribersViaJSONRequest;
    }()
    /** @hidden
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */

  }, {
    key: "getAIAttributedTracksByUserHandleRaw",
    value: function () {
      var _getAIAttributedTracksByUserHandleRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context5.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getAIAttributedTracksByUserHandle.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context5.next = 14;
                return this.request({
                  path: "/users/handle/{handle}/tracks/ai_attributed".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getAIAttributedTracksByUserHandleRaw(_x9, _x10) {
        return _getAIAttributedTracksByUserHandleRaw.apply(this, arguments);
      }

      return getAIAttributedTracksByUserHandleRaw;
    }()
    /**
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */

  }, {
    key: "getAIAttributedTracksByUserHandle",
    value: function () {
      var _getAIAttributedTracksByUserHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getAIAttributedTracksByUserHandleRaw(params, initOverrides);

              case 2:
                response = _context6.sent;
                _context6.next = 5;
                return response.value();

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getAIAttributedTracksByUserHandle(_x11, _x12) {
        return _getAIAttributedTracksByUserHandle.apply(this, arguments);
      }

      return getAIAttributedTracksByUserHandle;
    }()
    /** @hidden
     * Gets a user\'s favorite tracks
     */

  }, {
    key: "getFavoritesRaw",
    value: function () {
      var _getFavoritesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context7.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getFavorites.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};
                _context7.next = 12;
                return this.request({
                  path: "/users/{id}/favorites/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 12:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrackLibraryResponseFullFromJSON(jsonValue);
                }));

              case 14:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getFavoritesRaw(_x13, _x14) {
        return _getFavoritesRaw.apply(this, arguments);
      }

      return getFavoritesRaw;
    }()
    /**
     * Gets a user\'s favorite tracks
     */

  }, {
    key: "getFavorites",
    value: function () {
      var _getFavorites = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getFavoritesRaw(params, initOverrides);

              case 2:
                response = _context8.sent;
                _context8.next = 5;
                return response.value();

              case 5:
                return _context8.abrupt("return", _context8.sent);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getFavorites(_x15, _x16) {
        return _getFavorites.apply(this, arguments);
      }

      return getFavorites;
    }()
    /** @hidden
     * All users that follow the provided user
     */

  }, {
    key: "getFollowersRaw",
    value: function () {
      var _getFollowersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getFollowers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context9.next = 9;
                return this.request({
                  path: "/users/{id}/followers".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context9.sent;
                return _context9.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullFollowersResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getFollowersRaw(_x17, _x18) {
        return _getFollowersRaw.apply(this, arguments);
      }

      return getFollowersRaw;
    }()
    /**
     * All users that follow the provided user
     */

  }, {
    key: "getFollowers",
    value: function () {
      var _getFollowers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getFollowersRaw(params, initOverrides);

              case 2:
                response = _context10.sent;
                _context10.next = 5;
                return response.value();

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getFollowers(_x19, _x20) {
        return _getFollowers.apply(this, arguments);
      }

      return getFollowers;
    }()
    /** @hidden
     * All users that the provided user follows
     */

  }, {
    key: "getFollowingRaw",
    value: function () {
      var _getFollowingRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context11.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getFollowing.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context11.next = 9;
                return this.request({
                  path: "/users/{id}/following".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context11.sent;
                return _context11.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FollowingResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getFollowingRaw(_x21, _x22) {
        return _getFollowingRaw.apply(this, arguments);
      }

      return getFollowingRaw;
    }()
    /**
     * All users that the provided user follows
     */

  }, {
    key: "getFollowing",
    value: function () {
      var _getFollowing = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getFollowingRaw(params, initOverrides);

              case 2:
                response = _context12.sent;
                _context12.next = 5;
                return response.value();

              case 5:
                return _context12.abrupt("return", _context12.sent);

              case 6:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getFollowing(_x23, _x24) {
        return _getFollowing.apply(this, arguments);
      }

      return getFollowing;
    }()
    /** @hidden
     * Gets the purchases the user has made
     */

  }, {
    key: "getPurchasesRaw",
    value: function () {
      var _getPurchasesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context13.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getPurchases.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};
                _context13.next = 11;
                return this.request({
                  path: "/users/{id}/purchases".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context13.sent;
                return _context13.abrupt("return", new VoidApiResponse(response));

              case 13:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getPurchasesRaw(_x25, _x26) {
        return _getPurchasesRaw.apply(this, arguments);
      }

      return getPurchasesRaw;
    }()
    /**
     * Gets the purchases the user has made
     */

  }, {
    key: "getPurchases",
    value: function () {
      var _getPurchases = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getPurchasesRaw(params, initOverrides);

              case 2:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getPurchases(_x27, _x28) {
        return _getPurchases.apply(this, arguments);
      }

      return getPurchases;
    }()
    /** @hidden
     * Gets a list of users that might be of interest to followers of this user.
     */

  }, {
    key: "getRelatedUsersRaw",
    value: function () {
      var _getRelatedUsersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context15.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getRelatedUsers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context15.next = 9;
                return this.request({
                  path: "/users/{id}/related".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context15.sent;
                return _context15.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return RelatedArtistResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getRelatedUsersRaw(_x29, _x30) {
        return _getRelatedUsersRaw.apply(this, arguments);
      }

      return getRelatedUsersRaw;
    }()
    /**
     * Gets a list of users that might be of interest to followers of this user.
     */

  }, {
    key: "getRelatedUsers",
    value: function () {
      var _getRelatedUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.getRelatedUsersRaw(params, initOverrides);

              case 2:
                response = _context16.sent;
                _context16.next = 5;
                return response.value();

              case 5:
                return _context16.abrupt("return", _context16.sent);

              case 6:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getRelatedUsers(_x31, _x32) {
        return _getRelatedUsers.apply(this, arguments);
      }

      return getRelatedUsers;
    }()
    /** @hidden
     * Gets the given user\'s reposts
     */

  }, {
    key: "getRepostsRaw",
    value: function () {
      var _getRepostsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context17.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getReposts.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context17.next = 9;
                return this.request({
                  path: "/users/{id}/reposts".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context17.sent;
                return _context17.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullRepostsFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getRepostsRaw(_x33, _x34) {
        return _getRepostsRaw.apply(this, arguments);
      }

      return getRepostsRaw;
    }()
    /**
     * Gets the given user\'s reposts
     */

  }, {
    key: "getReposts",
    value: function () {
      var _getReposts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.getRepostsRaw(params, initOverrides);

              case 2:
                response = _context18.sent;
                _context18.next = 5;
                return response.value();

              case 5:
                return _context18.abrupt("return", _context18.sent);

              case 6:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getReposts(_x35, _x36) {
        return _getReposts.apply(this, arguments);
      }

      return getReposts;
    }()
    /** @hidden
     * Gets the user\'s reposts by the user handle
     */

  }, {
    key: "getRepostsByHandleRaw",
    value: function () {
      var _getRepostsByHandleRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context19.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getRepostsByHandle.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context19.next = 9;
                return this.request({
                  path: "/users/handle/{handle}/reposts".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context19.sent;
                return _context19.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullRepostsFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getRepostsByHandleRaw(_x37, _x38) {
        return _getRepostsByHandleRaw.apply(this, arguments);
      }

      return getRepostsByHandleRaw;
    }()
    /**
     * Gets the user\'s reposts by the user handle
     */

  }, {
    key: "getRepostsByHandle",
    value: function () {
      var _getRepostsByHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getRepostsByHandleRaw(params, initOverrides);

              case 2:
                response = _context20.sent;
                _context20.next = 5;
                return response.value();

              case 5:
                return _context20.abrupt("return", _context20.sent);

              case 6:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getRepostsByHandle(_x39, _x40) {
        return _getRepostsByHandle.apply(this, arguments);
      }

      return getRepostsByHandle;
    }()
    /** @hidden
     * Gets the sales the user has made
     */

  }, {
    key: "getSalesRaw",
    value: function () {
      var _getSalesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context21.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSales.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};
                _context21.next = 11;
                return this.request({
                  path: "/users/{id}/sales".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context21.sent;
                return _context21.abrupt("return", new VoidApiResponse(response));

              case 13:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getSalesRaw(_x41, _x42) {
        return _getSalesRaw.apply(this, arguments);
      }

      return getSalesRaw;
    }()
    /**
     * Gets the sales the user has made
     */

  }, {
    key: "getSales",
    value: function () {
      var _getSales = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getSalesRaw(params, initOverrides);

              case 2:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getSales(_x43, _x44) {
        return _getSales.apply(this, arguments);
      }

      return getSales;
    }()
    /** @hidden
     * All users that subscribe to the provided user
     */

  }, {
    key: "getSubscribersRaw",
    value: function () {
      var _getSubscribersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context23.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSubscribers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context23.next = 9;
                return this.request({
                  path: "/users/{id}/subscribers".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context23.sent;
                return _context23.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullSubscribersResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getSubscribersRaw(_x45, _x46) {
        return _getSubscribersRaw.apply(this, arguments);
      }

      return getSubscribersRaw;
    }()
    /**
     * All users that subscribe to the provided user
     */

  }, {
    key: "getSubscribers",
    value: function () {
      var _getSubscribers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.getSubscribersRaw(params, initOverrides);

              case 2:
                response = _context24.sent;
                _context24.next = 5;
                return response.value();

              case 5:
                return _context24.abrupt("return", _context24.sent);

              case 6:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getSubscribers(_x47, _x48) {
        return _getSubscribers.apply(this, arguments);
      }

      return getSubscribers;
    }()
    /** @hidden
     * Gets the specified supporter of the given user
     */

  }, {
    key: "getSupporterRaw",
    value: function () {
      var _getSupporterRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context25.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupporter.');

              case 2:
                if (!(params.supporterUserId === null || params.supporterUserId === undefined)) {
                  _context25.next = 4;
                  break;
                }

                throw new RequiredError('supporterUserId', 'Required parameter params.supporterUserId was null or undefined when calling getSupporter.');

              case 4:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context25.next = 9;
                return this.request({
                  path: "/users/{id}/supporters/{supporter_user_id}".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))).replace("{".concat("supporter_user_id", "}"), encodeURIComponent(String(params.supporterUserId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context25.sent;
                return _context25.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullGetSupporterFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getSupporterRaw(_x49, _x50) {
        return _getSupporterRaw.apply(this, arguments);
      }

      return getSupporterRaw;
    }()
    /**
     * Gets the specified supporter of the given user
     */

  }, {
    key: "getSupporter",
    value: function () {
      var _getSupporter = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.getSupporterRaw(params, initOverrides);

              case 2:
                response = _context26.sent;
                _context26.next = 5;
                return response.value();

              case 5:
                return _context26.abrupt("return", _context26.sent);

              case 6:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function getSupporter(_x51, _x52) {
        return _getSupporter.apply(this, arguments);
      }

      return getSupporter;
    }()
    /** @hidden
     * Gets the supporters of the given user
     */

  }, {
    key: "getSupportersRaw",
    value: function () {
      var _getSupportersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context27.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupporters.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context27.next = 9;
                return this.request({
                  path: "/users/{id}/supporters".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context27.sent;
                return _context27.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullGetSupportersFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getSupportersRaw(_x53, _x54) {
        return _getSupportersRaw.apply(this, arguments);
      }

      return getSupportersRaw;
    }()
    /**
     * Gets the supporters of the given user
     */

  }, {
    key: "getSupporters",
    value: function () {
      var _getSupporters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.getSupportersRaw(params, initOverrides);

              case 2:
                response = _context28.sent;
                _context28.next = 5;
                return response.value();

              case 5:
                return _context28.abrupt("return", _context28.sent);

              case 6:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getSupporters(_x55, _x56) {
        return _getSupporters.apply(this, arguments);
      }

      return getSupporters;
    }()
    /** @hidden
     * Gets the support from the given user to the supported user
     */

  }, {
    key: "getSupportingRaw",
    value: function () {
      var _getSupportingRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context29.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupporting.');

              case 2:
                if (!(params.supportedUserId === null || params.supportedUserId === undefined)) {
                  _context29.next = 4;
                  break;
                }

                throw new RequiredError('supportedUserId', 'Required parameter params.supportedUserId was null or undefined when calling getSupporting.');

              case 4:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context29.next = 9;
                return this.request({
                  path: "/users/{id}/supporting/{supported_user_id}".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))).replace("{".concat("supported_user_id", "}"), encodeURIComponent(String(params.supportedUserId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context29.sent;
                return _context29.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullGetSupportingFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getSupportingRaw(_x57, _x58) {
        return _getSupportingRaw.apply(this, arguments);
      }

      return getSupportingRaw;
    }()
    /**
     * Gets the support from the given user to the supported user
     */

  }, {
    key: "getSupporting",
    value: function () {
      var _getSupporting = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this.getSupportingRaw(params, initOverrides);

              case 2:
                response = _context30.sent;
                _context30.next = 5;
                return response.value();

              case 5:
                return _context30.abrupt("return", _context30.sent);

              case 6:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getSupporting(_x59, _x60) {
        return _getSupporting.apply(this, arguments);
      }

      return getSupporting;
    }()
    /** @hidden
     * Gets the users that the given user supports
     */

  }, {
    key: "getSupportingsRaw",
    value: function () {
      var _getSupportingsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context31.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupportings.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context31.next = 9;
                return this.request({
                  path: "/users/{id}/supporting".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context31.sent;
                return _context31.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullGetSupportingFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getSupportingsRaw(_x61, _x62) {
        return _getSupportingsRaw.apply(this, arguments);
      }

      return getSupportingsRaw;
    }()
    /**
     * Gets the users that the given user supports
     */

  }, {
    key: "getSupportings",
    value: function () {
      var _getSupportings = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.getSupportingsRaw(params, initOverrides);

              case 2:
                response = _context32.sent;
                _context32.next = 5;
                return response.value();

              case 5:
                return _context32.abrupt("return", _context32.sent);

              case 6:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getSupportings(_x63, _x64) {
        return _getSupportings.apply(this, arguments);
      }

      return getSupportings;
    }()
    /** @hidden
     * Get the Top Users having at least one track by follower count
     */

  }, {
    key: "getTopUsersRaw",
    value: function () {
      var _getTopUsersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context33.next = 7;
                return this.request({
                  path: "/users/top",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context33.sent;
                return _context33.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TopUsersResponseFullFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getTopUsersRaw(_x65, _x66) {
        return _getTopUsersRaw.apply(this, arguments);
      }

      return getTopUsersRaw;
    }()
    /**
     * Get the Top Users having at least one track by follower count
     */

  }, {
    key: "getTopUsers",
    value: function () {
      var _getTopUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34() {
        var params,
            initOverrides,
            response,
            _args34 = arguments;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                params = _args34.length > 0 && _args34[0] !== undefined ? _args34[0] : {};
                initOverrides = _args34.length > 1 ? _args34[1] : undefined;
                _context34.next = 4;
                return this.getTopUsersRaw(params, initOverrides);

              case 4:
                response = _context34.sent;
                _context34.next = 7;
                return response.value();

              case 7:
                return _context34.abrupt("return", _context34.sent);

              case 8:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function getTopUsers() {
        return _getTopUsers.apply(this, arguments);
      }

      return getTopUsers;
    }()
    /** @hidden
     * Get the Top Users for a Given Genre
     */

  }, {
    key: "getTopUsersInGenreRaw",
    value: function () {
      var _getTopUsersInGenreRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.genre) {
                  queryParameters['genre'] = params.genre;
                }

                headerParameters = {};
                _context35.next = 7;
                return this.request({
                  path: "/users/genre/top",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context35.sent;
                return _context35.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TopGenreUsersResponseFullFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function getTopUsersInGenreRaw(_x67, _x68) {
        return _getTopUsersInGenreRaw.apply(this, arguments);
      }

      return getTopUsersInGenreRaw;
    }()
    /**
     * Get the Top Users for a Given Genre
     */

  }, {
    key: "getTopUsersInGenre",
    value: function () {
      var _getTopUsersInGenre = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36() {
        var params,
            initOverrides,
            response,
            _args36 = arguments;
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                params = _args36.length > 0 && _args36[0] !== undefined ? _args36[0] : {};
                initOverrides = _args36.length > 1 ? _args36[1] : undefined;
                _context36.next = 4;
                return this.getTopUsersInGenreRaw(params, initOverrides);

              case 4:
                response = _context36.sent;
                _context36.next = 7;
                return response.value();

              case 7:
                return _context36.abrupt("return", _context36.sent);

              case 8:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function getTopUsersInGenre() {
        return _getTopUsersInGenre.apply(this, arguments);
      }

      return getTopUsersInGenre;
    }()
    /** @hidden
     * Gets the tracks created by a user using their user ID
     */

  }, {
    key: "getTracksByUserRaw",
    value: function () {
      var _getTracksByUserRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context37.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getTracksByUser.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context37.next = 14;
                return this.request({
                  path: "/users/{id}/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context37.sent;
                return _context37.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function getTracksByUserRaw(_x69, _x70) {
        return _getTracksByUserRaw.apply(this, arguments);
      }

      return getTracksByUserRaw;
    }()
    /**
     * Gets the tracks created by a user using their user ID
     */

  }, {
    key: "getTracksByUser",
    value: function () {
      var _getTracksByUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                _context38.next = 2;
                return this.getTracksByUserRaw(params, initOverrides);

              case 2:
                response = _context38.sent;
                _context38.next = 5;
                return response.value();

              case 5:
                return _context38.abrupt("return", _context38.sent);

              case 6:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function getTracksByUser(_x71, _x72) {
        return _getTracksByUser.apply(this, arguments);
      }

      return getTracksByUser;
    }()
    /** @hidden
     * Gets the tracks created by a user using the user\'s handle
     */

  }, {
    key: "getTracksByUserHandleRaw",
    value: function () {
      var _getTracksByUserHandleRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context39.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getTracksByUserHandle.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context39.next = 14;
                return this.request({
                  path: "/users/handle/{handle}/tracks".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context39.sent;
                return _context39.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));

      function getTracksByUserHandleRaw(_x73, _x74) {
        return _getTracksByUserHandleRaw.apply(this, arguments);
      }

      return getTracksByUserHandleRaw;
    }()
    /**
     * Gets the tracks created by a user using the user\'s handle
     */

  }, {
    key: "getTracksByUserHandle",
    value: function () {
      var _getTracksByUserHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee40(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                _context40.next = 2;
                return this.getTracksByUserHandleRaw(params, initOverrides);

              case 2:
                response = _context40.sent;
                _context40.next = 5;
                return response.value();

              case 5:
                return _context40.abrupt("return", _context40.sent);

              case 6:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));

      function getTracksByUserHandle(_x75, _x76) {
        return _getTracksByUserHandle.apply(this, arguments);
      }

      return getTracksByUserHandle;
    }()
    /** @hidden
     * Gets a single user by their user ID
     */

  }, {
    key: "getUserRaw",
    value: function () {
      var _getUserRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee41(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context41.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUser.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context41.next = 7;
                return this.request({
                  path: "/users/{id}".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context41.sent;
                return _context41.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullUserResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this);
      }));

      function getUserRaw(_x77, _x78) {
        return _getUserRaw.apply(this, arguments);
      }

      return getUserRaw;
    }()
    /**
     * Gets a single user by their user ID
     */

  }, {
    key: "getUser",
    value: function () {
      var _getUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee42(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                _context42.next = 2;
                return this.getUserRaw(params, initOverrides);

              case 2:
                response = _context42.sent;
                _context42.next = 5;
                return response.value();

              case 5:
                return _context42.abrupt("return", _context42.sent);

              case 6:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this);
      }));

      function getUser(_x79, _x80) {
        return _getUser.apply(this, arguments);
      }

      return getUser;
    }()
    /** @hidden
     * Gets a single user by their handle
     */

  }, {
    key: "getUserByHandleRaw",
    value: function () {
      var _getUserByHandleRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee43(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee43$(_context43) {
          while (1) {
            switch (_context43.prev = _context43.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context43.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getUserByHandle.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context43.next = 7;
                return this.request({
                  path: "/users/handle/{handle}".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context43.sent;
                return _context43.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullUserResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context43.stop();
            }
          }
        }, _callee43, this);
      }));

      function getUserByHandleRaw(_x81, _x82) {
        return _getUserByHandleRaw.apply(this, arguments);
      }

      return getUserByHandleRaw;
    }()
    /**
     * Gets a single user by their handle
     */

  }, {
    key: "getUserByHandle",
    value: function () {
      var _getUserByHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee44(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee44$(_context44) {
          while (1) {
            switch (_context44.prev = _context44.next) {
              case 0:
                _context44.next = 2;
                return this.getUserByHandleRaw(params, initOverrides);

              case 2:
                response = _context44.sent;
                _context44.next = 5;
                return response.value();

              case 5:
                return _context44.abrupt("return", _context44.sent);

              case 6:
              case "end":
                return _context44.stop();
            }
          }
        }, _callee44, this);
      }));

      function getUserByHandle(_x83, _x84) {
        return _getUserByHandle.apply(this, arguments);
      }

      return getUserByHandle;
    }()
    /** @hidden
     * Gets a user\'s saved/reposted/purchased/all albums
     * Fetch a user\'s full library playlists
     */

  }, {
    key: "getUserLibraryAlbumsRaw",
    value: function () {
      var _getUserLibraryAlbumsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee45(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee45$(_context45) {
          while (1) {
            switch (_context45.prev = _context45.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context45.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserLibraryAlbums.');

              case 2:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context45.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getUserLibraryAlbums.');

              case 4:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context45.next = 6;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getUserLibraryAlbums.');

              case 6:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.type !== undefined) {
                  queryParameters['type'] = params.type;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context45.next = 19;
                return this.request({
                  path: "/users/{id}/library/albums".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 19:
                response = _context45.sent;
                return _context45.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return CollectionLibraryResponseFullFromJSON(jsonValue);
                }));

              case 21:
              case "end":
                return _context45.stop();
            }
          }
        }, _callee45, this);
      }));

      function getUserLibraryAlbumsRaw(_x85, _x86) {
        return _getUserLibraryAlbumsRaw.apply(this, arguments);
      }

      return getUserLibraryAlbumsRaw;
    }()
    /**
     * Gets a user\'s saved/reposted/purchased/all albums
     * Fetch a user\'s full library playlists
     */

  }, {
    key: "getUserLibraryAlbums",
    value: function () {
      var _getUserLibraryAlbums = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee46(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee46$(_context46) {
          while (1) {
            switch (_context46.prev = _context46.next) {
              case 0:
                _context46.next = 2;
                return this.getUserLibraryAlbumsRaw(params, initOverrides);

              case 2:
                response = _context46.sent;
                _context46.next = 5;
                return response.value();

              case 5:
                return _context46.abrupt("return", _context46.sent);

              case 6:
              case "end":
                return _context46.stop();
            }
          }
        }, _callee46, this);
      }));

      function getUserLibraryAlbums(_x87, _x88) {
        return _getUserLibraryAlbums.apply(this, arguments);
      }

      return getUserLibraryAlbums;
    }()
    /** @hidden
     * Gets a user\'s saved/reposted/purchased/all playlists
     * Fetch a user\'s full library playlists
     */

  }, {
    key: "getUserLibraryPlaylistsRaw",
    value: function () {
      var _getUserLibraryPlaylistsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee47(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee47$(_context47) {
          while (1) {
            switch (_context47.prev = _context47.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context47.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserLibraryPlaylists.');

              case 2:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context47.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getUserLibraryPlaylists.');

              case 4:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context47.next = 6;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getUserLibraryPlaylists.');

              case 6:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.type !== undefined) {
                  queryParameters['type'] = params.type;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context47.next = 19;
                return this.request({
                  path: "/users/{id}/library/playlists".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 19:
                response = _context47.sent;
                return _context47.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return CollectionLibraryResponseFullFromJSON(jsonValue);
                }));

              case 21:
              case "end":
                return _context47.stop();
            }
          }
        }, _callee47, this);
      }));

      function getUserLibraryPlaylistsRaw(_x89, _x90) {
        return _getUserLibraryPlaylistsRaw.apply(this, arguments);
      }

      return getUserLibraryPlaylistsRaw;
    }()
    /**
     * Gets a user\'s saved/reposted/purchased/all playlists
     * Fetch a user\'s full library playlists
     */

  }, {
    key: "getUserLibraryPlaylists",
    value: function () {
      var _getUserLibraryPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee48(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee48$(_context48) {
          while (1) {
            switch (_context48.prev = _context48.next) {
              case 0:
                _context48.next = 2;
                return this.getUserLibraryPlaylistsRaw(params, initOverrides);

              case 2:
                response = _context48.sent;
                _context48.next = 5;
                return response.value();

              case 5:
                return _context48.abrupt("return", _context48.sent);

              case 6:
              case "end":
                return _context48.stop();
            }
          }
        }, _callee48, this);
      }));

      function getUserLibraryPlaylists(_x91, _x92) {
        return _getUserLibraryPlaylists.apply(this, arguments);
      }

      return getUserLibraryPlaylists;
    }()
    /** @hidden
     * Gets a user\'s saved/reposted/purchased/all tracks
     * Fetch a user\'s full library tracks
     */

  }, {
    key: "getUserLibraryTracksRaw",
    value: function () {
      var _getUserLibraryTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee49(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee49$(_context49) {
          while (1) {
            switch (_context49.prev = _context49.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context49.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserLibraryTracks.');

              case 2:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context49.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getUserLibraryTracks.');

              case 4:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context49.next = 6;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getUserLibraryTracks.');

              case 6:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.type !== undefined) {
                  queryParameters['type'] = params.type;
                }

                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context49.next = 19;
                return this.request({
                  path: "/users/{id}/library/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 19:
                response = _context49.sent;
                return _context49.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrackLibraryResponseFullFromJSON(jsonValue);
                }));

              case 21:
              case "end":
                return _context49.stop();
            }
          }
        }, _callee49, this);
      }));

      function getUserLibraryTracksRaw(_x93, _x94) {
        return _getUserLibraryTracksRaw.apply(this, arguments);
      }

      return getUserLibraryTracksRaw;
    }()
    /**
     * Gets a user\'s saved/reposted/purchased/all tracks
     * Fetch a user\'s full library tracks
     */

  }, {
    key: "getUserLibraryTracks",
    value: function () {
      var _getUserLibraryTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee50(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee50$(_context50) {
          while (1) {
            switch (_context50.prev = _context50.next) {
              case 0:
                _context50.next = 2;
                return this.getUserLibraryTracksRaw(params, initOverrides);

              case 2:
                response = _context50.sent;
                _context50.next = 5;
                return response.value();

              case 5:
                return _context50.abrupt("return", _context50.sent);

              case 6:
              case "end":
                return _context50.stop();
            }
          }
        }, _callee50, this);
      }));

      function getUserLibraryTracks(_x95, _x96) {
        return _getUserLibraryTracks.apply(this, arguments);
      }

      return getUserLibraryTracks;
    }()
    /** @hidden
     * Gets the user\'s replica set
     */

  }, {
    key: "getUserReplicaSetRaw",
    value: function () {
      var _getUserReplicaSetRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee51(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee51$(_context51) {
          while (1) {
            switch (_context51.prev = _context51.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context51.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserReplicaSet.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context51.next = 7;
                return this.request({
                  path: "/users/{id}/replica_set".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context51.sent;
                return _context51.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return UsersByContentNodeFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context51.stop();
            }
          }
        }, _callee51, this);
      }));

      function getUserReplicaSetRaw(_x97, _x98) {
        return _getUserReplicaSetRaw.apply(this, arguments);
      }

      return getUserReplicaSetRaw;
    }()
    /**
     * Gets the user\'s replica set
     */

  }, {
    key: "getUserReplicaSet",
    value: function () {
      var _getUserReplicaSet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee52(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee52$(_context52) {
          while (1) {
            switch (_context52.prev = _context52.next) {
              case 0:
                _context52.next = 2;
                return this.getUserReplicaSetRaw(params, initOverrides);

              case 2:
                response = _context52.sent;
                _context52.next = 5;
                return response.value();

              case 5:
                return _context52.abrupt("return", _context52.sent);

              case 6:
              case "end":
                return _context52.stop();
            }
          }
        }, _callee52, this);
      }));

      function getUserReplicaSet(_x99, _x100) {
        return _getUserReplicaSet.apply(this, arguments);
      }

      return getUserReplicaSet;
    }()
    /** @hidden
     * Get the tracks the user recently listened to.
     */

  }, {
    key: "getUsersTrackHistoryRaw",
    value: function () {
      var _getUsersTrackHistoryRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee53(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee53$(_context53) {
          while (1) {
            switch (_context53.prev = _context53.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context53.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUsersTrackHistory.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};
                _context53.next = 12;
                return this.request({
                  path: "/users/{id}/history/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 12:
                response = _context53.sent;
                return _context53.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return HistoryResponseFullFromJSON(jsonValue);
                }));

              case 14:
              case "end":
                return _context53.stop();
            }
          }
        }, _callee53, this);
      }));

      function getUsersTrackHistoryRaw(_x101, _x102) {
        return _getUsersTrackHistoryRaw.apply(this, arguments);
      }

      return getUsersTrackHistoryRaw;
    }()
    /**
     * Get the tracks the user recently listened to.
     */

  }, {
    key: "getUsersTrackHistory",
    value: function () {
      var _getUsersTrackHistory = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee54(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee54$(_context54) {
          while (1) {
            switch (_context54.prev = _context54.next) {
              case 0:
                _context54.next = 2;
                return this.getUsersTrackHistoryRaw(params, initOverrides);

              case 2:
                response = _context54.sent;
                _context54.next = 5;
                return response.value();

              case 5:
                return _context54.abrupt("return", _context54.sent);

              case 6:
              case "end":
                return _context54.stop();
            }
          }
        }, _callee54, this);
      }));

      function getUsersTrackHistory(_x103, _x104) {
        return _getUsersTrackHistory.apply(this, arguments);
      }

      return getUsersTrackHistory;
    }()
  }]);

  return UsersApi;
}(BaseAPI);
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortEnum = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleFilterTracksEnum = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */

var GetFavoritesSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetFavoritesSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetPurchasesSortMethodEnum = {
  ContentTitle: 'content_title',
  ArtistName: 'artist_name',
  Date: 'date'
};
/**
 * @export
 */

var GetPurchasesSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetSalesSortMethodEnum = {
  ContentTitle: 'content_title',
  ArtistName: 'artist_name',
  Date: 'date'
};
/**
 * @export
 */

var GetSalesSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetTracksByUserSortEnum = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetTracksByUserSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetTracksByUserSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetTracksByUserFilterTracksEnum = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */

var GetTracksByUserHandleSortEnum = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetTracksByUserHandleSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetTracksByUserHandleSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetTracksByUserHandleFilterTracksEnum = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */

var GetUserLibraryAlbumsSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetUserLibraryAlbumsTypeEnum = {
  All: 'all',
  Repost: 'repost',
  Favorite: 'favorite',
  Purchase: 'purchase'
};
/**
 * @export
 */

var GetUserLibraryAlbumsSortMethodEnum = {
  AddedDate: 'added_date',
  Reposts: 'reposts',
  Saves: 'saves'
};
/**
 * @export
 */

var GetUserLibraryPlaylistsSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetUserLibraryPlaylistsTypeEnum = {
  All: 'all',
  Repost: 'repost',
  Favorite: 'favorite',
  Purchase: 'purchase'
};
/**
 * @export
 */

var GetUserLibraryPlaylistsSortMethodEnum = {
  AddedDate: 'added_date',
  Reposts: 'reposts',
  Saves: 'saves'
};
/**
 * @export
 */

var GetUserLibraryTracksSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetUserLibraryTracksSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetUserLibraryTracksTypeEnum = {
  All: 'all',
  Repost: 'repost',
  Favorite: 'favorite',
  Purchase: 'purchase'
};
/**
 * @export
 */

var GetUsersTrackHistorySortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetUsersTrackHistorySortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};

/* tslint:disable */

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BASE_PATH: BASE_PATH,
  Configuration: Configuration,
  DefaultConfig: DefaultConfig,
  BaseAPI: BaseAPI,
  ResponseError: ResponseError,
  FetchError: FetchError,
  RequiredError: RequiredError,
  COLLECTION_FORMATS: COLLECTION_FORMATS,
  exists: exists,
  querystring: querystring,
  mapValues: mapValues,
  canConsumeForm: canConsumeForm,
  JSONApiResponse: JSONApiResponse,
  VoidApiResponse: VoidApiResponse,
  BlobApiResponse: BlobApiResponse,
  TextApiResponse: TextApiResponse,
  PlaylistsApi: PlaylistsApi,
  GetTrendingPlaylistsTimeEnum: GetTrendingPlaylistsTimeEnum,
  GetTrendingPlaylistsWithVersionTimeEnum: GetTrendingPlaylistsWithVersionTimeEnum,
  ReactionsApi: ReactionsApi,
  SearchApi: SearchApi,
  SearchKindEnum: SearchKindEnum,
  SearchAutocompleteKindEnum: SearchAutocompleteKindEnum,
  TipsApi: TipsApi,
  GetTipsCurrentUserFollowsEnum: GetTipsCurrentUserFollowsEnum,
  GetTipsUniqueByEnum: GetTipsUniqueByEnum,
  TracksApi: TracksApi,
  GetRecommendedTracksTimeEnum: GetRecommendedTracksTimeEnum,
  GetRecommendedTracksWithVersionTimeEnum: GetRecommendedTracksWithVersionTimeEnum,
  GetTrendingTracksTimeEnum: GetTrendingTracksTimeEnum,
  GetTrendingTracksWithVersionTimeEnum: GetTrendingTracksWithVersionTimeEnum,
  GetUnderTheRadarTracksFilterEnum: GetUnderTheRadarTracksFilterEnum,
  TransactionsApi: TransactionsApi,
  GetAudioTransactionHistorySortMethodEnum: GetAudioTransactionHistorySortMethodEnum,
  GetAudioTransactionHistorySortDirectionEnum: GetAudioTransactionHistorySortDirectionEnum,
  UsersApi: UsersApi,
  GetAIAttributedTracksByUserHandleSortEnum: GetAIAttributedTracksByUserHandleSortEnum,
  GetAIAttributedTracksByUserHandleSortMethodEnum: GetAIAttributedTracksByUserHandleSortMethodEnum,
  GetAIAttributedTracksByUserHandleSortDirectionEnum: GetAIAttributedTracksByUserHandleSortDirectionEnum,
  GetAIAttributedTracksByUserHandleFilterTracksEnum: GetAIAttributedTracksByUserHandleFilterTracksEnum,
  GetFavoritesSortMethodEnum: GetFavoritesSortMethodEnum,
  GetFavoritesSortDirectionEnum: GetFavoritesSortDirectionEnum,
  GetPurchasesSortMethodEnum: GetPurchasesSortMethodEnum,
  GetPurchasesSortDirectionEnum: GetPurchasesSortDirectionEnum,
  GetSalesSortMethodEnum: GetSalesSortMethodEnum,
  GetSalesSortDirectionEnum: GetSalesSortDirectionEnum,
  GetTracksByUserSortEnum: GetTracksByUserSortEnum,
  GetTracksByUserSortMethodEnum: GetTracksByUserSortMethodEnum,
  GetTracksByUserSortDirectionEnum: GetTracksByUserSortDirectionEnum,
  GetTracksByUserFilterTracksEnum: GetTracksByUserFilterTracksEnum,
  GetTracksByUserHandleSortEnum: GetTracksByUserHandleSortEnum,
  GetTracksByUserHandleSortMethodEnum: GetTracksByUserHandleSortMethodEnum,
  GetTracksByUserHandleSortDirectionEnum: GetTracksByUserHandleSortDirectionEnum,
  GetTracksByUserHandleFilterTracksEnum: GetTracksByUserHandleFilterTracksEnum,
  GetUserLibraryAlbumsSortDirectionEnum: GetUserLibraryAlbumsSortDirectionEnum,
  GetUserLibraryAlbumsTypeEnum: GetUserLibraryAlbumsTypeEnum,
  GetUserLibraryAlbumsSortMethodEnum: GetUserLibraryAlbumsSortMethodEnum,
  GetUserLibraryPlaylistsSortDirectionEnum: GetUserLibraryPlaylistsSortDirectionEnum,
  GetUserLibraryPlaylistsTypeEnum: GetUserLibraryPlaylistsTypeEnum,
  GetUserLibraryPlaylistsSortMethodEnum: GetUserLibraryPlaylistsSortMethodEnum,
  GetUserLibraryTracksSortMethodEnum: GetUserLibraryTracksSortMethodEnum,
  GetUserLibraryTracksSortDirectionEnum: GetUserLibraryTracksSortDirectionEnum,
  GetUserLibraryTracksTypeEnum: GetUserLibraryTracksTypeEnum,
  GetUsersTrackHistorySortMethodEnum: GetUsersTrackHistorySortMethodEnum,
  GetUsersTrackHistorySortDirectionEnum: GetUsersTrackHistorySortDirectionEnum,
  instanceOfActivityFull: instanceOfActivityFull,
  ActivityFullFromJSON: ActivityFullFromJSON,
  ActivityFullFromJSONTyped: ActivityFullFromJSONTyped,
  ActivityFullToJSON: ActivityFullToJSON,
  instanceOfCollectionActivityFull: instanceOfCollectionActivityFull,
  CollectionActivityFullFromJSON: CollectionActivityFullFromJSON,
  CollectionActivityFullFromJSONTyped: CollectionActivityFullFromJSONTyped,
  CollectionActivityFullToJSON: CollectionActivityFullToJSON,
  instanceOfCollectionLibraryResponseFull: instanceOfCollectionLibraryResponseFull,
  CollectionLibraryResponseFullFromJSON: CollectionLibraryResponseFullFromJSON,
  CollectionLibraryResponseFullFromJSONTyped: CollectionLibraryResponseFullFromJSONTyped,
  CollectionLibraryResponseFullToJSON: CollectionLibraryResponseFullToJSON,
  instanceOfCoverArt: instanceOfCoverArt,
  CoverArtFromJSON: CoverArtFromJSON,
  CoverArtFromJSONTyped: CoverArtFromJSONTyped,
  CoverArtToJSON: CoverArtToJSON,
  instanceOfCoverPhoto: instanceOfCoverPhoto,
  CoverPhotoFromJSON: CoverPhotoFromJSON,
  CoverPhotoFromJSONTyped: CoverPhotoFromJSONTyped,
  CoverPhotoToJSON: CoverPhotoToJSON,
  instanceOfDownloadMetadata: instanceOfDownloadMetadata,
  DownloadMetadataFromJSON: DownloadMetadataFromJSON,
  DownloadMetadataFromJSONTyped: DownloadMetadataFromJSONTyped,
  DownloadMetadataToJSON: DownloadMetadataToJSON,
  instanceOfFavorite: instanceOfFavorite,
  FavoriteFromJSON: FavoriteFromJSON,
  FavoriteFromJSONTyped: FavoriteFromJSONTyped,
  FavoriteToJSON: FavoriteToJSON,
  instanceOfFieldVisibility: instanceOfFieldVisibility,
  FieldVisibilityFromJSON: FieldVisibilityFromJSON,
  FieldVisibilityFromJSONTyped: FieldVisibilityFromJSONTyped,
  FieldVisibilityToJSON: FieldVisibilityToJSON,
  instanceOfFollowingResponse: instanceOfFollowingResponse,
  FollowingResponseFromJSON: FollowingResponseFromJSON,
  FollowingResponseFromJSONTyped: FollowingResponseFromJSONTyped,
  FollowingResponseToJSON: FollowingResponseToJSON,
  instanceOfFollowingResponseFull: instanceOfFollowingResponseFull,
  FollowingResponseFullFromJSON: FollowingResponseFullFromJSON,
  FollowingResponseFullFromJSONTyped: FollowingResponseFullFromJSONTyped,
  FollowingResponseFullToJSON: FollowingResponseFullToJSON,
  instanceOfFullBulkSubscribersResponse: instanceOfFullBulkSubscribersResponse,
  FullBulkSubscribersResponseFromJSON: FullBulkSubscribersResponseFromJSON,
  FullBulkSubscribersResponseFromJSONTyped: FullBulkSubscribersResponseFromJSONTyped,
  FullBulkSubscribersResponseToJSON: FullBulkSubscribersResponseToJSON,
  instanceOfFullFollowersResponse: instanceOfFullFollowersResponse,
  FullFollowersResponseFromJSON: FullFollowersResponseFromJSON,
  FullFollowersResponseFromJSONTyped: FullFollowersResponseFromJSONTyped,
  FullFollowersResponseToJSON: FullFollowersResponseToJSON,
  instanceOfFullGetSupporter: instanceOfFullGetSupporter,
  FullGetSupporterFromJSON: FullGetSupporterFromJSON,
  FullGetSupporterFromJSONTyped: FullGetSupporterFromJSONTyped,
  FullGetSupporterToJSON: FullGetSupporterToJSON,
  instanceOfFullGetSupporters: instanceOfFullGetSupporters,
  FullGetSupportersFromJSON: FullGetSupportersFromJSON,
  FullGetSupportersFromJSONTyped: FullGetSupportersFromJSONTyped,
  FullGetSupportersToJSON: FullGetSupportersToJSON,
  instanceOfFullGetSupporting: instanceOfFullGetSupporting,
  FullGetSupportingFromJSON: FullGetSupportingFromJSON,
  FullGetSupportingFromJSONTyped: FullGetSupportingFromJSONTyped,
  FullGetSupportingToJSON: FullGetSupportingToJSON,
  instanceOfFullPlaylistResponse: instanceOfFullPlaylistResponse,
  FullPlaylistResponseFromJSON: FullPlaylistResponseFromJSON,
  FullPlaylistResponseFromJSONTyped: FullPlaylistResponseFromJSONTyped,
  FullPlaylistResponseToJSON: FullPlaylistResponseToJSON,
  instanceOfFullPlaylistTracksResponse: instanceOfFullPlaylistTracksResponse,
  FullPlaylistTracksResponseFromJSON: FullPlaylistTracksResponseFromJSON,
  FullPlaylistTracksResponseFromJSONTyped: FullPlaylistTracksResponseFromJSONTyped,
  FullPlaylistTracksResponseToJSON: FullPlaylistTracksResponseToJSON,
  instanceOfFullRemix: instanceOfFullRemix,
  FullRemixFromJSON: FullRemixFromJSON,
  FullRemixFromJSONTyped: FullRemixFromJSONTyped,
  FullRemixToJSON: FullRemixToJSON,
  instanceOfFullRemixParent: instanceOfFullRemixParent,
  FullRemixParentFromJSON: FullRemixParentFromJSON,
  FullRemixParentFromJSONTyped: FullRemixParentFromJSONTyped,
  FullRemixParentToJSON: FullRemixParentToJSON,
  instanceOfFullReposts: instanceOfFullReposts,
  FullRepostsFromJSON: FullRepostsFromJSON,
  FullRepostsFromJSONTyped: FullRepostsFromJSONTyped,
  FullRepostsToJSON: FullRepostsToJSON,
  instanceOfFullSubscribersResponse: instanceOfFullSubscribersResponse,
  FullSubscribersResponseFromJSON: FullSubscribersResponseFromJSON,
  FullSubscribersResponseFromJSONTyped: FullSubscribersResponseFromJSONTyped,
  FullSubscribersResponseToJSON: FullSubscribersResponseToJSON,
  instanceOfFullSupporter: instanceOfFullSupporter,
  FullSupporterFromJSON: FullSupporterFromJSON,
  FullSupporterFromJSONTyped: FullSupporterFromJSONTyped,
  FullSupporterToJSON: FullSupporterToJSON,
  instanceOfFullSupporting: instanceOfFullSupporting,
  FullSupportingFromJSON: FullSupportingFromJSON,
  FullSupportingFromJSONTyped: FullSupportingFromJSONTyped,
  FullSupportingToJSON: FullSupportingToJSON,
  instanceOfFullTip: instanceOfFullTip,
  FullTipFromJSON: FullTipFromJSON,
  FullTipFromJSONTyped: FullTipFromJSONTyped,
  FullTipToJSON: FullTipToJSON,
  instanceOfFullTrackResponse: instanceOfFullTrackResponse,
  FullTrackResponseFromJSON: FullTrackResponseFromJSON,
  FullTrackResponseFromJSONTyped: FullTrackResponseFromJSONTyped,
  FullTrackResponseToJSON: FullTrackResponseToJSON,
  instanceOfFullTracks: instanceOfFullTracks,
  FullTracksFromJSON: FullTracksFromJSON,
  FullTracksFromJSONTyped: FullTracksFromJSONTyped,
  FullTracksToJSON: FullTracksToJSON,
  instanceOfFullTracksResponse: instanceOfFullTracksResponse,
  FullTracksResponseFromJSON: FullTracksResponseFromJSON,
  FullTracksResponseFromJSONTyped: FullTracksResponseFromJSONTyped,
  FullTracksResponseToJSON: FullTracksResponseToJSON,
  instanceOfFullTrendingPlaylistsResponse: instanceOfFullTrendingPlaylistsResponse,
  FullTrendingPlaylistsResponseFromJSON: FullTrendingPlaylistsResponseFromJSON,
  FullTrendingPlaylistsResponseFromJSONTyped: FullTrendingPlaylistsResponseFromJSONTyped,
  FullTrendingPlaylistsResponseToJSON: FullTrendingPlaylistsResponseToJSON,
  instanceOfFullUserResponse: instanceOfFullUserResponse,
  FullUserResponseFromJSON: FullUserResponseFromJSON,
  FullUserResponseFromJSONTyped: FullUserResponseFromJSONTyped,
  FullUserResponseToJSON: FullUserResponseToJSON,
  instanceOfGetTipsResponse: instanceOfGetTipsResponse,
  GetTipsResponseFromJSON: GetTipsResponseFromJSON,
  GetTipsResponseFromJSONTyped: GetTipsResponseFromJSONTyped,
  GetTipsResponseToJSON: GetTipsResponseToJSON,
  instanceOfHistoryResponseFull: instanceOfHistoryResponseFull,
  HistoryResponseFullFromJSON: HistoryResponseFullFromJSON,
  HistoryResponseFullFromJSONTyped: HistoryResponseFullFromJSONTyped,
  HistoryResponseFullToJSON: HistoryResponseFullToJSON,
  instanceOfPlaylistAddedTimestamp: instanceOfPlaylistAddedTimestamp,
  PlaylistAddedTimestampFromJSON: PlaylistAddedTimestampFromJSON,
  PlaylistAddedTimestampFromJSONTyped: PlaylistAddedTimestampFromJSONTyped,
  PlaylistAddedTimestampToJSON: PlaylistAddedTimestampToJSON,
  instanceOfPlaylistArtwork: instanceOfPlaylistArtwork,
  PlaylistArtworkFromJSON: PlaylistArtworkFromJSON,
  PlaylistArtworkFromJSONTyped: PlaylistArtworkFromJSONTyped,
  PlaylistArtworkToJSON: PlaylistArtworkToJSON,
  instanceOfPlaylistFull: instanceOfPlaylistFull,
  PlaylistFullFromJSON: PlaylistFullFromJSON,
  PlaylistFullFromJSONTyped: PlaylistFullFromJSONTyped,
  PlaylistFullToJSON: PlaylistFullToJSON,
  instanceOfPlaylistFullWithoutTracks: instanceOfPlaylistFullWithoutTracks,
  PlaylistFullWithoutTracksFromJSON: PlaylistFullWithoutTracksFromJSON,
  PlaylistFullWithoutTracksFromJSONTyped: PlaylistFullWithoutTracksFromJSONTyped,
  PlaylistFullWithoutTracksToJSON: PlaylistFullWithoutTracksToJSON,
  instanceOfPlaylistLibrary: instanceOfPlaylistLibrary,
  PlaylistLibraryFromJSON: PlaylistLibraryFromJSON,
  PlaylistLibraryFromJSONTyped: PlaylistLibraryFromJSONTyped,
  PlaylistLibraryToJSON: PlaylistLibraryToJSON,
  instanceOfPremiumContentSignature: instanceOfPremiumContentSignature,
  PremiumContentSignatureFromJSON: PremiumContentSignatureFromJSON,
  PremiumContentSignatureFromJSONTyped: PremiumContentSignatureFromJSONTyped,
  PremiumContentSignatureToJSON: PremiumContentSignatureToJSON,
  instanceOfProfilePicture: instanceOfProfilePicture,
  ProfilePictureFromJSON: ProfilePictureFromJSON,
  ProfilePictureFromJSONTyped: ProfilePictureFromJSONTyped,
  ProfilePictureToJSON: ProfilePictureToJSON,
  instanceOfRelatedArtistResponseFull: instanceOfRelatedArtistResponseFull,
  RelatedArtistResponseFullFromJSON: RelatedArtistResponseFullFromJSON,
  RelatedArtistResponseFullFromJSONTyped: RelatedArtistResponseFullFromJSONTyped,
  RelatedArtistResponseFullToJSON: RelatedArtistResponseFullToJSON,
  instanceOfRemixesResponse: instanceOfRemixesResponse,
  RemixesResponseFromJSON: RemixesResponseFromJSON,
  RemixesResponseFromJSONTyped: RemixesResponseFromJSONTyped,
  RemixesResponseToJSON: RemixesResponseToJSON,
  instanceOfRemixesResponseFull: instanceOfRemixesResponseFull,
  RemixesResponseFullFromJSON: RemixesResponseFullFromJSON,
  RemixesResponseFullFromJSONTyped: RemixesResponseFullFromJSONTyped,
  RemixesResponseFullToJSON: RemixesResponseFullToJSON,
  instanceOfRemixingResponse: instanceOfRemixingResponse,
  RemixingResponseFromJSON: RemixingResponseFromJSON,
  RemixingResponseFromJSONTyped: RemixingResponseFromJSONTyped,
  RemixingResponseToJSON: RemixingResponseToJSON,
  instanceOfRepost: instanceOfRepost,
  RepostFromJSON: RepostFromJSON,
  RepostFromJSONTyped: RepostFromJSONTyped,
  RepostToJSON: RepostToJSON,
  instanceOfSearchAutocompleteResponse: instanceOfSearchAutocompleteResponse,
  SearchAutocompleteResponseFromJSON: SearchAutocompleteResponseFromJSON,
  SearchAutocompleteResponseFromJSONTyped: SearchAutocompleteResponseFromJSONTyped,
  SearchAutocompleteResponseToJSON: SearchAutocompleteResponseToJSON,
  instanceOfSearchFullResponse: instanceOfSearchFullResponse,
  SearchFullResponseFromJSON: SearchFullResponseFromJSON,
  SearchFullResponseFromJSONTyped: SearchFullResponseFromJSONTyped,
  SearchFullResponseToJSON: SearchFullResponseToJSON,
  instanceOfSearchModel: instanceOfSearchModel,
  SearchModelFromJSON: SearchModelFromJSON,
  SearchModelFromJSONTyped: SearchModelFromJSONTyped,
  SearchModelToJSON: SearchModelToJSON,
  instanceOfStemFull: instanceOfStemFull,
  StemFullFromJSON: StemFullFromJSON,
  StemFullFromJSONTyped: StemFullFromJSONTyped,
  StemFullToJSON: StemFullToJSON,
  instanceOfStemParent: instanceOfStemParent,
  StemParentFromJSON: StemParentFromJSON,
  StemParentFromJSONTyped: StemParentFromJSONTyped,
  StemParentToJSON: StemParentToJSON,
  instanceOfStemsResponse: instanceOfStemsResponse,
  StemsResponseFromJSON: StemsResponseFromJSON,
  StemsResponseFromJSONTyped: StemsResponseFromJSONTyped,
  StemsResponseToJSON: StemsResponseToJSON,
  instanceOfSupporterReference: instanceOfSupporterReference,
  SupporterReferenceFromJSON: SupporterReferenceFromJSON,
  SupporterReferenceFromJSONTyped: SupporterReferenceFromJSONTyped,
  SupporterReferenceToJSON: SupporterReferenceToJSON,
  instanceOfTopGenreUsersResponseFull: instanceOfTopGenreUsersResponseFull,
  TopGenreUsersResponseFullFromJSON: TopGenreUsersResponseFullFromJSON,
  TopGenreUsersResponseFullFromJSONTyped: TopGenreUsersResponseFullFromJSONTyped,
  TopGenreUsersResponseFullToJSON: TopGenreUsersResponseFullToJSON,
  instanceOfTopUsersResponseFull: instanceOfTopUsersResponseFull,
  TopUsersResponseFullFromJSON: TopUsersResponseFullFromJSON,
  TopUsersResponseFullFromJSONTyped: TopUsersResponseFullFromJSONTyped,
  TopUsersResponseFullToJSON: TopUsersResponseFullToJSON,
  instanceOfTrackActivityFull: instanceOfTrackActivityFull,
  TrackActivityFullFromJSON: TrackActivityFullFromJSON,
  TrackActivityFullFromJSONTyped: TrackActivityFullFromJSONTyped,
  TrackActivityFullToJSON: TrackActivityFullToJSON,
  instanceOfTrackArtwork: instanceOfTrackArtwork,
  TrackArtworkFromJSON: TrackArtworkFromJSON,
  TrackArtworkFromJSONTyped: TrackArtworkFromJSONTyped,
  TrackArtworkToJSON: TrackArtworkToJSON,
  instanceOfTrackFavoritesResponseFull: instanceOfTrackFavoritesResponseFull,
  TrackFavoritesResponseFullFromJSON: TrackFavoritesResponseFullFromJSON,
  TrackFavoritesResponseFullFromJSONTyped: TrackFavoritesResponseFullFromJSONTyped,
  TrackFavoritesResponseFullToJSON: TrackFavoritesResponseFullToJSON,
  instanceOfTrackFull: instanceOfTrackFull,
  TrackFullFromJSON: TrackFullFromJSON,
  TrackFullFromJSONTyped: TrackFullFromJSONTyped,
  TrackFullToJSON: TrackFullToJSON,
  instanceOfTrackId: instanceOfTrackId,
  TrackIdFromJSON: TrackIdFromJSON,
  TrackIdFromJSONTyped: TrackIdFromJSONTyped,
  TrackIdToJSON: TrackIdToJSON,
  instanceOfTrackLibraryResponseFull: instanceOfTrackLibraryResponseFull,
  TrackLibraryResponseFullFromJSON: TrackLibraryResponseFullFromJSON,
  TrackLibraryResponseFullFromJSONTyped: TrackLibraryResponseFullFromJSONTyped,
  TrackLibraryResponseFullToJSON: TrackLibraryResponseFullToJSON,
  instanceOfTrackRepostsResponseFull: instanceOfTrackRepostsResponseFull,
  TrackRepostsResponseFullFromJSON: TrackRepostsResponseFullFromJSON,
  TrackRepostsResponseFullFromJSONTyped: TrackRepostsResponseFullFromJSONTyped,
  TrackRepostsResponseFullToJSON: TrackRepostsResponseFullToJSON,
  instanceOfTrackSegment: instanceOfTrackSegment,
  TrackSegmentFromJSON: TrackSegmentFromJSON,
  TrackSegmentFromJSONTyped: TrackSegmentFromJSONTyped,
  TrackSegmentToJSON: TrackSegmentToJSON,
  instanceOfTransactionDetails: instanceOfTransactionDetails,
  TransactionDetailsFromJSON: TransactionDetailsFromJSON,
  TransactionDetailsFromJSONTyped: TransactionDetailsFromJSONTyped,
  TransactionDetailsToJSON: TransactionDetailsToJSON,
  instanceOfTransactionHistoryCountResponse: instanceOfTransactionHistoryCountResponse,
  TransactionHistoryCountResponseFromJSON: TransactionHistoryCountResponseFromJSON,
  TransactionHistoryCountResponseFromJSONTyped: TransactionHistoryCountResponseFromJSONTyped,
  TransactionHistoryCountResponseToJSON: TransactionHistoryCountResponseToJSON,
  instanceOfTransactionHistoryResponse: instanceOfTransactionHistoryResponse,
  TransactionHistoryResponseFromJSON: TransactionHistoryResponseFromJSON,
  TransactionHistoryResponseFromJSONTyped: TransactionHistoryResponseFromJSONTyped,
  TransactionHistoryResponseToJSON: TransactionHistoryResponseToJSON,
  instanceOfTrendingIdsResponse: instanceOfTrendingIdsResponse,
  TrendingIdsResponseFromJSON: TrendingIdsResponseFromJSON,
  TrendingIdsResponseFromJSONTyped: TrendingIdsResponseFromJSONTyped,
  TrendingIdsResponseToJSON: TrendingIdsResponseToJSON,
  instanceOfTrendingTimesIds: instanceOfTrendingTimesIds,
  TrendingTimesIdsFromJSON: TrendingTimesIdsFromJSON,
  TrendingTimesIdsFromJSONTyped: TrendingTimesIdsFromJSONTyped,
  TrendingTimesIdsToJSON: TrendingTimesIdsToJSON,
  instanceOfUserFull: instanceOfUserFull,
  UserFullFromJSON: UserFullFromJSON,
  UserFullFromJSONTyped: UserFullFromJSONTyped,
  UserFullToJSON: UserFullToJSON,
  instanceOfUserReplicaSet: instanceOfUserReplicaSet,
  UserReplicaSetFromJSON: UserReplicaSetFromJSON,
  UserReplicaSetFromJSONTyped: UserReplicaSetFromJSONTyped,
  UserReplicaSetToJSON: UserReplicaSetToJSON,
  instanceOfUserSubscribers: instanceOfUserSubscribers,
  UserSubscribersFromJSON: UserSubscribersFromJSON,
  UserSubscribersFromJSONTyped: UserSubscribersFromJSONTyped,
  UserSubscribersToJSON: UserSubscribersToJSON,
  instanceOfUsersByContentNode: instanceOfUsersByContentNode,
  UsersByContentNodeFromJSON: UsersByContentNodeFromJSON,
  UsersByContentNodeFromJSONTyped: UsersByContentNodeFromJSONTyped,
  UsersByContentNodeToJSON: UsersByContentNodeToJSON,
  instanceOfVersionMetadata: instanceOfVersionMetadata,
  VersionMetadataFromJSON: VersionMetadataFromJSON,
  VersionMetadataFromJSONTyped: VersionMetadataFromJSONTyped,
  VersionMetadataToJSON: VersionMetadataToJSON
});

var appName;
/**
 * Appends the configured app_name to the query string for tracking API usage
 * @param options the middleware options
 * @param {string} options.appName the name of the app using the SDK
 */

var addAppNameMiddleware = function addAppNameMiddleware(_ref) {
  var providedAppName = _ref.appName,
      services = _ref.services;
  appName = providedAppName;
  return {
    pre: function () {
      var _pre = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(context) {
        var _appName, _context$init;

        var _yield$developerApps$, middleware, apiClientConfig, developerApps;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (appName) {
                  _context.next = 21;
                  break;
                }

                middleware = [services.discoveryNodeSelector.createMiddleware()];
                apiClientConfig = new Configuration$1({
                  fetchApi: fetch__default["default"],
                  middleware: middleware
                });
                developerApps = new DeveloperAppsApi(apiClientConfig, services.entityManager, services.auth);
                _context.t1 = developerApps;
                _context.next = 7;
                return services.auth.getAddress();

              case 7:
                _context.t2 = _context.sent;
                _context.t3 = {
                  address: _context.t2
                };
                _context.next = 11;
                return _context.t1.getDeveloperApp.call(_context.t1, _context.t3);

              case 11:
                _context.t4 = _yield$developerApps$ = _context.sent.data;
                _context.t0 = _context.t4 === null;

                if (_context.t0) {
                  _context.next = 15;
                  break;
                }

                _context.t0 = _yield$developerApps$ === void 0;

              case 15:
                if (!_context.t0) {
                  _context.next = 19;
                  break;
                }

                _context.t5 = void 0;
                _context.next = 20;
                break;

              case 19:
                _context.t5 = _yield$developerApps$.name;

              case 20:
                appName = _context.t5;

              case 21:
                return _context.abrupt("return", {
                  url: context.url + (context.url.includes('?') ? '&' : '?') + querystring$1({
                    app_name: (_appName = appName) !== null && _appName !== void 0 ? _appName : ''
                  }),
                  init: (_context$init = context.init) !== null && _context$init !== void 0 ? _context$init : {}
                });

              case 22:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function pre(_x) {
        return _pre.apply(this, arguments);
      }

      return pre;
    }()
  };
};

exports.DECISION_TREE_STATE = void 0;

(function (DECISION_TREE_STATE) {
  DECISION_TREE_STATE["CHECK_SHORT_CIRCUIT"] = "Check Short Circuit";
  DECISION_TREE_STATE["GET_ALL_SERVICES"] = "Get All Services";
  DECISION_TREE_STATE["FILTER_TO_WHITELIST"] = "Filter To Whitelist";
  DECISION_TREE_STATE["FILTER_FROM_BLACKLIST"] = "Filter From Blacklist";
  DECISION_TREE_STATE["FILTER_OUT_KNOWN_UNHEALTHY"] = "Filter Out Known Unhealthy";
  DECISION_TREE_STATE["GET_SELECTION_ROUND"] = "Get Selection Round";
  DECISION_TREE_STATE["NO_SERVICES_LEFT_TO_TRY"] = "No Services Left To Try";
  DECISION_TREE_STATE["SELECTED_FROM_BACKUP"] = "Selected From Backup";
  DECISION_TREE_STATE["FAILED_AND_RESETTING"] = "Failed Everything -- Resetting";
  DECISION_TREE_STATE["ROUND_FAILED_RETRY"] = "Round Failed Retry";
  DECISION_TREE_STATE["MADE_A_SELECTION"] = "Made A Selection";
  DECISION_TREE_STATE["RACED_AND_FOUND_BEST"] = "Raced And Found Best";
})(exports.DECISION_TREE_STATE || (exports.DECISION_TREE_STATE = {}));

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */

function baseClamp$2(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }

    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }

  return number;
}

var _baseClamp = baseClamp$2;

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */

function copyArray$2(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

var _copyArray = copyArray$2;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeRandom = Math.random;
/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */

function baseRandom$1(lower, upper) {
  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}

var _baseRandom = baseRandom$1;

var baseRandom = _baseRandom;
/**
 * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @param {number} [size=array.length] The size of `array`.
 * @returns {Array} Returns `array`.
 */

function shuffleSelf$2(array, size) {
  var index = -1,
      length = array.length,
      lastIndex = length - 1;
  size = size === undefined ? length : size;

  while (++index < size) {
    var rand = baseRandom(index, lastIndex),
        value = array[rand];
    array[rand] = array[index];
    array[index] = value;
  }

  array.length = size;
  return array;
}

var _shuffleSelf = shuffleSelf$2;

var baseClamp$1 = _baseClamp,
    copyArray$1 = _copyArray,
    shuffleSelf$1 = _shuffleSelf;
/**
 * A specialized version of `_.sampleSize` for arrays.
 *
 * @private
 * @param {Array} array The array to sample.
 * @param {number} n The number of elements to sample.
 * @returns {Array} Returns the random elements.
 */

function arraySampleSize$1(array, n) {
  return shuffleSelf$1(copyArray$1(array), baseClamp$1(n, 0, array.length));
}

var _arraySampleSize = arraySampleSize$1;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

function arrayMap$1(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

var _arrayMap = arrayMap$1;

var arrayMap = _arrayMap;
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */

function baseValues$1(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

var _baseValues = baseValues$1;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */

function baseTimes$1(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

var _baseTimes = baseTimes$1;

var freeGlobal$1 = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;

var freeGlobal = _freeGlobal;
/** Detect free variable `self`. */

var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root$4 = freeGlobal || freeSelf || Function('return this')();
var _root = root$4;

var root$3 = _root;
/** Built-in value references. */

var _Symbol2 = root$3.Symbol;
var _Symbol$2 = _Symbol2;

var _Symbol$1 = _Symbol$2;
/** Used for built-in method references. */

var objectProto$b = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString$1 = objectProto$b.toString;
/** Built-in value references. */

var symToStringTag$1 = _Symbol$1 ? _Symbol$1.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag$1(value) {
  var isOwn = hasOwnProperty$9.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }

  return result;
}

var _getRawTag = getRawTag$1;

/** Used for built-in method references. */
var objectProto$a = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto$a.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString$1(value) {
  return nativeObjectToString.call(value);
}

var _objectToString = objectToString$1;

var _Symbol = _Symbol$2,
    getRawTag = _getRawTag,
    objectToString = _objectToString;
/** `Object#toString` result references. */

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag$5(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

var _baseGetTag = baseGetTag$5;

function isObjectLike$6(value) {
  return value != null && _typeof(value) == 'object';
}

var isObjectLike_1 = isObjectLike$6;

var baseGetTag$4 = _baseGetTag,
    isObjectLike$5 = isObjectLike_1;
/** `Object#toString` result references. */

var argsTag$1 = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments$1(value) {
  return isObjectLike$5(value) && baseGetTag$4(value) == argsTag$1;
}

var _baseIsArguments = baseIsArguments$1;

var baseIsArguments = _baseIsArguments,
    isObjectLike$4 = isObjectLike_1;
/** Used for built-in method references. */

var objectProto$9 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto$9.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments$2 = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike$4(value) && hasOwnProperty$8.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
var isArguments_1 = isArguments$2;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$3 = Array.isArray;
var isArray_1 = isArray$3;

var isBuffer$2 = {exports: {}};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */

function stubFalse() {
  return false;
}

var stubFalse_1 = stubFalse;

(function (module, exports) {
  var root = _root,
      stubFalse = stubFalse_1;
  /** Detect free variable `exports`. */

  var freeExports = exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Built-in value references. */

  var Buffer = moduleExports ? root.Buffer : undefined;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */

  var isBuffer = nativeIsBuffer || stubFalse;
  module.exports = isBuffer;
})(isBuffer$2, isBuffer$2.exports);

var MAX_SAFE_INTEGER$1 = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex$2(value, length) {
  var type = _typeof(value);

  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

var _isIndex = isIndex$2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength$2(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

var isLength_1 = isLength$2;

var baseGetTag$3 = _baseGetTag,
    isLength$1 = isLength_1,
    isObjectLike$3 = isObjectLike_1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag$1 = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray$1(value) {
  return isObjectLike$3(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$3(value)];
}

var _baseIsTypedArray = baseIsTypedArray$1;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */

function baseUnary$1(func) {
  return function (value) {
    return func(value);
  };
}

var _baseUnary = baseUnary$1;

var _nodeUtil = {exports: {}};

(function (module, exports) {
  var freeGlobal = _freeGlobal;
  /** Detect free variable `exports`. */

  var freeExports = exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Detect free variable `process` from Node.js. */

  var freeProcess = moduleExports && freeGlobal.process;
  /** Used to access faster Node.js helpers. */

  var nodeUtil = function () {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      } // Legacy `process.binding('util')` for Node.js < 10.


      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();

  module.exports = nodeUtil;
})(_nodeUtil, _nodeUtil.exports);

var baseIsTypedArray = _baseIsTypedArray,
    baseUnary = _baseUnary,
    nodeUtil = _nodeUtil.exports;
/* Node.js helper references. */

var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;

var baseTimes = _baseTimes,
    isArguments$1 = isArguments_1,
    isArray$2 = isArray_1,
    isBuffer$1 = isBuffer$2.exports,
    isIndex$1 = _isIndex,
    isTypedArray$1 = isTypedArray_1;
/** Used for built-in method references. */

var objectProto$8 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$2(value),
      isArg = !isArr && isArguments$1(value),
      isBuff = !isArr && !isArg && isBuffer$1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex$1(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

var _arrayLikeKeys = arrayLikeKeys$2;

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype$3(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$7;
  return value === proto;
}

var _isPrototype = isPrototype$3;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */

function overArg$2(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

var _overArg = overArg$2;

var overArg$1 = _overArg;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;

var isPrototype$2 = _isPrototype,
    nativeKeys = _nativeKeys;
/** Used for built-in method references. */

var objectProto$6 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys$1(object) {
  if (!isPrototype$2(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty$6.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

var _baseKeys = baseKeys$1;

function isObject$8(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject$8;

var baseGetTag$2 = _baseGetTag,
    isObject$7 = isObject_1;
/** `Object#toString` result references. */

var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction$3(value) {
  if (!isObject$7(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag$2(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

var isFunction_1 = isFunction$3;

var isFunction$2 = isFunction_1,
    isLength = isLength_1;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike$4(value) {
  return value != null && isLength(value.length) && !isFunction$2(value);
}

var isArrayLike_1 = isArrayLike$4;

var arrayLikeKeys$1 = _arrayLikeKeys,
    baseKeys = _baseKeys,
    isArrayLike$3 = isArrayLike_1;
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */

function keys$1(object) {
  return isArrayLike$3(object) ? arrayLikeKeys$1(object) : baseKeys(object);
}

var keys_1 = keys$1;

var baseValues = _baseValues,
    keys = keys_1;
/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */

function values$1(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

var values_1 = values$1;

var baseClamp = _baseClamp,
    shuffleSelf = _shuffleSelf,
    values = values_1;
/**
 * The base implementation of `_.sampleSize` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to sample.
 * @param {number} n The number of elements to sample.
 * @returns {Array} Returns the random elements.
 */

function baseSampleSize$1(collection, n) {
  var array = values(collection);
  return shuffleSelf(array, baseClamp(n, 0, array.length));
}

var _baseSampleSize = baseSampleSize$1;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */

function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}

var eq_1 = eq$4;

var eq$3 = eq_1,
    isArrayLike$2 = isArrayLike_1,
    isIndex = _isIndex,
    isObject$6 = isObject_1;
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */

function isIterateeCall$2(value, index, object) {
  if (!isObject$6(object)) {
    return false;
  }

  var type = _typeof(index);

  if (type == 'number' ? isArrayLike$2(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq$3(object[index], value);
  }

  return false;
}

var _isIterateeCall = isIterateeCall$2;

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */

function trimmedEndIndex$1(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}

  return index;
}

var _trimmedEndIndex = trimmedEndIndex$1;

var trimmedEndIndex = _trimmedEndIndex;
/** Used to match leading whitespace. */

var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */

function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
}

var _baseTrim = baseTrim$1;

var baseGetTag$1 = _baseGetTag,
    isObjectLike$2 = isObjectLike_1;
/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol$1(value) {
  return _typeof(value) == 'symbol' || isObjectLike$2(value) && baseGetTag$1(value) == symbolTag;
}

var isSymbol_1 = isSymbol$1;

var baseTrim = _baseTrim,
    isObject$5 = isObject_1,
    isSymbol = isSymbol_1;
/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */

function toNumber$1(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject$5(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject$5(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

var toNumber_1 = toNumber$1;

var toNumber = toNumber_1;
/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */

function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }

  value = toNumber(value);

  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }

  return value === value ? value : 0;
}

var toFinite_1 = toFinite$1;

var toFinite = toFinite_1;
/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */

function toInteger$1(value) {
  var result = toFinite(value),
      remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}

var toInteger_1 = toInteger$1;

var arraySampleSize = _arraySampleSize,
    baseSampleSize = _baseSampleSize,
    isArray$1 = isArray_1,
    isIterateeCall$1 = _isIterateeCall,
    toInteger = toInteger_1;
/**
 * Gets `n` random elements at unique keys from `collection` up to the
 * size of `collection`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to sample.
 * @param {number} [n=1] The number of elements to sample.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the random elements.
 * @example
 *
 * _.sampleSize([1, 2, 3], 2);
 * // => [3, 1]
 *
 * _.sampleSize([1, 2, 3], 4);
 * // => [2, 3, 1]
 */

function sampleSize(collection, n, guard) {
  if (guard ? isIterateeCall$1(collection, n, guard) : n === undefined) {
    n = 1;
  } else {
    n = toInteger(n);
  }

  var func = isArray$1(collection) ? arraySampleSize : baseSampleSize;
  return func(collection, n);
}

var sampleSize_1 = sampleSize;

var HealthCheckStatus;

(function (HealthCheckStatus) {
  HealthCheckStatus["UNHEALTHY"] = "unhealthy";
  HealthCheckStatus["BEHIND"] = "behind";
  HealthCheckStatus["HEALTHY"] = "healthy";
})(HealthCheckStatus || (HealthCheckStatus = {}));

var servicesConfig$2 = {
  "minVersion": "0.0.0",
  "discoveryNodes": ["http://audius-protocol-discovery-provider-1"],
  "storageNodes": [{
    "delegateOwnerWallet": "0x0D38e653eC28bdea5A2296fD5940aaB2D0B8875c",
    "endpoint": "http://audius-protocol-creator-node-1"
  }],
  "entityManagerContractAddress": "0x254dffcd3277C0b1660F6d42EFbB754edaBAbC2B",
  "web3ProviderUrl": "http://audius-protocol-poa-ganache-1",
  "identityServiceUrl": "http://audius-protocol-identity-service-1"
};

var servicesConfig$1 = {
  "minVersion": "0.3.83",
  "discoveryNodes": ["https://discoveryprovider2.staging.audius.co", "https://discoveryprovider3.staging.audius.co", "https://discoveryprovider.staging.audius.co", "https://discoveryprovider5.staging.audius.co"],
  "storageNodes": [{
    "endpoint": "https://usermetadata.staging.audius.co",
    "delegateOwnerWallet": "0x671ddce7B4E676C9467F87e4031a917b5D6f75F0"
  }, {
    "endpoint": "https://creatornode5.staging.audius.co",
    "delegateOwnerWallet": "0xDC2BDF1F23381CA2eC9e9c70D4FD96CD8645D090"
  }, {
    "endpoint": "https://creatornode6.staging.audius.co",
    "delegateOwnerWallet": "0x68039d001D87E7A5E6B06fe0825EA7871C1Cd6C2"
  }, {
    "endpoint": "https://creatornode7.staging.audius.co",
    "delegateOwnerWallet": "0x1F8e7aF58086992Ef4c4fc0371446974BBbC0D9F"
  }, {
    "endpoint": "https://creatornode8.staging.audius.co",
    "delegateOwnerWallet": "0x8fcFA10Bd3808570987dbb5B1EF4AB74400FbfDA"
  }, {
    "endpoint": "https://creatornode9.staging.audius.co",
    "delegateOwnerWallet": "0x140eD283b33be2145ed7d9d15f1fE7bF1E0B2Ac3"
  }, {
    "endpoint": "https://creatornode10.staging.audius.co",
    "delegateOwnerWallet": "0xf7C96916bd37Ad76D4EEDd6536B81c29706C8056"
  }, {
    "endpoint": "https://creatornode11.staging.audius.co",
    "delegateOwnerWallet": "0x4c88d2c0f4c4586b41621aD6e98882ae904B98f6"
  }],
  "web3ProviderUrl": "https://poa-gateway.staging.audius.co",
  "entityManagerContractAddress": "0x1Cd8a543596D499B9b6E7a6eC15ECd2B7857Fd64",
  "identityServiceUrl": "https://identityservice.staging.audius.co"
};

var servicesConfig = {
  "minVersion": "0.3.85",
  "discoveryNodes": ["https://audius-metadata-1.figment.io", "https://audius-metadata-2.figment.io", "https://audius-discovery-1.altego.net", "https://audius-disco.ams-x01.nl.supercache.org", "https://dn-jpn.audius.metadata.fyi", "https://discoveryprovider3.audius.co", "https://discoveryprovider2.audius.co", "https://discoveryprovider.audius.co", "https://audius-metadata-3.figment.io", "https://audius-metadata-4.figment.io", "https://dn1.monophonic.digital", "https://dn-usa.audius.metadata.fyi", "https://discovery-us-01.audius.openplayer.org", "https://dn2.monophonic.digital", "https://audius-discovery-2.altego.net", "https://dn1.nodeoperator.io", "https://audius-disco.dfw-x02.us.supercache.org", "https://audius-discovery-3.altego.net", "https://dn1.matterlightblooming.xyz", "https://audius-dp.singapore.creatorseed.com", "https://discovery.grassfed.network", "https://audius-discovery-1.cultur3stake.com", "https://audius-discovery-3.cultur3stake.com", "https://audius-discovery-4.cultur3stake.com", "https://audius-discovery-5.cultur3stake.com", "https://audius-discovery-7.cultur3stake.com", "https://audius-discovery-8.cultur3stake.com", "https://audius-discovery-9.cultur3stake.com", "https://audius-discovery-10.cultur3stake.com", "https://discovery-au-02.audius.openplayer.org", "https://disc-lon01.audius.hashbeam.com", "https://audius-dp.amsterdam.creatorseed.com", "https://blockdaemon-audius-discovery-01.bdnodes.net", "https://blockdaemon-audius-discovery-02.bdnodes.net", "https://blockdaemon-audius-discovery-03.bdnodes.net", "https://blockdaemon-audius-discovery-04.bdnodes.net", "https://blockdaemon-audius-discovery-05.bdnodes.net", "https://blockdaemon-audius-discovery-06.bdnodes.net", "https://blockdaemon-audius-discovery-07.bdnodes.net", "https://blockchange-audius-discovery-01.bdnodes.net", "https://blockchange-audius-discovery-02.bdnodes.net", "https://blockchange-audius-discovery-03.bdnodes.net", "https://audius-discovery-11.cultur3stake.com", "https://audius-discovery-12.cultur3stake.com", "https://audius-discovery-13.cultur3stake.com", "https://audius-discovery-14.cultur3stake.com", "https://audius-discovery-16.cultur3stake.com", "https://audius-discovery-18.cultur3stake.com", "https://audius-discovery-17.cultur3stake.com", "https://audius-discovery-15.cultur3stake.com", "https://audius-discovery-6.cultur3stake.com", "https://audius-discovery-2.cultur3stake.com", "https://blockdaemon-audius-discovery-08.bdnodes.net", "https://audius-metadata-5.figment.io", "https://dn1.stuffisup.com", "https://audius-discovery-1.theblueprint.xyz", "https://audius-discovery-2.theblueprint.xyz", "https://audius-discovery-3.theblueprint.xyz", "https://audius-discovery-4.theblueprint.xyz", "https://audius.w3coins.io"],
  "storageNodes": [{
    "endpoint": "https://creatornode.audius.co",
    "delegateOwnerWallet": "0xc8d0C29B6d540295e8fc8ac72456F2f4D41088c8"
  }, {
    "endpoint": "https://creatornode2.audius.co",
    "delegateOwnerWallet": "0xf686647E3737d595C60c6DE2f5F90463542FE439"
  }, {
    "endpoint": "https://creatornode3.audius.co",
    "delegateOwnerWallet": "0x0C32BE6328578E99b6F06E0e7A6B385EB8FC13d1"
  }, {
    "endpoint": "https://content-node.audius.co",
    "delegateOwnerWallet": "0xC892c75Fa17e8b641a4843D0aa620792857d217A"
  }, {
    "endpoint": "https://audius-content-1.figment.io",
    "delegateOwnerWallet": "0xBfdE9a7DD3620CB6428463E9A9e9932B4d10fdc5"
  }, {
    "endpoint": "https://creatornode.audius.prod-us-west-2.staked.cloud",
    "delegateOwnerWallet": "0x675086B880260D217963cF14F503272AEb44b2E9"
  }, {
    "endpoint": "https://audius-content-2.figment.io",
    "delegateOwnerWallet": "0x6444212FFc23a4CcF7460f8Fe6D0e6074db59036"
  }, {
    "endpoint": "https://audius-content-3.figment.io",
    "delegateOwnerWallet": "0xECEDCaABecb40ef4bE733BA47FaD612aeA1F396F"
  }, {
    "endpoint": "https://audius-content-4.figment.io",
    "delegateOwnerWallet": "0x08fEF3884Db16E2E6211272cdC9Eee68E8b63b09"
  }, {
    "endpoint": "https://audius-content-5.figment.io",
    "delegateOwnerWallet": "0x10fF8197f2e94eF880d940D2414E0A14983c3bFE"
  }, {
    "endpoint": "https://creatornode.audius1.prod-us-west-2.staked.cloud",
    "delegateOwnerWallet": "0xC23Ee959E0B22a9B0F5dF18D7e7875cA4B6c4236"
  }, {
    "endpoint": "https://creatornode.audius2.prod-us-west-2.staked.cloud",
    "delegateOwnerWallet": "0x51a5575dc04c1f5f2e39390d090aaf78554F5f7B"
  }, {
    "endpoint": "https://creatornode.audius3.prod-us-west-2.staked.cloud",
    "delegateOwnerWallet": "0xe0b56BAe2276E016d3DB314Dd7374e596B0457ac"
  }, {
    "endpoint": "https://audius-content-6.figment.io",
    "delegateOwnerWallet": "0x68a4Bd6b4177ffB025AF9844cBE4Fe31348AEE1D"
  }, {
    "endpoint": "https://audius-content-7.figment.io",
    "delegateOwnerWallet": "0xf45a6DBf3ce0201F4012a19b1fB04D4f05B53a37"
  }, {
    "endpoint": "https://audius-content-8.figment.io",
    "delegateOwnerWallet": "0x9708Fb04DeA029212126255B311a21F1F884cCB4"
  }, {
    "endpoint": "https://usermetadata.audius.co",
    "delegateOwnerWallet": "0xD7E6Fe145874E6c2648F012379699c694b183A2c"
  }, {
    "endpoint": "https://audius-content-9.figment.io",
    "delegateOwnerWallet": "0x7c34c9709ed69513D55dF2020e799DA44fC52E6e"
  }, {
    "endpoint": "https://audius-content-10.figment.io",
    "delegateOwnerWallet": "0xff753331CEa586DD5B23bd21222a3c902909F2dd"
  }, {
    "endpoint": "https://audius-content-11.figment.io",
    "delegateOwnerWallet": "0xC9721F892BcC8822eb34237E875BE93904f11073"
  }, {
    "endpoint": "https://audius.prod.capturealpha.io",
    "delegateOwnerWallet": "0x0A5AEA27A7fB95b51056Df6AaD7fe7E9116eC9B4"
  }, {
    "endpoint": "https://content.grassfed.network",
    "delegateOwnerWallet": "0x33Ab85445c8A2690B9488e9fB5E6A9849d3a18d3"
  }, {
    "endpoint": "https://blockdaemon-audius-content-01.bdnodes.net",
    "delegateOwnerWallet": "0x807C0fba7405aeb8b6a37A974df6259C6aB9bB1e"
  }, {
    "endpoint": "https://audius-content-1.cultur3stake.com",
    "delegateOwnerWallet": "0xCEb6a23d6132Cfe329b3c8E3c45f9DDc28A62Bd4"
  }, {
    "endpoint": "https://audius-content-2.cultur3stake.com",
    "delegateOwnerWallet": "0x2e9e7A4e35C3136fB651a0dBF8f91c9f5C27BBf7"
  }, {
    "endpoint": "https://audius-content-3.cultur3stake.com",
    "delegateOwnerWallet": "0x742da6cAc2782FeA961bB7B9150a048F5167D1e1"
  }, {
    "endpoint": "https://audius-content-4.cultur3stake.com",
    "delegateOwnerWallet": "0xcbb0cE7481685587b0988195Ff0cD6AA1A701657"
  }, {
    "endpoint": "https://audius-content-5.cultur3stake.com",
    "delegateOwnerWallet": "0xFec4708155277D35d568aD6Ca322262577683584"
  }, {
    "endpoint": "https://audius-content-6.cultur3stake.com",
    "delegateOwnerWallet": "0x3Db0E61591063310eEd22fd57E6f7F1ab2Bb538E"
  }, {
    "endpoint": "https://audius-content-7.cultur3stake.com",
    "delegateOwnerWallet": "0xE6C00e7E8d582fD2856718a5439f1aeEB68e27E5"
  }, {
    "endpoint": "https://blockdaemon-audius-content-02.bdnodes.net",
    "delegateOwnerWallet": "0x4Ad694B3fC34b3cC245aF6AA7B43C52ddD0d7AAE"
  }, {
    "endpoint": "https://blockdaemon-audius-content-03.bdnodes.net",
    "delegateOwnerWallet": "0x8ea81225013719950E968DE0602c4Eca458fA9f4"
  }, {
    "endpoint": "https://blockdaemon-audius-content-04.bdnodes.net",
    "delegateOwnerWallet": "0xcfFA8ACF0b04d9278eEE13928be264b2E9aaab97"
  }, {
    "endpoint": "https://blockdaemon-audius-content-05.bdnodes.net",
    "delegateOwnerWallet": "0xB4Ff0cab630FB05a7fcEfec9E979a968b8f4fE55"
  }, {
    "endpoint": "https://blockdaemon-audius-content-06.bdnodes.net",
    "delegateOwnerWallet": "0x7449da7d1548C11c481b87667EC9b2A8F20C13A0"
  }, {
    "endpoint": "https://blockdaemon-audius-content-07.bdnodes.net",
    "delegateOwnerWallet": "0x00B1CA1A34257860f66e742eF163Ad30bF42d075"
  }, {
    "endpoint": "https://blockdaemon-audius-content-08.bdnodes.net",
    "delegateOwnerWallet": "0x16650eDB44C720ea627d5a59ff0b4f74c37fe419"
  }, {
    "endpoint": "https://blockdaemon-audius-content-09.bdnodes.net",
    "delegateOwnerWallet": "0xD5Cfcf4149c683516239fc653D5a470F3F4A606D"
  }, {
    "endpoint": "https://audius-content-8.cultur3stake.com",
    "delegateOwnerWallet": "0xff432F81D0eb77DA5973Cf55e24A897882fdd3E6"
  }, {
    "endpoint": "https://blockchange-audius-content-01.bdnodes.net",
    "delegateOwnerWallet": "0x8464c88502925a0076c381962F8B70b6EC892861"
  }, {
    "endpoint": "https://blockchange-audius-content-02.bdnodes.net",
    "delegateOwnerWallet": "0x5e0D0BeDC11F0B512457f6f707A35703b1447Fb5"
  }, {
    "endpoint": "https://blockchange-audius-content-03.bdnodes.net",
    "delegateOwnerWallet": "0xe3F1c416c3919bB2ffD78F1e38b9E81E8c80815F"
  }, {
    "endpoint": "https://audius-content-9.cultur3stake.com",
    "delegateOwnerWallet": "0xB6f506557B2e9026743FeA6157e52F204D26690F"
  }, {
    "endpoint": "https://audius-content-10.cultur3stake.com",
    "delegateOwnerWallet": "0x2AF4598D3CF95D8e76987c02BC8A8D71F58d49d5"
  }, {
    "endpoint": "https://audius-content-11.cultur3stake.com",
    "delegateOwnerWallet": "0xB2684Cca5281d2bA6D9Ce66Cca215635FF2Ba466"
  }, {
    "endpoint": "https://audius-content-12.cultur3stake.com",
    "delegateOwnerWallet": "0x28924C99822eA08bFCeDdE3a411308633948b349"
  }, {
    "endpoint": "https://audius-content-13.cultur3stake.com",
    "delegateOwnerWallet": "0xcb23908aa0dCDef762ebEaA38391D8fFC69E6e8F"
  }, {
    "endpoint": "https://audius-content-14.cultur3stake.com",
    "delegateOwnerWallet": "0xCbDa351492e52fdb2f0E7FBc440cA2047738b71C"
  }, {
    "endpoint": "https://audius-content-15.cultur3stake.com",
    "delegateOwnerWallet": "0x2fE2652296c40BB22D33C6379558Bf63A25b4f9a"
  }, {
    "endpoint": "https://audius-content-16.cultur3stake.com",
    "delegateOwnerWallet": "0x47367ED3Db5D9691d866cb09545DE7cccD571579"
  }, {
    "endpoint": "https://audius-content-17.cultur3stake.com",
    "delegateOwnerWallet": "0xb472c555Ab9eA1D33543383d6d1F8885c97eF83A"
  }, {
    "endpoint": "https://audius-content-18.cultur3stake.com",
    "delegateOwnerWallet": "0x4F62C17Dc54E58289354847974E1F246c8EAcf11"
  }, {
    "endpoint": "https://audius-content-12.figment.io",
    "delegateOwnerWallet": "0x780641e157621621658F118375dc1B36Ea514d46"
  }, {
    "endpoint": "https://cn0.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0xf9b373E223b73473C59034072263f52aEF60133B"
  }, {
    "endpoint": "https://cn1.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0x9b0D01bd7F01BD6916Ba139743Ce9C524B9375Dd"
  }, {
    "endpoint": "https://cn2.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0xf6e297203c0086dc229DAE17F5b61a15F42A1A00"
  }, {
    "endpoint": "https://cn3.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0x24C4b2cb6eC4c87a03F66723d8750dbe98Fa3e4f"
  }, {
    "endpoint": "https://audius-content-13.figment.io",
    "delegateOwnerWallet": "0x33a2da466B14990E0124383204b06F9196f62d8e"
  }, {
    "endpoint": "https://audius-content-14.figment.io",
    "delegateOwnerWallet": "0x817c513C1B702eA0BdD4F8C1204C60372f715006"
  }, {
    "endpoint": "https://cn4.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0x69e749266C59757dA81F8C659Be6B07ce5Bac6C9"
  }, {
    "endpoint": "https://audius-content-1.jollyworld.xyz",
    "delegateOwnerWallet": "0x125A9f40CFB329266ef415b9510D4E716Dba8Da6"
  }, {
    "endpoint": "https://audius-creator-1.theblueprint.xyz",
    "delegateOwnerWallet": "0x0E0aF7035581C615d07372be16D99A9B64E5B2e9"
  }, {
    "endpoint": "https://audius-creator-2.theblueprint.xyz",
    "delegateOwnerWallet": "0x3D0dD2Cd46c2658d228769f4a394662946A28987"
  }, {
    "endpoint": "https://audius-creator-3.theblueprint.xyz",
    "delegateOwnerWallet": "0x292B0d5987a7DE879909C48a54f0853C211da5f3"
  }, {
    "endpoint": "https://audius-creator-4.theblueprint.xyz",
    "delegateOwnerWallet": "0xA815f8108C2772D24D7DCB866c861148f043224D"
  }, {
    "endpoint": "https://audius-creator-5.theblueprint.xyz",
    "delegateOwnerWallet": "0x65Fe5BEf65A0E0b0520d6beE7767ea6Da7f792f6"
  }, {
    "endpoint": "https://audius-creator-6.theblueprint.xyz",
    "delegateOwnerWallet": "0x19B026B0f0Dbf619DBf8C4Efb0190308ace56366"
  }, {
    "endpoint": "https://creatornode.audius8.prod-eks-ap-northeast-1.staked.cloud",
    "delegateOwnerWallet": "0xc69F344FCDbc9D747559c968562f682ABfBa442C"
  }],
  "web3ProviderUrl": "https://poa-gateway.audius.co",
  "entityManagerContractAddress": "0x1Cd8a543596D499B9b6E7a6eC15ECd2B7857Fd64",
  "identityServiceUrl": "https://identityservice.audius.co"
};

var DEFAULT_LOG_LEVEL = 'warn';
var DEFAULT_LOG_PREFIX = '[audius-sdk]';
var logLevels = ['debug', 'info', 'warn', 'error'];
var Logger = /*#__PURE__*/function () {
  function Logger(config) {
    var _config$logLevel, _config$logPrefix;

    _classCallCheck(this, Logger);

    _defineProperty$1(this, "logLevel", void 0);

    _defineProperty$1(this, "logPrefix", '[audius-sdk]');

    this.logLevel = (_config$logLevel = config === null || config === void 0 ? void 0 : config.logLevel) !== null && _config$logLevel !== void 0 ? _config$logLevel : DEFAULT_LOG_LEVEL;
    this.logPrefix = (_config$logPrefix = config === null || config === void 0 ? void 0 : config.logPrefix) !== null && _config$logPrefix !== void 0 ? _config$logPrefix : DEFAULT_LOG_PREFIX;
  }

  _createClass(Logger, [{
    key: "createPrefixedLogger",
    value: function createPrefixedLogger(logPrefix) {
      return new Logger({
        logLevel: this.logLevel,
        logPrefix: "".concat(this.logPrefix).concat(logPrefix)
      });
    }
  }, {
    key: "debug",
    value: function debug() {
      var _console;

      if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('debug')) {
        return;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_console = console).debug.apply(_console, [this.logPrefix].concat(args));
    }
  }, {
    key: "info",
    value: function info() {
      var _console2;

      if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('info')) {
        return;
      }

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      (_console2 = console).info.apply(_console2, [this.logPrefix].concat(args));
    }
  }, {
    key: "warn",
    value: function warn() {
      var _console3;

      if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('warn')) {
        return;
      }

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      (_console3 = console).warn.apply(_console3, [this.logPrefix].concat(args));
    }
  }, {
    key: "error",
    value: function error() {
      var _console4;

      if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('error')) {
        return;
      }

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      (_console4 = console).error.apply(_console4, [this.logPrefix].concat(args));
    }
  }]);

  return Logger;
}();

/**
 * The name of the service for Discovery Node
 */

var DISCOVERY_SERVICE_NAME$1 = 'discovery-node';
var defaultDiscoveryNodeSelectorConfig = {
  initialSelectedNode: null,
  blocklist: null,
  allowlist: null,
  maxConcurrentRequests: 6,
  requestTimeout: 30000,
  unhealthyTTL: 3600000,
  backupsTTL: 120000,
  healthCheckThresholds: {
    minVersion: servicesConfig.minVersion,
    maxSlotDiffPlays: null,
    maxBlockDiff: 15
  },
  bootstrapServices: servicesConfig.discoveryNodes,
  logger: new Logger()
};

var isFullFlaskResponse = function isFullFlaskResponse(data) {
  return data.version !== undefined;
};
var isCommsResponse = function isCommsResponse(data) {
  return data.health !== undefined;
};

var isIndexerHealthy = function isIndexerHealthy(_ref) {
  var data = _ref.data,
      maxBlockDiff = _ref.maxBlockDiff;
  return data.block_difference === undefined || data.block_difference === null || data.block_difference <= maxBlockDiff;
};

var isApiIndexerHealthy = function isApiIndexerHealthy(_ref2) {
  var data = _ref2.data,
      maxBlockDiff = _ref2.maxBlockDiff;
  return data.latest_chain_block === null || data.latest_indexed_block === null || data.latest_chain_block === undefined || data.latest_indexed_block === undefined || data.latest_chain_block - data.latest_indexed_block <= maxBlockDiff;
};

var isSolanaIndexerHealthy = function isSolanaIndexerHealthy(_ref3) {
  var _data$plays, _data$rewards_manager, _data$spl_audio_info, _data$user_bank, _data$plays2, _data$plays2$tx_info, _data$plays3, _data$plays3$tx_info;

  var data = _ref3.data,
      maxSlotDiffPlays = _ref3.maxSlotDiffPlays;
  return !((_data$plays = data.plays) !== null && _data$plays !== void 0 && _data$plays.is_unhealthy) && !((_data$rewards_manager = data.rewards_manager) !== null && _data$rewards_manager !== void 0 && _data$rewards_manager.is_unhealthy) && !((_data$spl_audio_info = data.spl_audio_info) !== null && _data$spl_audio_info !== void 0 && _data$spl_audio_info.is_unhealthy) && !((_data$user_bank = data.user_bank) !== null && _data$user_bank !== void 0 && _data$user_bank.is_unhealthy) && (!((_data$plays2 = data.plays) !== null && _data$plays2 !== void 0 && (_data$plays2$tx_info = _data$plays2.tx_info) !== null && _data$plays2$tx_info !== void 0 && _data$plays2$tx_info.slot_diff) || maxSlotDiffPlays === null || ((_data$plays3 = data.plays) === null || _data$plays3 === void 0 ? void 0 : (_data$plays3$tx_info = _data$plays3.tx_info) === null || _data$plays3$tx_info === void 0 ? void 0 : _data$plays3$tx_info.slot_diff) <= maxSlotDiffPlays);
};

var isApiSolanaIndexerHealthy = function isApiSolanaIndexerHealthy(_ref4) {
  var data = _ref4.data,
      maxSlotDiffPlays = _ref4.maxSlotDiffPlays;
  return !maxSlotDiffPlays || !data.latest_chain_slot_plays || !data.latest_indexed_slot_plays || data.latest_chain_slot_plays - data.latest_indexed_slot_plays <= maxSlotDiffPlays;
}; // const isApiCommsHealthy = ({ data }: { data: CommsResponse }) => {
//   return data.health?.is_healthy
// }


var parseApiHealthStatusReason = function parseApiHealthStatusReason(_ref5) {
  var data = _ref5.data,
      _ref5$healthCheckThre = _ref5.healthCheckThresholds,
      minVersion = _ref5$healthCheckThre.minVersion,
      maxBlockDiff = _ref5$healthCheckThre.maxBlockDiff,
      maxSlotDiffPlays = _ref5$healthCheckThre.maxSlotDiffPlays;

  if (isFullFlaskResponse(data)) {
    var _data$version;

    if (((_data$version = data.version) === null || _data$version === void 0 ? void 0 : _data$version.service) !== DISCOVERY_SERVICE_NAME$1) {
      return {
        health: HealthCheckStatus.UNHEALTHY,
        reason: 'name'
      };
    }

    if (minVersion) {
      if (!data.version.version) {
        return {
          health: HealthCheckStatus.UNHEALTHY,
          reason: 'version'
        };
      }

      if (semver__default["default"].lt(data.version.version, minVersion)) {
        return {
          health: HealthCheckStatus.BEHIND,
          reason: 'version'
        };
      }
    }

    if (!isApiIndexerHealthy({
      data: data,
      maxBlockDiff: maxBlockDiff
    })) {
      return {
        health: HealthCheckStatus.BEHIND,
        reason: 'block diff'
      };
    }

    if (!isApiSolanaIndexerHealthy({
      data: data,
      maxSlotDiffPlays: maxSlotDiffPlays
    })) {
      return {
        health: HealthCheckStatus.BEHIND,
        reason: 'slot diff'
      };
    }
  } else if (isCommsResponse(data)) ;

  return {
    health: HealthCheckStatus.HEALTHY
  };
};

var getHealthCheckData = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(endpoint, fetchOptions) {
    var healthCheckURL, data, comms, response, json;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            healthCheckURL = "".concat(endpoint, "/health_check");
            data = null;
            comms = null;
            _context.next = 5;
            return fetch__default["default"](healthCheckURL, fetchOptions);

          case 5:
            response = _context.sent;

            if (response.ok) {
              _context.next = 8;
              break;
            }

            throw new Error(response.statusText);

          case 8:
            _context.next = 10;
            return response.json();

          case 10:
            json = _context.sent;
            data = json.data;
            comms = json.comms;

            if (data) {
              _context.next = 15;
              break;
            }

            throw new Error('data');

          case 15:
            if (comms) {
              _context.next = 17;
              break;
            }

            throw new Error('comms');

          case 17:
            return _context.abrupt("return", {
              data: data,
              comms: comms
            });

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getHealthCheckData(_x, _x2) {
    return _ref6.apply(this, arguments);
  };
}();

var parseHealthStatusReason = function parseHealthStatusReason(_ref7) {
  var data = _ref7.data,
      comms = _ref7.comms,
      _ref7$healthCheckThre = _ref7.healthCheckThresholds,
      minVersion = _ref7$healthCheckThre.minVersion,
      maxBlockDiff = _ref7$healthCheckThre.maxBlockDiff,
      maxSlotDiffPlays = _ref7$healthCheckThre.maxSlotDiffPlays;

  if (data === null) {
    return {
      health: HealthCheckStatus.UNHEALTHY,
      reason: 'data'
    };
  }

  if (data.service !== DISCOVERY_SERVICE_NAME$1) {
    return {
      health: HealthCheckStatus.UNHEALTHY,
      reason: 'name'
    };
  }

  if (!(comms !== null && comms !== void 0 && comms.healthy)) {
    return {
      health: HealthCheckStatus.UNHEALTHY,
      reason: 'comms'
    };
  }

  if (minVersion) {
    if (!data.version) {
      return {
        health: HealthCheckStatus.UNHEALTHY,
        reason: 'version'
      };
    }

    if (semver__default["default"].lt(data.version, minVersion)) {
      return {
        health: HealthCheckStatus.BEHIND,
        reason: 'version'
      };
    }
  }

  if (!isIndexerHealthy({
    data: data,
    maxBlockDiff: maxBlockDiff
  })) {
    return {
      health: HealthCheckStatus.BEHIND,
      reason: 'block diff'
    };
  }

  if (!isSolanaIndexerHealthy({
    data: data,
    maxSlotDiffPlays: maxSlotDiffPlays
  })) {
    return {
      health: HealthCheckStatus.BEHIND,
      reason: 'slot diff'
    };
  }

  return {
    health: HealthCheckStatus.HEALTHY
  };
};
var getDiscoveryNodeHealthCheck = /*#__PURE__*/function () {
  var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref8) {
    var endpoint, healthCheckThresholds, fetchOptions, timeoutMs, timeoutPromises, timeoutPromise, _yield$Promise$race, data, comms, reason;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            endpoint = _ref8.endpoint, healthCheckThresholds = _ref8.healthCheckThresholds, fetchOptions = _ref8.fetchOptions, timeoutMs = _ref8.timeoutMs;
            timeoutPromises = [];

            if (timeoutMs !== undefined) {
              timeoutPromise = new Promise(function (_resolve, reject) {
                return setTimeout(function () {
                  return reject(new Error('timeout'));
                }, timeoutMs);
              });
              timeoutPromises.push(timeoutPromise);
            }

            _context2.prev = 3;
            _context2.next = 6;
            return Promise.race([getHealthCheckData(endpoint, fetchOptions)].concat(timeoutPromises));

          case 6:
            _yield$Promise$race = _context2.sent;
            data = _yield$Promise$race.data;
            comms = _yield$Promise$race.comms;
            reason = parseHealthStatusReason({
              data: data,
              comms: comms,
              healthCheckThresholds: healthCheckThresholds
            });
            return _context2.abrupt("return", _objectSpread2(_objectSpread2({}, reason), {}, {
              data: data
            }));

          case 13:
            _context2.prev = 13;
            _context2.t0 = _context2["catch"](3);
            return _context2.abrupt("return", {
              health: HealthCheckStatus.UNHEALTHY,
              reason: _context2.t0 === null || _context2.t0 === void 0 ? void 0 : _context2.t0.message,
              data: null
            });

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 13]]);
  }));

  return function getDiscoveryNodeHealthCheck(_x3) {
    return _ref9.apply(this, arguments);
  };
}();

/**
 * Polyfill for Promise.any
 * Adapted from Sergio Tskhovrebov's implementation:
 * https://dev.to/sinxwal/looking-for-promise-any-let-s-quickly-implement-a-polyfill-for-it-1kga
 */
var promiseAny = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(iterable) {
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!Promise.any) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt("return", Promise.any(iterable));

          case 2:
            _context4.next = 4;
            return Promise.all(_toConsumableArray(iterable).map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(promise) {
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return new Promise(function (resolve, reject) {
                          Promise.resolve(promise).then(reject, resolve);
                        });

                      case 2:
                        return _context.abrupt("return", _context.sent);

                      case 3:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x2) {
                return _ref2.apply(this, arguments);
              };
            }())).then( /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(errors) {
                return regeneratorRuntime.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return Promise.reject(errors);

                      case 2:
                        return _context2.abrupt("return", _context2.sent);

                      case 3:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));

              return function (_x3) {
                return _ref3.apply(this, arguments);
              };
            }(), /*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(value) {
                return regeneratorRuntime.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.next = 2;
                        return Promise.resolve(value);

                      case 2:
                        return _context3.abrupt("return", _context3.sent);

                      case 3:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function (_x4) {
                return _ref4.apply(this, arguments);
              };
            }());

          case 4:
            return _context4.abrupt("return", _context4.sent);

          case 5:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function promiseAny(_x) {
    return _ref.apply(this, arguments);
  };
}();

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */

function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}

var _listCacheClear = listCacheClear$1;

var eq$2 = eq_1;
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function assocIndexOf$4(array, key) {
  var length = array.length;

  while (length--) {
    if (eq$2(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

var _assocIndexOf = assocIndexOf$4;

var assocIndexOf$3 = _assocIndexOf;
/** Used for built-in method references. */

var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete$1(key) {
  var data = this.__data__,
      index = assocIndexOf$3(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

var _listCacheDelete = listCacheDelete$1;

var assocIndexOf$2 = _assocIndexOf;
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function listCacheGet$1(key) {
  var data = this.__data__,
      index = assocIndexOf$2(data, key);
  return index < 0 ? undefined : data[index][1];
}

var _listCacheGet = listCacheGet$1;

var assocIndexOf$1 = _assocIndexOf;
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}

var _listCacheHas = listCacheHas$1;

var assocIndexOf = _assocIndexOf;
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */

function listCacheSet$1(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

var _listCacheSet = listCacheSet$1;

var listCacheClear = _listCacheClear,
    listCacheDelete = _listCacheDelete,
    listCacheGet = _listCacheGet,
    listCacheHas = _listCacheHas,
    listCacheSet = _listCacheSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache$4(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype['delete'] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;

var ListCache$3 = _ListCache;
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */

function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}

var _stackClear = stackClear$1;

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function stackDelete$1(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

var _stackDelete = stackDelete$1;

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function stackGet$1(key) {
  return this.__data__.get(key);
}

var _stackGet = stackGet$1;

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function stackHas$1(key) {
  return this.__data__.has(key);
}

var _stackHas = stackHas$1;

var root$2 = _root;
/** Used to detect overreaching core-js shims. */

var coreJsData$1 = root$2['__core-js_shared__'];
var _coreJsData = coreJsData$1;

var coreJsData = _coreJsData;
/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

var _isMasked = isMasked$1;

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$2 = funcProto$2.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

var _toSource = toSource$1;

var isFunction$1 = isFunction_1,
    isMasked = _isMasked,
    isObject$4 = isObject_1,
    toSource = _toSource;
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto$1 = Function.prototype,
    objectProto$5 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$1 = funcProto$1.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$5).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative$1(value) {
  if (!isObject$4(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

var _baseIsNative = baseIsNative$1;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

function getValue$1(object, key) {
  return object == null ? undefined : object[key];
}

var _getValue = getValue$1;

var baseIsNative = _baseIsNative,
    getValue = _getValue;
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */

function getNative$3(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

var _getNative = getNative$3;

var getNative$2 = _getNative,
    root$1 = _root;
/* Built-in method references that are verified to be native. */

var Map$3 = getNative$2(root$1, 'Map');
var _Map = Map$3;

var getNative$1 = _getNative;
/* Built-in method references that are verified to be native. */

var nativeCreate$4 = getNative$1(Object, 'create');
var _nativeCreate = nativeCreate$4;

var nativeCreate$3 = _nativeCreate;
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */

function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}

var _hashClear = hashClear$1;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var _hashDelete = hashDelete$1;

var nativeCreate$2 = _nativeCreate;
/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto$4 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet$1(key) {
  var data = this.__data__;

  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }

  return hasOwnProperty$4.call(data, key) ? data[key] : undefined;
}

var _hashGet = hashGet$1;

var nativeCreate$1 = _nativeCreate;
/** Used for built-in method references. */

var objectProto$3 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$3.call(data, key);
}

var _hashHas = hashHas$1;

var nativeCreate = _nativeCreate;
/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

var _hashSet = hashSet$1;

var hashClear = _hashClear,
    hashDelete = _hashDelete,
    hashGet = _hashGet,
    hashHas = _hashHas,
    hashSet = _hashSet;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash$1(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash$1.prototype.clear = hashClear;
Hash$1.prototype['delete'] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;

var Hash = _Hash,
    ListCache$2 = _ListCache,
    Map$2 = _Map;
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */

function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map$2 || ListCache$2)(),
    'string': new Hash()
  };
}

var _mapCacheClear = mapCacheClear$1;

function isKeyable$1(value) {
  var type = _typeof(value);

  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

var _isKeyable = isKeyable$1;

var isKeyable = _isKeyable;
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */

function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

var _getMapData = getMapData$4;

var getMapData$3 = _getMapData;
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

var _mapCacheDelete = mapCacheDelete$1;

var getMapData$2 = _getMapData;
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}

var _mapCacheGet = mapCacheGet$1;

var getMapData$1 = _getMapData;
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}

var _mapCacheHas = mapCacheHas$1;

var getMapData = _getMapData;
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */

function mapCacheSet$1(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

var _mapCacheSet = mapCacheSet$1;

var mapCacheClear = _mapCacheClear,
    mapCacheDelete = _mapCacheDelete,
    mapCacheGet = _mapCacheGet,
    mapCacheHas = _mapCacheHas,
    mapCacheSet = _mapCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache$1(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache$1.prototype.clear = mapCacheClear;
MapCache$1.prototype['delete'] = mapCacheDelete;
MapCache$1.prototype.get = mapCacheGet;
MapCache$1.prototype.has = mapCacheHas;
MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1;

var ListCache$1 = _ListCache,
    Map$1 = _Map,
    MapCache = _MapCache;
/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet$1(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache$1) {
    var pairs = data.__data__;

    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

var _stackSet = stackSet$1;

var ListCache = _ListCache,
    stackClear = _stackClear,
    stackDelete = _stackDelete,
    stackGet = _stackGet,
    stackHas = _stackHas,
    stackSet = _stackSet;
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Stack$1(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack$1.prototype.clear = stackClear;
Stack$1.prototype['delete'] = stackDelete;
Stack$1.prototype.get = stackGet;
Stack$1.prototype.has = stackHas;
Stack$1.prototype.set = stackSet;
var _Stack = Stack$1;

var getNative = _getNative;

var defineProperty$2 = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

var _defineProperty = defineProperty$2;

var defineProperty$1 = _defineProperty;
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function baseAssignValue$3(object, key, value) {
  if (key == '__proto__' && defineProperty$1) {
    defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

var _baseAssignValue = baseAssignValue$3;

var baseAssignValue$2 = _baseAssignValue,
    eq$1 = eq_1;
/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignMergeValue$2(object, key, value) {
  if (value !== undefined && !eq$1(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}

var _assignMergeValue = assignMergeValue$2;

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

function createBaseFor$1(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

var _createBaseFor = createBaseFor$1;

var createBaseFor = _createBaseFor;
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */

var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;

var _cloneBuffer = {exports: {}};

(function (module, exports) {
  var root = _root;
  /** Detect free variable `exports`. */

  var freeExports = exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Built-in value references. */

  var Buffer = moduleExports ? root.Buffer : undefined,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */

  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }

    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }

  module.exports = cloneBuffer;
})(_cloneBuffer, _cloneBuffer.exports);

var root = _root;
/** Built-in value references. */

var Uint8Array$2 = root.Uint8Array;
var _Uint8Array = Uint8Array$2;

var Uint8Array$1 = _Uint8Array;
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */

function cloneArrayBuffer$1(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}

var _cloneArrayBuffer = cloneArrayBuffer$1;

var cloneArrayBuffer = _cloneArrayBuffer;
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */

function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

var _cloneTypedArray = cloneTypedArray$1;

var isObject$3 = isObject_1;
/** Built-in value references. */

var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate$1 = function () {
  function object() {}

  return function (proto) {
    if (!isObject$3(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

var _baseCreate = baseCreate$1;

var overArg = _overArg;
/** Built-in value references. */

var getPrototype$2 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$2;

var baseCreate = _baseCreate,
    getPrototype$1 = _getPrototype,
    isPrototype$1 = _isPrototype;
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneObject$1(object) {
  return typeof object.constructor == 'function' && !isPrototype$1(object) ? baseCreate(getPrototype$1(object)) : {};
}

var _initCloneObject = initCloneObject$1;

var isArrayLike$1 = isArrayLike_1,
    isObjectLike$1 = isObjectLike_1;
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */

function isArrayLikeObject$1(value) {
  return isObjectLike$1(value) && isArrayLike$1(value);
}

var isArrayLikeObject_1 = isArrayLikeObject$1;

var baseGetTag = _baseGetTag,
    getPrototype = _getPrototype,
    isObjectLike = isObjectLike_1;
/** `Object#toString` result references. */

var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto$2 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject$1(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty$2.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

var isPlainObject_1 = isPlainObject$1;

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

function safeGet$2(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

var _safeGet = safeGet$2;

var baseAssignValue$1 = _baseAssignValue,
    eq = eq_1;
/** Used for built-in method references. */

var objectProto$1 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue$1(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty$1.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue$1(object, key, value);
  }
}

var _assignValue = assignValue$1;

var assignValue = _assignValue,
    baseAssignValue = _baseAssignValue;
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */

function copyObject$1(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

var _copyObject = copyObject$1;

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function nativeKeysIn$1(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

var _nativeKeysIn = nativeKeysIn$1;

var isObject$2 = isObject_1,
    isPrototype = _isPrototype,
    nativeKeysIn = _nativeKeysIn;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn$1(object) {
  if (!isObject$2(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

var _baseKeysIn = baseKeysIn$1;

var arrayLikeKeys = _arrayLikeKeys,
    baseKeysIn = _baseKeysIn,
    isArrayLike = isArrayLike_1;
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */

function keysIn$2(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

var keysIn_1 = keysIn$2;

var copyObject = _copyObject,
    keysIn$1 = keysIn_1;
/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */

function toPlainObject$1(value) {
  return copyObject(value, keysIn$1(value));
}

var toPlainObject_1 = toPlainObject$1;

var assignMergeValue$1 = _assignMergeValue,
    cloneBuffer = _cloneBuffer.exports,
    cloneTypedArray = _cloneTypedArray,
    copyArray = _copyArray,
    initCloneObject = _initCloneObject,
    isArguments = isArguments_1,
    isArray = isArray_1,
    isArrayLikeObject = isArrayLikeObject_1,
    isBuffer = isBuffer$2.exports,
    isFunction = isFunction_1,
    isObject$1 = isObject_1,
    isPlainObject = isPlainObject_1,
    isTypedArray = isTypedArray_1,
    safeGet$1 = _safeGet,
    toPlainObject = toPlainObject_1;
/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key),
      srcValue = safeGet$1(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$1(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue$1(object, key, newValue);
}

var _baseMergeDeep = baseMergeDeep$1;

var Stack = _Stack,
    assignMergeValue = _assignMergeValue,
    baseFor = _baseFor,
    baseMergeDeep = _baseMergeDeep,
    isObject = isObject_1,
    keysIn = keysIn_1,
    safeGet = _safeGet;
/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    stack || (stack = new Stack());

    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

var _baseMerge = baseMerge$1;

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */

function identity$2(value) {
  return value;
}

var identity_1 = identity$2;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */

function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

var _apply = apply$1;

var apply = _apply;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest$1(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

var _overRest = overRest$1;

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */

function constant$1(value) {
  return function () {
    return value;
  };
}

var constant_1 = constant$1;

var constant = constant_1,
    defineProperty = _defineProperty,
    identity$1 = identity_1;
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var baseSetToString$1 = !defineProperty ? identity$1 : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
var _baseSetToString = baseSetToString$1;

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut$1(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

var _shortOut = shortOut$1;

var baseSetToString = _baseSetToString,
    shortOut = _shortOut;
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var setToString$1 = shortOut(baseSetToString);
var _setToString = setToString$1;

var identity = identity_1,
    overRest = _overRest,
    setToString = _setToString;
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */

function baseRest$1(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

var _baseRest = baseRest$1;

var baseRest = _baseRest,
    isIterateeCall = _isIterateeCall;
/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */

function createAssigner$1(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

var _createAssigner = createAssigner$1;

var baseMerge = _baseMerge,
    createAssigner = _createAssigner;
/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */

var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});
var mergeWith_1 = mergeWith;

/**
 * Gets the config with any undefined properties replaced by the defaults
 * @param config the config
 * @param defaults the defaults
 * @returns the merged config with defaults
 */

var mergeConfigWithDefaults = function mergeConfigWithDefaults(config, defaults) {
  return mergeWith_1({}, defaults, config, function (_a, b) {
    if (Array.isArray(b)) {
      return b;
    }

    return undefined;
  });
};

var getPathFromUrl = function getPathFromUrl(url) {
  var pathRegex = /^([a-z]+:\/\/)?(?:www\.)?([^/]+)?(.*)$/;
  var match = url.match(pathRegex);

  if (match !== null && match !== void 0 && match[3]) {
    var path = match[3];
    return path;
  } else {
    throw new Error("Invalid URL, couldn't get path.");
  }
};

var DiscoveryNodeSelector = /*#__PURE__*/function () {
  function DiscoveryNodeSelector(config) {
    var _this$config$allowlis, _this$config$blocklis;

    _classCallCheck(this, DiscoveryNodeSelector);

    _defineProperty$1(this, "services", void 0);

    _defineProperty$1(this, "selectedNode", void 0);

    _defineProperty$1(this, "config", void 0);

    _defineProperty$1(this, "_isBehind", void 0);

    _defineProperty$1(this, "unhealthyServices", void 0);

    _defineProperty$1(this, "backupServices", void 0);

    _defineProperty$1(this, "unhealthyCleanupTimeout", null);

    _defineProperty$1(this, "backupCleanupTimeout", null);

    _defineProperty$1(this, "reselectLock", false);

    _defineProperty$1(this, "eventEmitter", void 0);

    _defineProperty$1(this, "addEventListener", void 0);

    _defineProperty$1(this, "removeEventListener", void 0);

    _defineProperty$1(this, "logger", void 0);

    this.config = mergeConfigWithDefaults(config, defaultDiscoveryNodeSelectorConfig);
    this.services = this.config.bootstrapServices;
    this._isBehind = false;
    this.unhealthyServices = new Set([]);
    this.backupServices = {};
    this.selectedNode = this.config.initialSelectedNode && (!this.config.allowlist || (_this$config$allowlis = this.config.allowlist) !== null && _this$config$allowlis !== void 0 && _this$config$allowlis.has(this.config.initialSelectedNode)) && !((_this$config$blocklis = this.config.blocklist) !== null && _this$config$blocklis !== void 0 && _this$config$blocklis.has(this.config.initialSelectedNode)) ? this.config.initialSelectedNode : null;
    this.eventEmitter = new EventEmitter__default["default"](); // Potentially need many event listeners for discovery reselection (to prevent race condition)

    this.eventEmitter.setMaxListeners(1000);
    this.addEventListener = this.eventEmitter.addListener.bind(this.eventEmitter);
    this.removeEventListener = this.eventEmitter.removeListener.bind(this.eventEmitter);
    this.logger = this.config.logger.createPrefixedLogger('[discovery-node-selector]');
  }
  /**
   * Updates the config.
   * Note that setting the initial node or bootstrap nodes here does nothing as the service is already initialized.
   * Will force reselections if health check thresholds change (as that might cause the current node to be considered unhealthy)
   * or if the selected node is excluded per allow/blocklists
   */


  _createClass(DiscoveryNodeSelector, [{
    key: "isBehind",
    get:
    /**
     * List of services to select from
     */

    /**
     * Currently selected discovery node
     */

    /**
     * Configuration passed in by consumer (with defaults)
     */

    /**
     * Whether or not we are using a backup, meaning we were
     * unable to select a discovery node that was up-to-date and healthy.
     * Clients may want to consider blocking writes as service may be degraded
     */
    function get() {
      return this._isBehind;
    },
    set: function set(isBehind) {
      if (isBehind && !this._isBehind) {
        this.logger.warn('using behind discovery node', this.selectedNode);
      } else if (!isBehind && this._isBehind) {
        this.logger.info('discovery node no longer behind', this.selectedNode);
      }

      this._isBehind = isBehind;
    }
    /**
     * During selection, services that fail health check will be put in this list
     * so that we try different nodes on new rounds of selection
     */

  }, {
    key: "updateConfig",
    value: function updateConfig(config) {
      this.config = mergeConfigWithDefaults(config, this.config);

      if (this.selectedNode) {
        var _config$blocklist;

        if (config.healthCheckThresholds) {
          this.selectedNode = null;
        } else if (config.allowlist && !config.allowlist.has(this.selectedNode)) {
          this.selectedNode = null;
        } else if ((_config$blocklist = config.blocklist) !== null && _config$blocklist !== void 0 && _config$blocklist.has(this.selectedNode)) {
          this.selectedNode = null;
        }
      }
    }
    /**
     * Returns a middleware that reselects if the current discovery node is behind
     * @returns the middleware
     */

  }, {
    key: "createMiddleware",
    value: function createMiddleware() {
      var _this = this;

      return {
        pre: function () {
          var _pre = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(context) {
            var url, endpoint;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    url = context.url;

                    if (url.startsWith('http')) {
                      _context.next = 6;
                      break;
                    }

                    _context.next = 4;
                    return _this.getSelectedEndpoint();

                  case 4:
                    endpoint = _context.sent;
                    url = "".concat(endpoint).concat(context.url);

                  case 6:
                    return _context.abrupt("return", {
                      url: url,
                      init: context.init
                    });

                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function pre(_x) {
            return _pre.apply(this, arguments);
          }

          return pre;
        }(),
        post: function () {
          var _post = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(context) {
            var response, endpoint, _data$latest_chain_bl, _data$latest_indexed_, _data$version$version, _data$version, responseClone, data, _parseApiHealthStatus, health, reason, blockDiff, version;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    response = context.response;
                    _context2.next = 3;
                    return _this.getSelectedEndpoint();

                  case 3:
                    endpoint = _context2.sent;

                    if (endpoint) {
                      _context2.next = 9;
                      break;
                    }

                    _context2.next = 7;
                    return _this.select(endpoint);

                  case 7:
                    _context2.next = 24;
                    break;

                  case 9:
                    if (!response.ok) {
                      _context2.next = 21;
                      break;
                    }

                    // Even when successful, copy response to read JSON body to
                    // check for signs the DN is unhealthy and reselect if necessary.
                    // This will get the client to pick new discovery providers
                    // if the selected one falls behind, even if requests are succeeding
                    responseClone = response.clone();
                    _context2.next = 13;
                    return responseClone.json();

                  case 13:
                    data = _context2.sent;
                    _parseApiHealthStatus = parseApiHealthStatusReason({
                      data: data,
                      healthCheckThresholds: _this.config.healthCheckThresholds
                    }), health = _parseApiHealthStatus.health, reason = _parseApiHealthStatus.reason;
                    blockDiff = isFullFlaskResponse(data) ? ((_data$latest_chain_bl = data.latest_chain_block) !== null && _data$latest_chain_bl !== void 0 ? _data$latest_chain_bl : 0) - ((_data$latest_indexed_ = data.latest_indexed_block) !== null && _data$latest_indexed_ !== void 0 ? _data$latest_indexed_ : 0) : 0;
                    version = isFullFlaskResponse(data) ? (_data$version$version = (_data$version = data.version) === null || _data$version === void 0 ? void 0 : _data$version.version) !== null && _data$version$version !== void 0 ? _data$version$version : '' : '';
                    _context2.next = 19;
                    return _this.reselectIfNecessary({
                      endpoint: endpoint,
                      health: health,
                      reason: reason,
                      data: {
                        block_difference: blockDiff,
                        version: version
                      }
                    });

                  case 19:
                    _context2.next = 24;
                    break;

                  case 21:
                    _context2.next = 23;
                    return _this.reselectAndRetry({
                      context: context,
                      endpoint: endpoint
                    });

                  case 23:
                    return _context2.abrupt("return", _context2.sent);

                  case 24:
                    return _context2.abrupt("return", response);

                  case 25:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function post(_x2) {
            return _post.apply(this, arguments);
          }

          return post;
        }(),
        onError: function () {
          var _onError = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(context) {
            var endpoint, response;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return _this.getSelectedEndpoint();

                  case 2:
                    endpoint = _context3.sent;
                    response = context.response;

                    if (endpoint) {
                      _context3.next = 9;
                      break;
                    }

                    _context3.next = 7;
                    return _this.select(endpoint);

                  case 7:
                    _context3.next = 12;
                    break;

                  case 9:
                    _context3.next = 11;
                    return _this.reselectAndRetry({
                      context: context,
                      endpoint: endpoint
                    });

                  case 11:
                    return _context3.abrupt("return", _context3.sent);

                  case 12:
                    return _context3.abrupt("return", response);

                  case 13:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));

          function onError(_x3) {
            return _onError.apply(this, arguments);
          }

          return onError;
        }()
      };
    }
    /**
     * Selects a discovery node or returns the existing selection
     * @returns a discovery node endpoint
     */

  }, {
    key: "getSelectedEndpoint",
    value: function () {
      var _getSelectedEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(this.selectedNode !== null)) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return", this.selectedNode);

              case 2:
                _context4.next = 4;
                return this.select(null);

              case 4:
                return _context4.abrupt("return", _context4.sent);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getSelectedEndpoint() {
        return _getSelectedEndpoint.apply(this, arguments);
      }

      return getSelectedEndpoint;
    }()
    /**
     * Gets the list of services
     */

  }, {
    key: "getServices",
    value: function getServices() {
      return this.services;
    }
    /**
     * Finds a healthy discovery node
     * @returns a healthy discovery node endpoint
     */

  }, {
    key: "select",
    value: function () {
      var _select = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(prevSelectedNode) {
        var _this2 = this;

        var decisionTree, services, selectedService, attemptedServicesCount, filteredServices, backup, round;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.reselectLock) {
                  _context5.next = 3;
                  break;
                }

                _context5.next = 3;
                return new Promise(function (resolve) {
                  _this2.eventEmitter.once('reselectAttemptComplete', function () {
                    resolve();
                  });
                });

              case 3:
                if (!(prevSelectedNode !== this.selectedNode && this.selectedNode != null)) {
                  _context5.next = 5;
                  break;
                }

                return _context5.abrupt("return", this.selectedNode);

              case 5:
                this.reselectLock = true;
                _context5.prev = 6;
                this.logger.debug('Selecting new discovery node...');
                decisionTree = []; // Get all the services we have

                services = _toConsumableArray(this.services);
                decisionTree.push({
                  stage: exports.DECISION_TREE_STATE.GET_ALL_SERVICES,
                  val: services
                }); // If a whitelist is provided, filter down to it

                if (this.config.allowlist) {
                  services = services.filter(function (s) {
                    var _this2$config$allowli;

                    return (_this2$config$allowli = _this2.config.allowlist) === null || _this2$config$allowli === void 0 ? void 0 : _this2$config$allowli.has(s);
                  });
                  decisionTree.push({
                    stage: exports.DECISION_TREE_STATE.FILTER_TO_WHITELIST,
                    val: services
                  });
                } // if a blacklist is provided, filter out services in the list


                if (this.config.blocklist) {
                  services = services.filter(function (s) {
                    var _this2$config$blockli;

                    return !((_this2$config$blockli = _this2.config.blocklist) !== null && _this2$config$blockli !== void 0 && _this2$config$blockli.has(s));
                  });
                  decisionTree.push({
                    stage: exports.DECISION_TREE_STATE.FILTER_FROM_BLACKLIST,
                    val: services
                  });
                }

                selectedService = null;
                attemptedServicesCount = 0; // Loop until a healthy node is found, batching health_check requests by maxConcurrentRequests

              case 15:
                if (!(selectedService === null)) {
                  _context5.next = 44;
                  break;
                }

                // Filter out anything we know is already unhealthy
                filteredServices = services.filter(function (s) {
                  return !_this2.unhealthyServices.has(s);
                });
                decisionTree.push({
                  stage: exports.DECISION_TREE_STATE.FILTER_OUT_KNOWN_UNHEALTHY,
                  val: filteredServices
                }); // If there are no services left to try, either pick a backup or return null

                if (!(filteredServices.length === 0)) {
                  _context5.next = 35;
                  break;
                }

                decisionTree.push({
                  stage: exports.DECISION_TREE_STATE.NO_SERVICES_LEFT_TO_TRY
                });

                if (!(Object.keys(this.backupServices).length > 0)) {
                  _context5.next = 30;
                  break;
                }

                _context5.next = 23;
                return this.selectFromBackups();

              case 23:
                backup = _context5.sent;
                decisionTree.push({
                  stage: exports.DECISION_TREE_STATE.SELECTED_FROM_BACKUP,
                  val: backup
                });
                this.selectedNode = backup;
                this.isBehind = true;
                return _context5.abrupt("return", backup);

              case 30:
                // Nothing could be found that was healthy.
                // Reset everything we know so that we might try again.
                this.unhealthyServices = new Set([]);
                this.backupServices = {};
                decisionTree.push({
                  stage: exports.DECISION_TREE_STATE.FAILED_AND_RESETTING
                });
                this.logger.error('Failed to select discovery node', decisionTree);
                return _context5.abrupt("return", null);

              case 35:
                // Randomly sample a "round" to test
                round = sampleSize_1(filteredServices, this.config.maxConcurrentRequests);
                decisionTree.push({
                  stage: exports.DECISION_TREE_STATE.GET_SELECTION_ROUND,
                  val: round
                }); // Race this "round" of services to find the quickest healthy node

                _context5.next = 39;
                return this.anyHealthyEndpoint(round);

              case 39:
                selectedService = _context5.sent;
                attemptedServicesCount += round.length; // Retry if none were found

                if (!selectedService) {
                  decisionTree.push({
                    stage: exports.DECISION_TREE_STATE.ROUND_FAILED_RETRY
                  });
                  this.logger.debug('No healthy services found. Attempting another round...', {
                    attemptedServicesCount: attemptedServicesCount
                  });
                }

                _context5.next = 15;
                break;

              case 44:
                // Trigger a cleanup event for all of the unhealthy and backup services,
                // so they can get retried in the future
                this.triggerCleanup();
                decisionTree.push({
                  stage: exports.DECISION_TREE_STATE.MADE_A_SELECTION,
                  val: selectedService
                }); // If we made it this far, we found the best service! (of the rounds we tried)

                if (selectedService) {
                  this.selectedNode = selectedService;
                  this.eventEmitter.emit('change', selectedService);
                }

                this.logger.info("Selected discprov ".concat(selectedService), decisionTree, {
                  attemptedServicesCount: attemptedServicesCount
                });
                this.isBehind = false;
                return _context5.abrupt("return", this.selectedNode);

              case 50:
                _context5.prev = 50;
                this.reselectLock = false;
                this.eventEmitter.emit('reselectAttemptComplete');
                return _context5.finish(50);

              case 54:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[6,, 50, 54]]);
      }));

      function select(_x4) {
        return _select.apply(this, arguments);
      }

      return select;
    }()
    /**
     * Checks to see if any of the endpoints are healthy, returning the first one that is.
     * Cancels the remaining promises.
     * Uses the configured timeout.
     * Any unhealthy or behind services found are placed into the unhealthy and backup lists respectively
     *
     * @param endpoints the endpoints to race
     * @returns the fastest healthy endpoint or null if none are healthy
     */

  }, {
    key: "anyHealthyEndpoint",
    value: function () {
      var _anyHealthyEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(endpoints) {
        var _this3 = this;

        var abortController, requestPromises;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                abortController = new nodeAbortController.AbortController();
                requestPromises = endpoints.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(endpoint) {
                    var _yield$getDiscoveryNo, health, data, reason, _data$network;

                    return regeneratorRuntime.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.next = 2;
                            return getDiscoveryNodeHealthCheck({
                              endpoint: endpoint,
                              fetchOptions: {
                                signal: abortController.signal
                              },
                              timeoutMs: _this3.config.requestTimeout,
                              healthCheckThresholds: _this3.config.healthCheckThresholds
                            });

                          case 2:
                            _yield$getDiscoveryNo = _context6.sent;
                            health = _yield$getDiscoveryNo.health;
                            data = _yield$getDiscoveryNo.data;
                            reason = _yield$getDiscoveryNo.reason;

                            if (!(health !== HealthCheckStatus.HEALTHY)) {
                              _context6.next = 11;
                              break;
                            }

                            if (reason !== null && reason !== void 0 && reason.toLowerCase().includes('aborted')) {
                              // Ignore aborted requests
                              _this3.logger.debug('health_check', endpoint, health, reason);
                            } else if (health === HealthCheckStatus.UNHEALTHY) {
                              _this3.unhealthyServices.add(endpoint);

                              _this3.logger.debug('health_check', endpoint, health, reason);
                            } else if (health === HealthCheckStatus.BEHIND) {
                              _this3.unhealthyServices.add(endpoint);

                              if (data) {
                                _this3.backupServices[endpoint] = {
                                  endpoint: endpoint,
                                  block_difference: data.block_difference,
                                  version: data.version
                                };
                              }

                              _this3.logger.debug('health_check', endpoint, health, reason);
                            }

                            throw new Error("".concat(endpoint, " ").concat(health, ": ").concat(reason));

                          case 11:
                            // We're healthy!
                            _this3.logger.debug('health_check', endpoint, health); // Cancel any existing requests from other promises


                            abortController.abort(); // Refresh service list with the healthy list from DN

                            if (data !== null && data !== void 0 && (_data$network = data.network) !== null && _data$network !== void 0 && _data$network.discovery_nodes && data.network.discovery_nodes.length > 0) {
                              _this3.services = data.network.discovery_nodes;
                            } else {
                              _this3.logger.warn("Couldn't load new service list from healthy service", endpoint);
                            }

                            return _context6.abrupt("return", endpoint);

                          case 15:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6);
                  }));

                  return function (_x6) {
                    return _ref.apply(this, arguments);
                  };
                }());
                _context7.prev = 2;
                _context7.next = 5;
                return promiseAny(requestPromises);

              case 5:
                return _context7.abrupt("return", _context7.sent);

              case 8:
                _context7.prev = 8;
                _context7.t0 = _context7["catch"](2);
                this.logger.error('No healthy nodes', _context7.t0);
                return _context7.abrupt("return", null);

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[2, 8]]);
      }));

      function anyHealthyEndpoint(_x5) {
        return _anyHealthyEndpoint.apply(this, arguments);
      }

      return anyHealthyEndpoint;
    }()
    /**
     * Checks the given endpoint's health check and reselects if necessary.
     * @param endpoint the endpoint to health_check
     * @returns a new discovery node if reselect was necessary, or the existing endpoint if reselect unnecessary
     */

  }, {
    key: "reselectIfNecessary",
    value: function () {
      var _reselectIfNecessary = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(_ref2) {
        var endpoint, health, reason, data;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                endpoint = _ref2.endpoint, health = _ref2.health, reason = _ref2.reason, data = _ref2.data;

                if (!(health === HealthCheckStatus.HEALTHY)) {
                  _context8.next = 6;
                  break;
                }

                this.isBehind = false;
                return _context8.abrupt("return", endpoint);

              case 6:
                if (!(this.isBehind && HealthCheckStatus.BEHIND)) {
                  _context8.next = 10;
                  break;
                }

                return _context8.abrupt("return", endpoint);

              case 10:
                if (health === HealthCheckStatus.UNHEALTHY || !data) {
                  this.unhealthyServices.add(endpoint);
                } else if (health === HealthCheckStatus.BEHIND) {
                  this.backupServices[endpoint] = {
                    endpoint: endpoint,
                    block_difference: data.block_difference,
                    version: data.version
                  };
                }

                this.logger.warn('api_health_check failed, reselecting', endpoint, health, reason);
                _context8.next = 14;
                return this.select(endpoint);

              case 14:
                return _context8.abrupt("return", _context8.sent);

              case 15:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function reselectIfNecessary(_x7) {
        return _reselectIfNecessary.apply(this, arguments);
      }

      return reselectIfNecessary;
    }()
    /**
     * Sets (or resets) a setTimeout to reset the backup and unhealthy service lists
     */

  }, {
    key: "triggerCleanup",
    value: function triggerCleanup() {
      var _this4 = this;

      if (this.unhealthyCleanupTimeout) {
        clearTimeout(this.unhealthyCleanupTimeout);
      }

      if (this.backupCleanupTimeout) {
        clearTimeout(this.backupCleanupTimeout);
      }

      this.unhealthyCleanupTimeout = setTimeout(function () {
        _this4.unhealthyServices = new Set([]);
      }, this.config.unhealthyTTL);
      this.backupCleanupTimeout = setTimeout(function () {
        _this4.backupServices = {};
      }, this.config.backupsTTL);
    }
    /**
     * First try to get a node that's got a healthy blockdiff, but a behind version.
     * If that fails, get the node with the lowest blockdiff on the most up to date version
     */

  }, {
    key: "selectFromBackups",
    value: function () {
      var _selectFromBackups = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var _this5 = this,
            _goodBlockdiffBadVers;

        var sortedBackups, goodBlockdiffBadVersion, nextBest;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                sortedBackups = Object.values(this.backupServices).sort(function (a, b) {
                  var versionSort = semver__default["default"].rcompare(a.version, b.version);

                  if (versionSort === 0) {
                    return a.block_difference - b.block_difference;
                  }

                  return versionSort;
                });
                goodBlockdiffBadVersion = sortedBackups.find(function (s) {
                  return s.block_difference <= _this5.config.healthCheckThresholds.maxBlockDiff;
                });
                nextBest = sortedBackups[0];

                if (!(!goodBlockdiffBadVersion && nextBest)) {
                  _context9.next = 5;
                  break;
                }

                return _context9.abrupt("return", nextBest.endpoint);

              case 5:
                return _context9.abrupt("return", (_goodBlockdiffBadVers = goodBlockdiffBadVersion === null || goodBlockdiffBadVersion === void 0 ? void 0 : goodBlockdiffBadVersion.endpoint) !== null && _goodBlockdiffBadVers !== void 0 ? _goodBlockdiffBadVers : null);

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function selectFromBackups() {
        return _selectFromBackups.apply(this, arguments);
      }

      return selectFromBackups;
    }()
  }, {
    key: "reselectAndRetry",
    value: function () {
      var _reselectAndRetry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(_ref3) {
        var _data$block_differenc, _data$version2;

        var context, endpoint, _yield$getDiscoveryNo2, health, data, reason, newEndpoint, path;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                context = _ref3.context, endpoint = _ref3.endpoint;
                // On request failure, check health_check and reselect if unhealthy
                this.logger.warn('request failed', endpoint, context);
                _context10.next = 4;
                return getDiscoveryNodeHealthCheck({
                  endpoint: endpoint,
                  healthCheckThresholds: this.config.healthCheckThresholds
                });

              case 4:
                _yield$getDiscoveryNo2 = _context10.sent;
                health = _yield$getDiscoveryNo2.health;
                data = _yield$getDiscoveryNo2.data;
                reason = _yield$getDiscoveryNo2.reason;
                _context10.next = 10;
                return this.reselectIfNecessary({
                  endpoint: endpoint,
                  health: health,
                  reason: reason,
                  data: {
                    block_difference: (_data$block_differenc = data === null || data === void 0 ? void 0 : data.block_difference) !== null && _data$block_differenc !== void 0 ? _data$block_differenc : 0,
                    version: (_data$version2 = data === null || data === void 0 ? void 0 : data.version) !== null && _data$version2 !== void 0 ? _data$version2 : ''
                  }
                });

              case 10:
                newEndpoint = _context10.sent;

                if (!(newEndpoint && newEndpoint !== endpoint)) {
                  _context10.next = 22;
                  break;
                }

                _context10.prev = 12;
                path = getPathFromUrl(context.url); // Retry once on new endpoint

                _context10.next = 16;
                return context.fetch("".concat(newEndpoint).concat(path), context.init);

              case 16:
                return _context10.abrupt("return", _context10.sent);

              case 19:
                _context10.prev = 19;
                _context10.t0 = _context10["catch"](12);
                this.logger.error('Retry on new node failed', newEndpoint);

              case 22:
                return _context10.abrupt("return", undefined);

              case 23:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[12, 19]]);
      }));

      function reselectAndRetry(_x8) {
        return _reselectAndRetry.apply(this, arguments);
      }

      return reselectAndRetry;
    }()
  }]);

  return DiscoveryNodeSelector;
}();

var Web3;

if (typeof window !== 'undefined' && window && window.Web3) {
  Web3 = window.Web3;
} else {
  Web3 = require$$0__default["default"];
}

var LibsWeb3 = Web3;

var getSendMethod = function getSendMethod(provider) {
  if ('sendAsync' in provider) {
    return provider.sendAsync;
  }

  return provider.send;
};
/**
 * web3 consumes a provider object on initialization
 * ref: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3/types/index.d.ts#L31
 * which references: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3-core/types/index.d.ts#L436
 * MultiProvider implements HttpProvider which can be consumed by web3
 * ref for HttpProvider: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3-providers-http/types/index.d.ts#L46-L66
 */


var MultiProvider = /*#__PURE__*/function (_Web3$providers$HttpP) {
  _inherits(MultiProvider, _Web3$providers$HttpP);

  var _super = _createSuper(MultiProvider);

  /**
   * Creates a MultiProvider
   * @param {Array<string | Provider> | string} - The providers to use.
   */
  function MultiProvider(providers) {
    var _web3ProviderInstance;

    var _this;

    _classCallCheck(this, MultiProvider);

    var web3Providers;

    if (typeof providers === 'string') {
      web3Providers = providers.split(',');
    } else if (!Array.isArray(providers)) {
      web3Providers = [providers];
    } else {
      web3Providers = providers;
    } // The below line ensures that we support different types of providers i.e. comma separated strings, an array of strings or an array of providers.


    var web3ProviderInstances = web3Providers.map(function (provider) {
      return new LibsWeb3(provider).eth.currentProvider;
    });
    _this = _super.call(this, (_web3ProviderInstance = web3ProviderInstances[0]) === null || _web3ProviderInstance === void 0 ? void 0 : _web3ProviderInstance.host);

    _defineProperty$1(_assertThisInitialized(_this), "providers", void 0);

    if (!web3ProviderInstances.every(getSendMethod)) {
      throw new Error('Some providers do not have a send method to use.');
    }

    _this.providers = web3ProviderInstances; // We replace HttpProvider.send with a custom function that supports fallback providers.

    _this.send = util.callbackify(_this._send.bind(_assertThisInitialized(_this))); // web3 only supports callback functions and not async

    return _this;
  }
  /**
   * @method _send
   * @param {Object} payload
   */


  _createClass(MultiProvider, [{
    key: "_send",
    value: function () {
      var _send2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(payload) {
        var _iterator, _step, provider, send, result;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _iterator = _createForOfIteratorHelper(lodash.shuffle(this.providers));
                _context.prev = 1;

                _iterator.s();

              case 3:
                if ((_step = _iterator.n()).done) {
                  _context.next = 18;
                  break;
                }

                provider = _step.value;
                _context.prev = 5;
                send = util.promisify(getSendMethod(provider).bind(provider));
                _context.next = 9;
                return send(payload);

              case 9:
                result = _context.sent;
                return _context.abrupt("return", result);

              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](5);
                console.log(_context.t0);

              case 16:
                _context.next = 3;
                break;

              case 18:
                _context.next = 23;
                break;

              case 20:
                _context.prev = 20;
                _context.t1 = _context["catch"](1);

                _iterator.e(_context.t1);

              case 23:
                _context.prev = 23;

                _iterator.f();

                return _context.finish(23);

              case 26:
                throw new Error('All requests failed');

              case 27:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 20, 23, 26], [5, 13]]);
      }));

      function _send(_x) {
        return _send2.apply(this, arguments);
      }

      return _send;
    }()
  }]);

  return MultiProvider;
}(LibsWeb3.providers.HttpProvider);

var uuid = function uuid() {
  // https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/873856#873856
  var s = [];
  var hexDigits = '0123456789abcdef';

  for (var i = 0; i < 36; i++) {
    s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
  }

  s[14] = '4'; // bits 12-15 of the time_hi_and_version field to 0010

  s[19] = hexDigits.substr(s[19] | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01

  s[8] = s[13] = s[18] = s[23] = '-';
  var uuid = s.join('');
  return uuid;
};

var encode_1 = encode$1;
var MSB = 128,
    REST = 127,
    MSBALL = ~REST,
    INT = Math.pow(2, 31);

function encode$1(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;

  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }

  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }

  out[offset] = num | 0;
  encode$1.bytes = offset - oldOffset + 1;
  return out;
}

var decode$2 = read;
var MSB$1 = 128,
    REST$1 = 127;

function read(buf, offset) {
  var res = 0,
      offset = offset || 0,
      shift = 0,
      counter = offset,
      b,
      l = buf.length;

  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError('Could not decode varint');
    }

    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);

  read.bytes = counter - offset;
  return res;
}

var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);

var length = function length(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};

var varint = {
  encode: encode_1,
  decode: decode$2,
  encodingLength: length
};
var _brrp_varint = varint;

var decode$1 = function decode(data) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var code = _brrp_varint.decode(data, offset);
  return [code, _brrp_varint.decode.bytes];
};
var encodeTo = function encodeTo(_int, target) {
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  _brrp_varint.encode(_int, target, offset);
  return target;
};
var encodingLength = function encodingLength(_int2) {
  return _brrp_varint.encodingLength(_int2);
};

var equals$1 = function equals(aa, bb) {
  if (aa === bb) return true;

  if (aa.byteLength !== bb.byteLength) {
    return false;
  }

  for (var ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }

  return true;
};

var coerce = function coerce(o) {
  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o;
  if (o instanceof ArrayBuffer) return new Uint8Array(o);

  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }

  throw new Error('Unknown type, must be binary type');
};

var create = function create(code, digest) {
  var size = digest.byteLength;
  var sizeOffset = encodingLength(code);
  var digestOffset = sizeOffset + encodingLength(size);
  var bytes = new Uint8Array(digestOffset + size);
  encodeTo(code, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest(code, size, digest, bytes);
};
var decode = function decode(multihash) {
  var bytes = coerce(multihash);

  var _varint$decode = decode$1(bytes),
      _varint$decode2 = _slicedToArray(_varint$decode, 2),
      code = _varint$decode2[0],
      sizeOffset = _varint$decode2[1];

  var _varint$decode3 = decode$1(bytes.subarray(sizeOffset)),
      _varint$decode4 = _slicedToArray(_varint$decode3, 2),
      size = _varint$decode4[0],
      digestOffset = _varint$decode4[1];

  var digest = bytes.subarray(sizeOffset + digestOffset);

  if (digest.byteLength !== size) {
    throw new Error('Incorrect length');
  }

  return new Digest(code, size, digest, bytes);
};
var equals = function equals(a, b) {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && equals$1(a.bytes, b.bytes);
  }
};
var Digest = /*#__PURE__*/_createClass(function Digest(code, size, digest, bytes) {
  _classCallCheck(this, Digest);

  this.code = code;
  this.size = size;
  this.digest = digest;
  this.bytes = bytes;
});

function base(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError('Alphabet too long');
  }

  var BASE_MAP = new Uint8Array(256);

  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }

  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);

    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + ' is ambiguous');
    }

    BASE_MAP[xc] = i;
  }

  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);

  function encode(source) {
    if (source instanceof Uint8Array) ;else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }

    if (!(source instanceof Uint8Array)) {
      throw new TypeError('Expected Uint8Array');
    }

    if (source.length === 0) {
      return '';
    }

    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;

    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }

    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);

    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i = 0;

      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }

      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }

      length = i;
      pbegin++;
    }

    var it2 = size - length;

    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }

    var str = LEADER.repeat(zeroes);

    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }

    return str;
  }

  function decodeUnsafe(source) {
    if (typeof source !== 'string') {
      throw new TypeError('Expected String');
    }

    if (source.length === 0) {
      return new Uint8Array();
    }

    var psz = 0;

    if (source[psz] === ' ') {
      return;
    }

    var zeroes = 0;
    var length = 0;

    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }

    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);

    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];

      if (carry === 255) {
        return;
      }

      var i = 0;

      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }

      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }

      length = i;
      psz++;
    }

    if (source[psz] === ' ') {
      return;
    }

    var it4 = size - length;

    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }

    var vch = new Uint8Array(zeroes + (size - it4));
    var j = zeroes;

    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }

    return vch;
  }

  function decode(string) {
    var buffer = decodeUnsafe(string);

    if (buffer) {
      return buffer;
    }

    throw new Error("Non-".concat(name, " character"));
  }

  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  };
}

var src = base;
var _brrp__multiformats_scope_baseX = src;

var Encoder = /*#__PURE__*/function () {
  function Encoder(name, prefix, baseEncode) {
    _classCallCheck(this, Encoder);

    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }

  _createClass(Encoder, [{
    key: "encode",
    value: function encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return "".concat(this.prefix).concat(this.baseEncode(bytes));
      } else {
        throw Error('Unknown type, must be binary type');
      }
    }
  }]);

  return Encoder;
}();

var Decoder = /*#__PURE__*/function () {
  function Decoder(name, prefix, baseDecode) {
    _classCallCheck(this, Decoder);

    this.name = name;
    this.prefix = prefix;

    if (prefix.codePointAt(0) === undefined) {
      throw new Error('Invalid prefix character');
    }

    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }

  _createClass(Decoder, [{
    key: "decode",
    value: function decode(text) {
      if (typeof text === 'string') {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error("Unable to decode multibase string ".concat(JSON.stringify(text), ", ").concat(this.name, " decoder only supports inputs prefixed with ").concat(this.prefix));
        }

        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error('Can only multibase decode strings');
      }
    }
  }, {
    key: "or",
    value: function or(decoder) {
      return _or(this, decoder);
    }
  }]);

  return Decoder;
}();

var ComposedDecoder = /*#__PURE__*/function () {
  function ComposedDecoder(decoders) {
    _classCallCheck(this, ComposedDecoder);

    this.decoders = decoders;
  }

  _createClass(ComposedDecoder, [{
    key: "or",
    value: function or(decoder) {
      return _or(this, decoder);
    }
  }, {
    key: "decode",
    value: function decode(input) {
      var prefix = input[0];
      var decoder = this.decoders[prefix];

      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(input), ", only inputs prefixed with ").concat(Object.keys(this.decoders), " are supported"));
      }
    }
  }]);

  return ComposedDecoder;
}();

var _or = function _or(left, right) {
  return new ComposedDecoder(_objectSpread2(_objectSpread2({}, left.decoders || _defineProperty$1({}, left.prefix, left)), right.decoders || _defineProperty$1({}, right.prefix, right)));
};
var Codec = /*#__PURE__*/function () {
  function Codec(name, prefix, baseEncode, baseDecode) {
    _classCallCheck(this, Codec);

    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix, baseEncode);
    this.decoder = new Decoder(name, prefix, baseDecode);
  }

  _createClass(Codec, [{
    key: "encode",
    value: function encode(input) {
      return this.encoder.encode(input);
    }
  }, {
    key: "decode",
    value: function decode(input) {
      return this.decoder.decode(input);
    }
  }]);

  return Codec;
}();
var from$1 = function from(_ref3) {
  var name = _ref3.name,
      prefix = _ref3.prefix,
      encode = _ref3.encode,
      decode = _ref3.decode;
  return new Codec(name, prefix, encode, decode);
};
var baseX = function baseX(_ref4) {
  var prefix = _ref4.prefix,
      name = _ref4.name,
      alphabet = _ref4.alphabet;

  var _basex = _brrp__multiformats_scope_baseX(alphabet, name),
      encode = _basex.encode,
      _decode = _basex.decode;

  return from$1({
    prefix: prefix,
    name: name,
    encode: encode,
    decode: function decode(text) {
      return coerce(_decode(text));
    }
  });
};

var _decode2 = function decode(string, alphabet, bitsPerChar, name) {
  var codes = {};

  for (var i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i;
  }

  var end = string.length;

  while (string[end - 1] === '=') {
    --end;
  }

  var out = new Uint8Array(end * bitsPerChar / 8 | 0);
  var bits = 0;
  var buffer = 0;
  var written = 0;

  for (var _i = 0; _i < end; ++_i) {
    var value = codes[string[_i]];

    if (value === undefined) {
      throw new SyntaxError("Non-".concat(name, " character"));
    }

    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;

    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }

  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError('Unexpected end of data');
  }

  return out;
};

var _encode = function encode(data, alphabet, bitsPerChar) {
  var pad = alphabet[alphabet.length - 1] === '=';
  var mask = (1 << bitsPerChar) - 1;
  var out = '';
  var bits = 0;
  var buffer = 0;

  for (var i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;

    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet[mask & buffer >> bits];
    }
  }

  if (bits) {
    out += alphabet[mask & buffer << bitsPerChar - bits];
  }

  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += '=';
    }
  }

  return out;
};

var rfc4648 = function rfc4648(_ref5) {
  var name = _ref5.name,
      prefix = _ref5.prefix,
      bitsPerChar = _ref5.bitsPerChar,
      alphabet = _ref5.alphabet;
  return from$1({
    prefix: prefix,
    name: name,
    encode: function encode(input) {
      return _encode(input, alphabet, bitsPerChar);
    },
    decode: function decode(input) {
      return _decode2(input, alphabet, bitsPerChar, name);
    }
  });
};

var base58btc = baseX({
  name: 'base58btc',
  prefix: 'z',
  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
});
baseX({
  name: 'base58flickr',
  prefix: 'Z',
  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
});

var base32 = rfc4648({
  prefix: 'b',
  name: 'base32',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'B',
  name: 'base32upper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'c',
  name: 'base32pad',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'C',
  name: 'base32padupper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'v',
  name: 'base32hex',
  alphabet: '0123456789abcdefghijklmnopqrstuv',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'V',
  name: 'base32hexupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
  bitsPerChar: 5
});
rfc4648({
  prefix: 't',
  name: 'base32hexpad',
  alphabet: '0123456789abcdefghijklmnopqrstuv=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'T',
  name: 'base32hexpadupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'h',
  name: 'base32z',
  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
  bitsPerChar: 5
});

var CID = /*#__PURE__*/function (_Symbol$toStringTag, _Symbol$for) {
  function CID(version, code, multihash, bytes) {
    _classCallCheck(this, CID);

    this.code = code;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }

  _createClass(CID, [{
    key: "toV0",
    value: function toV0() {
      switch (this.version) {
        case 0:
          {
            return this;
          }

        default:
          {
            var code = this.code,
                multihash = this.multihash;

            if (code !== DAG_PB_CODE) {
              throw new Error('Cannot convert a non dag-pb CID to CIDv0');
            }

            if (multihash.code !== SHA_256_CODE) {
              throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
            }

            return CID.createV0(multihash);
          }
      }
    }
  }, {
    key: "toV1",
    value: function toV1() {
      switch (this.version) {
        case 0:
          {
            var _this$multihash = this.multihash,
                code = _this$multihash.code,
                digest = _this$multihash.digest;
            var multihash = create(code, digest);
            return CID.createV1(this.code, multihash);
          }

        case 1:
          {
            return this;
          }

        default:
          {
            throw Error("Can not convert CID version ".concat(this.version, " to version 0. This is a bug please report"));
          }
      }
    }
  }, {
    key: "equals",
    value: function equals$1(other) {
      return other && this.code === other.code && this.version === other.version && equals(this.multihash, other.multihash);
    }
  }, {
    key: "toString",
    value: function toString(base) {
      var bytes = this.bytes,
          version = this.version,
          _baseCache = this._baseCache;

      switch (version) {
        case 0:
          return toStringV0(bytes, _baseCache, base || base58btc.encoder);

        default:
          return toStringV1(bytes, _baseCache, base || base32.encoder);
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        code: this.code,
        version: this.version,
        hash: this.multihash.bytes
      };
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return 'CID';
    }
  }, {
    key: _Symbol$for,
    value: function value() {
      return 'CID(' + this.toString() + ')';
    }
  }, {
    key: "toBaseEncodedString",
    get: function get() {
      throw new Error('Deprecated, use .toString()');
    }
  }, {
    key: "codec",
    get: function get() {
      throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
  }, {
    key: "buffer",
    get: function get() {
      throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');
    }
  }, {
    key: "multibaseName",
    get: function get() {
      throw new Error('"multibaseName" property is deprecated');
    }
  }, {
    key: "prefix",
    get: function get() {
      throw new Error('"prefix" property is deprecated');
    }
  }], [{
    key: "isCID",
    value: function isCID(value) {
      deprecate(/^0\.0/, IS_CID_DEPRECATION);
      return !!(value && (value[cidSymbol] || value.asCID === value));
    }
  }, {
    key: "asCID",
    value: function asCID(value) {
      if (value instanceof CID) {
        return value;
      } else if (value != null && value.asCID === value) {
        var _version = value.version,
            code = value.code,
            multihash = value.multihash,
            bytes = value.bytes;
        return new CID(_version, code, multihash, bytes || encodeCID(_version, code, multihash.bytes));
      } else if (value != null && value[cidSymbol] === true) {
        var _version2 = value.version,
            _multihash = value.multihash,
            _code = value.code;
        var digest = decode(_multihash);
        return CID.create(_version2, _code, digest);
      } else {
        return null;
      }
    }
  }, {
    key: "create",
    value: function create(version, code, digest) {
      if (typeof code !== 'number') {
        throw new Error('String codecs are no longer supported');
      }

      switch (version) {
        case 0:
          {
            if (code !== DAG_PB_CODE) {
              throw new Error("Version 0 CID must use dag-pb (code: ".concat(DAG_PB_CODE, ") block encoding"));
            } else {
              return new CID(version, code, digest, digest.bytes);
            }
          }

        case 1:
          {
            var bytes = encodeCID(version, code, digest.bytes);
            return new CID(version, code, digest, bytes);
          }

        default:
          {
            throw new Error('Invalid version');
          }
      }
    }
  }, {
    key: "createV0",
    value: function createV0(digest) {
      return CID.create(0, DAG_PB_CODE, digest);
    }
  }, {
    key: "createV1",
    value: function createV1(code, digest) {
      return CID.create(1, code, digest);
    }
  }, {
    key: "decode",
    value: function decode(bytes) {
      var _CID$decodeFirst = CID.decodeFirst(bytes),
          _CID$decodeFirst2 = _slicedToArray(_CID$decodeFirst, 2),
          cid = _CID$decodeFirst2[0],
          remainder = _CID$decodeFirst2[1];

      if (remainder.length) {
        throw new Error('Incorrect length');
      }

      return cid;
    }
  }, {
    key: "decodeFirst",
    value: function decodeFirst(bytes) {
      var specs = CID.inspectBytes(bytes);
      var prefixSize = specs.size - specs.multihashSize;
      var multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));

      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error('Incorrect length');
      }

      var digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      var digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      var cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
      return [cid, bytes.subarray(specs.size)];
    }
  }, {
    key: "inspectBytes",
    value: function inspectBytes(initialBytes) {
      var offset = 0;

      var next = function next() {
        var _varint$decode = decode$1(initialBytes.subarray(offset)),
            _varint$decode2 = _slicedToArray(_varint$decode, 2),
            i = _varint$decode2[0],
            length = _varint$decode2[1];

        offset += length;
        return i;
      };

      var version = next();
      var codec = DAG_PB_CODE;

      if (version === 18) {
        version = 0;
        offset = 0;
      } else if (version === 1) {
        codec = next();
      }

      if (version !== 0 && version !== 1) {
        throw new RangeError("Invalid CID version ".concat(version));
      }

      var prefixSize = offset;
      var multihashCode = next();
      var digestSize = next();
      var size = offset + digestSize;
      var multihashSize = size - prefixSize;
      return {
        version: version,
        codec: codec,
        multihashCode: multihashCode,
        digestSize: digestSize,
        multihashSize: multihashSize,
        size: size
      };
    }
  }, {
    key: "parse",
    value: function parse(source, base) {
      var _parseCIDtoBytes = parseCIDtoBytes(source, base),
          _parseCIDtoBytes2 = _slicedToArray(_parseCIDtoBytes, 2),
          prefix = _parseCIDtoBytes2[0],
          bytes = _parseCIDtoBytes2[1];

      var cid = CID.decode(bytes);

      cid._baseCache.set(prefix, source);

      return cid;
    }
  }]);

  return CID;
}(Symbol.toStringTag, Symbol["for"]('nodejs.util.inspect.custom'));

var parseCIDtoBytes = function parseCIDtoBytes(source, base) {
  switch (source[0]) {
    case 'Q':
      {
        var decoder = base || base58btc;
        return [base58btc.prefix, decoder.decode("".concat(base58btc.prefix).concat(source))];
      }

    case base58btc.prefix:
      {
        var _decoder = base || base58btc;

        return [base58btc.prefix, _decoder.decode(source)];
      }

    case base32.prefix:
      {
        var _decoder2 = base || base32;

        return [base32.prefix, _decoder2.decode(source)];
      }

    default:
      {
        if (base == null) {
          throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');
        }

        return [source[0], base.decode(source)];
      }
  }
};

var toStringV0 = function toStringV0(bytes, cache, base) {
  var prefix = base.prefix;

  if (prefix !== base58btc.prefix) {
    throw Error("Cannot string encode V0 in ".concat(base.name, " encoding"));
  }

  var cid = cache.get(prefix);

  if (cid == null) {
    var _cid = base.encode(bytes).slice(1);

    cache.set(prefix, _cid);
    return _cid;
  } else {
    return cid;
  }
};

var toStringV1 = function toStringV1(bytes, cache, base) {
  var prefix = base.prefix;
  var cid = cache.get(prefix);

  if (cid == null) {
    var _cid2 = base.encode(bytes);

    cache.set(prefix, _cid2);
    return _cid2;
  } else {
    return cid;
  }
};

var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;

var encodeCID = function encodeCID(version, code, multihash) {
  var codeOffset = encodingLength(version);
  var hashOffset = codeOffset + encodingLength(code);
  var bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version, bytes, 0);
  encodeTo(code, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};

var cidSymbol = Symbol["for"]('@ipld/js-cid/CID');
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version$1 = '0.0.0-dev';

var deprecate = function deprecate(range, message) {
  if (range.test(version$1)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};

var IS_CID_DEPRECATION = "CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n";

var textEncoder = new TextEncoder();
new TextDecoder();
var code = 512;
var encode = function encode(node) {
  return textEncoder.encode(JSON.stringify(node));
};

var from = function from(_ref) {
  var name = _ref.name,
      code = _ref.code,
      encode = _ref.encode;
  return new Hasher(name, code, encode);
};
var Hasher = /*#__PURE__*/function () {
  function Hasher(name, code, encode) {
    _classCallCheck(this, Hasher);

    this.name = name;
    this.code = code;
    this.encode = encode;
  }

  _createClass(Hasher, [{
    key: "digest",
    value: function digest(input) {
      var _this = this;

      if (input instanceof Uint8Array) {
        var result = this.encode(input);
        return result instanceof Uint8Array ? create(this.code, result) : result.then(function (digest) {
          return create(_this.code, digest);
        });
      } else {
        throw Error('Unknown type, must be binary type');
      }
    }
  }]);

  return Hasher;
}();

var sha256 = from({
  name: 'sha2-256',
  code: 18,
  encode: function encode(input) {
    return coerce(crypto__default["default"].createHash('sha256').update(input).digest());
  }
});
from({
  name: 'sha2-512',
  code: 19,
  encode: function encode(input) {
    return coerce(crypto__default["default"].createHash('sha512').update(input).digest());
  }
});

var block = {
  get: function () {
    var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key, _options) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              throw new Error("unexpected block API get for ".concat(key));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function get(_x, _x2) {
      return _get.apply(this, arguments);
    }

    return get;
  }(),
  put: function () {
    var _put = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_key, _val, _options) {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              throw new Error('unexpected block API put');

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function put(_x3, _x4, _x5) {
      return _put.apply(this, arguments);
    }

    return put;
  }(),
  open: function () {
    var _open = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function open() {
      return _open.apply(this, arguments);
    }

    return open;
  }(),
  close: function () {
    var _close = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function close() {
      return _close.apply(this, arguments);
    }

    return close;
  }(),
  has: function () {
    var _has = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_key, _options) {
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    function has(_x6, _x7) {
      return _has.apply(this, arguments);
    }

    return has;
  }(),
  "delete": function () {
    var _delete2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_key, _options) {
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    function _delete(_x8, _x9) {
      return _delete2.apply(this, arguments);
    }

    return _delete;
  }(),
  putMany: function putMany(_source, _options) {
    throw new Error('Function not implemented.');
  },
  getMany: function getMany(_source, _options) {
    throw new Error('Function not implemented.');
  },
  deleteMany: function deleteMany(_source, _options) {
    throw new Error('Function not implemented.');
  },
  batch: function batch() {
    throw new Error('Function not implemented.');
  },
  query: function query(_query, _options) {
    throw new Error('Function not implemented.');
  },
  queryKeys: function queryKeys(_query, _options) {
    throw new Error('Function not implemented.');
  }
};
var fileHasher = {
  convertNanosToMillis: function convertNanosToMillis(nanoSeconds) {
    return nanoSeconds / BigInt(1000000);
  },

  /**
   * Used to initalize the only hash fns. See Alan Shaw's reference code for more context.
   */
  initImageHasher: function initImageHasher(content, options) {
    options = options || {};
    options.onlyHash = true;
    options.cidVersion = 0;
    return {
      options: options,
      content: content
    };
  },

  /**
   * Used to iniitalize the only hash fns. See Alan Shaw's reference code for more context.
   */
  initNonImageHasher: function initNonImageHasher(content, options) {
    options = options || {};
    options.onlyHash = true;
    options.cidVersion = 0;
    return {
      options: options,
      content: content
    };
  },

  /**
   * Convert content to a buffer; used in `generateNonImageCid()`.
   * @param {ReadStream|Buffer|string} content if string, should be file path
   * @param {Object} logger
   * @returns buffer version of content
   */
  convertToBuffer: function convertToBuffer(content, logger) {
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
      var buffer, fsReadFile, errMsg;
      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!Buffer.isBuffer(content)) {
                _context7.next = 2;
                break;
              }

              return _context7.abrupt("return", content);

            case 2:
              _context7.prev = 2;

              if (!(content instanceof stream.Stream.Readable)) {
                _context7.next = 8;
                break;
              }

              _context7.next = 6;
              return new Promise(function (resolve, reject) {
                content.on('data', function (chunk) {
                  return buffer.push(chunk);
                });
                content.on('end', function () {
                  return resolve(Buffer.concat(buffer));
                });
                content.on('error', function (err) {
                  return reject(err);
                });
              });

            case 6:
              _context7.next = 12;
              break;

            case 8:
              fsReadFile = util.promisify(fs__default["default"].readFile);
              _context7.next = 11;
              return fsReadFile(content);

            case 11:
              buffer = _context7.sent;

            case 12:
              _context7.next = 19;
              break;

            case 14:
              _context7.prev = 14;
              _context7.t0 = _context7["catch"](2);
              errMsg = "[fileHasher - convertToBuffer()] Could not convert content into buffer: ".concat(_context7.t0.toString());
              logger.error(errMsg);
              throw new Error(errMsg);

            case 19:
              return _context7.abrupt("return", buffer);

            case 20:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, null, [[2, 14]]);
    }))();
  },

  /**
   * Custom fn to generate the content-hashing logic
   * @param content a buffer of the content
   * @param options options for importer
   * @returns the V0 CID from content addressing logic
   */
  hashNonImages: function hashNonImages(content) {
    var _arguments = arguments;
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
      var options, _fileHasher$initNonIm, lastCid, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, cid;

      return regeneratorRuntime.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              options = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};
              _fileHasher$initNonIm = fileHasher.initNonImageHasher(content, options);
              options = _fileHasher$initNonIm.options;
              content = _fileHasher$initNonIm.content;
              lastCid = '';
              _iteratorAbruptCompletion = false;
              _didIteratorError = false;
              _context8.prev = 8;
              _iterator = _asyncIterator(ipfsUnixfsImporter.importer([{
                content: content
              }], block, options));

            case 10:
              _context8.next = 12;
              return _iterator.next();

            case 12:
              if (!(_iteratorAbruptCompletion = !(_step = _context8.sent).done)) {
                _context8.next = 18;
                break;
              }

              cid = _step.value.cid;
              lastCid = "".concat(cid);

            case 15:
              _iteratorAbruptCompletion = false;
              _context8.next = 10;
              break;

            case 18:
              _context8.next = 24;
              break;

            case 20:
              _context8.prev = 20;
              _context8.t0 = _context8["catch"](8);
              _didIteratorError = true;
              _iteratorError = _context8.t0;

            case 24:
              _context8.prev = 24;
              _context8.prev = 25;

              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                _context8.next = 29;
                break;
              }

              _context8.next = 29;
              return _iterator["return"]();

            case 29:
              _context8.prev = 29;

              if (!_didIteratorError) {
                _context8.next = 32;
                break;
              }

              throw _iteratorError;

            case 32:
              return _context8.finish(29);

            case 33:
              return _context8.finish(24);

            case 34:
              return _context8.abrupt("return", lastCid);

            case 35:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, null, [[8, 20, 24, 34], [25,, 29, 33]]);
    }))();
  },

  /**
   * Custom fn to generate the content-hashing logic
   * @param content an Object[] with the structure [{ path: string, content: buffer }, ...]
   * @param options options for importer
   * @returns an Object[] with the structure [{path: <string>, cid: <string>, size: <number>}]
   *
   * Example with adding a profile picture:
   * [
      {
        "cid": "QmSRyKvnXwoxPZ9UxqxXPR8NXjcPYBEf1qbNrXyo5USqLL",
        "path": "blob/150x150.jpg",
        "size": 3091
      },
      {
        "cid": "QmQQMV9TXxRmDKafZiRvMVkqUNtUu9WGAfukUBS1yCk2ht",
        "path": "blob/480x480.jpg",
        "size": 20743
      },
      {
        "cid": "Qmd8cDdDGcWVaLEoJPVFtkKhYMqvHXZTvXcisYjubFxv1F",
        "path": "blob/1000x1000.jpg",
        "size": 72621
      },
      {
        "cid": "QmaYCPUH8G14yxetsMgW5J5tpTqPaTp3HMd3EAyffZKSvm",
        "path": "blob/original.jpg",
        "size": 185844
      },
      {
        "cid": "QmW8FUFhvaxv1MZmVcUcmR7Tg9WZhGf8xDNBesT9XepwrK",
        "path": "blob",
        "size": 282525
      }
    ]
  */
  hashImages: function hashImages(content) {
    var _arguments2 = arguments;
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
      var options, _fileHasher$initImage, result, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, file;

      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              options = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};
              _fileHasher$initImage = fileHasher.initImageHasher(content, options);
              options = _fileHasher$initImage.options;
              content = _fileHasher$initImage.content;
              result = [];
              _iteratorAbruptCompletion2 = false;
              _didIteratorError2 = false;
              _context9.prev = 8;
              _iterator2 = _asyncIterator(ipfsUnixfsImporter.importer(content, block, options));

            case 10:
              _context9.next = 12;
              return _iterator2.next();

            case 12:
              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context9.sent).done)) {
                _context9.next = 18;
                break;
              }

              file = _step2.value;
              result.push({
                path: file.path,
                cid: "".concat(file.cid),
                size: file.size
              });

            case 15:
              _iteratorAbruptCompletion2 = false;
              _context9.next = 10;
              break;

            case 18:
              _context9.next = 24;
              break;

            case 20:
              _context9.prev = 20;
              _context9.t0 = _context9["catch"](8);
              _didIteratorError2 = true;
              _iteratorError2 = _context9.t0;

            case 24:
              _context9.prev = 24;
              _context9.prev = 25;

              if (!(_iteratorAbruptCompletion2 && _iterator2["return"] != null)) {
                _context9.next = 29;
                break;
              }

              _context9.next = 29;
              return _iterator2["return"]();

            case 29:
              _context9.prev = 29;

              if (!_didIteratorError2) {
                _context9.next = 32;
                break;
              }

              throw _iteratorError2;

            case 32:
              return _context9.finish(29);

            case 33:
              return _context9.finish(24);

            case 34:
              return _context9.abrupt("return", result);

            case 35:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, null, [[8, 20, 24, 34], [25,, 29, 33]]);
    }))();
  },

  /**
   * Generates CID V0 (46-char string starting with "Qm") for a non-image file (track segment, track transcode, metadata)
   * @param {Buffer|ReadStream|string} content a single Buffer, a ReadStream, or path to an existing file
   * @param {Object?} logger
   * @returns {string} only hash response cid
   */
  generateNonImageCid: function generateNonImageCid(content) {
    var _arguments3 = arguments;
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
      var logger, buffer;
      return regeneratorRuntime.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              logger = _arguments3.length > 1 && _arguments3[1] !== undefined ? _arguments3[1] : console;
              _context10.next = 3;
              return fileHasher.convertToBuffer(content, logger);

            case 3:
              buffer = _context10.sent;
              _context10.next = 6;
              return fileHasher.hashNonImages(buffer);

            case 6:
              return _context10.abrupt("return", _context10.sent);

            case 7:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }))();
  },

  /**
   * Generates CID V1 for a JSON metadata object (NOT the string of the metadata - must be an object).
   * CID<T, 512, SHA_256, 1> represents CID with json codec (512) and sha256 hash using CID V1.
   * Call toString() on the result to get the CID V1 string.
   */
  generateMetadataCidV1: function generateMetadataCidV1(metadata) {
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
      var bytes, hash;
      return regeneratorRuntime.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              bytes = encode(metadata);
              _context11.next = 3;
              return sha256.digest(bytes);

            case 3:
              hash = _context11.sent;
              return _context11.abrupt("return", CID.create(1, code, hash));

            case 5:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }))();
  },

  /**
   * Wrapper that generates multihashes for image files
   * @param {Object[]} content an Object[] with the structure [{ path: string, content: buffer }, ...]
   * @param {Object?} logger
   * @returns {HashedImage[]} only hash responses with the structure [{path: <string>, cid: <string>, size: <number>}]
   */
  generateImageCids: function generateImageCids(content) {
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {

      return regeneratorRuntime.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 3;
              return fileHasher.hashImages(content);

            case 3:
              return _context12.abrupt("return", _context12.sent);

            case 4:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }))();
  }
};

var HASH_SALT = 'azowernasdfoia';
var MIN_LENGTH = 5;
var hashids = new Hashids__default["default"](HASH_SALT, MIN_LENGTH);
var ZeroAddress = '0x0000000000000000000000000000000000000000'; // eslint-disable-next-line @typescript-eslint/no-extraneous-class -- this should just be esm

var Utils = /*#__PURE__*/function () {
  function Utils() {
    _classCallCheck(this, Utils);
  }

  _createClass(Utils, null, [{
    key: "utf8ToHex",
    value: function utf8ToHex(utf8Str) {
      return LibsWeb3.utils.utf8ToHex(utf8Str);
    }
  }, {
    key: "padRight",
    value: function padRight(hexStr, size) {
      return LibsWeb3.utils.padRight(hexStr, size);
    }
  }, {
    key: "hexToUtf8",
    value: function hexToUtf8(hexStr) {
      return LibsWeb3.utils.hexToUtf8(hexStr);
    }
  }, {
    key: "keccak256",
    value: function keccak256(utf8Str) {
      return LibsWeb3.utils.keccak256(utf8Str);
    }
  }, {
    key: "isBN",
    value: function isBN(number) {
      return LibsWeb3.utils.isBN(number);
    }
  }, {
    key: "toBN",
    value: function toBN(number, base) {
      return new LibsWeb3.utils.BN(number, base);
    }
  }, {
    key: "BN",
    value: function BN() {
      return LibsWeb3.utils.BN;
    }
  }, {
    key: "checkStrLen",
    value: function checkStrLen(str, maxLen) {
      var minLen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

      if (str === undefined || str === null || str.length > maxLen || str.length < minLen) {
        throw new Error("String '".concat(str, "' must be between ").concat(minLen, "-").concat(maxLen, " characters"));
      }
    }
  }, {
    key: "wait",
    value: function () {
      var _wait = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(milliseconds) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, milliseconds);
                });

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function wait(_x) {
        return _wait.apply(this, arguments);
      }

      return wait;
    }() // Regular expression to check if endpoint is a FQDN. https://regex101.com/r/kIowvx/2

  }, {
    key: "isFQDN",
    value: function isFQDN(url) {
      var FQDN = /(?:^|[ \t])((https?:\/\/)?(?:localhost|[\w-]+(?:\.[\w-]+)+)(:\d+)?(\/\S*)?)/gm;
      return FQDN.test(url);
    }
  }, {
    key: "isHttps",
    value: function isHttps(url) {
      var https = /^https:\/\//;
      return https.test(url);
    } // Function to check if the endpont/health_check returns JSON object [ {'healthy':true} ]

  }, {
    key: "isHealthy",
    value: function () {
      var _isHealthy = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url) {
        var _yield$axios$get, body;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return axios__default["default"].get(url + '/health_check');

              case 3:
                _yield$axios$get = _context2.sent;
                body = _yield$axios$get.data;
                return _context2.abrupt("return", body.data.healthy);

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](0);
                return _context2.abrupt("return", false);

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[0, 8]]);
      }));

      function isHealthy(_x2) {
        return _isHealthy.apply(this, arguments);
      }

      return isHealthy;
    }()
  }, {
    key: "formatOptionalMultihash",
    value: function formatOptionalMultihash(multihash) {
      if (multihash) {
        return this.decodeMultihash(multihash).digest;
      } else {
        return this.utf8ToHex('');
      }
    }
  }, {
    key: "decodeMultihash",
    value: function decodeMultihash(multihash) {
      var base16Multihash = bs58__default["default"].decode(multihash);
      return {
        digest: "0x".concat(base16Multihash.slice(2).toString('hex')),
        hashFn: parseInt(base16Multihash[0]),
        size: parseInt(base16Multihash[1])
      };
    }
    /**
     * Given a digest value (written on chain, obtained through AudiusABIDecoder.decodeMethod),
     * convert back to a IFPS CIDv0
     * @param multihashDigest digest value from decodeMultihash
     * @returns String CID value
     */

  }, {
    key: "encodeMultihash",
    value: function encodeMultihash(multihashDigest) {
      // the 1220 is from reconstructing the hashFn and size with digest, the opposite of decodeMultihash
      // since IPFS CIDv0 has a fixed hashFn and size, the first two values are always 12 and 20
      // concat them together with digest and encode back to base58
      var digestStr = "1220".concat(multihashDigest.replace('0x', '')); // convert digestStr from hex to base 58

      return bs58__default["default"].encode(Buffer.from(digestStr, 'hex'));
    }
  }, {
    key: "parseDataFromResponse",
    value: function parseDataFromResponse(response) {
      if (!response || !response.data) return null;
      var obj = response.data; // adapted from https://github.com/jashkenas/underscore/blob/master/underscore.js _.isEmpty function

      if (obj == null) return null;
      if ((Array.isArray(obj) || typeof obj === 'string') && obj.length === 0) return null;
      if (Object.keys(obj).length === 0) return null;
      return obj;
    }
  }, {
    key: "configureWeb3",
    value: function () {
      var _configureWeb = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(web3Provider, chainNetworkId) {
        var requiresAccount,
            web3Instance,
            networkId,
            accounts,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                requiresAccount = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : true;
                // Initializing web3 with a HttpProvider wrapper for multiple providers
                // ref: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3/types/index.d.ts#L31.
                web3Instance = new LibsWeb3(new MultiProvider(web3Provider));
                _context3.prev = 2;
                _context3.next = 5;
                return web3Instance.eth.net.getId();

              case 5:
                networkId = _context3.sent;

                if (!(chainNetworkId && networkId.toString() !== chainNetworkId)) {
                  _context3.next = 8;
                  break;
                }

                return _context3.abrupt("return", false);

              case 8:
                if (!requiresAccount) {
                  _context3.next = 14;
                  break;
                }

                _context3.next = 11;
                return web3Instance.eth.getAccounts();

              case 11:
                accounts = _context3.sent;

                if (!(!accounts || accounts.length < 1)) {
                  _context3.next = 14;
                  break;
                }

                return _context3.abrupt("return", false);

              case 14:
                _context3.next = 19;
                break;

              case 16:
                _context3.prev = 16;
                _context3.t0 = _context3["catch"](2);
                return _context3.abrupt("return", false);

              case 19:
                return _context3.abrupt("return", web3Instance);

              case 20:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[2, 16]]);
      }));

      function configureWeb3(_x3, _x4) {
        return _configureWeb.apply(this, arguments);
      }

      return configureWeb3;
    }()
  }, {
    key: "zeroAddress",
    get: function get() {
      return ZeroAddress;
    }
  }, {
    key: "isZeroAddress",
    value: function isZeroAddress(address) {
      return address === Utils.zeroAddress;
    }
  }, {
    key: "makeUuid",
    value: function makeUuid() {
      return uuid();
    }
    /**
     * Decodes a string id into an int. Returns null if an invalid ID.
     */

  }, {
    key: "decodeHashId",
    value: function decodeHashId(id) {
      try {
        var ids = hashids.decode(id);
        if (!ids.length) return null;
        var num = Number(ids[0]);
        if (isNaN(num)) return null;
        return num;
      } catch (e) {
        console.error("Failed to decode ".concat(id), e);
        return null;
      }
    }
    /**
     * Encodes an int to a string based hashid
     */

  }, {
    key: "encodeHashId",
    value: function encodeHashId(id) {
      try {
        if (id === null) return null;
        var encodedId = hashids.encode(id);
        return encodedId;
      } catch (e) {
        console.error("Failed to encode ".concat(id), e);
        return null;
      }
    }
    /**
     * If `promise` responds before `timeoutMs`,
     * this function returns its response; else rejects with `timeoutMessage`
     */

  }, {
    key: "racePromiseWithTimeout",
    value: function () {
      var _racePromiseWithTimeout = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(promise, timeoutMs, timeoutMessage) {
        var timeoutPromise;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                // eslint-disable-next-line promise/param-names
                timeoutPromise = new Promise(function (_promise, reject) {
                  setTimeout(function () {
                    return reject(new Error(timeoutMessage));
                  }, timeoutMs);
                });
                _context4.next = 3;
                return Promise.race([promise, timeoutPromise]);

              case 3:
                return _context4.abrupt("return", _context4.sent);

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function racePromiseWithTimeout(_x5, _x6, _x7) {
        return _racePromiseWithTimeout.apply(this, arguments);
      }

      return racePromiseWithTimeout;
    }()
  }, {
    key: "getRandomInt",
    value: function getRandomInt(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min) + min);
    }
  }]);

  return Utils;
}();

_defineProperty$1(Utils, "fileHasher", fileHasher);

var web3Instance = new LibsWeb3(); // From https://github.com/AudiusProject/sig/blob/main/node/index.js

function hashAndSign(_x, _x2) {
  return _hashAndSign.apply(this, arguments);
}
/**
 * Recover the public wallet address given the response contains the signature and timestamp
 * @param {object} response entire service provider response (not axios)
 */

function _hashAndSign() {
  _hashAndSign = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(input, privateKey) {
    var toSignHash, signedMessage;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            toSignHash = web3Instance.utils.keccak256(input);
            _context.next = 3;
            return web3Instance.eth.accounts.sign(toSignHash, privateKey);

          case 3:
            signedMessage = _context.sent;
            return _context.abrupt("return", signedMessage.signature);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _hashAndSign.apply(this, arguments);
}
/**
 * Recursively sorts object keys alphabetically
 */

function sortObjectKeys$1(x) {
  if (_typeof(x) !== 'object' || !x) {
    return x;
  }

  if (Array.isArray(x)) {
    return x.map(sortObjectKeys$1);
  }

  return Object.keys(x).sort().reduce(function (o, k) {
    return _objectSpread2(_objectSpread2({}, o), {}, _defineProperty$1({}, k, sortObjectKeys$1(x[k])));
  }, {});
}

// Default multiplier on top of gas estimate to be extra safe that txns
// will go through
var GAS_LIMIT_MULTIPLIER = 1.05;
/**
 * Returns estimated gas use for a txn for a contract method
 * @param options
 * @param options.method the contract method
 * @param options.from address the method will be sent from (required if the contract requires a certain sender, e.g. guardian)
 * @param options.gasLimitMaximum the maximum amount of gas we will allow
 * (likely will return a number much smaller than this)
 * @param options.multipler the multiplier to safe-guard against estimates that are too low
 */

var estimateGas = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
    var method, from, gasLimitMaximum, _ref$multiplier, multiplier, estimatedGas, safeEstimatedGas;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            method = _ref.method, from = _ref.from, gasLimitMaximum = _ref.gasLimitMaximum, _ref$multiplier = _ref.multiplier, multiplier = _ref$multiplier === void 0 ? GAS_LIMIT_MULTIPLIER : _ref$multiplier;
            _context.prev = 1;
            _context.next = 4;
            return method.estimateGas({
              from: from,
              gas: gasLimitMaximum
            });

          case 4:
            estimatedGas = _context.sent;
            // Rounding is necessary here as fractional gas limits will break
            safeEstimatedGas = Math.ceil(estimatedGas * multiplier);
            console.info("Estimated gas limit ".concat(safeEstimatedGas, " for method ").concat(method._method.name));
            return _context.abrupt("return", safeEstimatedGas);

          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](1);
            console.error("Unable to estimate gas for transaction ".concat(method._method.name, ", using ").concat(gasLimitMaximum));
            return _context.abrupt("return", gasLimitMaximum);

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 10]]);
  }));

  return function estimateGas(_x) {
    return _ref2.apply(this, arguments);
  };
}();

function promiseFight(_x, _x2) {
  return _promiseFight.apply(this, arguments);
}

function _promiseFight() {
  _promiseFight = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(promises, captureErrored) {
    var errored;
    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            errored = [];
            _context6.next = 3;
            return Promise.all(promises.map( /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(p) {
                return regeneratorRuntime.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.next = 2;
                        return p.then( /*#__PURE__*/function () {
                          var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(val) {
                            return regeneratorRuntime.wrap(function _callee$(_context) {
                              while (1) {
                                switch (_context.prev = _context.next) {
                                  case 0:
                                    _context.next = 2;
                                    return Promise.reject(val);

                                  case 2:
                                    return _context.abrupt("return", _context.sent);

                                  case 3:
                                  case "end":
                                    return _context.stop();
                                }
                              }
                            }, _callee);
                          }));

                          return function (_x4) {
                            return _ref2.apply(this, arguments);
                          };
                        }(), /*#__PURE__*/function () {
                          var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(err) {
                            return regeneratorRuntime.wrap(function _callee2$(_context2) {
                              while (1) {
                                switch (_context2.prev = _context2.next) {
                                  case 0:
                                    if (captureErrored) errored.push(err);
                                    _context2.next = 3;
                                    return Promise.resolve(err);

                                  case 3:
                                    return _context2.abrupt("return", _context2.sent);

                                  case 4:
                                  case "end":
                                    return _context2.stop();
                                }
                              }
                            }, _callee2);
                          }));

                          return function (_x5) {
                            return _ref3.apply(this, arguments);
                          };
                        }());

                      case 2:
                        return _context3.abrupt("return", _context3.sent);

                      case 3:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function (_x3) {
                return _ref.apply(this, arguments);
              };
            }())).then( /*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(errors) {
                return regeneratorRuntime.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.next = 2;
                        return Promise.reject(errors);

                      case 2:
                        return _context4.abrupt("return", _context4.sent);

                      case 3:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));

              return function (_x6) {
                return _ref4.apply(this, arguments);
              };
            }(), /*#__PURE__*/function () {
              var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(val) {
                return regeneratorRuntime.wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        if (!captureErrored) {
                          _context5.next = 6;
                          break;
                        }

                        _context5.next = 3;
                        return Promise.resolve({
                          val: val,
                          errored: errored
                        });

                      case 3:
                        return _context5.abrupt("return", _context5.sent);

                      case 6:
                        _context5.next = 8;
                        return Promise.resolve(val);

                      case 8:
                        return _context5.abrupt("return", _context5.sent);

                      case 9:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5);
              }));

              return function (_x7) {
                return _ref5.apply(this, arguments);
              };
            }());

          case 3:
            return _context6.abrupt("return", _context6.sent);

          case 4:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _promiseFight.apply(this, arguments);
}

var sign = function sign(digest, privateKey) {
  var buffer = ethereumjsUtil.toBuffer(digest);
  var signature = ethereumjsUtil.ecsign(buffer, privateKey);
  return signature;
}; // lazyload permitTypehash to avoid a web3 race

var _permitTypehash = null;

var getPermitTypehash = function getPermitTypehash() {
  if (!_permitTypehash) {
    _permitTypehash = Utils.keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');
  }

  return _permitTypehash;
};

var _transferTokensTypehash = null;

var getTransferTokensTypeHash = function getTransferTokensTypeHash() {
  if (!_transferTokensTypehash) {
    _transferTokensTypehash = Utils.keccak256('TransferTokens(address from,uint256 amount,uint16 recipientChain,bytes32 recipient,uint256 artbiterFee,uint32 nonce,uint256 deadline)');
  }

  return _transferTokensTypehash;
}; // Returns the EIP712 hash which should be signed by the user
// in order to make a call to `permit`


function getPermitDigest(web3, name, address, chainId, approve, nonce, deadline) {
  var DOMAIN_SEPARATOR = getDomainSeparator(web3, name, address, chainId);
  var innerEncoded = web3.eth.abi.encodeParameters(['bytes32', 'address', 'address', 'uint256', 'uint256', 'uint256'], [getPermitTypehash(), approve.owner, approve.spender, approve.value, nonce, deadline]);
  var encoded = solidity.pack(['bytes1', 'bytes1', 'bytes32', 'bytes32'], ['0x19', '0x01', DOMAIN_SEPARATOR, Utils.keccak256(innerEncoded)]);
  return Utils.keccak256(encoded);
} // Returns the EIP712 hash which should be signed by the user
// in order to make a call to `transferTokens`

function getTransferTokensDigest(web3, name, address, chainId, transferTokens, nonce, deadline) {
  var DOMAIN_SEPARATOR = getDomainSeparator(web3, name, address, chainId);
  var innerEncoded = web3.eth.abi.encodeParameters(['bytes32', 'address', 'uint256', 'uint16', 'bytes32', 'uint256', 'uint32', 'uint256'], [getTransferTokensTypeHash(), transferTokens.from, transferTokens.amount, transferTokens.recipientChain, transferTokens.recipient, transferTokens.arbiterFee, nonce, deadline]);
  var encoded = solidity.pack(['bytes1', 'bytes1', 'bytes32', 'bytes32'], ['0x19', '0x01', DOMAIN_SEPARATOR, Utils.keccak256(innerEncoded)]);
  return Utils.keccak256(encoded);
} // Gets the EIP712 domain separator

function getDomainSeparator(web3, name, contractAddress, chainId) {
  var encoded = web3.eth.abi.encodeParameters(['bytes32', 'bytes32', 'bytes32', 'uint256', 'address'], [Utils.keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'), Utils.keccak256(name), Utils.keccak256('1'), chainId, contractAddress]);
  return Utils.keccak256(encoded);
}

function raceRequests(_x5, _x6, _x7) {
  return _raceRequests.apply(this, arguments);
}
/**
 * Gets the response for many requests with a timeout to each
 */


function _raceRequests() {
  _raceRequests = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(urls, callback, axiosConfig) {
    var timeout,
        timeBetweenRequests,
        validationCheck,
        CancelToken,
        sources,
        hasFinished,
        requests,
        response,
        errored,
        _yield$promiseFight,
        val,
        e,
        _args5 = arguments;

    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            timeout = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : 3000;
            timeBetweenRequests = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : 100;
            validationCheck = _args5.length > 5 && _args5[5] !== undefined ? _args5[5] : function (_) {
              return true;
            };
            CancelToken = axios__default["default"].CancelToken;
            sources = [];
            hasFinished = false;
            requests = urls.map( /*#__PURE__*/function () {
              var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(url, i) {
                var source;
                return regeneratorRuntime.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        source = CancelToken.source();
                        sources.push(source); // Slightly offset requests by their order, so:
                        // 1. We try creator node gateways first
                        // 2. We give requests the opportunity to get canceled if other's are very fast

                        _context4.next = 4;
                        return Utils.wait(timeBetweenRequests * i);

                      case 4:
                        if (!hasFinished) {
                          _context4.next = 6;
                          break;
                        }

                        return _context4.abrupt("return");

                      case 6:
                        _context4.next = 8;
                        return new Promise(function (resolve, reject) {
                          axios__default["default"](_objectSpread2({
                            method: 'get',
                            url: url,
                            cancelToken: source.token
                          }, axiosConfig)).then(function (response) {
                            var isValid = validationCheck(response);

                            if (isValid) {
                              hasFinished = true;
                              resolve({
                                blob: response,
                                url: url
                              });
                            } else {
                              // Invalid because of validity check
                              reject(response);
                            }
                          })["catch"](function (thrown) {
                            reject(thrown); // no-op.
                            // If debugging `axios.isCancel(thrown)`
                            // can be used to check if the throw was from a cancel.
                          });
                        });

                      case 8:
                        return _context4.abrupt("return", _context4.sent);

                      case 9:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));

              return function (_x10, _x11) {
                return _ref5.apply(this, arguments);
              };
            }());

            if (timeout !== null) {
              requests.push(Utils.wait(timeout));
            }

            _context5.prev = 8;
            _context5.next = 11;
            return promiseFight(requests, true);

          case 11:
            _yield$promiseFight = _context5.sent;
            val = _yield$promiseFight.val;
            e = _yield$promiseFight.errored;
            response = val;
            errored = e;
            _context5.next = 22;
            break;

          case 18:
            _context5.prev = 18;
            _context5.t0 = _context5["catch"](8);
            response = null;
            errored = _context5.t0;

          case 22:
            sources.forEach(function (source) {
              source.cancel('Fetch already succeeded');
            });

            if (!(response && 'url' in response && 'blob' in response)) {
              _context5.next = 26;
              break;
            }

            callback(response.url);
            return _context5.abrupt("return", {
              response: response.blob,
              errored: errored
            });

          case 26:
            return _context5.abrupt("return", {
              response: null,
              errored: errored
            });

          case 27:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[8, 18]]);
  }));
  return _raceRequests.apply(this, arguments);
}

function allRequests(_x8) {
  return _allRequests.apply(this, arguments);
}

function _allRequests() {
  _allRequests = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(_ref3) {
    var urlMap, timeout, validationCheck, urls, requests, responses;
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            urlMap = _ref3.urlMap, timeout = _ref3.timeout, validationCheck = _ref3.validationCheck;
            urls = Object.keys(urlMap);
            requests = urls.map( /*#__PURE__*/function () {
              var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(url) {
                return regeneratorRuntime.wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        _context6.next = 2;
                        return new Promise(function (resolve) {
                          axios__default["default"]({
                            method: 'get',
                            timeout: timeout,
                            url: url
                          }).then(function (response) {
                            var isValid = validationCheck(response);

                            if (isValid) {
                              if (typeof urlMap[url] === 'string') {
                                resolve(urlMap[url]);
                              } else {
                                var serviceWithResponse = _objectSpread2(_objectSpread2({}, urlMap[url]), response.data.data);

                                resolve(serviceWithResponse);
                              }
                            } else {
                              resolve(null);
                            }
                          })["catch"](function () {
                            resolve(null);
                          });
                        });

                      case 2:
                        return _context6.abrupt("return", _context6.sent);

                      case 3:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6);
              }));

              return function (_x12) {
                return _ref6.apply(this, arguments);
              };
            }());
            _context7.next = 5;
            return Promise.all(requests);

          case 5:
            responses = _context7.sent.filter(Boolean);
            return _context7.abrupt("return", responses);

          case 7:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _allRequests.apply(this, arguments);
}

var randomKeyPair = solanaWeb3.Keypair.generate();

var crc32c = {};

/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */

(function (exports) {

  (function (factory) {
    /*jshint ignore:start */

    /*eslint-disable */
    if (typeof DO_NOT_EXPORT_CRC === 'undefined') {
      {
        factory(exports);
      }
    } else {
      factory({});
    }
    /*eslint-enable */

    /*jshint ignore:end */

  })(function (CRC32C) {
    CRC32C.version = '1.2.2';
    /*global Int32Array */

    function signed_crc_table() {
      var c = 0,
          table = new Array(256);

      for (var n = 0; n != 256; ++n) {
        c = n;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        table[n] = c;
      }

      return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
    }

    var T0 = signed_crc_table();

    function slice_by_16_tables(T) {
      var c = 0,
          v = 0,
          n = 0,
          table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096);

      for (n = 0; n != 256; ++n) {
        table[n] = T[n];
      }

      for (n = 0; n != 256; ++n) {
        v = T[n];

        for (c = 256 + n; c < 4096; c += 256) {
          v = table[c] = v >>> 8 ^ T[v & 0xFF];
        }
      }

      var out = [];

      for (n = 1; n != 16; ++n) {
        out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
      }

      return out;
    }

    var TT = slice_by_16_tables(T0);
    var T1 = TT[0],
        T2 = TT[1],
        T3 = TT[2],
        T4 = TT[3],
        T5 = TT[4];
    var T6 = TT[5],
        T7 = TT[6],
        T8 = TT[7],
        T9 = TT[8],
        Ta = TT[9];
    var Tb = TT[10],
        Tc = TT[11],
        Td = TT[12],
        Te = TT[13],
        Tf = TT[14];

    function crc32_bstr(bstr, seed) {
      var C = seed ^ -1;

      for (var i = 0, L = bstr.length; i < L;) {
        C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 0xFF];
      }

      return ~C;
    }

    function crc32_buf(B, seed) {
      var C = seed ^ -1,
          L = B.length - 15,
          i = 0;

      for (; i < L;) {
        C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
      }

      L += 15;

      while (i < L) {
        C = C >>> 8 ^ T0[(C ^ B[i++]) & 0xFF];
      }

      return ~C;
    }

    function crc32_str(str, seed) {
      var C = seed ^ -1;

      for (var i = 0, L = str.length, c = 0, d = 0; i < L;) {
        c = str.charCodeAt(i++);

        if (c < 0x80) {
          C = C >>> 8 ^ T0[(C ^ c) & 0xFF];
        } else if (c < 0x800) {
          C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 0xFF];
        } else if (c >= 0xD800 && c < 0xE000) {
          c = (c & 1023) + 64;
          d = str.charCodeAt(i++) & 1023;
          C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 0xFF];
        } else {
          C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 0xFF];
        }
      }

      return ~C;
    }

    CRC32C.table = T0; // $FlowIgnore

    CRC32C.bstr = crc32_bstr; // $FlowIgnore

    CRC32C.buf = crc32_buf; // $FlowIgnore

    CRC32C.str = crc32_str;
  });
})(crc32c);

var NodeScore = /*#__PURE__*/_createClass(function NodeScore(node) {
  _classCallCheck(this, NodeScore);

  _defineProperty$1(this, "node", void 0);

  _defineProperty$1(this, "score", void 0);

  this.node = node;
  this.score = 0;
});
/**
 * TypeScript equivalent of https://github.com/tysonmote/rendezvous/blob/be0258dbbd3d/rendezvous.go
 */


var RendezvousHash = /*#__PURE__*/function () {
  function RendezvousHash() {
    _classCallCheck(this, RendezvousHash);

    _defineProperty$1(this, "nodes", []);

    this.add.apply(this, arguments);
  }

  _createClass(RendezvousHash, [{
    key: "add",
    value: function add() {
      for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
        nodes[_key] = arguments[_key];
      }

      for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {
        var node = _nodes[_i];
        this.nodes.push(new NodeScore(buffer.Buffer.from(node)));
      }
    }
  }, {
    key: "get",
    value: function get(key) {
      var _maxNode$toString, _maxNode;

      var maxScore = 0;
      var maxNode = null;
      var keyBytes = buffer.Buffer.from(key);

      var _iterator = _createForOfIteratorHelper(this.nodes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var node = _step.value;
          var score = this.hash(node.node, keyBytes);

          if (score > maxScore || score === maxScore && node.node.compare(maxNode) < 0) {
            maxScore = score;
            maxNode = node.node;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return (_maxNode$toString = (_maxNode = maxNode) === null || _maxNode === void 0 ? void 0 : _maxNode.toString()) !== null && _maxNode$toString !== void 0 ? _maxNode$toString : '';
    }
  }, {
    key: "getN",
    value: function getN(n, key) {
      var keyBytes = buffer.Buffer.from(key);

      var _iterator2 = _createForOfIteratorHelper(this.nodes),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var node = _step2.value;
          node.score = this.hash(node.node, keyBytes);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.nodes.sort(function (a, b) {
        if (a.score === b.score) {
          return a.node.compare(b.node);
        }

        return b.score - a.score;
      });

      if (n > this.nodes.length) {
        n = this.nodes.length;
      }

      var nodes = [];

      for (var i = 0; i < n; i++) {
        nodes.push(this.nodes[i].node.toString());
      }

      return nodes;
    }
  }, {
    key: "getNodes",
    value: function getNodes() {
      return this.nodes.map(function (nodeScore) {
        return nodeScore.node.toString();
      });
    }
  }, {
    key: "hash",
    value: function hash(node, key) {
      var combined = buffer.Buffer.concat([key, node]); // Convert to unsigned 32-bit integer to match go implementation, which is uint32 here:
      // https://github.com/tysonmote/rendezvous/blob/be0258dbbd3d/rendezvous.go#L92

      return crc32c.buf(combined, 0) >>> 0;
    }
  }]);

  return RendezvousHash;
}();

/**
 * Selects numNodes storage nodes from the given list of allNodes, optionally ordering them (descending) by rendezvous score.
 * @dev This makes the wallet lowercase - not suitable for use with CIDs because they're case sensitive (use RendezvousHash directly instead).
 */

var getNStorageNodes = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(allNodes) {
    var numNodes,
        wallet,
        logger,
        sortedEndpoints,
        endpoints,
        hash,
        healthyEndpoints,
        i,
        batch,
        healthCheckPromises,
        healthCheckResults,
        j,
        _args2 = arguments;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            numNodes = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 0;
            wallet = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : '';
            logger = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : console;
            _context2.prev = 3;
            if (numNodes === 0) numNodes = allNodes.length;

            // Sort endpoints by rendezvous score if a rendezvous key is provided
            if (wallet !== null && wallet !== void 0 && wallet.length) {
              endpoints = allNodes.map(function (n) {
                return n.endpoint.toLowerCase();
              });
              hash = _construct(RendezvousHash, _toConsumableArray(endpoints));
              sortedEndpoints = hash.getN(endpoints.length, wallet.toLowerCase());
            } else {
              sortedEndpoints = allNodes.map(function (n) {
                return n.endpoint;
              });
            } // Check multiple nodes at a time for health until we have numNodes healthy nodes


            healthyEndpoints = [];
            i = 0;

          case 8:
            if (!(i < sortedEndpoints.length)) {
              _context2.next = 20;
              break;
            }

            batch = sortedEndpoints.slice(i, i + numNodes);
            healthCheckPromises = batch.map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(endpoint) {
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return isNodeHealthy(endpoint, logger);

                      case 2:
                        return _context.abrupt("return", _context.sent);

                      case 3:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x2) {
                return _ref2.apply(this, arguments);
              };
            }());
            _context2.next = 13;
            return Promise.all(healthCheckPromises);

          case 13:
            healthCheckResults = _context2.sent;

            for (j = 0; j < healthCheckResults.length; j++) {
              if (healthCheckResults[j]) {
                healthyEndpoints.push(batch[j]);
              }
            }

            if (!(healthyEndpoints.length >= numNodes)) {
              _context2.next = 17;
              break;
            }

            return _context2.abrupt("return", healthyEndpoints.slice(0, numNodes));

          case 17:
            i += numNodes;
            _context2.next = 8;
            break;

          case 20:
            if (numNodes !== allNodes.length && sortedEndpoints.length < numNodes) {
              logger.error("getNStorageNodes: Could not select ".concat(numNodes, " healthy nodes from ").concat(allNodes.length, " nodes"));
            }

            return _context2.abrupt("return", healthyEndpoints);

          case 24:
            _context2.prev = 24;
            _context2.t0 = _context2["catch"](3);
            logger.error("getNStorageNodes: Error selecting nodes: ".concat(_context2.t0));
            return _context2.abrupt("return", []);

          case 28:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 24]]);
  }));

  return function getNStorageNodes(_x) {
    return _ref.apply(this, arguments);
  };
}();
var isNodeHealthy = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(endpoint) {
    var logger,
        resp,
        _args3 = arguments;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            logger = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : console;
            _context3.prev = 1;
            _context3.next = 4;
            return axios__default["default"]({
              baseURL: endpoint,
              url: "/health_check",
              method: 'get',
              timeout: 3000
            });

          case 4:
            resp = _context3.sent;

            if (!(resp.status === 200)) {
              _context3.next = 9;
              break;
            }

            return _context3.abrupt("return", true);

          case 9:
            logger.warn("isNodeHealthy: ".concat(endpoint, " returned non-200 status ").concat(resp.status));
            return _context3.abrupt("return", false);

          case 11:
            _context3.next = 17;
            break;

          case 13:
            _context3.prev = 13;
            _context3.t0 = _context3["catch"](1);
            logger.error("isNodeHealthy: Error checking health: ".concat(_context3.t0));
            return _context3.abrupt("return", false);

          case 17:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[1, 13]]);
  }));

  return function isNodeHealthy(_x3) {
    return _ref3.apply(this, arguments);
  };
}();

var defaultStorageNodeSelectorConfig = {
  bootstrapNodes: servicesConfig.storageNodes,
  logger: new Logger()
};

var DISCOVERY_RESPONSE_TIMEOUT = 15000;
var StorageNodeSelector = /*#__PURE__*/function () {
  // endpoints (lowercase)
  function StorageNodeSelector(config) {
    var _this$config$bootstra,
        _this$discoveryNodeSe,
        _this = this;

    _classCallCheck(this, StorageNodeSelector);

    _defineProperty$1(this, "config", void 0);

    _defineProperty$1(this, "auth", void 0);

    _defineProperty$1(this, "logger", void 0);

    _defineProperty$1(this, "nodes", void 0);

    _defineProperty$1(this, "orderedNodes", void 0);

    _defineProperty$1(this, "selectedNode", void 0);

    _defineProperty$1(this, "selectedDiscoveryNode", void 0);

    _defineProperty$1(this, "discoveryNodeSelector", void 0);

    _defineProperty$1(this, "initialDiscoveryFetchPromise", void 0);

    _defineProperty$1(this, "resolveInitialDiscoveryFetchPromise", function () {});

    this.config = mergeConfigWithDefaults(config, defaultStorageNodeSelectorConfig);
    this.discoveryNodeSelector = config.discoveryNodeSelector;
    this.auth = config.auth;
    this.logger = this.config.logger.createPrefixedLogger('[storage-node-selector]');
    this.nodes = (_this$config$bootstra = this.config.bootstrapNodes) !== null && _this$config$bootstra !== void 0 ? _this$config$bootstra : [];
    (_this$discoveryNodeSe = this.discoveryNodeSelector) === null || _this$discoveryNodeSe === void 0 ? void 0 : _this$discoveryNodeSe.addEventListener('change', this.onChangeDiscoveryNode.bind(this));
    this.checkIfDiscoveryNodeAlreadyAvailable();
    this.initialDiscoveryFetchPromise = new Promise(function (resolve) {
      _this.resolveInitialDiscoveryFetchPromise = resolve;
    });
  }

  _createClass(StorageNodeSelector, [{
    key: "checkIfDiscoveryNodeAlreadyAvailable",
    value: function () {
      var _checkIfDiscoveryNodeAlreadyAvailable = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this$discoveryNodeSe2;

        var endpoint;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return (_this$discoveryNodeSe2 = this.discoveryNodeSelector) === null || _this$discoveryNodeSe2 === void 0 ? void 0 : _this$discoveryNodeSe2.getSelectedEndpoint();

              case 2:
                endpoint = _context.sent;

                if (endpoint) {
                  this.onChangeDiscoveryNode(endpoint);
                }

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function checkIfDiscoveryNodeAlreadyAvailable() {
        return _checkIfDiscoveryNodeAlreadyAvailable.apply(this, arguments);
      }

      return checkIfDiscoveryNodeAlreadyAvailable;
    }()
  }, {
    key: "onChangeDiscoveryNode",
    value: function () {
      var _onChangeDiscoveryNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(endpoint) {
        var _responseData$data$ne;

        var healthCheckEndpoint, discoveryHealthCheckResponse, responseData, contentNodes;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.logger.info('Updating list of available content nodes');

                if (!(this.selectedDiscoveryNode === endpoint)) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return");

              case 3:
                this.selectedDiscoveryNode = endpoint;
                healthCheckEndpoint = "".concat(endpoint, "/health_check");
                _context2.next = 7;
                return fetch__default["default"](healthCheckEndpoint);

              case 7:
                discoveryHealthCheckResponse = _context2.sent;

                if (discoveryHealthCheckResponse.ok) {
                  _context2.next = 11;
                  break;
                }

                this.logger.warn('Discovery provider health check did not respond successfully');
                return _context2.abrupt("return");

              case 11:
                _context2.next = 13;
                return discoveryHealthCheckResponse.json();

              case 13:
                responseData = _context2.sent;
                contentNodes = (_responseData$data$ne = responseData.data.network) === null || _responseData$data$ne === void 0 ? void 0 : _responseData$data$ne.content_nodes;

                if (contentNodes) {
                  _context2.next = 18;
                  break;
                }

                this.logger.warn('Discovery provider health check did not contain any available content nodes');
                return _context2.abrupt("return");

              case 18:
                this.nodes = contentNodes;
                this.resolveInitialDiscoveryFetchPromise();

              case 20:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function onChangeDiscoveryNode(_x) {
        return _onChangeDiscoveryNode.apply(this, arguments);
      }

      return onChangeDiscoveryNode;
    }()
  }, {
    key: "getSelectedNode",
    value: function () {
      var _getSelectedNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var _this2 = this;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.selectedNode) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return", this.selectedNode);

              case 2:
                if (this.nodes.length) {
                  _context3.next = 5;
                  break;
                }

                _context3.next = 5;
                return Promise.race([this.initialDiscoveryFetchPromise, new Promise(function (resolve) {
                  return setTimeout(function () {
                    _this2.logger.warn('List of storage nodes could not be fetched');

                    resolve();
                  }, DISCOVERY_RESPONSE_TIMEOUT);
                })]);

              case 5:
                _context3.next = 7;
                return this.select();

              case 7:
                return _context3.abrupt("return", _context3.sent);

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getSelectedNode() {
        return _getSelectedNode.apply(this, arguments);
      }

      return getSelectedNode;
    }()
  }, {
    key: "getNodes",
    value: function getNodes(cid) {
      return this.orderNodes(cid);
    }
  }, {
    key: "select",
    value: function () {
      var _select = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _this$selectedNode;

        var currentNodeIndex, selectedNode, nextNodeIndex, nextNode;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (this.orderedNodes) {
                  _context4.next = 8;
                  break;
                }

                _context4.t0 = this;
                _context4.next = 4;
                return this.auth.getAddress();

              case 4:
                _context4.t1 = _context4.sent.toLowerCase();
                _context4.next = 7;
                return _context4.t0.orderNodes.call(_context4.t0, _context4.t1);

              case 7:
                this.orderedNodes = _context4.sent;

              case 8:
                if (!(this.orderedNodes.length === 0)) {
                  _context4.next = 10;
                  break;
                }

                return _context4.abrupt("return", null);

              case 10:
                currentNodeIndex = this.selectedNode ? this.orderedNodes.indexOf(this.selectedNode) : -1;
                nextNodeIndex = currentNodeIndex;

              case 12:
                if (selectedNode) {
                  _context4.next = 25;
                  break;
                }

                nextNodeIndex = (nextNodeIndex + 1) % this.orderedNodes.length;

                if (!(nextNodeIndex === currentNodeIndex)) {
                  _context4.next = 16;
                  break;
                }

                return _context4.abrupt("break", 25);

              case 16:
                nextNode = this.orderedNodes[nextNodeIndex];

                if (nextNode) {
                  _context4.next = 19;
                  break;
                }

                return _context4.abrupt("continue", 12);

              case 19:
                _context4.next = 21;
                return isNodeHealthy(nextNode);

              case 21:
                if (!_context4.sent) {
                  _context4.next = 23;
                  break;
                }

                selectedNode = nextNode;

              case 23:
                _context4.next = 12;
                break;

              case 25:
                this.selectedNode = selectedNode;
                this.logger.info('Selected content node', this.selectedNode);
                return _context4.abrupt("return", (_this$selectedNode = this.selectedNode) !== null && _this$selectedNode !== void 0 ? _this$selectedNode : null);

              case 28:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function select() {
        return _select.apply(this, arguments);
      }

      return select;
    }()
  }, {
    key: "orderNodes",
    value: function orderNodes(key) {
      var endpoints = this.nodes.map(function (node) {
        return node.endpoint.toLowerCase();
      });

      var hash = _construct(RendezvousHash, _toConsumableArray(endpoints));

      return hash.getN(this.nodes.length, key);
    }
  }]);

  return StorageNodeSelector;
}();

/**
 * This file includes schemas for use in EIP-712 compliant signature generation and
 * signature validation, generator functions for generating data
 * in the form needed by eth_personalSign / eth-sig-util's signTypedData functions,
 * generators for contract signing domains, and a helper function for generating
 * cryptographically secure nonces in nodejs or in the browser.
 * modeled off: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md
 */
var domains = {};

function getDomainData(contractName, signatureVersion, chainId, contractAddress) {
  return {
    name: contractName,
    version: signatureVersion,
    chainId: chainId,
    verifyingContract: contractAddress
  };
}

domains.getEntityManagerDomain = function (chainId, contractAddress) {
  return getDomainData('Entity Manager', '1', chainId, contractAddress);
};

var schemas = {};
/* contract signing domain */

schemas.domain = [{
  name: 'name',
  type: 'string'
}, {
  name: 'version',
  type: 'string'
}, {
  name: 'chainId',
  type: 'uint256'
}, {
  name: 'verifyingContract',
  type: 'address'
}];
schemas.manageEntity = [{
  name: 'userId',
  type: 'uint'
}, {
  name: 'entityType',
  type: 'string'
}, {
  name: 'entityId',
  type: 'uint'
}, {
  name: 'action',
  type: 'string'
}, {
  name: 'metadata',
  type: 'string'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
var generators = {};

function getRequestData(domainDataFn, chainId, contractAddress, messageTypeName, messageSchema, message) {
  var domainData = domainDataFn(chainId, contractAddress);
  var types = {
    EIP712Domain: schemas.domain
  };
  types[messageTypeName] = messageSchema;
  return {
    types: types,
    domain: domainData,
    primaryType: messageTypeName,
    message: message
  };
}
/* User Factory Generators */


generators.getAddUserRequestData = function (chainId, contractAddress, handle, nonce) {
  var message = {
    handle: handle,
    nonce: nonce
  };
  return getRequestData(domains.getUserFactoryDomain, chainId, contractAddress, 'AddUserRequest', schemas.addUserRequest, message);
};

generators.getManageEntityData = function (chainId, contractAddress, userId, entityType, entityId, action, metadata, nonce) {
  var message = {
    userId: userId,
    entityType: entityType,
    entityId: entityId,
    action: action,
    metadata: metadata,
    nonce: nonce
  };
  return getRequestData(domains.getEntityManagerDomain, chainId, contractAddress, 'ManageEntity', schemas.manageEntity, message);
};
/** Return a secure random hex string of nChar length in a browser-compatible way
 *  Taken from https://stackoverflow.com/questions/37378237/how-to-generate-a-random-token-of-32-bit-in-javascript
 */


function browserRandomHash(nChar) {
  // convert number of characters to number of bytes
  var nBytes = Math.ceil(nChar = (+nChar || 8) / 2); // create a typed array of that many bytes

  var u = new Uint8Array(nBytes); // populate it wit crypto-random values

  window.crypto.getRandomValues(u); // convert it to an Array of Strings (e.g. '01', 'AF', ..)

  var zpad = function zpad(str) {
    return '00'.slice(str.length) + str;
  };

  var a = Array.prototype.map.call(u, function (x) {
    return zpad(x.toString(16));
  }); // Array of String to String

  var str = a.join('').toLowerCase(); // and snip off the excess digit if we want an odd number

  if (nChar % 2) str = str.slice(1); // return what we made

  return str;
} // We need to detect whether the nodejs crypto module is available to determine how to
// generate secure random numbers below


var nodeCrypto;

try {
  nodeCrypto = require('crypto');
} catch (e) {
  nodeCrypto = null;
}

function getNonce() {
  // detect whether we are in browser or in nodejs, and use the correct csprng
  if (typeof window === 'undefined' || window === null) {
    return '0x' + nodeCrypto.randomBytes(32).toString('hex');
  } else {
    return '0x' + browserRandomHash(64);
  }
}

var signatureSchemas = {
  domains: domains,
  schemas: schemas,
  generators: generators,
  getNonce: getNonce
};

var contractName$2 = "EntityManager";
var abi$e = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_signer",
				type: "address"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_entityType",
				type: "string"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_entityId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_metadata",
				type: "string"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_action",
				type: "string"
			}
		],
		name: "ManageEntity",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "_isVerified",
				type: "bool"
			}
		],
		name: "ManageIsVerified",
		type: "event"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "usedSignatures",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "string",
				name: "name",
				type: "string"
			},
			{
				internalType: "string",
				name: "version",
				type: "string"
			},
			{
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_verifierAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_networkId",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_userId",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "_entityType",
				type: "string"
			},
			{
				internalType: "uint256",
				name: "_entityId",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "_action",
				type: "string"
			},
			{
				internalType: "string",
				name: "_metadata",
				type: "string"
			},
			{
				internalType: "bytes32",
				name: "_nonce",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "manageEntity",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_userId",
				type: "uint256"
			},
			{
				internalType: "bool",
				name: "_isVerified",
				type: "bool"
			}
		],
		name: "manageIsVerified",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var EntityManagerABI = {
	contractName: contractName$2,
	abi: abi$e
};

var defaultEntityManagerConfig = {
  contractAddress: servicesConfig.entityManagerContractAddress,
  web3ProviderUrl: servicesConfig.web3ProviderUrl,
  identityServiceUrl: servicesConfig.identityServiceUrl,
  useDiscoveryRelay: false,
  logger: new Logger()
};
var DEFAULT_GAS_LIMIT$1 = 2000000;
var CONFIRMATION_POLLING_INTERVAL = 2000;
var CONFIRMATION_TIMEOUT = 45000;

var EntityManager$1 = /*#__PURE__*/function () {
  /**
   * Configuration passed in by consumer (with defaults)
   */
  function EntityManager(config) {
    _classCallCheck(this, EntityManager);

    _defineProperty$1(this, "config", void 0);

    _defineProperty$1(this, "discoveryNodeSelector", void 0);

    _defineProperty$1(this, "contract", void 0);

    _defineProperty$1(this, "web3", void 0);

    _defineProperty$1(this, "logger", void 0);

    this.config = mergeConfigWithDefaults(config, defaultEntityManagerConfig);
    this.discoveryNodeSelector = config.discoveryNodeSelector;
    this.web3 = new Web3$1(new Web3$1.providers.HttpProvider(this.config.web3ProviderUrl, {
      timeout: 10000
    }));
    this.contract = new this.web3.eth.Contract(abi$e, this.config.contractAddress);
    this.logger = this.config.logger.createPrefixedLogger('[entity-manager]');
  }
  /**
   * Calls the manage entity method on chain to update some data
   */


  _createClass(EntityManager, [{
    key: "manageEntity",
    value: function () {
      var _manageEntity = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
        var userId, entityType, entityId, action, _ref$metadata, metadata, auth, _ref$confirmationTime, confirmationTimeout, _ref$skipConfirmation, skipConfirmation, nonce, chainId, signatureData, senderAddress, signature, method, response, jsonResponse, _jsonResponse$error;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                userId = _ref.userId, entityType = _ref.entityType, entityId = _ref.entityId, action = _ref.action, _ref$metadata = _ref.metadata, metadata = _ref$metadata === void 0 ? '' : _ref$metadata, auth = _ref.auth, _ref$confirmationTime = _ref.confirmationTimeout, confirmationTimeout = _ref$confirmationTime === void 0 ? CONFIRMATION_TIMEOUT : _ref$confirmationTime, _ref$skipConfirmation = _ref.skipConfirmation, skipConfirmation = _ref$skipConfirmation === void 0 ? false : _ref$skipConfirmation;
                nonce = signatureSchemas.getNonce();
                _context.next = 4;
                return this.web3.eth.net.getId();

              case 4:
                chainId = _context.sent;
                signatureData = signatureSchemas.generators.getManageEntityData(chainId, this.config.contractAddress, userId, entityType, entityId, action, metadata, nonce);
                _context.next = 8;
                return auth.getAddress();

              case 8:
                senderAddress = _context.sent;
                _context.next = 11;
                return auth.signTransaction(signatureData);

              case 11:
                signature = _context.sent;
                _context.next = 14;
                return this.contract.methods.manageEntity(userId, entityType, entityId, action, metadata, nonce, signature);

              case 14:
                method = _context.sent;
                _context.t0 = fetch__default["default"];
                _context.t1 = "";
                _context.next = 19;
                return this.getRelayEndpoint();

              case 19:
                _context.t2 = _context.sent;
                _context.t3 = _context.t1.concat.call(_context.t1, _context.t2, "/relay");
                _context.t4 = {
                  method: 'POST',
                  headers: new fetch$1.Headers({
                    'Content-Type': 'application/json'
                  }),
                  body: JSON.stringify({
                    contractAddress: this.config.contractAddress,
                    contractRegistryKey: 'EntityManager',
                    encodedABI: method.encodeABI(),
                    // Gas limit not really needed with ACDC
                    gasLimit: DEFAULT_GAS_LIMIT$1,
                    senderAddress: senderAddress
                  })
                };
                _context.next = 24;
                return (0, _context.t0)(_context.t3, _context.t4);

              case 24:
                response = _context.sent;
                _context.next = 27;
                return response.json();

              case 27:
                jsonResponse = _context.sent;

                if (!response.ok) {
                  _context.next = 35;
                  break;
                }

                if (skipConfirmation) {
                  _context.next = 32;
                  break;
                }

                _context.next = 32;
                return this.confirmWrite({
                  blockHash: jsonResponse.receipt.blockHash,
                  blockNumber: jsonResponse.receipt.blockNumber,
                  confirmationTimeout: confirmationTimeout
                });

              case 32:
                return _context.abrupt("return", {
                  blockHash: jsonResponse.receipt.blockHash,
                  blockNumber: jsonResponse.receipt.blockNumber
                });

              case 35:
                if (!(response.status === 429)) {
                  _context.next = 40;
                  break;
                }

                this.logger.error('API Rate Limit Exceeded: You have exceeded the allowed number of requests for this action. Please wait and try again later. If you require a higher rate limit, please send an email to api@audius.co with your request, detailing the reasons and expected usage.');
                throw new Error('Error making relay request: API Rate Limit Exceeded. If you require a higher rate limit, please send an email to api@audius.co with your request.');

              case 40:
                throw new Error("Error making relay request".concat(jsonResponse !== null && jsonResponse !== void 0 && (_jsonResponse$error = jsonResponse.error) !== null && _jsonResponse$error !== void 0 && _jsonResponse$error.message ? ": ".concat(jsonResponse.error.message) : '.'));

              case 41:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function manageEntity(_x) {
        return _manageEntity.apply(this, arguments);
      }

      return manageEntity;
    }()
    /**
     * Confirms a write by polling for the block to be indexed by the selected
     * discovery node
     */

  }, {
    key: "confirmWrite",
    value: function () {
      var _confirmWrite = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref2) {
        var _this = this;

        var blockHash, blockNumber, _ref2$confirmationTim, confirmationTimeout, _ref2$confirmationPol, confirmationPollingInterval, confirmBlock, confirmation, start;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                blockHash = _ref2.blockHash, blockNumber = _ref2.blockNumber, _ref2$confirmationTim = _ref2.confirmationTimeout, confirmationTimeout = _ref2$confirmationTim === void 0 ? CONFIRMATION_TIMEOUT : _ref2$confirmationTim, _ref2$confirmationPol = _ref2.confirmationPollingInterval, confirmationPollingInterval = _ref2$confirmationPol === void 0 ? CONFIRMATION_POLLING_INTERVAL : _ref2$confirmationPol;

                confirmBlock = /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                    var endpoint, _yield$yield$fetch$js, block_passed;

                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return _this.discoveryNodeSelector.getSelectedEndpoint();

                          case 2:
                            endpoint = _context2.sent;
                            _context2.next = 5;
                            return fetch__default["default"]("".concat(endpoint, "/block_confirmation?blocknumber=").concat(blockNumber, "&blockhash=").concat(blockHash));

                          case 5:
                            _context2.next = 7;
                            return _context2.sent.json();

                          case 7:
                            _yield$yield$fetch$js = _context2.sent;
                            block_passed = _yield$yield$fetch$js.data.block_passed;
                            return _context2.abrupt("return", block_passed ? BlockConfirmation.CONFIRMED : BlockConfirmation.UNKNOWN);

                          case 10:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function confirmBlock() {
                    return _ref3.apply(this, arguments);
                  };
                }();

                _context3.next = 4;
                return confirmBlock();

              case 4:
                confirmation = _context3.sent;
                start = Date.now();

              case 6:
                if (!(confirmation === BlockConfirmation.UNKNOWN)) {
                  _context3.next = 16;
                  break;
                }

                if (!(Date.now() - start > confirmationTimeout)) {
                  _context3.next = 9;
                  break;
                }

                throw new Error("Could not confirm write within ".concat(confirmationTimeout, "ms"));

              case 9:
                _context3.next = 11;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, confirmationPollingInterval);
                });

              case 11:
                _context3.next = 13;
                return confirmBlock();

              case 13:
                confirmation = _context3.sent;
                _context3.next = 6;
                break;

              case 16:
                return _context3.abrupt("return", true);

              case 17:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function confirmWrite(_x2) {
        return _confirmWrite.apply(this, arguments);
      }

      return confirmWrite;
    }()
  }, {
    key: "getCurrentBlock",
    value: function () {
      var _getCurrentBlock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var currentBlockNumber;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.web3.eth.getBlockNumber();

              case 2:
                currentBlockNumber = _context4.sent;
                _context4.next = 5;
                return this.web3.eth.getBlock(currentBlockNumber);

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getCurrentBlock() {
        return _getCurrentBlock.apply(this, arguments);
      }

      return getCurrentBlock;
    }()
  }, {
    key: "getRelayEndpoint",
    value: function () {
      var _getRelayEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var useDiscoveryRelay, discoveryEndpoint;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                useDiscoveryRelay = this.config.useDiscoveryRelay;

                if (!(useDiscoveryRelay === undefined || !useDiscoveryRelay)) {
                  _context5.next = 3;
                  break;
                }

                return _context5.abrupt("return", this.config.identityServiceUrl);

              case 3:
                _context5.next = 5;
                return this.discoveryNodeSelector.getSelectedEndpoint();

              case 5:
                discoveryEndpoint = _context5.sent;

                if (!(discoveryEndpoint === null)) {
                  _context5.next = 8;
                  break;
                }

                return _context5.abrupt("return", this.config.identityServiceUrl);

              case 8:
                return _context5.abrupt("return", discoveryEndpoint);

              case 9:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getRelayEndpoint() {
        return _getRelayEndpoint.apply(this, arguments);
      }

      return getRelayEndpoint;
    }()
  }]);

  return EntityManager;
}();

var wait$1 = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(milliseconds) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return new Promise(function (resolve) {
              return setTimeout(resolve, milliseconds);
            });

          case 2:
            return _context.abrupt("return", _context.sent);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function wait(_x) {
    return _ref.apply(this, arguments);
  };
}();

var defaultStorageServiceConfig = {
  logger: new Logger()
};
var MAX_TRACK_TRANSCODE_TIMEOUT$1 = 3600000; // 1 hour

var MAX_IMAGE_RESIZE_TIMEOUT_MS$1 = 5 * 60000; // 5 minutes

var POLL_STATUS_INTERVAL$1 = 3000; // 3s

/**
 * Recursively sorts object keys alphabetically
 */
function sortObjectKeys(x) {
  if (_typeof(x) !== 'object' || !x) {
    return x;
  }

  if (Array.isArray(x)) {
    return x.map(sortObjectKeys);
  }

  return Object.keys(x).sort().reduce(function (o, k) {
    return _objectSpread2(_objectSpread2({}, o), {}, _defineProperty$1({}, k, sortObjectKeys(x[k])));
  }, {});
}

var Storage = /*#__PURE__*/function () {
  /**
   * Configuration passed in by consumer (with defaults)
   */
  function Storage(config) {
    _classCallCheck(this, Storage);

    _defineProperty$1(this, "config", void 0);

    _defineProperty$1(this, "storageNodeSelector", void 0);

    _defineProperty$1(this, "logger", void 0);

    this.config = mergeConfigWithDefaults(config, defaultStorageServiceConfig);
    this.storageNodeSelector = config.storageNodeSelector;
    this.logger = this.config.logger.createPrefixedLogger('[storage]');
  }
  /**
   * Upload a file on content nodes
   * @param uploadId
   * @param data
   * @param auth
   * @returns
   */


  _createClass(Storage, [{
    key: "editFile",
    value: function () {
      var _editFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
        var uploadId, data, auth, signatureData, signature, signatureEnvelope, contentNodeEndpoint, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                uploadId = _ref.uploadId, data = _ref.data, auth = _ref.auth;
                // Generate signature
                signatureData = {
                  upload_id: uploadId,
                  timestamp: Date.now()
                };
                _context.next = 4;
                return auth.hashAndSign(JSON.stringify(sortObjectKeys(signatureData)));

              case 4:
                signature = _context.sent;
                signatureEnvelope = {
                  data: JSON.stringify(signatureData),
                  signature: signature
                };
                _context.next = 8;
                return this.storageNodeSelector.getSelectedNode();

              case 8:
                contentNodeEndpoint = _context.sent;

                if (contentNodeEndpoint) {
                  _context.next = 11;
                  break;
                }

                throw new Error('No content node available for upload');

              case 11:
                _context.next = 13;
                return axios__default["default"]({
                  method: 'post',
                  url: "".concat(contentNodeEndpoint, "/uploads/").concat(uploadId),
                  maxContentLength: Infinity,
                  data: data,
                  params: {
                    signature: JSON.stringify(signatureEnvelope)
                  }
                });

              case 13:
                response = _context.sent;
                _context.next = 16;
                return this.pollProcessingStatus(uploadId, response.data.template === 'audio' ? MAX_TRACK_TRANSCODE_TIMEOUT$1 : MAX_IMAGE_RESIZE_TIMEOUT_MS$1);

              case 16:
                return _context.abrupt("return", _context.sent);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function editFile(_x) {
        return _editFile.apply(this, arguments);
      }

      return editFile;
    }()
    /**
     * Upload a file to a content node
     * @param file
     * @param onProgress
     * @param template
     * @param options
     * @returns
     */

  }, {
    key: "uploadFile",
    value: function () {
      var _uploadFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {
        var _file$name;

        var file, onProgress, template, _ref2$options, options, formData, contentNodeEndpoint, response;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                file = _ref2.file, onProgress = _ref2.onProgress, template = _ref2.template, _ref2$options = _ref2.options, options = _ref2$options === void 0 ? {} : _ref2$options;
                formData = new FormData__default["default"]();
                formData.append('template', template);
                Object.keys(options).forEach(function (key) {
                  formData.append(key, "".concat(options[key]));
                });
                formData.append('files', isNodeFile(file) ? file.buffer : file, (_file$name = file.name) !== null && _file$name !== void 0 ? _file$name : 'blob');
                _context2.next = 7;
                return this.storageNodeSelector.getSelectedNode();

              case 7:
                contentNodeEndpoint = _context2.sent;

                if (contentNodeEndpoint) {
                  _context2.next = 10;
                  break;
                }

                throw new Error('No content node available for upload');

              case 10:
                _context2.next = 12;
                return axios__default["default"]({
                  method: 'post',
                  url: "".concat(contentNodeEndpoint, "/uploads"),
                  maxContentLength: Infinity,
                  data: formData,
                  headers: formData.getBoundary ? {
                    'Content-Type': "multipart/form-data; boundary=".concat(formData.getBoundary())
                  } : undefined,
                  onUploadProgress: function onUploadProgress(progressEvent) {
                    return onProgress === null || onProgress === void 0 ? void 0 : onProgress(progressEvent.loaded, progressEvent.total);
                  }
                });

              case 12:
                response = _context2.sent;
                _context2.next = 15;
                return this.pollProcessingStatus(response.data[0].id, template === 'audio' ? MAX_TRACK_TRANSCODE_TIMEOUT$1 : MAX_IMAGE_RESIZE_TIMEOUT_MS$1);

              case 15:
                return _context2.abrupt("return", _context2.sent);

              case 16:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function uploadFile(_x2) {
        return _uploadFile.apply(this, arguments);
      }

      return uploadFile;
    }()
    /**
     * Works for both track transcode and image resize jobs
     * @param id ID of the transcode/resize job
     * @param maxPollingMs millis to stop polling and error if job is not done
     * @returns successful job info, or throws error if job fails / times out
     */

  }, {
    key: "pollProcessingStatus",
    value: function () {
      var _pollProcessingStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(id, maxPollingMs) {
        var start, resp, _e$message, _e$response;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                start = Date.now();

              case 1:
                if (!(Date.now() - start < maxPollingMs)) {
                  _context3.next = 21;
                  break;
                }

                _context3.prev = 2;
                _context3.next = 5;
                return this.getProcessingStatus(id);

              case 5:
                resp = _context3.sent;

                if (!((resp === null || resp === void 0 ? void 0 : resp.status) === 'done')) {
                  _context3.next = 8;
                  break;
                }

                return _context3.abrupt("return", resp);

              case 8:
                if (!((resp === null || resp === void 0 ? void 0 : resp.status) === 'error' || (resp === null || resp === void 0 ? void 0 : resp.status) === 'error_retranscode_preview')) {
                  _context3.next = 10;
                  break;
                }

                throw new Error("Upload failed: id=".concat(id, ", resp=").concat(JSON.stringify(resp)));

              case 10:
                _context3.next = 17;
                break;

              case 12:
                _context3.prev = 12;
                _context3.t0 = _context3["catch"](2);

                if (!((_e$message = _context3.t0.message) !== null && _e$message !== void 0 && _e$message.startsWith('Upload failed') || _context3.t0.response && ((_e$response = _context3.t0.response) === null || _e$response === void 0 ? void 0 : _e$response.status) === 422)) {
                  _context3.next = 16;
                  break;
                }

                throw _context3.t0;

              case 16:
                // Swallow errors caused by failure to establish connection to node so we can retry polling
                this.logger.error("Failed to poll for processing status, ".concat(_context3.t0));

              case 17:
                _context3.next = 19;
                return wait$1(POLL_STATUS_INTERVAL$1);

              case 19:
                _context3.next = 1;
                break;

              case 21:
                throw new Error("Upload took over ".concat(maxPollingMs, "ms. id=").concat(id));

              case 22:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 12]]);
      }));

      function pollProcessingStatus(_x3, _x4) {
        return _pollProcessingStatus.apply(this, arguments);
      }

      return pollProcessingStatus;
    }()
    /**
     * Gets the task progress given the task type and id associated with the job
     * @param id the id of the transcoding or resizing job
     * @returns the status, and the success or failed response if the job is complete
     */

  }, {
    key: "getProcessingStatus",
    value: function () {
      var _getProcessingStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(id) {
        var contentNodeEndpoint, response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.storageNodeSelector.getSelectedNode();

              case 2:
                contentNodeEndpoint = _context4.sent;
                _context4.next = 5;
                return fetch__default["default"]("".concat(contentNodeEndpoint, "/uploads/").concat(id));

              case 5:
                response = _context4.sent;
                _context4.next = 8;
                return response.json();

              case 8:
                return _context4.abrupt("return", _context4.sent);

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getProcessingStatus(_x5) {
        return _getProcessingStatus.apply(this, arguments);
      }

      return getProcessingStatus;
    }()
  }]);

  return Storage;
}();

var NOT_INITIALIZED = 'Auth not initialized - Please provide an apiKey and apiSecret, or a custom implementation of Auth';
var Auth = /*#__PURE__*/_createClass(function Auth() {
  _classCallCheck(this, Auth);

  _defineProperty$1(this, "getSharedSecret", function () {
    throw new Error(NOT_INITIALIZED);
  });

  _defineProperty$1(this, "sign", function () {
    throw new Error(NOT_INITIALIZED);
  });

  _defineProperty$1(this, "hashAndSign", function () {
    throw new Error('Auth not initialized');
  });

  _defineProperty$1(this, "signTransaction", function () {
    throw new Error(NOT_INITIALIZED);
  });

  _defineProperty$1(this, "getAddress", function () {
    throw new Error(NOT_INITIALIZED);
  });
});

/**
 * AuthService for Developer Apps wishing to write on a user's behalf
 */

var AppAuth = /*#__PURE__*/_createClass(function AppAuth(apiKey, apiSecret) {
  var _this = this;

  _classCallCheck(this, AppAuth);

  _defineProperty$1(this, "apiKey", void 0);

  _defineProperty$1(this, "apiSecret", void 0);

  _defineProperty$1(this, "getSharedSecret", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            throw new Error('AppAuth does not support getSharedSecret');

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));

  _defineProperty$1(this, "sign", function () {
    throw new Error('AppAuth does not support sign');
  });

  _defineProperty$1(this, "hashAndSign", function () {
    throw new Error('AppAuth does not support hashAndSign');
  });

  _defineProperty$1(this, "signTransaction", /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(data) {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (_this.apiSecret) {
                _context2.next = 2;
                break;
              }

              throw new Error('AppAuth cannot `signTransaction` because apiSecret was not provided when initializing the SDK.');

            case 2:
              return _context2.abrupt("return", sigUtil.signTypedData(Buffer.from(_this.apiSecret, 'hex'), {
                data: data
              }));

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }());

  _defineProperty$1(this, "getAddress", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", "0x".concat(_this.apiKey));

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  })));

  this.apiKey = apiKey.replace(/^0x/, '');

  if (apiSecret) {
    this.apiSecret = apiSecret.replace(/^0x/, '');
  } else {
    this.apiSecret = null;
  }
});

var DevAppSchema = zod.z.object({
  /**
   * Your app name
   */
  appName: zod.z.optional(zod.z.string()),

  /**
   * Services injection
   */
  services: zod.z.optional(zod.z.custom()),

  /**
   * API key, required for writes
   */
  apiKey: zod.z.string().min(1),

  /**
   * API secret, required for writes
   */
  apiSecret: zod.z.optional(zod.z.string().min(1))
});
var CustomAppSchema = zod.z.object({
  /**
   * Your app name
   */
  appName: zod.z.string().min(1),

  /**
   * Services injection
   */
  services: zod.z.optional(zod.z.custom()),

  /**
   * API key, required for writes
   */
  apiKey: zod.z.optional(zod.z.string().min(1)),

  /**
   * API secret, required for writes
   */
  apiSecret: zod.z.optional(zod.z.string().min(1))
});
var SdkConfigSchema = zod.z.union([DevAppSchema, CustomAppSchema]);

/**
 * The Audius SDK
 */

var sdk = function sdk(config) {
  SdkConfigSchema.parse(config);
  var appName = config.appName,
      apiKey = config.apiKey; // Initialize services

  var services = initializeServices(config); // Initialize APIs

  var apis = initializeApis({
    appName: appName,
    services: services
  }); // Initialize OAuth

  var oauth = typeof window !== 'undefined' ? new OAuth({
    appName: appName,
    apiKey: apiKey,
    usersApi: apis.users,
    logger: services.logger
  }) : undefined;
  return _objectSpread2({
    oauth: oauth
  }, apis);
};

var initializeServices = function initializeServices(config) {
  var _config$services$logg, _config$services, _config$services$stor, _config$services2, _config$services$auth, _config$services3, _config$services$disc, _config$services4, _config$services$disc2, _config$services5;

  var defaultLogger = new Logger();
  var logger = (_config$services$logg = (_config$services = config.services) === null || _config$services === void 0 ? void 0 : _config$services.logger) !== null && _config$services$logg !== void 0 ? _config$services$logg : defaultLogger;

  if (config.apiSecret && browserOrNode.isBrowser) {
    logger.warn("apiSecret should only be provided server side so that it isn't exposed");
  }

  var defaultAuthService = config.apiKey ? new AppAuth(config.apiKey, config.apiSecret) : new Auth();
  var defaultDiscoveryNodeSelector = new DiscoveryNodeSelector({
    logger: logger
  });
  var storageNodeSelector = (_config$services$stor = (_config$services2 = config.services) === null || _config$services2 === void 0 ? void 0 : _config$services2.storageNodeSelector) !== null && _config$services$stor !== void 0 ? _config$services$stor : new StorageNodeSelector({
    auth: (_config$services$auth = (_config$services3 = config.services) === null || _config$services3 === void 0 ? void 0 : _config$services3.auth) !== null && _config$services$auth !== void 0 ? _config$services$auth : defaultAuthService,
    discoveryNodeSelector: (_config$services$disc = (_config$services4 = config.services) === null || _config$services4 === void 0 ? void 0 : _config$services4.discoveryNodeSelector) !== null && _config$services$disc !== void 0 ? _config$services$disc : defaultDiscoveryNodeSelector,
    logger: logger
  });
  var defaultEntityManager = new EntityManager$1(_objectSpread2(_objectSpread2({}, defaultEntityManagerConfig), {}, {
    discoveryNodeSelector: (_config$services$disc2 = (_config$services5 = config.services) === null || _config$services5 === void 0 ? void 0 : _config$services5.discoveryNodeSelector) !== null && _config$services$disc2 !== void 0 ? _config$services$disc2 : defaultDiscoveryNodeSelector
  }));
  var defaultStorage = new Storage({
    storageNodeSelector: storageNodeSelector,
    logger: logger
  });
  var defaultServices = {
    storageNodeSelector: storageNodeSelector,
    discoveryNodeSelector: defaultDiscoveryNodeSelector,
    entityManager: defaultEntityManager,
    storage: defaultStorage,
    auth: defaultAuthService,
    logger: logger
  };
  return _objectSpread2(_objectSpread2({}, defaultServices), config.services);
};

var initializeApis = function initializeApis(_ref) {
  var appName = _ref.appName,
      services = _ref.services;
  var middleware = [addAppNameMiddleware({
    appName: appName,
    services: services
  }), services.discoveryNodeSelector.createMiddleware()];
  var generatedApiClientConfig = new Configuration$1({
    fetchApi: fetch__default["default"],
    middleware: middleware
  });
  var tracks = new TracksApi$1(generatedApiClientConfig, services.discoveryNodeSelector, services.storage, services.entityManager, services.auth, services.logger);
  var users = new UsersApi$1(generatedApiClientConfig, services.storage, services.entityManager, services.auth, services.logger);
  var albums = new AlbumsApi(generatedApiClientConfig, services.storage, services.entityManager, services.auth, services.logger);
  var playlists = new PlaylistsApi$1(generatedApiClientConfig, services.storage, services.entityManager, services.auth, services.logger);
  var tips = new TipsApi$1(generatedApiClientConfig);

  var _ResolveApi = new ResolveApi(generatedApiClientConfig),
      resolve = _ResolveApi.resolve;

  var chats = new ChatsApi(new Configuration$1({
    fetchApi: fetch__default["default"],
    basePath: '',
    middleware: middleware
  }), services.auth, services.discoveryNodeSelector, services.logger);
  var grants = new GrantsApi(generatedApiClientConfig, services.entityManager, services.auth);
  var developerApps = new DeveloperAppsApi(generatedApiClientConfig, services.entityManager, services.auth);
  var generatedApiClientConfigFull = new Configuration({
    fetchApi: fetch__default["default"],
    middleware: middleware
  });
  var full = {
    tracks: new TracksApi(generatedApiClientConfigFull),
    users: new UsersApi(generatedApiClientConfigFull),
    search: new SearchApi(generatedApiClientConfigFull),
    playlists: new PlaylistsApi(generatedApiClientConfigFull),
    reactions: new ReactionsApi(generatedApiClientConfigFull),
    tips: new TipsApi(generatedApiClientConfigFull),
    transactions: new TransactionsApi(generatedApiClientConfigFull)
  };
  return {
    tracks: tracks,
    users: users,
    albums: albums,
    playlists: playlists,
    tips: tips,
    resolve: resolve,
    full: full,
    chats: chats,
    grants: grants,
    developerApps: developerApps
  };
};

var MIN_GAS_PRICE = Math.pow(10, 9); // 1 GWei, ETH minimum allowed gas price

var HIGH_GAS_PRICE = 250 * MIN_GAS_PRICE; // 250 GWei

var DEFAULT_GAS_PRICE = 100 * MIN_GAS_PRICE; // 100 Gwei is a reasonably average gas price

var MAX_GAS_LIMIT = 5000000; // We've seen prod tx's take up to 4M. Set to the highest we've observed + a buffer

/** Singleton state-manager for Audius Eth Contracts */

var EthWeb3Manager = /*#__PURE__*/function () {
  function EthWeb3Manager(_ref) {
    var web3Config = _ref.web3Config,
        identityService = _ref.identityService,
        hedgehog = _ref.hedgehog;

    _classCallCheck(this, EthWeb3Manager);

    _defineProperty$1(this, "web3Config", void 0);

    _defineProperty$1(this, "web3", void 0);

    _defineProperty$1(this, "identityService", void 0);

    _defineProperty$1(this, "hedgehog", void 0);

    _defineProperty$1(this, "ownerWallet", void 0);

    if (!web3Config) throw new Error('web3Config object not passed in');
    if (!web3Config.providers) throw new Error('missing web3Config property: providers'); // MultiProvider implements a web3 provider with fallback.

    var provider = new MultiProvider(web3Config.providers);
    this.web3Config = web3Config;
    this.web3 = new LibsWeb3(provider);
    this.identityService = identityService;
    this.hedgehog = hedgehog;

    if (this.web3Config.ownerWallet) {
      this.ownerWallet = this.web3Config.ownerWallet;
    } else if (this.hedgehog) {
      // Hedgehog might not exist (in the case of @audius/sdk)
      var storedWallet = this.hedgehog.getWallet();

      if (storedWallet) {
        this.ownerWallet = storedWallet;
      }
    }
  }

  _createClass(EthWeb3Manager, [{
    key: "getWeb3",
    value: function getWeb3() {
      return this.web3;
    }
  }, {
    key: "getWalletAddress",
    value: function getWalletAddress() {
      if (this.ownerWallet) {
        // @ts-expect-error TODO extend ethereum-js-wallet to include toLowerCase
        return this.ownerWallet.toLowerCase();
      }

      throw new Error('Owner wallet not set');
    }
    /**
     * Signs provided string data (should be timestamped).
     */

  }, {
    key: "sign",
    value: function () {
      var _sign = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(data) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.web3.eth.personal.sign(this.web3.utils.fromUtf8(data), this.getWalletAddress());

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function sign(_x) {
        return _sign.apply(this, arguments);
      }

      return sign;
    }()
  }, {
    key: "sendTransaction",
    value: function () {
      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(contractMethod) {
        var _this = this;

        var contractAddress,
            privateKey,
            txRetries,
            txGasLimit,
            gasLimit,
            _gasPrice,
            gasPriceStr,
            privateKeyBuffer,
            walletAddress,
            txCount,
            encodedABI,
            txParams,
            tx,
            signedTx,
            response,
            gasPrice,
            _args3 = arguments;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                contractAddress = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : null;
                privateKey = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : null;
                txRetries = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : 5;
                txGasLimit = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : null;

                if (!(txGasLimit !== null && txGasLimit !== void 0)) {
                  _context3.next = 8;
                  break;
                }

                _context3.t0 = txGasLimit;
                _context3.next = 11;
                break;

              case 8:
                _context3.next = 10;
                return estimateGas({
                  method: contractMethod,
                  from: this.ownerWallet,
                  gasLimitMaximum: MAX_GAS_LIMIT
                });

              case 10:
                _context3.t0 = _context3.sent;

              case 11:
                gasLimit = _context3.t0;

                if (!(contractAddress && privateKey)) {
                  _context3.next = 34;
                  break;
                }

                _context3.t1 = parseInt;
                _context3.next = 16;
                return this.web3.eth.getGasPrice();

              case 16:
                _context3.t2 = _context3.sent;
                _gasPrice = (0, _context3.t1)(_context3.t2);

                if (isNaN(_gasPrice) || _gasPrice > HIGH_GAS_PRICE) {
                  _gasPrice = DEFAULT_GAS_PRICE;
                } else if (_gasPrice === 0) {
                  // If the gas is zero, the txn will likely never get mined.
                  _gasPrice = MIN_GAS_PRICE;
                }

                gasPriceStr = '0x' + _gasPrice.toString(16);
                privateKeyBuffer = Buffer.from(privateKey, 'hex');
                walletAddress = this.getWalletAddress();
                _context3.next = 24;
                return this.web3.eth.getTransactionCount(walletAddress);

              case 24:
                txCount = _context3.sent;
                encodedABI = contractMethod.encodeABI();
                txParams = {
                  nonce: this.web3.utils.toHex(txCount),
                  gasPrice: gasPriceStr,
                  gasLimit: gasLimit,
                  data: encodedABI,
                  to: contractAddress,
                  value: '0x00'
                };
                tx = new ethereumjsTx.Transaction(txParams);
                tx.sign(privateKeyBuffer);
                signedTx = '0x' + tx.serialize().toString('hex'); // Send the tx with retries

                _context3.next = 32;
                return retry__default["default"]( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                  return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.next = 2;
                          return _this.web3.eth.sendSignedTransaction(signedTx);

                        case 2:
                          return _context2.abrupt("return", _context2.sent);

                        case 3:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                })), {
                  // Retry function 5x by default
                  // 1st retry delay = 500ms, 2nd = 1500ms, 3rd...nth retry = 4000 ms (capped)
                  minTimeout: 500,
                  maxTimeout: 4000,
                  factor: 3,
                  retries: txRetries,
                  onRetry: function onRetry(err) {
                    if (err) {
                      console.log( // eslint-disable-next-line @typescript-eslint/no-base-to-string -- TODO
                      "libs ethWeb3Manager transaction send retry error : ".concat(err));
                    }
                  }
                });

              case 32:
                response = _context3.sent;
                return _context3.abrupt("return", response);

              case 34:
                _context3.t3 = parseInt;
                _context3.next = 37;
                return this.web3.eth.getGasPrice();

              case 37:
                _context3.t4 = _context3.sent;
                gasPrice = (0, _context3.t3)(_context3.t4);
                _context3.next = 41;
                return contractMethod.send({
                  from: this.ownerWallet,
                  gas: gasLimit,
                  gasPrice: gasPrice
                });

              case 41:
                return _context3.abrupt("return", _context3.sent);

              case 42:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function sendTransaction(_x2) {
        return _sendTransaction.apply(this, arguments);
      }

      return sendTransaction;
    }()
    /**
     * Relays an eth transaction via the identity service with retries
     * The relay pays for the transaction fee on behalf of the user
     * The gas Limit is estimated if not provided
     */

  }, {
    key: "relayTransaction",
    value: function () {
      var _relayTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(contractMethod, contractAddress, ownerWallet, relayerWallet) {
        var _this2 = this;

        var txRetries,
            txGasLimit,
            encodedABI,
            gasLimit,
            response,
            _args5 = arguments;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                txRetries = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : 5;
                txGasLimit = _args5.length > 5 && _args5[5] !== undefined ? _args5[5] : null;
                encodedABI = contractMethod.encodeABI();

                if (!(txGasLimit !== null && txGasLimit !== void 0)) {
                  _context5.next = 7;
                  break;
                }

                _context5.t0 = txGasLimit;
                _context5.next = 10;
                break;

              case 7:
                _context5.next = 9;
                return estimateGas({
                  from: relayerWallet,
                  method: contractMethod,
                  gasLimitMaximum: MAX_GAS_LIMIT
                });

              case 9:
                _context5.t0 = _context5.sent;

              case 10:
                gasLimit = _context5.t0;
                _context5.next = 13;
                return retry__default["default"]( /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(bail) {
                    var attempt, _error$response, error;

                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.prev = 0;

                            if (_this2.identityService) {
                              _context4.next = 3;
                              break;
                            }

                            return _context4.abrupt("return");

                          case 3:
                            _context4.next = 5;
                            return _this2.identityService.ethRelay(contractAddress, ownerWallet, encodedABI, gasLimit.toString());

                          case 5:
                            attempt = _context4.sent;
                            return _context4.abrupt("return", attempt);

                          case 9:
                            _context4.prev = 9;
                            _context4.t0 = _context4["catch"](0);
                            error = _context4.t0;

                            if (!(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 429)) {
                              _context4.next = 15;
                              break;
                            }

                            // Don't retry in the case we are getting rate limited
                            bail(new Error('Please wait before trying again'));
                            return _context4.abrupt("return");

                          case 15:
                            throw error;

                          case 16:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4, null, [[0, 9]]);
                  }));

                  return function (_x7) {
                    return _ref3.apply(this, arguments);
                  };
                }(), {
                  // Retry function 5x by default
                  // 1st retry delay = 500ms, 2nd = 1500ms, 3rd...nth retry = 4000 ms (capped)
                  minTimeout: 500,
                  maxTimeout: 4000,
                  factor: 3,
                  retries: txRetries,
                  onRetry: function onRetry(err) {
                    if (err) {
                      console.log( // eslint-disable-next-line @typescript-eslint/no-base-to-string -- TODO
                      "libs ethWeb3Manager transaction relay retry error : ".concat(err));
                    }
                  }
                });

              case 13:
                response = _context5.sent;
                return _context5.abrupt("return", response === null || response === void 0 ? void 0 : response.resp);

              case 15:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      function relayTransaction(_x3, _x4, _x5, _x6) {
        return _relayTransaction.apply(this, arguments);
      }

      return relayTransaction;
    }()
  }, {
    key: "getRelayMethodParams",
    value: function () {
      var _getRelayMethodParams = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(contractAddress, contractMethod, relayerWallet) {
        var encodedABI, gasLimit;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                encodedABI = contractMethod.encodeABI();
                _context6.next = 3;
                return estimateGas({
                  from: relayerWallet,
                  method: contractMethod,
                  gasLimitMaximum: HIGH_GAS_PRICE
                });

              case 3:
                gasLimit = _context6.sent;
                return _context6.abrupt("return", {
                  contractAddress: contractAddress,
                  encodedABI: encodedABI,
                  gasLimit: gasLimit
                });

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function getRelayMethodParams(_x8, _x9, _x10) {
        return _getRelayMethodParams.apply(this, arguments);
      }

      return getRelayMethodParams;
    }()
  }]);

  return EthWeb3Manager;
}();

var name = "@audius/sdk";
var version = "3.0.7";
var audius = {
	releaseSHA: "a05a01e81a7313101b0560db611bec3fece1a756"
};
var description = "Audius SDK";
var keywords = [
	"audius",
	"sdk",
	"api",
	"music",
	"audio",
	"web3",
	"decentralized",
	"blockchain"
];
var main = "dist/index.cjs.js";
var module$1 = "dist/index.esm.js";
var types = "dist/index.d.ts";
var browser = {
	"./dist/index.cjs.js": "./dist/index.browser.cjs.js",
	"./dist/index.esm.js": "./dist/index.browser.esm.js"
};
var scripts = {
	"init-local": "ts-node initScripts/local.js",
	"test:sdk": "./node_modules/.bin/jest --coverage=false",
	"test:sdk:browser": "./node_modules/.bin/jest --env jsdom",
	test: "./scripts/test.sh",
	"test:unit": "ts-mocha 'src/**/*.test.{js,ts}' --ignore 'src/sdk/**/*.test.{js,ts}' --exit",
	"test:unit:watch": "ts-mocha 'src/[!sdk]**/*.test.{js,ts}' --ignore 'src/sdk/**/*.test.{js,ts}' --watch",
	"test:integration": "ts-mocha tests/index.js",
	setup: "./scripts/migrate_contracts.sh",
	build: "rollup -c --configPlugin typescript",
	"build:sdk": "rollup -c rollup.sdk.config.ts --configPlugin typescript",
	"build:sdk:browser": "rollup -c rollup.sdk.browser.config.ts --configPlugin typescript",
	"build:sdk:browser:dist": "rollup -c rollup.sdk.browser.dist.config.ts --configPlugin typescript",
	"build:sdk:native": "rollup -c rollup.sdk.native.config.ts --configPlugin typescript",
	"build:legacy:browser": "rollup -c rollup.legacy.browser.config.ts --configPlugin typescript",
	"build:legacy:native": "rollup -c rollup.legacy.native.config.ts --configPlugin typescript",
	start: "rollup -c -w --configPlugin typescript",
	"start:sdk": "rollup -c rollup.sdk.config.ts -w --configPlugin typescript",
	"start:sdk:browser": "rollup -c rollup.sdk.browser.config.ts -w --configPlugin typescript",
	"start:sdk:browser:dist": "rollup -c rollup.sdk.browser.dist.config.ts -w --configPlugin typescript",
	"start:sdk:native": "rollup -c rollup.sdk.native.config.ts -w --configPlugin typescript",
	"start:legacy:browser": "rollup -c rollup.legacy.browser.config.ts -w --configPlugin typescript",
	"start:legacy:native": "rollup -c rollup.legacy.native.config.ts -w --configPlugin typescript",
	lint: "eslint ./src ./types",
	"lint:fix": "npm run lint -- --fix",
	typecheck: "tsc --noEmit",
	"sdk:config": "ts-node ./src/sdk/scripts/generateServicesConfig.ts",
	gen: "npm run gen:prod",
	"gen:dev": "npm run gen:dev:default ; npm run gen:dev:full",
	"gen:dev:default": "node ./src/sdk/api/generator/gen.js --env dev",
	"gen:dev:full": "node ./src/sdk/api/generator/gen.js --env dev --api-flavor full",
	"gen:stage": "npm run gen:stage:default ; npm run gen:stage:full",
	"gen:stage:default": "node ./src/sdk/api/generator/gen.js --env stage",
	"gen:stage:full": "node ./src/sdk/api/generator/gen.js --env stage --api-flavor full",
	"gen:prod": "npm run gen:prod:default ; npm run gen:prod:full",
	"gen:prod:default": "node ./src/sdk/api/generator/gen.js",
	"gen:prod:full": "node ./src/sdk/api/generator/gen.js --api-flavor full",
	prepare: "patch-package"
};
var dependencies = {
	"@audius/hedgehog": "2.1.0",
	"@babel/runtime": "7.18.3",
	"@certusone/wormhole-sdk": "0.1.1",
	"@ethersproject/solidity": "5.0.5",
	"@improbable-eng/grpc-web-node-http-transport": "0.15.0",
	"@noble/hashes": "^1.3.0",
	"@noble/secp256k1": "1.7.0",
	"@project-serum/anchor": "0.24.1",
	"@scure/base": "1.1.1",
	"@solana/spl-token": "0.1.8",
	"@solana/web3.js": "1.37.1",
	"abi-decoder": "2.4.0",
	ajv: "6.12.2",
	"async-retry": "1.3.1",
	axios: "0.19.2",
	"bn.js": "5.2.1",
	borsh: "0.4.0",
	"browser-or-node": "^2.1.1",
	bs58: "4.0.1",
	"cipher-base": "1.0.4",
	"crc-32": "1.2.2",
	"cross-fetch": "3.1.5",
	elliptic: "6.5.4",
	esm: "3.2.25",
	"eth-sig-util": "2.5.4",
	"ethereumjs-tx": "2.1.2",
	"ethereumjs-util": "7.1.4",
	"ethereumjs-wallet": "1.0.2",
	ethers: "5.4.7",
	"file-type": "16.5.3",
	"form-data": "3.0.0",
	hashids: "2.2.10",
	"interface-blockstore": "2.0.3",
	"interface-store": "2.0.2",
	"ipfs-unixfs-importer": "9.0.6",
	"isomorphic-ws": "5.0.0",
	jsonschema: "1.2.6",
	keccak256: "1.0.2",
	lodash: "4.17.21",
	"micro-aes-gcm": "0.3.3",
	multiformats: "9.9.0",
	"node-abort-controller": "3.1.1",
	"node-localstorage": "1.3.1",
	"proper-url-join": "1.2.0",
	"rollup-plugin-shim": "1.0.0",
	"safe-buffer": "5.2.1",
	secp256k1: "4.0.2",
	semver: "6.3.0",
	"snakecase-keys": "5.4.5",
	"stream-browserify": "3.0.0",
	ulid: "2.3.0",
	web3: "1.7.1",
	xmlhttprequest: "1.8.0",
	zod: "3.21.4"
};
var devDependencies = {
	"@babel/plugin-transform-runtime": "7.18.2",
	"@babel/preset-env": "7.16.11",
	"@openapitools/openapi-generator-cli": "2.4.26",
	"@openzeppelin/test-helpers": "0.5.6",
	"@rollup/plugin-alias": "3.1.9",
	"@rollup/plugin-babel": "5.3.1",
	"@rollup/plugin-commonjs": "21.0.2",
	"@rollup/plugin-json": "4.1.0",
	"@rollup/plugin-node-resolve": "13.1.3",
	"@rollup/plugin-typescript": "8.3.1",
	"@tsconfig/node18-strictest": "1.0.0",
	"@types/async-retry": "1.4.4",
	"@types/bn.js": "5.1.0",
	"@types/bs58": "4.0.1",
	"@types/eth-sig-util": "2.1.1",
	"@types/expect": "24.3.0",
	"@types/form-data": "2.5.0",
	"@types/hashids": "2.0.1",
	"@types/jest": "29.5.2",
	"@types/lodash": "4.14.149",
	"@types/mocha": "9.1.0",
	"@types/node-localstorage": "1.3.0",
	"@types/pify": "5.0.1",
	"@types/proper-url-join": "2.1.1",
	"@types/semver": "7.3.9",
	"@typescript-eslint/eslint-plugin": "4.33.0",
	commander: "9.2.0",
	eslint: "7.32.0",
	"eslint-config-prettier": "8.5.0",
	"eslint-config-standard-with-typescript": "21.0.1",
	"eslint-plugin-import": "2.25.4",
	"eslint-plugin-mocha": "10.0.3",
	"eslint-plugin-node": "11.1.0",
	"eslint-plugin-prettier": "4.0.0",
	"eslint-plugin-promise": "5.2.0",
	jest: "29.4.1",
	"jest-environment-jsdom": "29.4.1",
	mocha: "9.2.2",
	msw: "1.0.0",
	nock: "13.1.2",
	nyc: "15.1.0",
	"patch-package": "6.5.0",
	prettier: "2.6.1",
	"prettier-config-standard": "5.0.0",
	rollup: "2.70.1",
	"rollup-plugin-dts": "4.2.0",
	"rollup-plugin-ignore": "1.0.10",
	"rollup-plugin-polyfill-node": "0.9.0",
	"rollup-plugin-terser": "7.0.2",
	sinon: "9.0.2",
	standard: "16.0.4",
	"ts-jest": "29.0.5",
	"ts-mocha": "9.0.2",
	"ts-node": "10.7.0",
	"type-fest": "2.17.0",
	"typed-emitter": "2.1.0",
	typescript: "4.6.2",
	"wait-for-expect": "3.0.2"
};
var repository = {
	type: "git",
	url: "git+https://github.com/AudiusProject/audius-protocol/tree/main/libs"
};
var engines = {
	node: ">=14.0.0"
};
var author = "Audius";
var license = "Apache-2.0";
var bugs = {
	url: "https://github.com/AudiusProject/audius-protocol/issues"
};
var homepage = "https://github.com/AudiusProject/audius-protocol/tree/main/libs";
var require$$0 = {
	name: name,
	version: version,
	audius: audius,
	description: description,
	keywords: keywords,
	main: main,
	module: module$1,
	types: types,
	browser: browser,
	"react-native": "./dist/index.native.js",
	scripts: scripts,
	dependencies: dependencies,
	devDependencies: devDependencies,
	repository: repository,
	engines: engines,
	author: author,
	license: license,
	bugs: bugs,
	homepage: homepage
};

// This is necessary to prevent importing a file outside of the src
// directory which causes issues with rollup typescript type compilation

var packageJson = require$$0;
var version_1 = packageJson.version;

var contractName$1 = "Registry";
var abi$d = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "ContractAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "ContractRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_oldAddress",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_newAddress",
				type: "address"
			}
		],
		name: "ContractUpgraded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "addContract",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_version",
				type: "uint256"
			}
		],
		name: "getContract",
		outputs: [
			{
				internalType: "address",
				name: "contractAddr",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			}
		],
		name: "getContract",
		outputs: [
			{
				internalType: "address",
				name: "contractAddr",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			}
		],
		name: "getContractVersionCount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			}
		],
		name: "removeContract",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "_newAddress",
				type: "address"
			}
		],
		name: "upgradeContract",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var RegistryABI = {
	contractName: contractName$1,
	abi: abi$d
};

var contractName = "DiscoveryProviderFactory";
var abi$c = [
	{
		inputs: [
			{
				internalType: "address",
				name: "_registryAddress",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "_discoveryProviderStorageRegistryKey",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "_id",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_wallet",
				type: "address"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_endpoint",
				type: "string"
			}
		],
		name: "NewDiscoveryProvider",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address payable",
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_id",
				type: "uint256"
			}
		],
		name: "getDiscoveryProvider",
		outputs: [
			{
				internalType: "address",
				name: "wallet",
				type: "address"
			},
			{
				internalType: "string",
				name: "endpoint",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getTotalNumberOfProviders",
		outputs: [
			{
				internalType: "uint256",
				name: "total",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "string",
				name: "_endpoint",
				type: "string"
			}
		],
		name: "register",
		outputs: [
			{
				internalType: "uint256",
				name: "discProvId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var DiscoverProviderFactoryABI = {
	contractName: contractName,
	abi: abi$c
};

var abiMap = {};
[RegistryABI, DiscoverProviderFactoryABI, EntityManagerABI].forEach(function (_ref) {
  var contractName = _ref.contractName,
      abi = _ref.abi;
  abiDecoder__default["default"].addABI(abi);
  abiMap[contractName] = abi;
}); // eslint-disable-next-line @typescript-eslint/no-extraneous-class -- should just use esm

var AudiusABIDecoder = /*#__PURE__*/function () {
  function AudiusABIDecoder() {
    _classCallCheck(this, AudiusABIDecoder);
  }

  _createClass(AudiusABIDecoder, null, [{
    key: "decodeMethod",
    value: function decodeMethod(contractName, encodedABI) {
      var decoded = abiDecoder__default["default"].decodeMethod(encodedABI);

      if (!decoded) {
        throw new Error('No Audius ABI matches given data');
      } // hack around abi-decoder's lack of contract-specific support (only one global
      // namespace of functions)


      var abi = abiMap[contractName];

      if (!abi) {
        throw new Error("Unrecognized contract name ".concat(contractName));
      }

      var foundFunction;
      abi.forEach(function (item) {
        if (item.type === 'function' && item.name === decoded.name) {
          foundFunction = item;
        }
      });

      if (!foundFunction) {
        throw new Error("Unrecognized function ".concat(decoded.name, " for contract ").concat(contractName));
      }

      var paramSpecs = foundFunction.inputs;
      decoded.params.forEach(function (param, idx) {
        if (idx >= paramSpecs.length) {
          throw new Error('Extra parameter');
        }

        var paramSpec = paramSpecs[idx];

        if ((paramSpec === null || paramSpec === void 0 ? void 0 : paramSpec.name) !== param.name || paramSpec.type !== param.type) {
          throw new Error("Invalid name or value for param ".concat(paramSpec === null || paramSpec === void 0 ? void 0 : paramSpec.name, ": ").concat(paramSpec === null || paramSpec === void 0 ? void 0 : paramSpec.type));
        }
      });
      return decoded;
    }
  }, {
    key: "decodeLogs",
    value: function decodeLogs(_, logs) {
      return abiDecoder__default["default"].decodeLogs(logs);
    }
  }, {
    key: "decodeAbi",
    value: function decodeAbi(contractName, encodedABI) {
      var decodedABI = AudiusABIDecoder.decodeMethod(contractName, encodedABI);
      var mapping = new Map(); // map without leading underscore in _userId

      decodedABI.params.forEach(function (param) {
        mapping.set(param.name.substring(1), param.value);
      });
      return mapping;
    }
  }, {
    key: "recoverSigner",
    value: function recoverSigner(_ref2) {
      var encodedAbi = _ref2.encodedAbi,
          chainId = _ref2.chainId,
          entityManagerAddress = _ref2.entityManagerAddress;
      var decodedAbi = this.decodeAbi('EntityManager', encodedAbi);
      var data = signatureSchemas.generators.getManageEntityData(chainId, entityManagerAddress, decodedAbi.get("userId"), decodedAbi.get("entityType"), decodedAbi.get("entityId"), decodedAbi.get("action"), decodedAbi.get("metadata"), decodedAbi.get("nonce"));
      var sig = decodedAbi.get("subjectSig");
      if (sig === undefined) throw new Error("subjectSig is not present in decoded abi");
      return sigUtil__default["default"].recoverTypedSignature({
        data: data,
        sig: sig
      });
    }
  }]);

  return AudiusABIDecoder;
}();

/* eslint-disable @typescript-eslint/no-var-requires */
var XMLHttpRequestRef;

if (typeof window === 'undefined' || window === null) {
  XMLHttpRequestRef = require('xmlhttprequest').XMLHttpRequest;
} else {
  XMLHttpRequestRef = window.XMLHttpRequest;
}

var DEFAULT_GAS_LIMIT = 2000000;
/** singleton class to be instantiated and persisted with every AudiusLibs */

var Web3Manager = /*#__PURE__*/function () {
  // Need to maintain the user's provided handle for anti-abuse measures on relay
  function Web3Manager(_ref) {
    var web3Config = _ref.web3Config,
        identityService = _ref.identityService,
        hedgehog = _ref.hedgehog,
        _ref$isServer = _ref.isServer,
        isServer = _ref$isServer === void 0 ? false : _ref$isServer;

    _classCallCheck(this, Web3Manager);

    _defineProperty$1(this, "web3Config", void 0);

    _defineProperty$1(this, "isServer", void 0);

    _defineProperty$1(this, "identityService", void 0);

    _defineProperty$1(this, "hedgehog", void 0);

    _defineProperty$1(this, "AudiusABIDecoder", void 0);

    _defineProperty$1(this, "web3", void 0);

    _defineProperty$1(this, "useExternalWeb3", void 0);

    _defineProperty$1(this, "ownerWallet", void 0);

    _defineProperty$1(this, "userSuppliedHandle", void 0);

    this.web3Config = web3Config;
    this.isServer = isServer; // Unset if externalWeb3 = true

    this.identityService = identityService;
    this.hedgehog = hedgehog;
    this.AudiusABIDecoder = AudiusABIDecoder;
  }

  _createClass(Web3Manager, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _web3Config$externalW, _web3Config$internalW;

        var web3Config, _this$hedgehog, pkeyBuffer, storedWallet, _this$hedgehog2, passwordEntropy;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                web3Config = this.web3Config;

                if (web3Config) {
                  _context.next = 3;
                  break;
                }

                throw new Error('Failed to initialize Web3Manager');

              case 3:
                if (!( // External Web3
                web3Config !== null && web3Config !== void 0 && web3Config.useExternalWeb3 && (_web3Config$externalW = web3Config.externalWeb3Config) !== null && _web3Config$externalW !== void 0 && _web3Config$externalW.web3 && web3Config.externalWeb3Config.ownerWallet)) {
                  _context.next = 9;
                  break;
                }

                this.web3 = web3Config.externalWeb3Config.web3;
                this.useExternalWeb3 = true;
                this.ownerWallet = web3Config.externalWeb3Config.ownerWallet;
                _context.next = 28;
                break;

              case 9:
                if (!( // Internal Web3
                web3Config && !web3Config.useExternalWeb3 && (_web3Config$internalW = web3Config.internalWeb3Config) !== null && _web3Config$internalW !== void 0 && _web3Config$internalW.web3ProviderEndpoints)) {
                  _context.next = 27;
                  break;
                }

                // either user has external web3 but it's not configured, or doesn't have web3
                this.web3 = new LibsWeb3(this.provider(web3Config.internalWeb3Config.web3ProviderEndpoints[0], 10000));
                this.useExternalWeb3 = false;

                if (!web3Config.internalWeb3Config.privateKey) {
                  _context.next = 16;
                  break;
                }

                pkeyBuffer = Buffer.from(web3Config.internalWeb3Config.privateKey, 'hex');
                this.ownerWallet = EthereumWallet__default["default"].fromPrivateKey(pkeyBuffer);
                return _context.abrupt("return");

              case 16:
                // create private key pair here if it doesn't already exist
                storedWallet = (_this$hedgehog = this.hedgehog) === null || _this$hedgehog === void 0 ? void 0 : _this$hedgehog.getWallet();

                if (!storedWallet) {
                  _context.next = 21;
                  break;
                }

                this.ownerWallet = storedWallet;
                _context.next = 25;
                break;

              case 21:
                passwordEntropy = "audius-dummy-pkey-".concat(Math.floor(Math.random() * 1000000));
                _context.next = 24;
                return (_this$hedgehog2 = this.hedgehog) === null || _this$hedgehog2 === void 0 ? void 0 : _this$hedgehog2.createWalletObj(passwordEntropy);

              case 24:
                this.ownerWallet = _context.sent;

              case 25:
                _context.next = 28;
                break;

              case 27:
                throw new Error("web3ProviderEndpoint isn't passed into constructor");

              case 28:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "getWeb3",
    value: function getWeb3() {
      return this.web3;
    }
  }, {
    key: "setWeb3",
    value: function setWeb3(web3) {
      this.web3 = web3;
    }
  }, {
    key: "getWalletAddress",
    value: function getWalletAddress() {
      if (this.useExternalWeb3) {
        // Lowercase the owner wallet. Consider using the checksum address.
        // See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md.
        // @ts-expect-error Wallet type doesn't have `toLowerCase` method?
        return this.ownerWallet.toLowerCase();
      } else {
        var _this$ownerWallet;

        return (_this$ownerWallet = this.ownerWallet) === null || _this$ownerWallet === void 0 ? void 0 : _this$ownerWallet.getAddressString();
      }
    }
  }, {
    key: "setOwnerWallet",
    value: function setOwnerWallet(ownerWallet) {
      this.ownerWallet = ownerWallet;
    }
  }, {
    key: "web3IsExternal",
    value: function web3IsExternal() {
      return this.useExternalWeb3;
    }
  }, {
    key: "setUserSuppliedHandle",
    value: function setUserSuppliedHandle(handle) {
      this.userSuppliedHandle = handle;
    }
  }, {
    key: "getOwnerWalletPrivateKey",
    value: function getOwnerWalletPrivateKey() {
      if (this.useExternalWeb3) {
        throw new Error("Can't get owner wallet private key for external web3");
      } else {
        var _this$ownerWallet2;

        return (_this$ownerWallet2 = this.ownerWallet) === null || _this$ownerWallet2 === void 0 ? void 0 : _this$ownerWallet2.getPrivateKey();
      }
    }
    /**
     * Signs provided string data (should be timestamped).
     * @param data
     */

  }, {
    key: "sign",
    value: function () {
      var _sign = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(data) {
        var account, _this$web, _this$web2;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.useExternalWeb3) {
                  _context2.next = 11;
                  break;
                }

                account = this.getWalletAddress();

                if (!this.isServer) {
                  _context2.next = 8;
                  break;
                }

                _context2.next = 5;
                return (_this$web = this.web3) === null || _this$web === void 0 ? void 0 : _this$web.eth.sign(this.web3.utils.fromUtf8(data), account);

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 8:
                _context2.next = 10;
                return (_this$web2 = this.web3) === null || _this$web2 === void 0 ? void 0 : _this$web2.eth.personal.sign(this.web3.utils.fromUtf8(data), account, '');

              case 10:
                return _context2.abrupt("return", _context2.sent);

              case 11:
                return _context2.abrupt("return", sigUtil__default["default"].personalSign(this.getOwnerWalletPrivateKey(), {
                  data: data
                }));

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function sign(_x) {
        return _sign.apply(this, arguments);
      }

      return sign;
    }()
    /**
     * Given a data payload and signature, verifies that signature is valid, and returns
     * Ethereum wallet address used to sign data.
     * @param data information that was signed
     * @param signature hex-formatted signature of data generated by web3 personalSign method
     */

  }, {
    key: "verifySignature",
    value: function () {
      var _verifySignature = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(data, signature) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", sigUtil__default["default"].recoverPersonalSignature({
                  data: data,
                  sig: signature
                }));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function verifySignature(_x2, _x3) {
        return _verifySignature.apply(this, arguments);
      }

      return verifySignature;
    }()
  }, {
    key: "signTypedData",
    value: function () {
      var _signTypedData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(signatureData) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this.useExternalWeb3) {
                  _context4.next = 6;
                  break;
                }

                _context4.next = 3;
                return ethSignTypedData(this.getWeb3(), this.getWalletAddress(), signatureData);

              case 3:
                return _context4.abrupt("return", _context4.sent);

              case 6:
                // Due to changes in ethereumjs-util's toBuffer method as of v6.2.0
                // non hex-prefixed string values are not permitted and need to be
                // provided directly as a buffer.
                // https://github.com/ethereumjs/ethereumjs-util/releases/tag/v6.2.0
                Object.keys(signatureData.message).forEach(function (key) {
                  var message = signatureData.message[key];

                  if (typeof message === 'string' && !message.startsWith('0x')) {
                    signatureData.message[key] = Buffer.from(message);
                  }
                });
                return _context4.abrupt("return", sigUtil__default["default"].signTypedData(this.ownerWallet.getPrivateKey(), {
                  data: signatureData
                }));

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function signTypedData(_x4) {
        return _signTypedData.apply(this, arguments);
      }

      return signTypedData;
    }()
  }, {
    key: "sendTransaction",
    value: function () {
      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(contractMethod, contractRegistryKey, contractAddress) {
        var _this = this;

        var txRetries,
            txGasLimit,
            nethermindContractAddress,
            nethermindContractMethod,
            gasLimit,
            encodedABI,
            nethermindEncodedAbi,
            response,
            receipt,
            events,
            decoded,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                txRetries = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : 5;
                txGasLimit = _args6.length > 4 ? _args6[4] : undefined;
                nethermindContractAddress = _args6.length > 5 ? _args6[5] : undefined;
                nethermindContractMethod = _args6.length > 6 ? _args6[6] : undefined;

                if (!(txGasLimit !== null && txGasLimit !== void 0)) {
                  _context6.next = 8;
                  break;
                }

                _context6.t0 = txGasLimit;
                _context6.next = 11;
                break;

              case 8:
                _context6.next = 10;
                return estimateGas({
                  method: contractMethod,
                  gasLimitMaximum: DEFAULT_GAS_LIMIT
                });

              case 10:
                _context6.t0 = _context6.sent;

              case 11:
                gasLimit = _context6.t0;

                if (!this.useExternalWeb3) {
                  _context6.next = 18;
                  break;
                }

                _context6.next = 15;
                return contractMethod.send({
                  from: this.ownerWallet,
                  gas: gasLimit
                });

              case 15:
                return _context6.abrupt("return", _context6.sent);

              case 18:
                encodedABI = contractMethod.encodeABI();
                nethermindEncodedAbi = nethermindContractMethod === null || nethermindContractMethod === void 0 ? void 0 : nethermindContractMethod.encodeABI();
                _context6.next = 22;
                return retry__default["default"]( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(bail) {
                    var _this$identityService;

                    return regeneratorRuntime.wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            _context5.prev = 0;
                            _context5.next = 3;
                            return (_this$identityService = _this.identityService) === null || _this$identityService === void 0 ? void 0 : _this$identityService.relay(contractRegistryKey, contractAddress, _this.ownerWallet.getAddressString(), encodedABI, gasLimit, _this.userSuppliedHandle, nethermindContractAddress, nethermindEncodedAbi);

                          case 3:
                            return _context5.abrupt("return", _context5.sent);

                          case 6:
                            _context5.prev = 6;
                            _context5.t0 = _context5["catch"](0);

                            if (!(_context5.t0.response.status === 403)) {
                              _context5.next = 11;
                              break;
                            }

                            bail(_context5.t0);
                            return _context5.abrupt("return");

                          case 11:
                            throw _context5.t0;

                          case 12:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5, null, [[0, 6]]);
                  }));

                  return function (_x8) {
                    return _ref2.apply(this, arguments);
                  };
                }(), {
                  // Retry function 5x by default
                  // 1st retry delay = 500ms, 2nd = 1500ms, 3rd...nth retry = 4000 ms (capped)
                  minTimeout: 500,
                  maxTimeout: 4000,
                  factor: 3,
                  retries: txRetries,
                  onRetry: function onRetry(err) {
                    if (err) {
                      console.log( // eslint-disable-next-line @typescript-eslint/no-base-to-string
                      "libs web3Manager transaction send retry error : ".concat(err));
                    }
                  }
                });

              case 22:
                response = _context6.sent;
                receipt = response.receipt; // interestingly, using contractMethod.send from Metamask's web3 (eg. like in the if
                // above) parses the event log into an 'events' key on the transaction receipt and
                // blows away the 'logs' key. However, using sendRawTransaction as our
                // relayer does, returns only the logs. Here, we replicate the part of the 'events'
                // key that our code consumes, but we may want to change our functions to consume
                // this data in a different way in future (this parsing is messy).
                // More on Metamask's / Web3.js' behavior here:
                // https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#methods-mymethod-send

                if (receipt.logs) {
                  events = {}; // TODO: decodeLogs appears to return DecodedLog, not DecodedLog[] so maybe a type/version issue

                  decoded = this.AudiusABIDecoder.decodeLogs(contractRegistryKey, receipt.logs);
                  decoded.forEach(function (evt) {
                    var returnValues = {};
                    evt.events.forEach(function (arg) {
                      returnValues[arg.name] = arg.value;
                    });
                    var eventLog = {
                      returnValues: returnValues
                    };
                    events[evt.name] = eventLog;
                  });
                  receipt.events = events;
                }

                return _context6.abrupt("return", response.receipt);

              case 26:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function sendTransaction(_x5, _x6, _x7) {
        return _sendTransaction.apply(this, arguments);
      }

      return sendTransaction;
    }() // TODO - Remove this. Adapted from https://github.com/raiden-network/webui/pull/51/files
    // Vendored code below

  }, {
    key: "provider",
    value: function provider(url, timeout) {
      return this.monkeyPatchProvider(new LibsWeb3.providers.HttpProvider(url, {
        timeout: timeout
      }));
    } // TODO: Workaround for https://github.com/ethereum/web3.js/issues/1803 it should be immediately removed
    // as soon as the issue is fixed upstream.
    // Issue is also documented here https://github.com/ethereum/web3.js/issues/1802

  }, {
    key: "monkeyPatchProvider",
    value: function monkeyPatchProvider(httpProvider) {
      // @ts-expect-error overriding a private method not appearing in types
      override(httpProvider, '_prepareRequest', function () {
        return function () {
          var request = new XMLHttpRequestRef();
          request.open('POST', this.host, true);
          request.setRequestHeader('Content-Type', 'application/json');
          request.timeout = this.timeout && this.timeout !== 1 ? this.timeout : 0;

          if (this.headers) {
            this.headers.forEach(function (header) {
              request.setRequestHeader(header.name, header.value);
            });
          }

          return request;
        };
      });
      return httpProvider;
    }
  }]);

  return Web3Manager;
}();
/** Browser and testing-compatible signTypedData */

var ethSignTypedData = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(web3, wallet, signatureData) {
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return new Promise(function (resolve, reject) {
              var _window$audiusLibs$we, _provider$providers, _provider$providers$;

              var processedSignatureData = signatureData;
              var method;
              var provider = (_window$audiusLibs$we = window.audiusLibs.web3Manager) === null || _window$audiusLibs$we === void 0 ? void 0 : _window$audiusLibs$we.getWeb3().currentProvider;

              if ( // @ts-expect-error isMetaMask is not defined on HTTPProvider, but MetaMask's flavor has it.
              (provider === null || provider === void 0 ? void 0 : (_provider$providers = provider.providers) === null || _provider$providers === void 0 ? void 0 : (_provider$providers$ = _provider$providers[0]) === null || _provider$providers$ === void 0 ? void 0 : _provider$providers$.isMetaMask) === true) {
                method = 'eth_signTypedData_v3';
                processedSignatureData = JSON.stringify(signatureData);
              } else {
                method = 'eth_signTypedData'; // fix per https://github.com/ethereum/web3.js/issues/1119
              }
              web3.currentProvider.send({
                method: method,
                params: [wallet, processedSignatureData],
                // @ts-expect-error from not in JsonRpcPayload
                from: wallet
              }, function (err, result) {
                if (err) {
                  reject(err);
                } else if (result !== null && result !== void 0 && result.error) {
                  reject(result === null || result === void 0 ? void 0 : result.error);
                } else {
                  resolve(result === null || result === void 0 ? void 0 : result.result);
                }
              });
            });

          case 2:
            return _context7.abrupt("return", _context7.sent);

          case 3:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));

  return function ethSignTypedData(_x9, _x10, _x11) {
    return _ref3.apply(this, arguments);
  };
}();

function override(object, methodName, callback) {
  object[methodName] = callback(object[methodName]);
}

var AudiusTokenClient = /*#__PURE__*/function () {
  function AudiusTokenClient(ethWeb3Manager, contractABI, contractAddress) {
    _classCallCheck(this, AudiusTokenClient);

    _defineProperty$1(this, "ethWeb3Manager", void 0);

    _defineProperty$1(this, "contractABI", void 0);

    _defineProperty$1(this, "contractAddress", void 0);

    _defineProperty$1(this, "web3", void 0);

    _defineProperty$1(this, "AudiusTokenContract", void 0);

    _defineProperty$1(this, "bustCacheNonce", void 0);

    this.ethWeb3Manager = ethWeb3Manager;
    this.contractABI = contractABI;
    this.contractAddress = contractAddress;
    this.web3 = this.ethWeb3Manager.getWeb3();
    this.AudiusTokenContract = new this.web3.eth.Contract(this.contractABI, this.contractAddress);
    this.bustCacheNonce = 0;
  }
  /* ------- GETTERS ------- */


  _createClass(AudiusTokenClient, [{
    key: "bustCache",
    value: function () {
      var _bustCache = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.bustCacheNonce += 1;

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function bustCache() {
        return _bustCache.apply(this, arguments);
      }

      return bustCache;
    }()
  }, {
    key: "balanceOf",
    value: function () {
      var _balanceOf = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(account) {
        var args, balance;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.bustCacheNonce > 0) {
                  args = {
                    _audiusBustCache: this.bustCacheNonce
                  };
                }

                _context2.next = 3;
                return this.AudiusTokenContract.methods.balanceOf(account).call(args);

              case 3:
                balance = _context2.sent;
                return _context2.abrupt("return", this.web3.utils.toBN(balance));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function balanceOf(_x) {
        return _balanceOf.apply(this, arguments);
      }

      return balanceOf;
    }() // Get the name of the contract

  }, {
    key: "name",
    value: function () {
      var _name = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var name;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.AudiusTokenContract.methods.name().call();

              case 2:
                name = _context3.sent;
                return _context3.abrupt("return", name);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function name() {
        return _name.apply(this, arguments);
      }

      return name;
    }() // Get the name of the contract

  }, {
    key: "nonces",
    value: function () {
      var _nonces = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(wallet) {
        var nonce, number;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.AudiusTokenContract.methods.nonces(wallet).call({
                  _audiusBustCache: Date.now()
                });

              case 2:
                nonce = _context4.sent;
                number = this.web3.utils.toBN(nonce).toNumber();
                return _context4.abrupt("return", number);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function nonces(_x2) {
        return _nonces.apply(this, arguments);
      }

      return nonces;
    }()
    /* ------- SETTERS ------- */

  }, {
    key: "transfer",
    value: function () {
      var _transfer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(recipient, amount) {
        var contractMethod, tx;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                contractMethod = this.AudiusTokenContract.methods.transfer(recipient, amount);
                _context5.next = 3;
                return this.ethWeb3Manager.sendTransaction(contractMethod);

              case 3:
                tx = _context5.sent;
                return _context5.abrupt("return", {
                  txReceipt: tx
                });

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function transfer(_x3, _x4) {
        return _transfer.apply(this, arguments);
      }

      return transfer;
    }()
  }, {
    key: "transferFrom",
    value: function () {
      var _transferFrom = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(owner, recipient, relayer, amount) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                method = this.AudiusTokenContract.methods.transferFrom(owner, recipient, amount);
                _context6.next = 3;
                return this.ethWeb3Manager.relayTransaction(method, this.contractAddress, owner, relayer,
                /* retries */
                0);

              case 3:
                tx = _context6.sent;
                return _context6.abrupt("return", {
                  txReceipt: tx
                });

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function transferFrom(_x5, _x6, _x7, _x8) {
        return _transferFrom.apply(this, arguments);
      }

      return transferFrom;
    }() // Permit meta transaction of balance transfer

  }, {
    key: "permit",
    value: function () {
      var _permit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(owner, // address
      spender, // address
      value, // uint
      deadline, // uint
      v, // uint8
      r, // bytes32
      s // bytes32
      ) {
        var contractMethod, tx;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                contractMethod = this.AudiusTokenContract.methods.permit(owner, spender, value, deadline, v, r, s);
                _context7.next = 3;
                return this.ethWeb3Manager.relayTransaction(contractMethod, this.contractAddress, owner, spender,
                /* retries */
                0);

              case 3:
                tx = _context7.sent;
                return _context7.abrupt("return", tx);

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function permit(_x9, _x10, _x11, _x12, _x13, _x14, _x15) {
        return _permit.apply(this, arguments);
      }

      return permit;
    }() // Allow spender to withdraw from calling account up to value amount
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md

  }, {
    key: "approve",
    value: function () {
      var _approve = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(spender, value) {
        var privateKey,
            contractMethod,
            tx,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                privateKey = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : null;
                contractMethod = this.AudiusTokenContract.methods.approve(spender, value);

                if (!(privateKey === null)) {
                  _context8.next = 8;
                  break;
                }

                _context8.next = 5;
                return this.ethWeb3Manager.sendTransaction(contractMethod);

              case 5:
                tx = _context8.sent;
                _context8.next = 11;
                break;

              case 8:
                _context8.next = 10;
                return this.ethWeb3Manager.sendTransaction(contractMethod, this.contractAddress, privateKey);

              case 10:
                tx = _context8.sent;

              case 11:
                return _context8.abrupt("return", {
                  txReceipt: tx
                });

              case 12:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function approve(_x16, _x17) {
        return _approve.apply(this, arguments);
      }

      return approve;
    }()
  }, {
    key: "approveProxyTokens",
    value: function () {
      var _approveProxyTokens = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(owner, spender, value, relayer) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                method = this.AudiusTokenContract.methods.approve(spender, value);
                _context9.next = 3;
                return this.ethWeb3Manager.relayTransaction(method, this.contractAddress, owner, relayer,
                /* retries */
                0);

              case 3:
                tx = _context9.sent;
                return _context9.abrupt("return", {
                  txReceipt: tx
                });

              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function approveProxyTokens(_x18, _x19, _x20, _x21) {
        return _approveProxyTokens.apply(this, arguments);
      }

      return approveProxyTokens;
    }()
  }]);

  return AudiusTokenClient;
}();

var RegistryClient = /*#__PURE__*/function () {
  function RegistryClient(web3Manager, contractABI, contractAddress) {
    _classCallCheck(this, RegistryClient);

    _defineProperty$1(this, "web3Manager", void 0);

    _defineProperty$1(this, "contractABI", void 0);

    _defineProperty$1(this, "contractAddress", void 0);

    _defineProperty$1(this, "web3", void 0);

    _defineProperty$1(this, "Registry", void 0);

    this.web3Manager = web3Manager;
    this.contractABI = contractABI;
    this.contractAddress = contractAddress;
    this.web3 = this.web3Manager.getWeb3();
    this.Registry = new this.web3.eth.Contract(contractABI, contractAddress);
  }

  _createClass(RegistryClient, [{
    key: "getContract",
    value: function () {
      var _getContract = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(contractRegistryKey) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                Utils.checkStrLen(contractRegistryKey, 32);
                return _context.abrupt("return", this.Registry.methods.getContract(Utils.utf8ToHex(contractRegistryKey)).call());

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getContract(_x) {
        return _getContract.apply(this, arguments);
      }

      return getContract;
    }()
  }]);

  return RegistryClient;
}();

var DECISION_TREE_STATE;

(function (DECISION_TREE_STATE) {
  DECISION_TREE_STATE["CHECK_SHORT_CIRCUIT"] = "Check Short Circuit";
  DECISION_TREE_STATE["GET_ALL_SERVICES"] = "Get All Services";
  DECISION_TREE_STATE["FILTER_TO_WHITELIST"] = "Filter To Whitelist";
  DECISION_TREE_STATE["FILTER_FROM_BLACKLIST"] = "Filter From Blacklist";
  DECISION_TREE_STATE["FILTER_OUT_KNOWN_UNHEALTHY"] = "Filter Out Known Unhealthy";
  DECISION_TREE_STATE["GET_SELECTION_ROUND"] = "Get Selection Round";
  DECISION_TREE_STATE["NO_SERVICES_LEFT_TO_TRY"] = "No Services Left To Try";
  DECISION_TREE_STATE["SELECTED_FROM_BACKUP"] = "Selected From Backup";
  DECISION_TREE_STATE["FAILED_AND_RESETTING"] = "Failed Everything -- Resetting";
  DECISION_TREE_STATE["ROUND_FAILED_RETRY"] = "Round Failed Retry";
  DECISION_TREE_STATE["MADE_A_SELECTION"] = "Made A Selection";
  DECISION_TREE_STATE["RACED_AND_FOUND_BEST"] = "Raced And Found Best";
})(DECISION_TREE_STATE || (DECISION_TREE_STATE = {}));

function isVerbose(service) {
  return typeof service !== 'string';
}
/**
 * A class that assists with autoselecting services.
 * `ServiceSelection` is intended to be overridden with further
 * business logic that a particular sevice might preference.
 *
 * The general use case is as follows:
 *
 * ```
 *
 * const selector = new ServiceSelection({
 *   getServices: ethContracts.getDiscoveryProviders()
 * })
 *
 * const service = await selector.select()
 *
 * ```
 *
 * This class operates by taking a list of services and
 * round-robin makes requests at them until a suitable one is found.
 *
 * Two types of "bad" services are defined below:
 *  - Unhealthy: this service is bad and should not be used
 *  - Backup: this service is bad, but if we can't find anything better, maybe use it
 *
 * Classes that extend `ServiceSelection` can choose to implement custom logic on top
 * of them and is generally how this class is intended to be used.
 */


var ServiceSelection = /*#__PURE__*/function () {
  function ServiceSelection(_ref) {
    var blacklist = _ref.blacklist,
        whitelist = _ref.whitelist,
        getServices = _ref.getServices,
        _ref$maxConcurrentReq = _ref.maxConcurrentRequests,
        maxConcurrentRequests = _ref$maxConcurrentReq === void 0 ? 6 : _ref$maxConcurrentReq,
        _ref$requestTimeout = _ref.requestTimeout,
        requestTimeout = _ref$requestTimeout === void 0 ? 30 * 1000 : _ref$requestTimeout,
        _ref$unhealthyTTL = _ref.unhealthyTTL,
        unhealthyTTL = _ref$unhealthyTTL === void 0 ? 60 * 60 * 1000 : _ref$unhealthyTTL,
        _ref$backupsTTL = _ref.backupsTTL,
        backupsTTL = _ref$backupsTTL === void 0 ? 2 * 60 * 1000 : _ref$backupsTTL;

    _classCallCheck(this, ServiceSelection);

    _defineProperty$1(this, "blacklist", void 0);

    _defineProperty$1(this, "whitelist", void 0);

    _defineProperty$1(this, "getServices", void 0);

    _defineProperty$1(this, "maxConcurrentRequests", void 0);

    _defineProperty$1(this, "requestTimeout", void 0);

    _defineProperty$1(this, "unhealthyTTL", void 0);

    _defineProperty$1(this, "backupsTTL", void 0);

    _defineProperty$1(this, "unhealthy", void 0);

    _defineProperty$1(this, "backups", void 0);

    _defineProperty$1(this, "totalAttempts", void 0);

    _defineProperty$1(this, "decisionTree", void 0);

    _defineProperty$1(this, "unhealthyCleanupTimeout", null);

    _defineProperty$1(this, "backupCleanupTimeout", null);

    // For Creator Node selection
    this.blacklist = blacklist;
    this.whitelist = whitelist;
    this.getServices = getServices;
    this.maxConcurrentRequests = maxConcurrentRequests;
    this.requestTimeout = requestTimeout;
    this.unhealthyTTL = unhealthyTTL;
    this.backupsTTL = backupsTTL; // Truly "unhealthy" services. Should not ever be picked.

    this.unhealthy = new Set([]); // Selectable services but not optimal. Will be picked as a last resort.

    this.backups = {}; // Total number of services attempted

    this.totalAttempts = 0; // The decision tree path that was taken. Reset on each new selection.

    this.decisionTree = [];
  }
  /**
   * Selects a service
   * @param reset if reset is true, clear the decision tree
   */
  // we need any type here to allow sub-classes to more strictly type return type


  _createClass(ServiceSelection, [{
    key: "select",
    value: function () {
      var _select = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this = this;

        var reset,
            shortcircuit,
            services,
            filteredServices,
            round,
            backup,
            _yield$this$race,
            best,
            errored,
            _args = arguments;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                reset = _args.length > 0 && _args[0] !== undefined ? _args[0] : true;

                if (reset) {
                  this.decisionTree = [];
                } // If a short circuit is provided, take it. Don't check it, just use it.


                _context.next = 4;
                return this.shortcircuit();

              case 4:
                shortcircuit = _context.sent;
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.CHECK_SHORT_CIRCUIT,
                  val: shortcircuit
                }); // If there is a shortcircuit defined and we have not blacklisted it, pick it

                if (!(shortcircuit && (!this.blacklist || !this.blacklist.has(shortcircuit)))) {
                  _context.next = 8;
                  break;
                }

                return _context.abrupt("return", shortcircuit);

              case 8:
                _context.next = 10;
                return this.getServices();

              case 10:
                services = _context.sent;
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.GET_ALL_SERVICES,
                  val: services
                }); // If a whitelist is provided, filter down to it

                if (this.whitelist) {
                  services = this.filterToWhitelist(services);
                  this.decisionTree.push({
                    stage: DECISION_TREE_STATE.FILTER_TO_WHITELIST,
                    val: services
                  });
                } // if a blacklist is provided, filter out services in the list


                if (this.blacklist) {
                  services = this.filterFromBlacklist(services);
                  this.decisionTree.push({
                    stage: DECISION_TREE_STATE.FILTER_FROM_BLACKLIST,
                    val: services
                  });
                } // Filter out anything we know is already unhealthy


                filteredServices = this.filterOutKnownUnhealthy(services);
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.FILTER_OUT_KNOWN_UNHEALTHY,
                  val: filteredServices
                }); // Randomly sample a "round" to test

                round = this.getSelectionRound(filteredServices);
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.GET_SELECTION_ROUND,
                  val: round
                });
                this.totalAttempts += round.length; // If there are no services left to try, either pick a backup or return null

                if (!(filteredServices.length === 0)) {
                  _context.next = 33;
                  break;
                }

                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.NO_SERVICES_LEFT_TO_TRY
                });

                if (!(this.getBackupsSize() > 0)) {
                  _context.next = 29;
                  break;
                }

                _context.next = 24;
                return this.selectFromBackups();

              case 24:
                backup = _context.sent;
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.SELECTED_FROM_BACKUP,
                  val: backup
                });
                return _context.abrupt("return", backup);

              case 29:
                // Nothing could be found that was healthy.
                // Reset everything we know so that we might try again.
                this.unhealthy = new Set([]);
                this.backups = {};
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.FAILED_AND_RESETTING
                });
                return _context.abrupt("return", null);

              case 33:
                _context.next = 35;
                return this.race(round);

              case 35:
                _yield$this$race = _context.sent;
                best = _yield$this$race.best;
                errored = _yield$this$race.errored;
                // Mark all the errored ones as unhealthy
                errored.forEach(function (e) {
                  if (e) {
                    _this.addUnhealthy(e);
                  }
                }); // Trigger a cleanup event for all of the unhealthy and backup services,
                // so they can get retried in the future

                this.triggerCleanup(); // Recursively try this selection function if we didn't find something

                if (best) {
                  _context.next = 45;
                  break;
                }

                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.ROUND_FAILED_RETRY
                });
                _context.next = 44;
                return this.select(
                /* reset */
                false);

              case 44:
                return _context.abrupt("return", _context.sent);

              case 45:
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.MADE_A_SELECTION,
                  val: best
                }); // If we made it this far, we found the best service! (of the rounds we tried)

                return _context.abrupt("return", best);

              case 47:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function select() {
        return _select.apply(this, arguments);
      }

      return select;
    }()
    /**
     * Finds all selectable services (respecting whitelist, health checks & timeouts).
     * Note: this method is potentially slow.
     * If you need just a single service, prefer calling `.select()`
     * @param {boolean} verbose whether or not to return full services metadata
     * @param {Set} whitelist a whitelist to override the set of endpoints
     */

  }, {
    key: "findAll",
    value: function () {
      var _findAll = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _this2 = this;

        var _ref2,
            _ref2$verbose,
            verbose,
            _ref2$whitelist,
            whitelist,
            services,
            urlMap,
            results,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref2 = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, _ref2$verbose = _ref2.verbose, verbose = _ref2$verbose === void 0 ? false : _ref2$verbose, _ref2$whitelist = _ref2.whitelist, whitelist = _ref2$whitelist === void 0 ? this.whitelist : _ref2$whitelist;
                _context2.next = 3;
                return this.getServices({
                  verbose: verbose
                });

              case 3:
                services = _context2.sent;

                // If a whitelist is provided, filter down to it
                if (whitelist) {
                  services = services.filter(function (service) {
                    return whitelist.has(isVerbose(service) ? service.endpoint : service);
                  });
                } // Key the services by their health check endpoint


                urlMap = services.reduce(function (urlMap, service) {
                  urlMap[ServiceSelection.getHealthCheckEndpoint(isVerbose(service) ? service.endpoint : service)] = service;
                  return urlMap;
                }, {});
                _context2.prev = 6;
                _context2.next = 9;
                return allRequests({
                  urlMap: urlMap,
                  timeout: this.requestTimeout,
                  validationCheck: function validationCheck(resp) {
                    return _this2.isHealthy(resp, urlMap);
                  }
                });

              case 9:
                results = _context2.sent;
                return _context2.abrupt("return", results);

              case 13:
                _context2.prev = 13;
                _context2.t0 = _context2["catch"](6);
                console.error(_context2.t0);
                return _context2.abrupt("return", []);

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 13]]);
      }));

      function findAll() {
        return _findAll.apply(this, arguments);
      }

      return findAll;
    }()
    /** Triggers a clean up of unhealthy and backup services so they can be retried later */

  }, {
    key: "triggerCleanup",
    value: function triggerCleanup() {
      var _this3 = this;

      if (this.unhealthyCleanupTimeout) {
        clearTimeout(this.unhealthyCleanupTimeout);
      }

      if (this.backupCleanupTimeout) {
        clearTimeout(this.backupCleanupTimeout);
      }

      this.unhealthyCleanupTimeout = setTimeout(function () {
        _this3.clearUnhealthy();
      }, this.unhealthyTTL);
      this.backupCleanupTimeout = setTimeout(function () {
        _this3.clearBackups();
      }, this.backupsTTL);
    }
  }, {
    key: "clearUnhealthy",
    value: function clearUnhealthy() {
      this.unhealthy = new Set([]);
    }
  }, {
    key: "clearBackups",
    value: function clearBackups() {
      this.backups = {};
    }
    /** A short-circuit. If overriden, can be used to skip selection (which could be slow) */

  }, {
    key: "shortcircuit",
    value: function () {
      var _shortcircuit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", null);

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function shortcircuit() {
        return _shortcircuit.apply(this, arguments);
      }

      return shortcircuit;
    }()
    /**
     * Filter out services that are in the blacklist
     * @param services endpoints
     */

  }, {
    key: "filterFromBlacklist",
    value: function filterFromBlacklist(services) {
      var _this4 = this;

      return services.filter(function (s) {
        var _this4$blacklist;

        return !((_this4$blacklist = _this4.blacklist) !== null && _this4$blacklist !== void 0 && _this4$blacklist.has(s));
      });
    }
    /** Filter down services to those in the whitelist */

  }, {
    key: "filterToWhitelist",
    value: function filterToWhitelist(services) {
      var _this5 = this;

      return services.filter(function (s) {
        var _this5$whitelist;

        return (_this5$whitelist = _this5.whitelist) === null || _this5$whitelist === void 0 ? void 0 : _this5$whitelist.has(s);
      });
    }
    /** Filter out known unhealthy services from the provided */

  }, {
    key: "filterOutKnownUnhealthy",
    value: function filterOutKnownUnhealthy(services) {
      var _this6 = this;

      return services.filter(function (s) {
        return !_this6.unhealthy.has(s);
      });
    }
    /** Given a list of services, samples maxConcurrentRequests from them */

  }, {
    key: "getSelectionRound",
    value: function getSelectionRound(services) {
      return lodash.sampleSize(services, this.maxConcurrentRequests);
    }
    /** Gets the total number of attempts we've made this instantiation */

  }, {
    key: "getTotalAttempts",
    value: function getTotalAttempts() {
      return this.totalAttempts;
    }
    /** Where does the health check for this type of service live */

  }, {
    key: "isHealthy",
    value:
    /**
     * What the criteria is for a healthy service
     * @param response axios response
     * @param {{ [key: string]: string}} urlMap health check urls mapped to their cannonical url
     * e.g. https://discoveryprovider.audius.co/health_check => https://discoveryprovider.audius.co
     */
    function isHealthy(response, _urlMap) {
      return response.status === 200;
    }
    /** Races requests against each other with provided timeouts and health checks */

  }, {
    key: "race",
    value: function () {
      var _race = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(services) {
        var _this7 = this;

        var serviceMap, best, _yield$raceRequests, errored;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                // Key the services by their health check endpoint
                serviceMap = services.reduce(function (acc, s) {
                  acc[ServiceSelection.getHealthCheckEndpoint(s)] = s;
                  return acc;
                }, {});
                best = null;
                _context4.prev = 2;
                _context4.next = 5;
                return raceRequests(Object.keys(serviceMap), function (url) {
                  best = serviceMap[url];
                }, {},
                /* timeout */
                this.requestTimeout,
                /* timeBetweenRequests */
                0,
                /* validationCheck */
                function (resp) {
                  return _this7.isHealthy(resp, serviceMap);
                });

              case 5:
                _yield$raceRequests = _context4.sent;
                errored = _yield$raceRequests.errored;
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.RACED_AND_FOUND_BEST,
                  val: best
                });
                return _context4.abrupt("return", {
                  best: best,
                  errored: errored.map(function (e) {
                    var _e$config$url;

                    return serviceMap[(_e$config$url = e.config.url) !== null && _e$config$url !== void 0 ? _e$config$url : ''];
                  })
                });

              case 11:
                _context4.prev = 11;
                _context4.t0 = _context4["catch"](2);
                return _context4.abrupt("return", {
                  best: null,
                  errored: []
                });

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[2, 11]]);
      }));

      function race(_x) {
        return _race.apply(this, arguments);
      }

      return race;
    }()
    /** Adds a service to the unhealthy set */

  }, {
    key: "addUnhealthy",
    value: function addUnhealthy(service) {
      this.unhealthy.add(service);
    }
    /** Gets unhealthy set size */

  }, {
    key: "getUnhealthySize",
    value: function getUnhealthySize() {
      return this.unhealthy.size;
    }
    /**
     * Removes from unhealthy set
     * @param key service endpoint
     */

  }, {
    key: "removeFromUnhealthy",
    value: function removeFromUnhealthy(key) {
      if (this.unhealthy.has(key)) this.unhealthy["delete"](key);
    }
    /**
     * Adds a service to the list of backups
     * @param service the service to add
     * @param response the services response. This can be used to weigh various
     * backups against eachother
     */

  }, {
    key: "addBackup",
    value: function addBackup(service, response) {
      this.backups[service] = response;
    }
    /**
     * Controls how a backup is picked. Overriding methods may choose to use the backup's response.
     * e.g. pick a backup that's the fewest versions behind
     */

  }, {
    key: "selectFromBackups",
    value: function () {
      var _selectFromBackups = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", Object.keys(this.backups)[0]);

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function selectFromBackups() {
        return _selectFromBackups.apply(this, arguments);
      }

      return selectFromBackups;
    }()
    /**
     * Removes from backups
     * @param key service endpoint
     */

  }, {
    key: "removeFromBackups",
    value: function removeFromBackups(key) {
      if (Object.prototype.hasOwnProperty.call(this.backups, key)) // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete this.backups[key];
    }
    /**
     * Returns the size of backups
     */

  }, {
    key: "getBackupsSize",
    value: function getBackupsSize() {
      return Object.keys(this.backups).length;
    }
  }], [{
    key: "getHealthCheckEndpoint",
    value: function getHealthCheckEndpoint(service) {
      return "".concat(service, "/health_check");
    }
  }]);

  return ServiceSelection;
}();

/**
 * This class provides the logic to select a healthy gateway
 */

var ProviderSelection = /*#__PURE__*/function (_ServiceSelection) {
  _inherits(ProviderSelection, _ServiceSelection);

  var _super = _createSuper(ProviderSelection);

  function ProviderSelection() {
    var _this;

    var services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, ProviderSelection);

    _this = _super.call(this, {
      whitelist: new Set(),
      getServices: function () {
        var _getServices = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", _this.services);

                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function getServices() {
          return _getServices.apply(this, arguments);
        }

        return getServices;
      }()
    });

    _defineProperty$1(_assertThisInitialized(_this), "services", void 0);

    _this.services = services;
    return _this;
  }
  /**
   * Filters out previously tried providers, and then initializes the client
   * (ContractClient, RegistryClient) with a healthy POA provider.
   *
   * @param client object used for making transaction calls
   */


  _createClass(ProviderSelection, [{
    key: "select",
    value: function () {
      var _select = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(client) {
        var web3Manager, filteredServices, web3;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                web3Manager = client.web3Manager;
                _context2.t0 = this;
                _context2.next = 4;
                return this.getServices();

              case 4:
                _context2.t1 = _context2.sent;
                filteredServices = _context2.t0.filterOutKnownUnhealthy.call(_context2.t0, _context2.t1);
                web3 = new require$$0__default["default"](web3Manager.provider(filteredServices[0], 10000));
                web3Manager.setWeb3(web3);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function select(_x) {
        return _select.apply(this, arguments);
      }

      return select;
    }()
  }, {
    key: "getServicesSize",
    value: function getServicesSize() {
      return this.services.length;
    }
  }]);

  return ProviderSelection;
}(ServiceSelection);

var CONTRACT_INITIALIZING_INTERVAL = 100;
var CONTRACT_INITIALIZING_TIMEOUT = 10000;
var CONTRACT_INIT_MAX_ATTEMPTS = 5;
var METHOD_CALL_MAX_RETRIES = 5;
/*
 * Base class for instantiating contracts.
 * Performs a single init of the eth contract the first
 * time a method on the contract is invoked.
 */

var ContractClient = /*#__PURE__*/function () {
  function ContractClient(web3Manager, contractABI, contractRegistryKey, getRegistryAddress) {
    var _contractAddresses$, _contractAddresses$2;

    var logger = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : console;
    var contractAddress = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

    _classCallCheck(this, ContractClient);

    _defineProperty$1(this, "web3Manager", void 0);

    _defineProperty$1(this, "contractABI", void 0);

    _defineProperty$1(this, "contractRegistryKey", void 0);

    _defineProperty$1(this, "getRegistryAddress", void 0);

    _defineProperty$1(this, "_contractAddress", void 0);

    _defineProperty$1(this, "_nethermindContractAddress", void 0);

    _defineProperty$1(this, "_contract", void 0);

    _defineProperty$1(this, "_isInitialized", void 0);

    _defineProperty$1(this, "_isInitializing", void 0);

    _defineProperty$1(this, "_initAttempts", void 0);

    _defineProperty$1(this, "providerSelector", void 0);

    _defineProperty$1(this, "logger", void 0);

    this.web3Manager = web3Manager;
    this.contractABI = contractABI;
    this.contractRegistryKey = contractRegistryKey;
    this.getRegistryAddress = getRegistryAddress;
    this.logger = logger; // Once initialized, contract address and contract are set up
    // contractAddress: <entity manager POA>, <entity manager nethermind>
    // this is backwards compatible so clients may pass in one address
    // or both POA and nethermind

    var contractAddresses = contractAddress ? contractAddress.split(',') : [];
    this._contractAddress = (_contractAddresses$ = contractAddresses[0]) !== null && _contractAddresses$ !== void 0 ? _contractAddresses$ : null;
    this._nethermindContractAddress = (_contractAddresses$2 = contractAddresses[1]) !== null && _contractAddresses$2 !== void 0 ? _contractAddresses$2 : null;
    this._contract = null; // Initialization setup

    this._isInitialized = false;
    this._isInitializing = false;
    this._initAttempts = 0; // Initializing this.providerSelector for POA provider fallback logic

    if (this.web3Manager instanceof Web3Manager && !this.web3Manager.web3Config.useExternalWeb3) {
      var providerEndpoints = this.web3Manager.web3Config.internalWeb3Config.web3ProviderEndpoints;
      this.providerSelector = new ProviderSelection(providerEndpoints);
    } else {
      this.providerSelector = null;
    }
  }
  /** Inits the contract if necessary */


  _createClass(ContractClient, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this = this;

        var interval, web3, selectNewEndpoint;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._isInitialized) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                if (!this._isInitializing) {
                  _context.next = 7;
                  break;
                }

                _context.next = 5;
                return new Promise(function (resolve, reject) {
                  interval = setInterval(function () {
                    if (_this._isInitialized) resolve();
                  }, CONTRACT_INITIALIZING_INTERVAL);
                  setTimeout(function () {
                    reject(new Error('[ContractClient:init()] Initialization timeout'));
                  }, CONTRACT_INITIALIZING_TIMEOUT);
                });

              case 5:
                clearInterval(interval);
                return _context.abrupt("return");

              case 7:
                this._isInitializing = true;
                _context.prev = 8;

                if (this._contractAddress) {
                  _context.next = 16;
                  break;
                }

                _context.next = 12;
                return this.getRegistryAddress(this.contractRegistryKey);

              case 12:
                this._contractAddress = _context.sent;

                if (!(this._contractAddress === '0x0000000000000000000000000000000000000000')) {
                  _context.next = 16;
                  break;
                }

                this._isInitializing = false;
                throw new Error("Failed retrieve address for ".concat(this.contractRegistryKey));

              case 16:
                web3 = this.web3Manager.getWeb3();
                this._contract = new web3.eth.Contract(this.contractABI, this._contractAddress);
                this._isInitializing = false;
                this._isInitialized = !!this._contractAddress;
                _context.next = 32;
                break;

              case 22:
                _context.prev = 22;
                _context.t0 = _context["catch"](8);

                if (!(++this._initAttempts >= CONTRACT_INIT_MAX_ATTEMPTS)) {
                  _context.next = 27;
                  break;
                }

                this.logger.error("Failed to initialize ".concat(this.contractRegistryKey, ". Max attempts exceeded."));
                return _context.abrupt("return");

              case 27:
                selectNewEndpoint = !!this.providerSelector;
                this.logger.error("Failed to initialize ".concat(this.contractRegistryKey, " on attempt #").concat(this._initAttempts, ". Retrying with selectNewEndpoint=").concat(selectNewEndpoint));
                this._isInitializing = false;
                _context.next = 32;
                return this.retryInit(selectNewEndpoint);

              case 32:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[8, 22]]);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "retryInit",
    value: function () {
      var _retryInit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var selectNewEndpoint,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                selectNewEndpoint = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : true;
                _context2.prev = 1;

                if (!selectNewEndpoint) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 5;
                return this.selectNewEndpoint();

              case 5:
                _context2.next = 7;
                return this.init();

              case 7:
                _context2.next = 12;
                break;

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2["catch"](1);
                this.logger.error(_context2.t0 === null || _context2.t0 === void 0 ? void 0 : _context2.t0.message);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 9]]);
      }));

      function retryInit() {
        return _retryInit.apply(this, arguments);
      }

      return retryInit;
    }()
    /**
     * Adds current provider into unhealthy set and selects the next healthy provider
     */

  }, {
    key: "selectNewEndpoint",
    value: function () {
      var _selectNewEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var _this$providerSelecto, _this$providerSelecto2, _this$providerSelecto3, _this$providerSelecto6;

        var currentProviderUrl, _this$providerSelecto4, _this$providerSelecto5;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                currentProviderUrl = this.web3Manager.getWeb3().currentProvider.host;
                (_this$providerSelecto = this.providerSelector) === null || _this$providerSelecto === void 0 ? void 0 : _this$providerSelecto.addUnhealthy(currentProviderUrl);

                if (((_this$providerSelecto2 = this.providerSelector) === null || _this$providerSelecto2 === void 0 ? void 0 : _this$providerSelecto2.getUnhealthySize()) === ((_this$providerSelecto3 = this.providerSelector) === null || _this$providerSelecto3 === void 0 ? void 0 : _this$providerSelecto3.getServicesSize())) {
                  this.logger.warn('No healthy providers available - resetting ProviderSelection and selecting.');
                  (_this$providerSelecto4 = this.providerSelector) === null || _this$providerSelecto4 === void 0 ? void 0 : _this$providerSelecto4.clearUnhealthy();
                  (_this$providerSelecto5 = this.providerSelector) === null || _this$providerSelecto5 === void 0 ? void 0 : _this$providerSelecto5.clearBackups();
                } // Reset _isInitializing to false to retry init logic and avoid the _isInitialzing check


                this._isInitializing = false;
                _context3.next = 6;
                return (_this$providerSelecto6 = this.providerSelector) === null || _this$providerSelecto6 === void 0 ? void 0 : _this$providerSelecto6.select(this);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function selectNewEndpoint() {
        return _selectNewEndpoint.apply(this, arguments);
      }

      return selectNewEndpoint;
    }()
    /** Gets the contract address and ensures that the contract has initted. */

  }, {
    key: "getAddress",
    value: function () {
      var _getAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.init();

              case 2:
                return _context4.abrupt("return", this._contractAddress);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAddress() {
        return _getAddress.apply(this, arguments);
      }

      return getAddress;
    }()
  }, {
    key: "getNethermindAddress",
    value: function () {
      var _getNethermindAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.init();

              case 2:
                return _context5.abrupt("return", this._nethermindContractAddress);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getNethermindAddress() {
        return _getNethermindAddress.apply(this, arguments);
      }

      return getNethermindAddress;
    }()
    /**
     * Gets a contract method and ensures that the contract has initted
     * The contract can then be invoked with .call() or be passed to a sendTransaction.
     * @param methodName the name of the contract method
     */

  }, {
    key: "getMethod",
    value: function () {
      var _getMethod = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(methodName) {
        var _this$_contract$metho,
            _this2 = this;

        var _this$_contract,
            _len,
            args,
            _key,
            method,
            call,
            _args8 = arguments;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.init();

              case 2:
                if (!(!this._contract || !(methodName in this._contract.methods))) {
                  _context8.next = 4;
                  break;
                }

                throw new Error("Contract method ".concat(methodName, " not found in ").concat(Object.keys((_this$_contract = this._contract) === null || _this$_contract === void 0 ? void 0 : _this$_contract.methods)));

              case 4:
                for (_len = _args8.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = _args8[_key];
                }

                _context8.next = 7;
                return (_this$_contract$metho = this._contract.methods)[methodName].apply(_this$_contract$metho, args);

              case 7:
                method = _context8.sent;
                // Override method.call (chain reads) with built in retry logic
                call = method.call;
                method.call = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
                  var _len2,
                      args,
                      _key2,
                      _args7 = arguments;

                  return regeneratorRuntime.wrap(function _callee7$(_context7) {
                    while (1) {
                      switch (_context7.prev = _context7.next) {
                        case 0:
                          for (_len2 = _args7.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                            args[_key2] = _args7[_key2];
                          }

                          _context7.next = 3;
                          return retry__default["default"]( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
                            return regeneratorRuntime.wrap(function _callee6$(_context6) {
                              while (1) {
                                switch (_context6.prev = _context6.next) {
                                  case 0:
                                    return _context6.abrupt("return", call.apply(void 0, args));

                                  case 1:
                                  case "end":
                                    return _context6.stop();
                                }
                              }
                            }, _callee6);
                          })), {
                            // Retry function 5x by default
                            // 1st retry delay = 500ms, 2nd = 1500ms, 3rd...nth retry = 4000 ms (capped)
                            minTimeout: 500,
                            maxTimeout: 4000,
                            factor: 3,
                            retries: METHOD_CALL_MAX_RETRIES,
                            onRetry: function onRetry(err) {
                              if (err) {
                                // eslint-disable-next-line @typescript-eslint/no-base-to-string
                                _this2.logger.warn("Retry error for ".concat(methodName, " : ").concat(err));
                              }
                            }
                          });

                        case 3:
                          return _context7.abrupt("return", _context7.sent);

                        case 4:
                        case "end":
                          return _context7.stop();
                      }
                    }
                  }, _callee7);
                }));
                return _context8.abrupt("return", method);

              case 11:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getMethod(_x) {
        return _getMethod.apply(this, arguments);
      }

      return getMethod;
    }()
  }, {
    key: "getEthNetId",
    value: function () {
      var _getEthNetId = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var netId;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.init();

              case 2:
                _context9.next = 4;
                return this.web3Manager.getWeb3().eth.net.getId();

              case 4:
                netId = _context9.sent;
                return _context9.abrupt("return", netId);

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getEthNetId() {
        return _getEthNetId.apply(this, arguments);
      }

      return getEthNetId;
    }()
  }, {
    key: "getContract",
    value: function () {
      var _getContract = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.init();

              case 2:
                return _context10.abrupt("return", this._contract);

              case 3:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getContract() {
        return _getContract.apply(this, arguments);
      }

      return getContract;
    }()
  }]);

  return ContractClient;
}();

/**
 * Transform a method name and its argument types into a string-composed
 * signature, e.g. someMethod(bytes32, int32)
 * @param methodName
 * @param argumentTypes
 */

var createMethodSignature = function createMethodSignature(methodName, argumentTypes) {
  return "".concat(methodName, "(").concat(argumentTypes.join(','), ")");
};
/**
 * Represent an instance of a proposal vote.
 */


Object.freeze({
  no: 1,
  yes: 2
});
var GovernanceClient = /*#__PURE__*/function (_ContractClient) {
  _inherits(GovernanceClient, _ContractClient);

  var _super = _createSuper(GovernanceClient);

  function GovernanceClient(ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, audiusTokenClient, stakingProxyClient) {
    var _this;

    var logger = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : console;
    var isDebug = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;

    _classCallCheck(this, GovernanceClient);

    _this = _super.call(this, ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, logger);

    _defineProperty$1(_assertThisInitialized(_this), "audiusTokenClient", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "stakingProxyClient", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "isDebug", void 0);

    _this.audiusTokenClient = audiusTokenClient;
    _this.stakingProxyClient = stakingProxyClient;
    _this.isDebug = isDebug;
    _this.formatVote = _this.formatVote.bind(_assertThisInitialized(_this));
    _this.formatProposalEvent = _this.formatProposalEvent.bind(_assertThisInitialized(_this));
    _this.abiEncode = _this.abiEncode.bind(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Gets the function signature and call data for a contract method.
   * The signature and call data are passed to other contracts (like governance)
   * as arguments.
   * @param methodName
   * @param contractMethod
   */


  _createClass(GovernanceClient, [{
    key: "getSignatureAndCallData",
    value: function getSignatureAndCallData(methodName, contractMethod) {
      var argumentTypes = contractMethod._method.inputs.map(function (i) {
        return i.type;
      });

      var argumentValues = contractMethod.arguments;
      var signature = createMethodSignature(methodName, argumentTypes);
      var callData = this.abiEncode(argumentTypes, argumentValues);
      return {
        signature: signature,
        callData: callData
      };
    }
  }, {
    key: "guardianExecuteTransaction",
    value: function () {
      var _guardianExecuteTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(contractRegistryKey, functionSignature, callData) {
        var callValue0, method;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // 0 eth valued transaction. We don't anticipate needed to attach
                // value to this txn, so default to 0.
                callValue0 = this.toBN('0');
                _context.next = 3;
                return this.getMethod('guardianExecuteTransaction', contractRegistryKey, callValue0, functionSignature, callData);

              case 3:
                method = _context.sent;
                return _context.abrupt("return", method);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function guardianExecuteTransaction(_x, _x2, _x3) {
        return _guardianExecuteTransaction.apply(this, arguments);
      }

      return guardianExecuteTransaction;
    }()
  }, {
    key: "getVotingPeriod",
    value: function () {
      var _getVotingPeriod = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var method, period;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getMethod('getVotingPeriod');

              case 2:
                method = _context2.sent;
                _context2.next = 5;
                return method.call();

              case 5:
                period = _context2.sent;
                return _context2.abrupt("return", parseInt(period));

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getVotingPeriod() {
        return _getVotingPeriod.apply(this, arguments);
      }

      return getVotingPeriod;
    }()
  }, {
    key: "setVotingPeriod",
    value: function () {
      var _setVotingPeriod = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(period) {
        var methodName, contractMethod, _this$getSignatureAnd, signature, callData, contractRegistryKey, method;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                methodName = 'setVotingPeriod';
                _context3.next = 3;
                return this.getMethod(methodName, period);

              case 3:
                contractMethod = _context3.sent;
                _this$getSignatureAnd = this.getSignatureAndCallData(methodName, contractMethod), signature = _this$getSignatureAnd.signature, callData = _this$getSignatureAnd.callData;
                contractRegistryKey = this.web3Manager.getWeb3().utils.utf8ToHex(this.contractRegistryKey);
                _context3.next = 8;
                return this.guardianExecuteTransaction(contractRegistryKey, signature, callData);

              case 8:
                method = _context3.sent;
                _context3.next = 11;
                return this.web3Manager.sendTransaction(method);

              case 11:
                return _context3.abrupt("return", _context3.sent);

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function setVotingPeriod(_x4) {
        return _setVotingPeriod.apply(this, arguments);
      }

      return setVotingPeriod;
    }()
  }, {
    key: "getVotingQuorumPercent",
    value: function () {
      var _getVotingQuorumPercent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var method, percent;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getMethod('getVotingQuorumPercent');

              case 2:
                method = _context4.sent;
                _context4.next = 5;
                return method.call();

              case 5:
                percent = _context4.sent;
                return _context4.abrupt("return", parseInt(percent));

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getVotingQuorumPercent() {
        return _getVotingQuorumPercent.apply(this, arguments);
      }

      return getVotingQuorumPercent;
    }()
  }, {
    key: "getExecutionDelay",
    value: function () {
      var _getExecutionDelay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var method, delay;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getMethod('getExecutionDelay');

              case 2:
                method = _context5.sent;
                _context5.next = 5;
                return method.call();

              case 5:
                delay = _context5.sent;
                return _context5.abrupt("return", parseInt(delay));

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getExecutionDelay() {
        return _getExecutionDelay.apply(this, arguments);
      }

      return getExecutionDelay;
    }()
  }, {
    key: "setExecutionDelay",
    value: function () {
      var _setExecutionDelay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(delay) {
        var methodName, contractMethod, _this$getSignatureAnd2, signature, callData, contractRegistryKey, method;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                methodName = 'setExecutionDelay';
                _context6.next = 3;
                return this.getMethod(methodName, delay);

              case 3:
                contractMethod = _context6.sent;
                _this$getSignatureAnd2 = this.getSignatureAndCallData(methodName, contractMethod), signature = _this$getSignatureAnd2.signature, callData = _this$getSignatureAnd2.callData;
                contractRegistryKey = this.web3Manager.getWeb3().utils.utf8ToHex(this.contractRegistryKey);
                _context6.next = 8;
                return this.guardianExecuteTransaction(contractRegistryKey, signature, callData);

              case 8:
                method = _context6.sent;
                _context6.next = 11;
                return this.web3Manager.sendTransaction(method);

              case 11:
                return _context6.abrupt("return", _context6.sent);

              case 12:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function setExecutionDelay(_x5) {
        return _setExecutionDelay.apply(this, arguments);
      }

      return setExecutionDelay;
    }()
  }, {
    key: "getProposalById",
    value: function () {
      var _getProposalById = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(id) {
        var method, proposal, formattedProposal;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getMethod('getProposalById', id);

              case 2:
                method = _context7.sent;
                _context7.next = 5;
                return method.call();

              case 5:
                proposal = _context7.sent;
                formattedProposal = this.formatProposal(proposal);
                return _context7.abrupt("return", formattedProposal);

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getProposalById(_x6) {
        return _getProposalById.apply(this, arguments);
      }

      return getProposalById;
    }()
  }, {
    key: "getProposalTargetContractHash",
    value: function () {
      var _getProposalTargetContractHash = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(id) {
        var method;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getMethod('getProposalTargetContractHash', id);

              case 2:
                method = _context8.sent;
                return _context8.abrupt("return", method.call());

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getProposalTargetContractHash(_x7) {
        return _getProposalTargetContractHash.apply(this, arguments);
      }

      return getProposalTargetContractHash;
    }()
  }, {
    key: "getProposals",
    value: function () {
      var _getProposals = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var queryStartBlock,
            contract,
            events,
            _args9 = arguments;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                queryStartBlock = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : 0;
                _context9.next = 3;
                return this.getContract();

              case 3:
                contract = _context9.sent;
                _context9.next = 6;
                return contract.getPastEvents('ProposalSubmitted', {
                  fromBlock: queryStartBlock
                });

              case 6:
                events = _context9.sent;
                return _context9.abrupt("return", events === null || events === void 0 ? void 0 : events.map(this.formatProposalEvent));

              case 8:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getProposals() {
        return _getProposals.apply(this, arguments);
      }

      return getProposals;
    }()
  }, {
    key: "getProposalsForAddresses",
    value: function () {
      var _getProposalsForAddresses = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(addresses) {
        var queryStartBlock,
            contract,
            events,
            _args10 = arguments;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                queryStartBlock = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : 0;
                _context10.next = 3;
                return this.getContract();

              case 3:
                contract = _context10.sent;
                _context10.next = 6;
                return contract.getPastEvents('ProposalSubmitted', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _proposer: addresses
                  }
                });

              case 6:
                events = _context10.sent;
                return _context10.abrupt("return", events.map(this.formatProposalEvent));

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getProposalsForAddresses(_x8) {
        return _getProposalsForAddresses.apply(this, arguments);
      }

      return getProposalsForAddresses;
    }()
  }, {
    key: "getProposalSubmission",
    value: function () {
      var _getProposalSubmission = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(proposalId) {
        var queryStartBlock,
            contract,
            events,
            _args11 = arguments;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                queryStartBlock = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : 0;
                _context11.next = 3;
                return this.getContract();

              case 3:
                contract = _context11.sent;
                _context11.next = 6;
                return contract.getPastEvents('ProposalSubmitted', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _proposalId: proposalId
                  }
                });

              case 6:
                events = _context11.sent;
                return _context11.abrupt("return", this.formatProposalEvent(events[0]));

              case 8:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getProposalSubmission(_x9) {
        return _getProposalSubmission.apply(this, arguments);
      }

      return getProposalSubmission;
    }()
  }, {
    key: "getInProgressProposals",
    value: function () {
      var _getInProgressProposals = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var method, ids;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getMethod('getInProgressProposals');

              case 2:
                method = _context12.sent;
                _context12.next = 5;
                return method.call();

              case 5:
                ids = _context12.sent;
                return _context12.abrupt("return", ids);

              case 7:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getInProgressProposals() {
        return _getInProgressProposals.apply(this, arguments);
      }

      return getInProgressProposals;
    }()
  }, {
    key: "submitProposal",
    value: function () {
      var _submitProposal = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref) {
        var _functionSignature$ma, _functionSignature$ma2, _functionSignature$ma3, _tx$events, _tx$events$ProposalSu, _tx$events$ProposalSu2;

        var targetContractRegistryKey, callValue, functionSignature, callData, name, description, argumentTypes, encodedCallData, method, tx, id;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                targetContractRegistryKey = _ref.targetContractRegistryKey, callValue = _ref.callValue, functionSignature = _ref.functionSignature, callData = _ref.callData, name = _ref.name, description = _ref.description;
                argumentTypes = (_functionSignature$ma = functionSignature.match( /*#__PURE__*/_wrapRegExp(/.*\((.*)\)/, {
                  args: 1
                }))) === null || _functionSignature$ma === void 0 ? void 0 : (_functionSignature$ma2 = _functionSignature$ma.groups) === null || _functionSignature$ma2 === void 0 ? void 0 : (_functionSignature$ma3 = _functionSignature$ma2['args']) === null || _functionSignature$ma3 === void 0 ? void 0 : _functionSignature$ma3.split(',');
                encodedCallData = this.abiEncode(argumentTypes, callData);
                _context13.next = 5;
                return this.getMethod('submitProposal', targetContractRegistryKey, callValue, functionSignature, encodedCallData, name, description);

              case 5:
                method = _context13.sent;
                _context13.next = 8;
                return this.web3Manager.sendTransaction(method);

              case 8:
                tx = _context13.sent;
                id = (_tx$events = tx.events) === null || _tx$events === void 0 ? void 0 : (_tx$events$ProposalSu = _tx$events['ProposalSubmitted']) === null || _tx$events$ProposalSu === void 0 ? void 0 : (_tx$events$ProposalSu2 = _tx$events$ProposalSu.returnValues) === null || _tx$events$ProposalSu2 === void 0 ? void 0 : _tx$events$ProposalSu2._proposalId;

                if (!id) {
                  _context13.next = 12;
                  break;
                }

                return _context13.abrupt("return", id);

              case 12:
                throw new Error('submitProposal: txn malformed');

              case 13:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function submitProposal(_x10) {
        return _submitProposal.apply(this, arguments);
      }

      return submitProposal;
    }()
  }, {
    key: "submitVote",
    value: function () {
      var _submitVote = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(_ref2) {
        var proposalId, vote, method;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                proposalId = _ref2.proposalId, vote = _ref2.vote;
                _context14.next = 3;
                return this.getMethod('submitVote', proposalId, vote);

              case 3:
                method = _context14.sent;
                _context14.next = 6;
                return this.web3Manager.sendTransaction(method);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function submitVote(_x11) {
        return _submitVote.apply(this, arguments);
      }

      return submitVote;
    }()
  }, {
    key: "updateVote",
    value: function () {
      var _updateVote = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(_ref3) {
        var proposalId, vote, method;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                proposalId = _ref3.proposalId, vote = _ref3.vote;
                _context15.next = 3;
                return this.getMethod('updateVote', proposalId, vote);

              case 3:
                method = _context15.sent;
                _context15.next = 6;
                return this.web3Manager.sendTransaction(method);

              case 6:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function updateVote(_x12) {
        return _updateVote.apply(this, arguments);
      }

      return updateVote;
    }()
  }, {
    key: "evaluateProposalOutcome",
    value: function () {
      var _evaluateProposalOutcome = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(proposalId) {
        var method, outcome;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.getMethod('evaluateProposalOutcome', proposalId);

              case 2:
                method = _context16.sent;
                _context16.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                outcome = _context16.sent;
                return _context16.abrupt("return", outcome);

              case 7:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function evaluateProposalOutcome(_x13) {
        return _evaluateProposalOutcome.apply(this, arguments);
      }

      return evaluateProposalOutcome;
    }()
  }, {
    key: "getProposalEvaluation",
    value: function () {
      var _getProposalEvaluation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(proposalId) {
        var queryStartBlock,
            contract,
            events,
            _args17 = arguments;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                queryStartBlock = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : 0;
                _context17.next = 3;
                return this.getContract();

              case 3:
                contract = _context17.sent;
                _context17.next = 6;
                return contract.getPastEvents('ProposalOutcomeEvaluated', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _proposalId: proposalId
                  }
                });

              case 6:
                events = _context17.sent;
                return _context17.abrupt("return", events);

              case 8:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getProposalEvaluation(_x14) {
        return _getProposalEvaluation.apply(this, arguments);
      }

      return getProposalEvaluation;
    }()
  }, {
    key: "getVotes",
    value: function () {
      var _getVotes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(_ref4) {
        var proposalId, _ref4$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                proposalId = _ref4.proposalId, _ref4$queryStartBlock = _ref4.queryStartBlock, queryStartBlock = _ref4$queryStartBlock === void 0 ? 0 : _ref4$queryStartBlock;
                _context18.next = 3;
                return this.getContract();

              case 3:
                contract = _context18.sent;
                _context18.next = 6;
                return contract.getPastEvents('ProposalVoteSubmitted', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _proposalId: proposalId
                  }
                });

              case 6:
                events = _context18.sent;
                return _context18.abrupt("return", events.map(this.formatVote));

              case 8:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getVotes(_x15) {
        return _getVotes.apply(this, arguments);
      }

      return getVotes;
    }()
  }, {
    key: "getVoteUpdates",
    value: function () {
      var _getVoteUpdates = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(_ref5) {
        var proposalId, _ref5$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                proposalId = _ref5.proposalId, _ref5$queryStartBlock = _ref5.queryStartBlock, queryStartBlock = _ref5$queryStartBlock === void 0 ? 0 : _ref5$queryStartBlock;
                _context19.next = 3;
                return this.getContract();

              case 3:
                contract = _context19.sent;
                _context19.next = 6;
                return contract.getPastEvents('ProposalVoteUpdated', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _proposalId: proposalId
                  }
                });

              case 6:
                events = _context19.sent;
                return _context19.abrupt("return", events.map(this.formatVote));

              case 8:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getVoteUpdates(_x16) {
        return _getVoteUpdates.apply(this, arguments);
      }

      return getVoteUpdates;
    }()
  }, {
    key: "getVoteSubmissionsByAddress",
    value: function () {
      var _getVoteSubmissionsByAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(_ref6) {
        var addresses, _ref6$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                addresses = _ref6.addresses, _ref6$queryStartBlock = _ref6.queryStartBlock, queryStartBlock = _ref6$queryStartBlock === void 0 ? 0 : _ref6$queryStartBlock;
                _context20.next = 3;
                return this.getContract();

              case 3:
                contract = _context20.sent;
                _context20.next = 6;
                return contract.getPastEvents('ProposalVoteSubmitted', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _voter: addresses
                  }
                });

              case 6:
                events = _context20.sent;
                return _context20.abrupt("return", events.map(this.formatVote));

              case 8:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getVoteSubmissionsByAddress(_x17) {
        return _getVoteSubmissionsByAddress.apply(this, arguments);
      }

      return getVoteSubmissionsByAddress;
    }()
  }, {
    key: "getVoteUpdatesByAddress",
    value: function () {
      var _getVoteUpdatesByAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(_ref7) {
        var addresses, _ref7$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                addresses = _ref7.addresses, _ref7$queryStartBlock = _ref7.queryStartBlock, queryStartBlock = _ref7$queryStartBlock === void 0 ? 0 : _ref7$queryStartBlock;
                _context21.next = 3;
                return this.getContract();

              case 3:
                contract = _context21.sent;
                _context21.next = 6;
                return contract.getPastEvents('ProposalVoteUpdated', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _voter: addresses
                  }
                });

              case 6:
                events = _context21.sent;
                return _context21.abrupt("return", events.map(this.formatVote));

              case 8:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getVoteUpdatesByAddress(_x18) {
        return _getVoteUpdatesByAddress.apply(this, arguments);
      }

      return getVoteUpdatesByAddress;
    }()
  }, {
    key: "getVoteByProposalAndVoter",
    value: function () {
      var _getVoteByProposalAndVoter = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(_ref8) {
        var proposalId, voterAddress, method, result;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                proposalId = _ref8.proposalId, voterAddress = _ref8.voterAddress;
                _context22.next = 3;
                return this.getMethod('getVoteInfoByProposalAndVoter', proposalId, voterAddress);

              case 3:
                method = _context22.sent;
                _context22.next = 6;
                return method.call();

              case 6:
                result = _context22.sent;
                return _context22.abrupt("return", parseInt(result.vote));

              case 8:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getVoteByProposalAndVoter(_x19) {
        return _getVoteByProposalAndVoter.apply(this, arguments);
      }

      return getVoteByProposalAndVoter;
    }() // Helpers

    /**
     * ABI encodes argument types and values together into one encoded string
     */

  }, {
    key: "abiEncode",
    value: function abiEncode(types, values) {
      return this.web3Manager.getWeb3().eth.abi.encodeParameters(types, values);
    }
  }, {
    key: "toBN",
    value: function toBN(val) {
      return this.web3Manager.getWeb3().utils.toBN(val);
    }
    /**
     * Prune off extraneous fields from proposal returned by txn
     */

  }, {
    key: "formatProposal",
    value: function formatProposal(proposal) {
      return {
        proposalId: parseInt(proposal.proposalId),
        proposer: proposal.proposer,
        submissionBlockNumber: parseInt(proposal.submissionBlockNumber),
        targetContractRegistryKey: proposal.targetContractRegistryKey,
        targetContractAddress: proposal.targetContractAddress,
        callValue: parseInt(proposal.callValue),
        functionSignature: proposal.functionSignature,
        callData: proposal.callData,
        outcome: parseInt(proposal.outcome),
        numVotes: parseInt(proposal.numVotes),
        voteMagnitudeYes: this.toBN(proposal.voteMagnitudeYes),
        voteMagnitudeNo: this.toBN(proposal.voteMagnitudeNo)
      };
    }
    /**
     * Formats a proposal event
     */

  }, {
    key: "formatProposalEvent",
    value: function formatProposalEvent(proposalEvent) {
      var event = proposalEvent.returnValues;
      return {
        proposalId: parseInt(event._proposalId),
        proposer: event._proposer,
        description: event._description,
        name: event._name,
        blockNumber: proposalEvent.blockNumber
      };
    }
    /**
     * Prune off extraneous fields from vote event
     */

  }, {
    key: "formatVote",
    value: function formatVote(voteEvent) {
      var event = voteEvent.returnValues;
      return {
        proposalId: parseInt(event._proposalId),
        voter: event._voter,
        vote: parseInt(event._vote),
        voterStake: this.toBN(event._voterStake),
        blockNumber: voteEvent.blockNumber
      };
    }
    /**
     *
     * @param {Number} proposalId id of the governance proposal
     * @returns {BN} amount of tokens in wei required to reach quorum
     */

  }, {
    key: "calculateQuorum",
    value: function () {
      var _calculateQuorum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(proposalId) {
        var _yield$this$getPropos, submissionBlockNumber, quoroumPercent, totalStakeAtProposal, quorumStakeDivMod, quorumStake;

        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.getProposalById(proposalId);

              case 2:
                _yield$this$getPropos = _context23.sent;
                submissionBlockNumber = _yield$this$getPropos.submissionBlockNumber;
                _context23.next = 6;
                return this.getVotingQuorumPercent();

              case 6:
                quoroumPercent = _context23.sent;
                _context23.next = 9;
                return this.stakingProxyClient.totalStakedAt(submissionBlockNumber);

              case 9:
                totalStakeAtProposal = _context23.sent;
                // quorum = (total staked at proposal * quorum percent) / 100
                // the divmod function returns an object with both the quotient (div) and the remainder (mod)
                // { div, mod }
                quorumStakeDivMod = totalStakeAtProposal.mul(Utils.toBN(quoroumPercent)) // @ts-expect-error divmod not in types for some reason
                .divmod(Utils.toBN(100));
                quorumStake = quorumStakeDivMod.div; // if there's a non-zero remainder, round up

                if (!quorumStakeDivMod.mod.isZero()) {
                  quorumStake = quorumStakeDivMod.div.add(Utils.toBN(1));
                }

                return _context23.abrupt("return", quorumStake);

              case 14:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function calculateQuorum(_x20) {
        return _calculateQuorum.apply(this, arguments);
      }

      return calculateQuorum;
    }()
  }]);

  return GovernanceClient;
}(ContractClient);

/**
 * Contract class that extends a ContractClient and provides an interface
 * to retrieve governed methods that cannot be executed directly.
 */

var GovernedContractClient = /*#__PURE__*/function (_ContractClient) {
  _inherits(GovernedContractClient, _ContractClient);

  var _super = _createSuper(GovernedContractClient);

  function GovernedContractClient(web3Manager, contractABI, contractRegistryKey, getRegistryAddress, governanceClient) {
    var _this;

    var logger = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : console;

    _classCallCheck(this, GovernedContractClient);

    _this = _super.call(this, web3Manager, contractABI, contractRegistryKey, getRegistryAddress, logger);

    _defineProperty$1(_assertThisInitialized(_this), "governanceClient", void 0);

    _this.governanceClient = governanceClient;
    return _this;
  }
  /**
   * Gets a governed version of a method and allows a single transaction
   * to be sent to the governance client with the appropriate payload.
   * Similar to `getMethod`
   */


  _createClass(GovernedContractClient, [{
    key: "getGovernedMethod",
    value: function () {
      var _getGovernedMethod = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(methodName) {
        var _len,
            args,
            _key,
            contractMethod,
            _this$governanceClien,
            signature,
            callData,
            contractRegistryKey,
            method,
            _args = arguments;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                for (_len = _args.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = _args[_key];
                }

                _context.next = 3;
                return this.getMethod.apply(this, [methodName].concat(args));

              case 3:
                contractMethod = _context.sent;
                _this$governanceClien = this.governanceClient.getSignatureAndCallData(methodName, contractMethod), signature = _this$governanceClien.signature, callData = _this$governanceClien.callData;
                contractRegistryKey = this.web3Manager.getWeb3().utils.utf8ToHex(this.contractRegistryKey);
                _context.next = 8;
                return this.governanceClient.guardianExecuteTransaction(contractRegistryKey, signature, callData);

              case 8:
                method = _context.sent;
                return _context.abrupt("return", method);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getGovernedMethod(_x) {
        return _getGovernedMethod.apply(this, arguments);
      }

      return getGovernedMethod;
    }()
  }]);

  return GovernedContractClient;
}(ContractClient);

var ServiceTypeManagerClient = /*#__PURE__*/function (_GovernedContractClie) {
  _inherits(ServiceTypeManagerClient, _GovernedContractClie);

  var _super = _createSuper(ServiceTypeManagerClient);

  function ServiceTypeManagerClient() {
    _classCallCheck(this, ServiceTypeManagerClient);

    return _super.apply(this, arguments);
  }

  _createClass(ServiceTypeManagerClient, [{
    key: "setServiceVersion",
    value:
    /**
     *
     * @param serviceType Type of service to set the version, either `discovery-node` or `content-node`
     * @param serviceVersion Version string to set on chain
     * @param privateKey Optional privateKey to pass along to web3Manager sendTransaction
     * @param dryRun Optional parameter to return the generated parameters without sending tx
     * @returns comma-separated String of serviceType and serviceVersion if dryRun; else response from web3Manager.sendTransaction
     */
    function () {
      var _setServiceVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(serviceType, serviceVersion) {
        var privateKey,
            dryRun,
            method,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                privateKey = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;
                dryRun = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;
                _context.next = 4;
                return this.getGovernedMethod('setServiceVersion', Utils.utf8ToHex(serviceType), Utils.utf8ToHex(serviceVersion));

              case 4:
                method = _context.sent;

                if (!dryRun) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt("return", "".concat(Utils.utf8ToHex(serviceType), ",").concat(Utils.utf8ToHex(serviceVersion)));

              case 7:
                _context.t0 = this.web3Manager;
                _context.t1 = method;
                _context.next = 11;
                return this.governanceClient.getAddress();

              case 11:
                _context.t2 = _context.sent;
                _context.t3 = privateKey;
                _context.next = 15;
                return _context.t0.sendTransaction.call(_context.t0, _context.t1, _context.t2, _context.t3);

              case 15:
                return _context.abrupt("return", _context.sent);

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setServiceVersion(_x, _x2) {
        return _setServiceVersion.apply(this, arguments);
      }

      return setServiceVersion;
    }()
  }, {
    key: "addServiceType",
    value: function () {
      var _addServiceType = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(serviceType, serviceTypeMin, serviceTypeMax) {
        var privateKey,
            method,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                privateKey = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : null;
                _context2.next = 3;
                return this.getGovernedMethod('addServiceType', Utils.utf8ToHex(serviceType), serviceTypeMin, serviceTypeMax);

              case 3:
                method = _context2.sent;
                _context2.t0 = this.web3Manager;
                _context2.t1 = method;
                _context2.next = 8;
                return this.governanceClient.getAddress();

              case 8:
                _context2.t2 = _context2.sent;
                _context2.t3 = privateKey;
                _context2.next = 12;
                return _context2.t0.sendTransaction.call(_context2.t0, _context2.t1, _context2.t2, _context2.t3);

              case 12:
                return _context2.abrupt("return", _context2.sent);

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function addServiceType(_x3, _x4, _x5) {
        return _addServiceType.apply(this, arguments);
      }

      return addServiceType;
    }()
  }, {
    key: "getValidServiceTypes",
    value: function () {
      var _getValidServiceTypes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var method, types;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getMethod('getValidServiceTypes');

              case 2:
                method = _context3.sent;
                _context3.next = 5;
                return method.call();

              case 5:
                types = _context3.sent;
                return _context3.abrupt("return", types.map(function (t) {
                  return Utils.hexToUtf8(t);
                }));

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getValidServiceTypes() {
        return _getValidServiceTypes.apply(this, arguments);
      }

      return getValidServiceTypes;
    }()
  }, {
    key: "getCurrentVersion",
    value: function () {
      var _getCurrentVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(serviceType) {
        var method, hexVersion;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getMethod('getCurrentVersion', Utils.utf8ToHex(serviceType));

              case 2:
                method = _context4.sent;
                _context4.next = 5;
                return method.call();

              case 5:
                hexVersion = _context4.sent;
                return _context4.abrupt("return", Utils.hexToUtf8(hexVersion));

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getCurrentVersion(_x6) {
        return _getCurrentVersion.apply(this, arguments);
      }

      return getCurrentVersion;
    }()
  }, {
    key: "getVersion",
    value: function () {
      var _getVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(serviceType, serviceTypeIndex) {
        var serviceTypeBytes32, method, version;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                serviceTypeBytes32 = Utils.utf8ToHex(serviceType);
                _context5.next = 3;
                return this.getMethod('getVersion', serviceTypeBytes32, serviceTypeIndex);

              case 3:
                method = _context5.sent;
                _context5.next = 6;
                return method.call();

              case 6:
                version = _context5.sent;
                return _context5.abrupt("return", Utils.hexToUtf8(version));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getVersion(_x7, _x8) {
        return _getVersion.apply(this, arguments);
      }

      return getVersion;
    }()
  }, {
    key: "getNumberOfVersions",
    value: function () {
      var _getNumberOfVersions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(serviceType) {
        var method;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getMethod('getNumberOfVersions', Utils.utf8ToHex(serviceType));

              case 2:
                method = _context6.sent;
                _context6.t0 = parseInt;
                _context6.next = 6;
                return method.call();

              case 6:
                _context6.t1 = _context6.sent;
                return _context6.abrupt("return", (0, _context6.t0)(_context6.t1));

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getNumberOfVersions(_x9) {
        return _getNumberOfVersions.apply(this, arguments);
      }

      return getNumberOfVersions;
    }()
    /**
     * @notice Add a new service type
     * @returns {
     *  isValid: Is the types type is isValid
     *  minStake: minimum stake for service type
     *  maxStake: minimum stake for service type
     * }
     */

  }, {
    key: "getServiceTypeInfo",
    value: function () {
      var _getServiceTypeInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(serviceType) {
        var method, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getMethod('getServiceTypeInfo', Utils.utf8ToHex(serviceType));

              case 2:
                method = _context7.sent;
                _context7.next = 5;
                return method.call();

              case 5:
                response = _context7.sent;
                return _context7.abrupt("return", {
                  isValid: response[0],
                  minStake: Utils.toBN(response[1]),
                  maxStake: Utils.toBN(response[2])
                });

              case 7:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getServiceTypeInfo(_x10) {
        return _getServiceTypeInfo.apply(this, arguments);
      }

      return getServiceTypeInfo;
    }()
  }]);

  return ServiceTypeManagerClient;
}(GovernedContractClient);

var ServiceProviderFactoryClient = /*#__PURE__*/function (_GovernedContractClie) {
  _inherits(ServiceProviderFactoryClient, _GovernedContractClie);

  var _super = _createSuper(ServiceProviderFactoryClient);

  function ServiceProviderFactoryClient(ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, audiusTokenClient, stakingProxyClient, governanceClient) {
    var _this;

    var logger = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : console;
    var isDebug = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;

    _classCallCheck(this, ServiceProviderFactoryClient);

    _this = _super.call(this, ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, governanceClient, logger);

    _defineProperty$1(_assertThisInitialized(_this), "audiusTokenClient", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "stakingProxyClient", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "isDebug", void 0);

    _this.audiusTokenClient = audiusTokenClient;
    _this.stakingProxyClient = stakingProxyClient;
    _this.isDebug = isDebug;
    return _this;
  }

  _createClass(ServiceProviderFactoryClient, [{
    key: "registerWithDelegate",
    value: function () {
      var _registerWithDelegate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(serviceType, endpoint, amount, delegateOwnerWallet) {
        var _tx$events, _tx$events$Registered;

        var performHealthCheck,
            sanitizedEndpoint,
            requestUrl,
            axiosRequestObj,
            resp,
            endpointServiceType,
            contractAddress,
            tx0,
            method,
            tx,
            returnValues,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                performHealthCheck = _args.length > 4 && _args[4] !== undefined ? _args[4] : true;
                sanitizedEndpoint = endpoint.replace(/\/$/, '');

                if (!(!this.isDebug && !Utils.isHttps(sanitizedEndpoint))) {
                  _context.next = 4;
                  break;
                }

                throw new Error('Domain name not using https protocol!');

              case 4:
                if (!(!this.isDebug && !Utils.isFQDN(sanitizedEndpoint))) {
                  _context.next = 6;
                  break;
                }

                throw new Error('Not a fully qualified domain name!');

              case 6:
                if (!(!Number.isInteger(amount) && !Utils.isBN(amount))) {
                  _context.next = 8;
                  break;
                }

                throw new Error('Invalid amount');

              case 8:
                if (!performHealthCheck) {
                  _context.next = 17;
                  break;
                }

                requestUrl = urlJoin__default["default"](sanitizedEndpoint, 'health_check');
                axiosRequestObj = {
                  url: requestUrl,
                  method: 'get',
                  timeout: 1000,
                  params: {
                    'allow_unregistered': 'true'
                  }
                };
                _context.next = 13;
                return axios__default["default"](axiosRequestObj);

              case 13:
                resp = _context.sent;
                endpointServiceType = resp.data.data.service;

                if (!(serviceType !== endpointServiceType)) {
                  _context.next = 17;
                  break;
                }

                throw new Error('Attempting to register endpoint with mismatched service type');

              case 17:
                _context.next = 19;
                return this.stakingProxyClient.getAddress();

              case 19:
                contractAddress = _context.sent;
                _context.next = 22;
                return this.audiusTokenClient.approve(contractAddress, amount);

              case 22:
                tx0 = _context.sent;
                _context.next = 25;
                return this.getMethod('register', Utils.utf8ToHex(serviceType), sanitizedEndpoint, amount, delegateOwnerWallet);

              case 25:
                method = _context.sent;
                _context.next = 28;
                return this.web3Manager.sendTransaction(method, 1000000);

              case 28:
                tx = _context.sent;
                returnValues = (_tx$events = tx.events) === null || _tx$events === void 0 ? void 0 : (_tx$events$Registered = _tx$events['RegisteredServiceProvider']) === null || _tx$events$Registered === void 0 ? void 0 : _tx$events$Registered.returnValues;
                return _context.abrupt("return", {
                  txReceipt: tx,
                  spID: parseInt(returnValues._spID),
                  serviceType: Utils.hexToUtf8(returnValues._serviceType),
                  owner: returnValues._owner,
                  endpoint: returnValues._endpoint,
                  tokenApproveReceipt: tx0
                });

              case 31:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function registerWithDelegate(_x, _x2, _x3, _x4) {
        return _registerWithDelegate.apply(this, arguments);
      }

      return registerWithDelegate;
    }()
  }, {
    key: "register",
    value: function () {
      var _register = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(serviceType, endpoint, amount) {
        var performHealthCheck,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                performHealthCheck = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : true;
                _context2.next = 3;
                return this.registerWithDelegate(serviceType, endpoint, amount, this.web3Manager.getWalletAddress(), performHealthCheck);

              case 3:
                return _context2.abrupt("return", _context2.sent);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function register(_x5, _x6, _x7) {
        return _register.apply(this, arguments);
      }

      return register;
    }()
  }, {
    key: "getRegisteredServiceProviderEvents",
    value: function () {
      var _getRegisteredServiceProviderEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref) {
        var serviceType, owner, _ref$queryStartBlock, queryStartBlock, contract, filter, events;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                serviceType = _ref.serviceType, owner = _ref.owner, _ref$queryStartBlock = _ref.queryStartBlock, queryStartBlock = _ref$queryStartBlock === void 0 ? 0 : _ref$queryStartBlock;
                _context3.next = 3;
                return this.getContract();

              case 3:
                contract = _context3.sent;
                filter = {};

                if (owner) {
                  filter._owner = owner;
                }

                if (serviceType) {
                  filter._serviceType = serviceType;
                }

                _context3.next = 9;
                return contract.getPastEvents('RegisteredServiceProvider', {
                  fromBlock: queryStartBlock,
                  filter: filter
                });

              case 9:
                events = _context3.sent;
                return _context3.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    spID: parseInt(event.returnValues['_spID']),
                    serviceType: Utils.hexToUtf8(event.returnValues['_serviceType']),
                    owner: event.returnValues['_owner'],
                    endpoint: event.returnValues['_endpoint'],
                    stakeAmount: Utils.toBN(event.returnValues['_stakeAmout'])
                  };
                }));

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getRegisteredServiceProviderEvents(_x8) {
        return _getRegisteredServiceProviderEvents.apply(this, arguments);
      }

      return getRegisteredServiceProviderEvents;
    }()
  }, {
    key: "getDeregisteredServiceProviderEvents",
    value: function () {
      var _getDeregisteredServiceProviderEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_ref2) {
        var serviceType, owner, _ref2$queryStartBlock, queryStartBlock, contract, filter, events;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                serviceType = _ref2.serviceType, owner = _ref2.owner, _ref2$queryStartBlock = _ref2.queryStartBlock, queryStartBlock = _ref2$queryStartBlock === void 0 ? 0 : _ref2$queryStartBlock;
                _context4.next = 3;
                return this.getContract();

              case 3:
                contract = _context4.sent;
                filter = {};

                if (owner) {
                  filter._owner = owner;
                }

                if (serviceType) {
                  filter._serviceType = serviceType;
                }

                _context4.next = 9;
                return contract.getPastEvents('DeregisteredServiceProvider', {
                  fromBlock: queryStartBlock,
                  filter: filter
                });

              case 9:
                events = _context4.sent;
                return _context4.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    spID: parseInt(event.returnValues['_spID']),
                    serviceType: Utils.hexToUtf8(event.returnValues['_serviceType']),
                    owner: event.returnValues['_owner'],
                    endpoint: event.returnValues['_endpoint'],
                    stakeAmount: Utils.toBN(event.returnValues['_stakeAmount'])
                  };
                }));

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getDeregisteredServiceProviderEvents(_x9) {
        return _getDeregisteredServiceProviderEvents.apply(this, arguments);
      }

      return getDeregisteredServiceProviderEvents;
    }()
  }, {
    key: "getIncreasedStakeEvents",
    value: function () {
      var _getIncreasedStakeEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref3) {
        var owner, _ref3$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                owner = _ref3.owner, _ref3$queryStartBlock = _ref3.queryStartBlock, queryStartBlock = _ref3$queryStartBlock === void 0 ? 0 : _ref3$queryStartBlock;
                _context5.next = 3;
                return this.getContract();

              case 3:
                contract = _context5.sent;
                _context5.next = 6;
                return contract.getPastEvents('IncreasedStake', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _owner: owner
                  }
                });

              case 6:
                events = _context5.sent;
                return _context5.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    owner: event.returnValues['_owner'],
                    increaseAmount: Utils.toBN(event.returnValues['_increaseAmount']),
                    newStakeAmount: Utils.toBN(event.returnValues['_newStakeAmount'])
                  };
                }));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getIncreasedStakeEvents(_x10) {
        return _getIncreasedStakeEvents.apply(this, arguments);
      }

      return getIncreasedStakeEvents;
    }()
  }, {
    key: "getDecreasedStakeEvaluatedEvents",
    value: function () {
      var _getDecreasedStakeEvaluatedEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref4) {
        var owner, _ref4$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                owner = _ref4.owner, _ref4$queryStartBlock = _ref4.queryStartBlock, queryStartBlock = _ref4$queryStartBlock === void 0 ? 0 : _ref4$queryStartBlock;
                _context6.next = 3;
                return this.getContract();

              case 3:
                contract = _context6.sent;
                _context6.next = 6;
                return contract.getPastEvents('DecreaseStakeRequestEvaluated', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _owner: owner
                  }
                });

              case 6:
                events = _context6.sent;
                return _context6.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    owner: event.returnValues['_owner'],
                    decreaseAmount: Utils.toBN(event.returnValues['_decreaseAmount']),
                    newStakeAmount: Utils.toBN(event.returnValues['_newStakeAmount'])
                  };
                }));

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getDecreasedStakeEvaluatedEvents(_x11) {
        return _getDecreasedStakeEvaluatedEvents.apply(this, arguments);
      }

      return getDecreasedStakeEvaluatedEvents;
    }()
  }, {
    key: "getDecreasedStakeRequestedEvents",
    value: function () {
      var _getDecreasedStakeRequestedEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(_ref5) {
        var owner, _ref5$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                owner = _ref5.owner, _ref5$queryStartBlock = _ref5.queryStartBlock, queryStartBlock = _ref5$queryStartBlock === void 0 ? 0 : _ref5$queryStartBlock;
                _context7.next = 3;
                return this.getContract();

              case 3:
                contract = _context7.sent;
                _context7.next = 6;
                return contract.getPastEvents('DecreaseStakeRequested', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _owner: owner
                  }
                });

              case 6:
                events = _context7.sent;
                return _context7.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    owner: event.returnValues['_owner'],
                    decreaseAmount: Utils.toBN(event.returnValues['_decreaseAmount']),
                    lockupExpiryBlock: parseInt(event.returnValues['_lockupExpiryBlock'])
                  };
                }));

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getDecreasedStakeRequestedEvents(_x12) {
        return _getDecreasedStakeRequestedEvents.apply(this, arguments);
      }

      return getDecreasedStakeRequestedEvents;
    }()
  }, {
    key: "getDecreasedStakeCancelledEvents",
    value: function () {
      var _getDecreasedStakeCancelledEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(_ref6) {
        var owner, _ref6$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                owner = _ref6.owner, _ref6$queryStartBlock = _ref6.queryStartBlock, queryStartBlock = _ref6$queryStartBlock === void 0 ? 0 : _ref6$queryStartBlock;
                _context8.next = 3;
                return this.getContract();

              case 3:
                contract = _context8.sent;
                _context8.next = 6;
                return contract.getPastEvents('DecreaseStakeRequestCancelled', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _owner: owner
                  }
                });

              case 6:
                events = _context8.sent;
                return _context8.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    owner: event.returnValues['_owner'],
                    decreaseAmount: Utils.toBN(event.returnValues['_decreaseAmount']),
                    lockupExpiryBlock: parseInt(event.returnValues['_lockupExpiryBlock'])
                  };
                }));

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getDecreasedStakeCancelledEvents(_x13) {
        return _getDecreasedStakeCancelledEvents.apply(this, arguments);
      }

      return getDecreasedStakeCancelledEvents;
    }() // Get the deregistered service's most recent endpoint and delegate owner wallet

  }, {
    key: "getDeregisteredService",
    value: function () {
      var _getDeregisteredService = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(_ref7) {
        var serviceType, spID, _ref7$queryStartBlock, queryStartBlock, contract, service, registerEvents, _registerEvents, _registerEvents$retur, _endpoint, _owner, endpointUpdateEvents, _endpointUpdateEvents2, _endpointUpdateEvents, _newEndpoint, walletEvents, _walletEvents, _walletEvents$returnV, _updatedWallet;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                serviceType = _ref7.serviceType, spID = _ref7.spID, _ref7$queryStartBlock = _ref7.queryStartBlock, queryStartBlock = _ref7$queryStartBlock === void 0 ? 0 : _ref7$queryStartBlock;
                _context9.next = 3;
                return this.getContract();

              case 3:
                contract = _context9.sent;
                service = {
                  endpoint: '',
                  delegateOwnerWallet: ''
                };
                _context9.next = 7;
                return contract.getPastEvents('RegisteredServiceProvider', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _spID: spID,
                    _serviceType: Utils.utf8ToHex(serviceType)
                  }
                });

              case 7:
                registerEvents = _context9.sent;

                if (registerEvents.length > 0) {
                  _registerEvents$retur = (_registerEvents = registerEvents[registerEvents.length - 1]) === null || _registerEvents === void 0 ? void 0 : _registerEvents.returnValues, _endpoint = _registerEvents$retur._endpoint, _owner = _registerEvents$retur._owner;
                  service.endpoint = _endpoint;
                  service.owner = _owner;
                }

                _context9.next = 11;
                return contract.getPastEvents('EndpointUpdated', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _spID: spID,
                    _serviceType: Utils.utf8ToHex(serviceType)
                  }
                });

              case 11:
                endpointUpdateEvents = _context9.sent;

                if (endpointUpdateEvents.length > 0) {
                  _endpointUpdateEvents = (_endpointUpdateEvents2 = endpointUpdateEvents[endpointUpdateEvents.length - 1]) === null || _endpointUpdateEvents2 === void 0 ? void 0 : _endpointUpdateEvents2.returnValues, _newEndpoint = _endpointUpdateEvents._newEndpoint;
                  service.endpoint = _newEndpoint;
                }

                _context9.next = 15;
                return contract.getPastEvents('DelegateOwnerWalletUpdated', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _spID: spID,
                    _serviceType: Utils.utf8ToHex(serviceType)
                  }
                });

              case 15:
                walletEvents = _context9.sent;

                if (walletEvents.length > 0) {
                  _walletEvents$returnV = (_walletEvents = walletEvents[walletEvents.length - 1]) === null || _walletEvents === void 0 ? void 0 : _walletEvents.returnValues, _updatedWallet = _walletEvents$returnV._updatedWallet;
                  service.delegateOwnerWallet = _updatedWallet;
                }

                return _context9.abrupt("return", service);

              case 18:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getDeregisteredService(_x14) {
        return _getDeregisteredService.apply(this, arguments);
      }

      return getDeregisteredService;
    }()
  }, {
    key: "increaseStake",
    value: function () {
      var _increaseStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(amount) {
        var contractAddress, tx0, method, tx;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.stakingProxyClient.getAddress();

              case 2:
                contractAddress = _context10.sent;
                _context10.next = 5;
                return this.audiusTokenClient.approve(contractAddress, amount);

              case 5:
                tx0 = _context10.sent;
                _context10.next = 8;
                return this.getMethod('increaseStake', amount);

              case 8:
                method = _context10.sent;
                _context10.next = 11;
                return this.web3Manager.sendTransaction(method, 1000000);

              case 11:
                tx = _context10.sent;
                return _context10.abrupt("return", {
                  txReceipt: tx,
                  tokenApproveReceipt: tx0
                });

              case 13:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function increaseStake(_x15) {
        return _increaseStake.apply(this, arguments);
      }

      return increaseStake;
    }()
    /**
     * Makes a request to decrease stake
     * @param amount
     * @returns decrease stake lockup expiry block
     */

  }, {
    key: "requestDecreaseStake",
    value: function () {
      var _requestDecreaseStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(amount) {
        var requestDecreaseMethod, account, lockupExpiryBlock;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.getMethod('requestDecreaseStake', amount);

              case 2:
                requestDecreaseMethod = _context11.sent;
                _context11.next = 5;
                return this.web3Manager.sendTransaction(requestDecreaseMethod, // @ts-expect-error TODO: sendTransaction's signature seems pretty different
                1000000);

              case 5:
                account = this.web3Manager.getWalletAddress();
                _context11.next = 8;
                return this.getLockupExpiry(account);

              case 8:
                lockupExpiryBlock = _context11.sent;
                return _context11.abrupt("return", parseInt(lockupExpiryBlock));

              case 10:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function requestDecreaseStake(_x16) {
        return _requestDecreaseStake.apply(this, arguments);
      }

      return requestDecreaseStake;
    }()
    /**
     * Gets the pending decrease stake request for a given account
     * @param account wallet address to fetch for
     */

  }, {
    key: "getPendingDecreaseStakeRequest",
    value: function () {
      var _getPendingDecreaseStakeRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(account) {
        var requestInfoMethod, _yield$requestInfoMet, amount, lockupExpiryBlock;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getMethod('getPendingDecreaseStakeRequest', account);

              case 2:
                requestInfoMethod = _context12.sent;
                _context12.next = 5;
                return requestInfoMethod.call();

              case 5:
                _yield$requestInfoMet = _context12.sent;
                amount = _yield$requestInfoMet.amount;
                lockupExpiryBlock = _yield$requestInfoMet.lockupExpiryBlock;
                return _context12.abrupt("return", {
                  amount: Utils.toBN(amount),
                  lockupExpiryBlock: parseInt(lockupExpiryBlock)
                });

              case 9:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getPendingDecreaseStakeRequest(_x17) {
        return _getPendingDecreaseStakeRequest.apply(this, arguments);
      }

      return getPendingDecreaseStakeRequest;
    }()
    /**
     * Gets the pending decrease stake lockup duration
     */

  }, {
    key: "getDecreaseStakeLockupDuration",
    value: function () {
      var _getDecreaseStakeLockupDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
        var requestInfoMethod, info;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this.getMethod('getDecreaseStakeLockupDuration');

              case 2:
                requestInfoMethod = _context13.sent;
                _context13.next = 5;
                return requestInfoMethod.call();

              case 5:
                info = _context13.sent;
                return _context13.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getDecreaseStakeLockupDuration() {
        return _getDecreaseStakeLockupDuration.apply(this, arguments);
      }

      return getDecreaseStakeLockupDuration;
    }()
    /**
     * Gets the deployer cut lockup duration
     */

  }, {
    key: "getDeployerCutLockupDuration",
    value: function () {
      var _getDeployerCutLockupDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
        var requestInfoMethod, info;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getMethod('getDeployerCutLockupDuration');

              case 2:
                requestInfoMethod = _context14.sent;
                _context14.next = 5;
                return requestInfoMethod.call();

              case 5:
                info = _context14.sent;
                return _context14.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getDeployerCutLockupDuration() {
        return _getDeployerCutLockupDuration.apply(this, arguments);
      }

      return getDeployerCutLockupDuration;
    }()
    /**
     * Cancels the pending decrease stake request
     * @param account wallet address to cancel request for
     */

  }, {
    key: "cancelDecreaseStakeRequest",
    value: function () {
      var _cancelDecreaseStakeRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(account) {
        var requestCancelDecreaseMethod;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this.getMethod('cancelDecreaseStakeRequest', account);

              case 2:
                requestCancelDecreaseMethod = _context15.sent;
                _context15.next = 5;
                return this.web3Manager.sendTransaction(requestCancelDecreaseMethod, // @ts-expect-error TODO: double check sendTransaction
                1000000);

              case 5:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function cancelDecreaseStakeRequest(_x18) {
        return _cancelDecreaseStakeRequest.apply(this, arguments);
      }

      return cancelDecreaseStakeRequest;
    }()
    /**
     * Fetches the pending decrease stake lockup expiry block for a user
     * @param account wallet address to fetch for
     */

  }, {
    key: "getLockupExpiry",
    value: function () {
      var _getLockupExpiry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(account) {
        var _yield$this$getPendin, lockupExpiryBlock;

        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.getPendingDecreaseStakeRequest(account);

              case 2:
                _yield$this$getPendin = _context16.sent;
                lockupExpiryBlock = _yield$this$getPendin.lockupExpiryBlock;
                return _context16.abrupt("return", parseInt(lockupExpiryBlock));

              case 5:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getLockupExpiry(_x19) {
        return _getLockupExpiry.apply(this, arguments);
      }

      return getLockupExpiry;
    }()
  }, {
    key: "decreaseStake",
    value: function () {
      var _decreaseStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this.getMethod('decreaseStake');

              case 2:
                method = _context17.sent;
                _context17.next = 5;
                return this.web3Manager.sendTransaction(method, 1000000);

              case 5:
                tx = _context17.sent;
                return _context17.abrupt("return", {
                  txReceipt: tx
                });

              case 7:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function decreaseStake() {
        return _decreaseStake.apply(this, arguments);
      }

      return decreaseStake;
    }()
    /**
     * Deregisters a service
     * @param serviceType
     * @param endpoint
     */

  }, {
    key: "deregister",
    value: function () {
      var _deregister = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(serviceType, endpoint) {
        var _tx$events2, _tx$events2$Deregiste;

        var method, tx, returnValues;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.getMethod('deregister', Utils.utf8ToHex(serviceType), endpoint);

              case 2:
                method = _context18.sent;
                _context18.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context18.sent;
                returnValues = (_tx$events2 = tx.events) === null || _tx$events2 === void 0 ? void 0 : (_tx$events2$Deregiste = _tx$events2['DeregisteredServiceProvider']) === null || _tx$events2$Deregiste === void 0 ? void 0 : _tx$events2$Deregiste.returnValues;
                return _context18.abrupt("return", {
                  txReceipt: tx,
                  spID: parseInt(returnValues._spID),
                  serviceType: Utils.hexToUtf8(returnValues._serviceType),
                  owner: returnValues._owner,
                  endpoint: returnValues._endpoint
                });

              case 8:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function deregister(_x20, _x21) {
        return _deregister.apply(this, arguments);
      }

      return deregister;
    }()
  }, {
    key: "getTotalServiceTypeProviders",
    value: function () {
      var _getTotalServiceTypeProviders = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(serviceType) {
        var method, count;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.getMethod('getTotalServiceTypeProviders', Utils.utf8ToHex(serviceType));

              case 2:
                method = _context19.sent;
                _context19.next = 5;
                return method.call();

              case 5:
                count = _context19.sent;
                return _context19.abrupt("return", parseInt(count));

              case 7:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getTotalServiceTypeProviders(_x22) {
        return _getTotalServiceTypeProviders.apply(this, arguments);
      }

      return getTotalServiceTypeProviders;
    }()
  }, {
    key: "getServiceProviderIdFromEndpoint",
    value: function () {
      var _getServiceProviderIdFromEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(endpoint) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getMethod('getServiceProviderIdFromEndpoint', endpoint);

              case 2:
                method = _context20.sent;
                _context20.next = 5;
                return method.call();

              case 5:
                info = _context20.sent;
                return _context20.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getServiceProviderIdFromEndpoint(_x23) {
        return _getServiceProviderIdFromEndpoint.apply(this, arguments);
      }

      return getServiceProviderIdFromEndpoint;
    }() // TODO: Remove this method after all consumers are using
    // `getServiceEndpointInfo` directly

  }, {
    key: "getServiceProviderInfo",
    value: function () {
      var _getServiceProviderInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(serviceType, serviceId) {
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this.getServiceEndpointInfo(serviceType, serviceId);

              case 2:
                return _context21.abrupt("return", _context21.sent);

              case 3:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getServiceProviderInfo(_x24, _x25) {
        return _getServiceProviderInfo.apply(this, arguments);
      }

      return getServiceProviderInfo;
    }()
  }, {
    key: "getServiceEndpointInfo",
    value: function () {
      var _getServiceEndpointInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(serviceType, serviceId) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getMethod('getServiceEndpointInfo', Utils.utf8ToHex(serviceType), serviceId);

              case 2:
                method = _context22.sent;
                _context22.next = 5;
                return method.call();

              case 5:
                info = _context22.sent;
                return _context22.abrupt("return", {
                  owner: info.owner,
                  endpoint: info.endpoint.replace(/\/$/, ''),
                  spID: parseInt(serviceId),
                  type: serviceType,
                  blockNumber: parseInt(info.blockNumber),
                  delegateOwnerWallet: info.delegateOwnerWallet
                });

              case 7:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getServiceEndpointInfo(_x26, _x27) {
        return _getServiceEndpointInfo.apply(this, arguments);
      }

      return getServiceEndpointInfo;
    }()
  }, {
    key: "getServiceProviderInfoFromEndpoint",
    value: function () {
      var _getServiceProviderInfoFromEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(endpoint) {
        var requestUrl, axiosRequestObj, resp, serviceType, serviceProviderId, info;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                requestUrl = urlJoin__default["default"](endpoint, 'health_check');
                axiosRequestObj = {
                  url: requestUrl,
                  method: 'get',
                  timeout: 1000
                };
                _context23.next = 4;
                return axios__default["default"](axiosRequestObj);

              case 4:
                resp = _context23.sent;
                serviceType = resp.data.data.service;
                _context23.next = 8;
                return this.getServiceProviderIdFromEndpoint(endpoint);

              case 8:
                serviceProviderId = _context23.sent;
                _context23.next = 11;
                return this.getServiceEndpointInfo(serviceType, serviceProviderId);

              case 11:
                info = _context23.sent;
                return _context23.abrupt("return", info);

              case 13:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getServiceProviderInfoFromEndpoint(_x28) {
        return _getServiceProviderInfoFromEndpoint.apply(this, arguments);
      }

      return getServiceProviderInfoFromEndpoint;
    }()
  }, {
    key: "getServiceProviderIdsFromAddress",
    value: function () {
      var _getServiceProviderIdsFromAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(ownerAddress, serviceType) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.getMethod('getServiceProviderIdsFromAddress', ownerAddress, Utils.utf8ToHex(serviceType));

              case 2:
                method = _context24.sent;
                _context24.next = 5;
                return method.call();

              case 5:
                info = _context24.sent;
                return _context24.abrupt("return", info.map(function (id) {
                  return parseInt(id);
                }));

              case 7:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getServiceProviderIdsFromAddress(_x29, _x30) {
        return _getServiceProviderIdsFromAddress.apply(this, arguments);
      }

      return getServiceProviderIdsFromAddress;
    }()
  }, {
    key: "getServiceProviderIdFromAddress",
    value: function () {
      var _getServiceProviderIdFromAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(ownerAddress, serviceType) {
        var infos;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this.getServiceProviderIdsFromAddress(ownerAddress, serviceType);

              case 2:
                infos = _context25.sent;
                return _context25.abrupt("return", infos[0]);

              case 4:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getServiceProviderIdFromAddress(_x31, _x32) {
        return _getServiceProviderIdFromAddress.apply(this, arguments);
      }

      return getServiceProviderIdFromAddress;
    }()
  }, {
    key: "getServiceEndpointInfoFromAddress",
    value: function () {
      var _getServiceEndpointInfoFromAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(ownerAddress, serviceType) {
        var spId, spInfo;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.getServiceProviderIdFromAddress(ownerAddress, serviceType);

              case 2:
                spId = _context26.sent;
                _context26.next = 5;
                return this.getServiceEndpointInfo(serviceType, spId);

              case 5:
                _context26.t0 = _context26.sent;
                spInfo = [_context26.t0];
                return _context26.abrupt("return", spInfo);

              case 8:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function getServiceEndpointInfoFromAddress(_x33, _x34) {
        return _getServiceEndpointInfoFromAddress.apply(this, arguments);
      }

      return getServiceEndpointInfoFromAddress;
    }()
    /**
     * Returns all service providers of requested `serviceType`
     * Returns array of objects with schema { blockNumber, delegateOwnerWallet, endpoint, owner, spID, type }
     */

  }, {
    key: "getServiceProviderList",
    value: function () {
      var _getServiceProviderList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(serviceType) {
        var _this2 = this;

        var numberOfProviders, providerList;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.getTotalServiceTypeProviders(serviceType);

              case 2:
                numberOfProviders = _context28.sent;
                _context28.next = 5;
                return Promise.all(lodash.range(1, numberOfProviders + 1).map( /*#__PURE__*/function () {
                  var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(i) {
                    return regeneratorRuntime.wrap(function _callee27$(_context27) {
                      while (1) {
                        switch (_context27.prev = _context27.next) {
                          case 0:
                            _context27.next = 2;
                            return _this2.getServiceEndpointInfo(serviceType, i);

                          case 2:
                            return _context27.abrupt("return", _context27.sent);

                          case 3:
                          case "end":
                            return _context27.stop();
                        }
                      }
                    }, _callee27);
                  }));

                  return function (_x36) {
                    return _ref8.apply(this, arguments);
                  };
                }()));

              case 5:
                providerList = _context28.sent;
                return _context28.abrupt("return", providerList.filter(function (provider) {
                  return provider.endpoint !== '';
                }));

              case 7:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getServiceProviderList(_x35) {
        return _getServiceProviderList.apply(this, arguments);
      }

      return getServiceProviderList;
    }()
  }, {
    key: "updateDecreaseStakeLockupDuration",
    value: function () {
      var _updateDecreaseStakeLockupDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(duration) {
        var method;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.next = 2;
                return this.getGovernedMethod('updateDecreaseStakeLockupDuration', duration);

              case 2:
                method = _context29.sent;
                _context29.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                return _context29.abrupt("return", _context29.sent);

              case 6:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function updateDecreaseStakeLockupDuration(_x37) {
        return _updateDecreaseStakeLockupDuration.apply(this, arguments);
      }

      return updateDecreaseStakeLockupDuration;
    }()
  }, {
    key: "getServiceProviderDetails",
    value: function () {
      var _getServiceProviderDetails = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(serviceProviderAddress) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this.getMethod('getServiceProviderDetails', serviceProviderAddress);

              case 2:
                method = _context30.sent;
                _context30.next = 5;
                return method.call();

              case 5:
                info = _context30.sent;
                return _context30.abrupt("return", {
                  deployerCut: parseInt(info.deployerCut),
                  deployerStake: Utils.toBN(info.deployerStake),
                  maxAccountStake: Utils.toBN(info.maxAccountStake),
                  minAccountStake: Utils.toBN(info.minAccountStake),
                  numberOfEndpoints: parseInt(info.numberOfEndpoints),
                  validBounds: info.validBounds
                });

              case 7:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getServiceProviderDetails(_x38) {
        return _getServiceProviderDetails.apply(this, arguments);
      }

      return getServiceProviderDetails;
    }()
  }, {
    key: "updateDelegateOwnerWallet",
    value: function () {
      var _updateDelegateOwnerWallet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(serviceType, endpoint, updatedDelegateOwnerWallet) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                _context31.next = 2;
                return this.getMethod('updateDelegateOwnerWallet', Utils.utf8ToHex(serviceType), endpoint, updatedDelegateOwnerWallet);

              case 2:
                method = _context31.sent;
                _context31.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context31.sent;
                return _context31.abrupt("return", tx);

              case 7:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function updateDelegateOwnerWallet(_x39, _x40, _x41) {
        return _updateDelegateOwnerWallet.apply(this, arguments);
      }

      return updateDelegateOwnerWallet;
    }()
  }, {
    key: "updateEndpoint",
    value: function () {
      var _updateEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(serviceType, oldEndpoint, newEndpoint) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.getMethod('updateEndpoint', Utils.utf8ToHex(serviceType), oldEndpoint, newEndpoint);

              case 2:
                method = _context32.sent;
                _context32.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context32.sent;
                return _context32.abrupt("return", tx);

              case 7:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function updateEndpoint(_x42, _x43, _x44) {
        return _updateEndpoint.apply(this, arguments);
      }

      return updateEndpoint;
    }()
  }, {
    key: "requestUpdateDeployerCut",
    value: function () {
      var _requestUpdateDeployerCut = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(ownerAddress, deployerCut) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                _context33.next = 2;
                return this.getMethod('requestUpdateDeployerCut', ownerAddress, deployerCut);

              case 2:
                method = _context33.sent;
                _context33.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context33.sent;
                return _context33.abrupt("return", tx);

              case 7:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function requestUpdateDeployerCut(_x45, _x46) {
        return _requestUpdateDeployerCut.apply(this, arguments);
      }

      return requestUpdateDeployerCut;
    }()
  }, {
    key: "getPendingUpdateDeployerCutRequest",
    value: function () {
      var _getPendingUpdateDeployerCutRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(ownerAddress) {
        var method, _yield$method$call, lockupExpiryBlock, newDeployerCut;

        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                _context34.next = 2;
                return this.getMethod('getPendingUpdateDeployerCutRequest', ownerAddress);

              case 2:
                method = _context34.sent;
                _context34.next = 5;
                return method.call();

              case 5:
                _yield$method$call = _context34.sent;
                lockupExpiryBlock = _yield$method$call.lockupExpiryBlock;
                newDeployerCut = _yield$method$call.newDeployerCut;
                return _context34.abrupt("return", {
                  lockupExpiryBlock: parseInt(lockupExpiryBlock),
                  newDeployerCut: parseInt(newDeployerCut)
                });

              case 9:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function getPendingUpdateDeployerCutRequest(_x47) {
        return _getPendingUpdateDeployerCutRequest.apply(this, arguments);
      }

      return getPendingUpdateDeployerCutRequest;
    }()
  }, {
    key: "cancelUpdateDeployerCut",
    value: function () {
      var _cancelUpdateDeployerCut = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(ownerAddress) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                _context35.next = 2;
                return this.getMethod('cancelUpdateDeployerCut', ownerAddress);

              case 2:
                method = _context35.sent;
                _context35.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context35.sent;
                return _context35.abrupt("return", tx);

              case 7:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function cancelUpdateDeployerCut(_x48) {
        return _cancelUpdateDeployerCut.apply(this, arguments);
      }

      return cancelUpdateDeployerCut;
    }()
  }, {
    key: "updateDeployerCut",
    value: function () {
      var _updateDeployerCut = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36(ownerAddress) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                _context36.next = 2;
                return this.getMethod('updateDeployerCut', ownerAddress);

              case 2:
                method = _context36.sent;
                _context36.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context36.sent;
                return _context36.abrupt("return", tx);

              case 7:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function updateDeployerCut(_x49) {
        return _updateDeployerCut.apply(this, arguments);
      }

      return updateDeployerCut;
    }()
  }, {
    key: "updateServiceProviderStake",
    value: function () {
      var _updateServiceProviderStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(ownerAddress, newAmount) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                _context37.next = 2;
                return this.getMethod('updateServiceProviderStake', ownerAddress, newAmount);

              case 2:
                method = _context37.sent;
                _context37.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context37.sent;
                return _context37.abrupt("return", tx);

              case 7:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function updateServiceProviderStake(_x50, _x51) {
        return _updateServiceProviderStake.apply(this, arguments);
      }

      return updateServiceProviderStake;
    }()
  }]);

  return ServiceProviderFactoryClient;
}(GovernedContractClient);

var StakingProxyClient = /*#__PURE__*/function (_ContractClient) {
  _inherits(StakingProxyClient, _ContractClient);

  var _super = _createSuper(StakingProxyClient);

  function StakingProxyClient(ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, audiusTokenClient) {
    var _this;

    var logger = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : console;

    _classCallCheck(this, StakingProxyClient);

    _this = _super.call(this, ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, logger);

    _defineProperty$1(_assertThisInitialized(_this), "audiusTokenClient", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "toBN", void 0);

    _this.audiusTokenClient = audiusTokenClient;
    _this.toBN = ethWeb3Manager.getWeb3().utils.toBN;
    return _this;
  }

  _createClass(StakingProxyClient, [{
    key: "token",
    value: function () {
      var _token = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var method;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getMethod('token');

              case 2:
                method = _context.sent;
                return _context.abrupt("return", method.call());

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function token() {
        return _token.apply(this, arguments);
      }

      return token;
    }()
  }, {
    key: "totalStaked",
    value: function () {
      var _totalStaked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var method;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getMethod('totalStaked');

              case 2:
                method = _context2.sent;
                _context2.t0 = this;
                _context2.next = 6;
                return method.call();

              case 6:
                _context2.t1 = _context2.sent;
                return _context2.abrupt("return", _context2.t0.toBN.call(_context2.t0, _context2.t1));

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function totalStaked() {
        return _totalStaked.apply(this, arguments);
      }

      return totalStaked;
    }()
  }, {
    key: "supportsHistory",
    value: function () {
      var _supportsHistory = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var method;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getMethod('supportsHistory');

              case 2:
                method = _context3.sent;
                return _context3.abrupt("return", method.call());

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function supportsHistory() {
        return _supportsHistory.apply(this, arguments);
      }

      return supportsHistory;
    }()
  }, {
    key: "totalStakedFor",
    value: function () {
      var _totalStakedFor = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(account) {
        var method;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getMethod('totalStakedFor', account);

              case 2:
                method = _context4.sent;
                _context4.t0 = this;
                _context4.next = 6;
                return method.call();

              case 6:
                _context4.t1 = _context4.sent;
                return _context4.abrupt("return", _context4.t0.toBN.call(_context4.t0, _context4.t1));

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function totalStakedFor(_x) {
        return _totalStakedFor.apply(this, arguments);
      }

      return totalStakedFor;
    }()
  }, {
    key: "totalStakedForAt",
    value: function () {
      var _totalStakedForAt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(account, blockNumber) {
        var method;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getMethod('totalStakedForAt', account, blockNumber);

              case 2:
                method = _context5.sent;
                _context5.t0 = this;
                _context5.next = 6;
                return method.call();

              case 6:
                _context5.t1 = _context5.sent;
                return _context5.abrupt("return", _context5.t0.toBN.call(_context5.t0, _context5.t1));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function totalStakedForAt(_x2, _x3) {
        return _totalStakedForAt.apply(this, arguments);
      }

      return totalStakedForAt;
    }()
  }, {
    key: "totalStakedAt",
    value: function () {
      var _totalStakedAt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(blockNumber) {
        var method;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getMethod('totalStakedAt', blockNumber);

              case 2:
                method = _context6.sent;
                _context6.t0 = this;
                _context6.next = 6;
                return method.call();

              case 6:
                _context6.t1 = _context6.sent;
                return _context6.abrupt("return", _context6.t0.toBN.call(_context6.t0, _context6.t1));

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function totalStakedAt(_x4) {
        return _totalStakedAt.apply(this, arguments);
      }

      return totalStakedAt;
    }()
  }, {
    key: "isStaker",
    value: function () {
      var _isStaker = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(account) {
        var method;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getMethod('isStaker', account);

              case 2:
                method = _context7.sent;
                return _context7.abrupt("return", method.call());

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function isStaker(_x5) {
        return _isStaker.apply(this, arguments);
      }

      return isStaker;
    }()
  }, {
    key: "getDelegateManagerAddress",
    value: function () {
      var _getDelegateManagerAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var method;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getMethod('getDelegateManagerAddress');

              case 2:
                method = _context8.sent;
                return _context8.abrupt("return", method.call());

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getDelegateManagerAddress() {
        return _getDelegateManagerAddress.apply(this, arguments);
      }

      return getDelegateManagerAddress;
    }()
  }, {
    key: "getClaimsManagerAddress",
    value: function () {
      var _getClaimsManagerAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var method;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.getMethod('getClaimsManagerAddress');

              case 2:
                method = _context9.sent;
                return _context9.abrupt("return", method.call());

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getClaimsManagerAddress() {
        return _getClaimsManagerAddress.apply(this, arguments);
      }

      return getClaimsManagerAddress;
    }()
  }, {
    key: "getServiceProviderFactoryAddress",
    value: function () {
      var _getServiceProviderFactoryAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var method;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getMethod('getServiceProviderFactoryAddress');

              case 2:
                method = _context10.sent;
                return _context10.abrupt("return", method.call());

              case 4:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getServiceProviderFactoryAddress() {
        return _getServiceProviderFactoryAddress.apply(this, arguments);
      }

      return getServiceProviderFactoryAddress;
    }()
  }, {
    key: "getGovernanceAddress",
    value: function () {
      var _getGovernanceAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var method;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.getMethod('getGovernanceAddress');

              case 2:
                method = _context11.sent;
                return _context11.abrupt("return", method.call());

              case 4:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getGovernanceAddress() {
        return _getGovernanceAddress.apply(this, arguments);
      }

      return getGovernanceAddress;
    }()
  }, {
    key: "getLastClaimedBlockForUser",
    value: function () {
      var _getLastClaimedBlockForUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getMethod('lastClaimedFor', this.web3Manager.getWalletAddress());

              case 2:
                method = _context12.sent;
                _context12.next = 5;
                return method.call();

              case 5:
                tx = _context12.sent;
                return _context12.abrupt("return", tx);

              case 7:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getLastClaimedBlockForUser() {
        return _getLastClaimedBlockForUser.apply(this, arguments);
      }

      return getLastClaimedBlockForUser;
    }()
  }]);

  return StakingProxyClient;
}(ContractClient);

var DelegateManagerClient = /*#__PURE__*/function (_GovernedContractClie) {
  _inherits(DelegateManagerClient, _GovernedContractClie);

  var _super = _createSuper(DelegateManagerClient);

  function DelegateManagerClient(ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, audiusTokenClient, stakingProxyClient, governanceClient) {
    var _this;

    var logger = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : console;

    _classCallCheck(this, DelegateManagerClient);

    _this = _super.call(this, ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, governanceClient, logger);

    _defineProperty$1(_assertThisInitialized(_this), "audiusTokenClient", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "stakingProxyClient", void 0);

    _this.audiusTokenClient = audiusTokenClient;
    _this.stakingProxyClient = stakingProxyClient;
    return _this;
  }

  _createClass(DelegateManagerClient, [{
    key: "delegateStake",
    value: function () {
      var _delegateStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(targetSP, amount) {
        var _tx$events, _tx$events$IncreaseDe;

        var contractAddress, tx0, method, tx, returnValues;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.stakingProxyClient.getAddress();

              case 2:
                contractAddress = _context.sent;
                _context.next = 5;
                return this.audiusTokenClient.approve(contractAddress, amount);

              case 5:
                tx0 = _context.sent;
                _context.next = 8;
                return this.getMethod('delegateStake', targetSP, amount);

              case 8:
                method = _context.sent;
                _context.next = 11;
                return this.web3Manager.sendTransaction(method);

              case 11:
                tx = _context.sent;
                returnValues = (_tx$events = tx.events) === null || _tx$events === void 0 ? void 0 : (_tx$events$IncreaseDe = _tx$events['IncreaseDelegatedStake']) === null || _tx$events$IncreaseDe === void 0 ? void 0 : _tx$events$IncreaseDe.returnValues;
                return _context.abrupt("return", {
                  txReceipt: tx,
                  tokenApproveReceipt: tx0,
                  delegator: returnValues === null || returnValues === void 0 ? void 0 : returnValues._delegator,
                  serviceProvider: returnValues === null || returnValues === void 0 ? void 0 : returnValues._serviceProvider,
                  increaseAmount: Utils.toBN(returnValues === null || returnValues === void 0 ? void 0 : returnValues._increaseAmount)
                });

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function delegateStake(_x, _x2) {
        return _delegateStake.apply(this, arguments);
      }

      return delegateStake;
    }()
    /* Pass either delegator or serviceProvider filters */

  }, {
    key: "getIncreaseDelegateStakeEvents",
    value: function () {
      var _getIncreaseDelegateStakeEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref) {
        var delegator, serviceProvider, _ref$queryStartBlock, queryStartBlock, contract, filter, events;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                delegator = _ref.delegator, serviceProvider = _ref.serviceProvider, _ref$queryStartBlock = _ref.queryStartBlock, queryStartBlock = _ref$queryStartBlock === void 0 ? 0 : _ref$queryStartBlock;
                _context2.next = 3;
                return this.getContract();

              case 3:
                contract = _context2.sent;
                filter = {};

                if (delegator) {
                  filter._delegator = delegator;
                } else {
                  filter._serviceProvider = serviceProvider;
                }

                _context2.next = 8;
                return contract.getPastEvents('IncreaseDelegatedStake', {
                  fromBlock: queryStartBlock,
                  filter: filter
                });

              case 8:
                events = _context2.sent;
                return _context2.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    delegator: event.returnValues['_delegator'],
                    increaseAmount: Utils.toBN(event.returnValues['_increaseAmount']),
                    serviceProvider: event.returnValues['_serviceProvider']
                  };
                }));

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getIncreaseDelegateStakeEvents(_x3) {
        return _getIncreaseDelegateStakeEvents.apply(this, arguments);
      }

      return getIncreaseDelegateStakeEvents;
    }()
  }, {
    key: "getDecreaseDelegateStakeEvents",
    value: function () {
      var _getDecreaseDelegateStakeEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref2) {
        var delegator, serviceProvider, _ref2$queryStartBlock, queryStartBlock, contract, filter, events;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                delegator = _ref2.delegator, serviceProvider = _ref2.serviceProvider, _ref2$queryStartBlock = _ref2.queryStartBlock, queryStartBlock = _ref2$queryStartBlock === void 0 ? 0 : _ref2$queryStartBlock;
                _context3.next = 3;
                return this.getContract();

              case 3:
                contract = _context3.sent;
                filter = {};

                if (delegator) {
                  filter._delegator = delegator;
                }

                if (serviceProvider) {
                  filter._serviceProvider = serviceProvider;
                }

                _context3.next = 9;
                return contract.getPastEvents('UndelegateStakeRequestEvaluated', {
                  fromBlock: queryStartBlock,
                  filter: filter
                });

              case 9:
                events = _context3.sent;
                return _context3.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    delegator: event.returnValues['_delegator'],
                    amount: Utils.toBN(event.returnValues['_amount']),
                    serviceProvider: event.returnValues['_serviceProvider']
                  };
                }));

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getDecreaseDelegateStakeEvents(_x4) {
        return _getDecreaseDelegateStakeEvents.apply(this, arguments);
      }

      return getDecreaseDelegateStakeEvents;
    }()
  }, {
    key: "getUndelegateStakeRequestedEvents",
    value: function () {
      var _getUndelegateStakeRequestedEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_ref3) {
        var delegator, serviceProvider, _ref3$queryStartBlock, queryStartBlock, contract, filter, events;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                delegator = _ref3.delegator, serviceProvider = _ref3.serviceProvider, _ref3$queryStartBlock = _ref3.queryStartBlock, queryStartBlock = _ref3$queryStartBlock === void 0 ? 0 : _ref3$queryStartBlock;
                _context4.next = 3;
                return this.getContract();

              case 3:
                contract = _context4.sent;
                filter = {};

                if (delegator) {
                  filter._delegator = delegator;
                }

                if (serviceProvider) {
                  filter._serviceProvider = serviceProvider;
                }

                _context4.next = 9;
                return contract.getPastEvents('UndelegateStakeRequested', {
                  fromBlock: queryStartBlock,
                  filter: filter
                });

              case 9:
                events = _context4.sent;
                return _context4.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    lockupExpiryBlock: parseInt(event.returnValues['_lockupExpiryBlock']),
                    delegator: event.returnValues['_delegator'],
                    amount: Utils.toBN(event.returnValues['_amount']),
                    serviceProvider: event.returnValues['_serviceProvider']
                  };
                }));

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getUndelegateStakeRequestedEvents(_x5) {
        return _getUndelegateStakeRequestedEvents.apply(this, arguments);
      }

      return getUndelegateStakeRequestedEvents;
    }()
  }, {
    key: "getUndelegateStakeCancelledEvents",
    value: function () {
      var _getUndelegateStakeCancelledEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref4) {
        var delegator, serviceProvider, _ref4$queryStartBlock, queryStartBlock, contract, filter, events;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                delegator = _ref4.delegator, serviceProvider = _ref4.serviceProvider, _ref4$queryStartBlock = _ref4.queryStartBlock, queryStartBlock = _ref4$queryStartBlock === void 0 ? 0 : _ref4$queryStartBlock;
                _context5.next = 3;
                return this.getContract();

              case 3:
                contract = _context5.sent;
                filter = {};

                if (delegator) {
                  filter._delegator = delegator;
                }

                if (serviceProvider) {
                  filter._serviceProvider = serviceProvider;
                }

                _context5.next = 9;
                return contract.getPastEvents('UndelegateStakeRequestCancelled', {
                  fromBlock: queryStartBlock,
                  filter: filter
                });

              case 9:
                events = _context5.sent;
                return _context5.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    delegator: event.returnValues['_delegator'],
                    amount: Utils.toBN(event.returnValues['_amount']),
                    serviceProvider: event.returnValues['_serviceProvider']
                  };
                }));

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getUndelegateStakeCancelledEvents(_x6) {
        return _getUndelegateStakeCancelledEvents.apply(this, arguments);
      }

      return getUndelegateStakeCancelledEvents;
    }()
  }, {
    key: "getClaimEvents",
    value: function () {
      var _getClaimEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref5) {
        var claimer, _ref5$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                claimer = _ref5.claimer, _ref5$queryStartBlock = _ref5.queryStartBlock, queryStartBlock = _ref5$queryStartBlock === void 0 ? 0 : _ref5$queryStartBlock;
                _context6.next = 3;
                return this.getContract();

              case 3:
                contract = _context6.sent;
                _context6.next = 6;
                return contract.getPastEvents('Claim', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _claimer: claimer
                  }
                });

              case 6:
                events = _context6.sent;
                return _context6.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    claimer: event.returnValues['_claimer'],
                    rewards: Utils.toBN(event.returnValues['_rewards']),
                    newTotal: Utils.toBN(event.returnValues['_newTotal'])
                  };
                }));

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getClaimEvents(_x7) {
        return _getClaimEvents.apply(this, arguments);
      }

      return getClaimEvents;
    }()
  }, {
    key: "getSlashEvents",
    value: function () {
      var _getSlashEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(_ref6) {
        var target, _ref6$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                target = _ref6.target, _ref6$queryStartBlock = _ref6.queryStartBlock, queryStartBlock = _ref6$queryStartBlock === void 0 ? 0 : _ref6$queryStartBlock;
                _context7.next = 3;
                return this.getContract();

              case 3:
                contract = _context7.sent;
                _context7.next = 6;
                return contract.getPastEvents('Slash', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _target: target
                  }
                });

              case 6:
                events = _context7.sent;
                return _context7.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    target: event.returnValues['_target'],
                    amount: Utils.toBN(event.returnValues['_amount']),
                    newTotal: Utils.toBN(event.returnValues['_newTotal'])
                  };
                }));

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getSlashEvents(_x8) {
        return _getSlashEvents.apply(this, arguments);
      }

      return getSlashEvents;
    }()
  }, {
    key: "getDelegatorRemovedEvents",
    value: function () {
      var _getDelegatorRemovedEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(_ref7) {
        var target, _ref7$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                target = _ref7.target, _ref7$queryStartBlock = _ref7.queryStartBlock, queryStartBlock = _ref7$queryStartBlock === void 0 ? 0 : _ref7$queryStartBlock;
                _context8.next = 3;
                return this.getContract();

              case 3:
                contract = _context8.sent;
                _context8.next = 6;
                return contract.getPastEvents('DelegatorRemoved', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _target: target
                  }
                });

              case 6:
                events = _context8.sent;
                return _context8.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    serviceProvider: event.returnValues['_serviceProvider'],
                    delegator: event.returnValues['_delegator'],
                    unstakedAmount: Utils.toBN(event.returnValues['_unstakedAmount'])
                  };
                }));

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getDelegatorRemovedEvents(_x9) {
        return _getDelegatorRemovedEvents.apply(this, arguments);
      }

      return getDelegatorRemovedEvents;
    }()
  }, {
    key: "requestUndelegateStake",
    value: function () {
      var _requestUndelegateStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(targetSP, amount) {
        var method;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.getMethod('requestUndelegateStake', targetSP, amount);

              case 2:
                method = _context9.sent;
                _context9.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                return _context9.abrupt("return", _context9.sent);

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function requestUndelegateStake(_x10, _x11) {
        return _requestUndelegateStake.apply(this, arguments);
      }

      return requestUndelegateStake;
    }()
  }, {
    key: "cancelUndelegateStakeRequest",
    value: function () {
      var _cancelUndelegateStakeRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var method;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getMethod('cancelUndelegateStakeRequest');

              case 2:
                method = _context10.sent;
                _context10.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function cancelUndelegateStakeRequest() {
        return _cancelUndelegateStakeRequest.apply(this, arguments);
      }

      return cancelUndelegateStakeRequest;
    }()
  }, {
    key: "undelegateStake",
    value: function () {
      var _undelegateStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var _tx$events2, _tx$events2$Undelegat;

        var method, tx, returnValues;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.getMethod('undelegateStake');

              case 2:
                method = _context11.sent;
                _context11.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context11.sent;
                returnValues = (_tx$events2 = tx.events) === null || _tx$events2 === void 0 ? void 0 : (_tx$events2$Undelegat = _tx$events2['UndelegateStakeRequestEvaluated']) === null || _tx$events2$Undelegat === void 0 ? void 0 : _tx$events2$Undelegat.returnValues;
                return _context11.abrupt("return", {
                  txReceipt: tx,
                  delegator: returnValues._delegator,
                  serviceProvider: returnValues._serviceProvider,
                  decreaseAmount: Utils.toBN(returnValues._amount)
                });

              case 8:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function undelegateStake() {
        return _undelegateStake.apply(this, arguments);
      }

      return undelegateStake;
    }()
  }, {
    key: "claimRewards",
    value: function () {
      var _claimRewards = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(serviceProvider) {
        var txRetries,
            method,
            _args12 = arguments;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                txRetries = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : 5;
                _context12.next = 3;
                return this.getMethod('claimRewards', serviceProvider);

              case 3:
                method = _context12.sent;
                _context12.next = 6;
                return this.web3Manager.sendTransaction(method, null, null, txRetries);

              case 6:
                return _context12.abrupt("return", _context12.sent);

              case 7:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function claimRewards(_x12) {
        return _claimRewards.apply(this, arguments);
      }

      return claimRewards;
    }()
  }, {
    key: "requestRemoveDelegator",
    value: function () {
      var _requestRemoveDelegator = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(serviceProvider, delegator) {
        var method;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this.getMethod('requestRemoveDelegator', serviceProvider, delegator);

              case 2:
                method = _context13.sent;
                _context13.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                return _context13.abrupt("return", _context13.sent);

              case 6:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function requestRemoveDelegator(_x13, _x14) {
        return _requestRemoveDelegator.apply(this, arguments);
      }

      return requestRemoveDelegator;
    }()
  }, {
    key: "cancelRemoveDelegatorRequest",
    value: function () {
      var _cancelRemoveDelegatorRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(serviceProvider, delegator) {
        var method;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getMethod('cancelRemoveDelegatorRequest', serviceProvider, delegator);

              case 2:
                method = _context14.sent;
                _context14.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                return _context14.abrupt("return", _context14.sent);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function cancelRemoveDelegatorRequest(_x15, _x16) {
        return _cancelRemoveDelegatorRequest.apply(this, arguments);
      }

      return cancelRemoveDelegatorRequest;
    }()
  }, {
    key: "removeDelegator",
    value: function () {
      var _removeDelegator = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(serviceProvider, delegator) {
        var _tx$events3, _tx$events3$RemoveDel;

        var method, tx, returnValues;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this.getMethod('removeDelegator', serviceProvider, delegator);

              case 2:
                method = _context15.sent;
                _context15.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context15.sent;
                returnValues = (_tx$events3 = tx.events) === null || _tx$events3 === void 0 ? void 0 : (_tx$events3$RemoveDel = _tx$events3['RemoveDelegatorRequestEvaluated']) === null || _tx$events3$RemoveDel === void 0 ? void 0 : _tx$events3$RemoveDel.returnValues;
                return _context15.abrupt("return", {
                  txReceipt: tx,
                  delegator: returnValues._delegator,
                  serviceProvider: returnValues._serviceProvider,
                  unstakedAmount: Utils.toBN(returnValues._unstakedAmount)
                });

              case 8:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function removeDelegator(_x17, _x18) {
        return _removeDelegator.apply(this, arguments);
      }

      return removeDelegator;
    }() // ========================================= View Functions =========================================

  }, {
    key: "getDelegatorsList",
    value: function () {
      var _getDelegatorsList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(serviceProvider) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.getMethod('getDelegatorsList', serviceProvider);

              case 2:
                method = _context16.sent;
                _context16.next = 5;
                return method.call();

              case 5:
                info = _context16.sent;
                return _context16.abrupt("return", info);

              case 7:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getDelegatorsList(_x19) {
        return _getDelegatorsList.apply(this, arguments);
      }

      return getDelegatorsList;
    }()
  }, {
    key: "getTotalDelegatedToServiceProvider",
    value: function () {
      var _getTotalDelegatedToServiceProvider = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(serviceProvider) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this.getMethod('getTotalDelegatedToServiceProvider', serviceProvider);

              case 2:
                method = _context17.sent;
                _context17.next = 5;
                return method.call();

              case 5:
                info = _context17.sent;
                return _context17.abrupt("return", Utils.toBN(info));

              case 7:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getTotalDelegatedToServiceProvider(_x20) {
        return _getTotalDelegatedToServiceProvider.apply(this, arguments);
      }

      return getTotalDelegatedToServiceProvider;
    }()
  }, {
    key: "getTotalDelegatorStake",
    value: function () {
      var _getTotalDelegatorStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(delegator) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.getMethod('getTotalDelegatorStake', delegator);

              case 2:
                method = _context18.sent;
                _context18.next = 5;
                return method.call();

              case 5:
                info = _context18.sent;
                return _context18.abrupt("return", Utils.toBN(info));

              case 7:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getTotalDelegatorStake(_x21) {
        return _getTotalDelegatorStake.apply(this, arguments);
      }

      return getTotalDelegatorStake;
    }()
  }, {
    key: "getTotalLockedDelegationForServiceProvider",
    value: function () {
      var _getTotalLockedDelegationForServiceProvider = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(serviceProvider) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.getMethod('getTotalLockedDelegationForServiceProvider', serviceProvider);

              case 2:
                method = _context19.sent;
                _context19.next = 5;
                return method.call();

              case 5:
                info = _context19.sent;
                return _context19.abrupt("return", Utils.toBN(info));

              case 7:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getTotalLockedDelegationForServiceProvider(_x22) {
        return _getTotalLockedDelegationForServiceProvider.apply(this, arguments);
      }

      return getTotalLockedDelegationForServiceProvider;
    }()
  }, {
    key: "getDelegatorStakeForServiceProvider",
    value: function () {
      var _getDelegatorStakeForServiceProvider = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(delegator, serviceProvider) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getMethod('getDelegatorStakeForServiceProvider', delegator, serviceProvider);

              case 2:
                method = _context20.sent;
                _context20.next = 5;
                return method.call();

              case 5:
                info = _context20.sent;
                return _context20.abrupt("return", Utils.toBN(info));

              case 7:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getDelegatorStakeForServiceProvider(_x23, _x24) {
        return _getDelegatorStakeForServiceProvider.apply(this, arguments);
      }

      return getDelegatorStakeForServiceProvider;
    }()
  }, {
    key: "getPendingUndelegateRequest",
    value: function () {
      var _getPendingUndelegateRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(delegator) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this.getMethod('getPendingUndelegateRequest', delegator);

              case 2:
                method = _context21.sent;
                _context21.next = 5;
                return method.call();

              case 5:
                info = _context21.sent;
                return _context21.abrupt("return", {
                  amount: Utils.toBN(info.amount),
                  lockupExpiryBlock: parseInt(info.lockupExpiryBlock),
                  target: info.target
                });

              case 7:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getPendingUndelegateRequest(_x25) {
        return _getPendingUndelegateRequest.apply(this, arguments);
      }

      return getPendingUndelegateRequest;
    }()
  }, {
    key: "getPendingRemoveDelegatorRequest",
    value: function () {
      var _getPendingRemoveDelegatorRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(serviceProvider, delegator) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getMethod('getPendingRemoveDelegatorRequest', serviceProvider, delegator);

              case 2:
                method = _context22.sent;
                _context22.next = 5;
                return method.call();

              case 5:
                info = _context22.sent;
                return _context22.abrupt("return", {
                  lockupExpiryBlock: parseInt(info)
                });

              case 7:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getPendingRemoveDelegatorRequest(_x26, _x27) {
        return _getPendingRemoveDelegatorRequest.apply(this, arguments);
      }

      return getPendingRemoveDelegatorRequest;
    }()
  }, {
    key: "getUndelegateLockupDuration",
    value: function () {
      var _getUndelegateLockupDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.getMethod('getUndelegateLockupDuration');

              case 2:
                method = _context23.sent;
                _context23.next = 5;
                return method.call();

              case 5:
                info = _context23.sent;
                return _context23.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getUndelegateLockupDuration() {
        return _getUndelegateLockupDuration.apply(this, arguments);
      }

      return getUndelegateLockupDuration;
    }()
  }, {
    key: "getMaxDelegators",
    value: function () {
      var _getMaxDelegators = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.getMethod('getMaxDelegators');

              case 2:
                method = _context24.sent;
                _context24.next = 5;
                return method.call();

              case 5:
                info = _context24.sent;
                return _context24.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getMaxDelegators() {
        return _getMaxDelegators.apply(this, arguments);
      }

      return getMaxDelegators;
    }()
  }, {
    key: "getMinDelegationAmount",
    value: function () {
      var _getMinDelegationAmount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this.getMethod('getMinDelegationAmount');

              case 2:
                method = _context25.sent;
                _context25.next = 5;
                return method.call();

              case 5:
                info = _context25.sent;
                return _context25.abrupt("return", Utils.toBN(info));

              case 7:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getMinDelegationAmount() {
        return _getMinDelegationAmount.apply(this, arguments);
      }

      return getMinDelegationAmount;
    }()
  }, {
    key: "getRemoveDelegatorLockupDuration",
    value: function () {
      var _getRemoveDelegatorLockupDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.getMethod('getRemoveDelegatorLockupDuration');

              case 2:
                method = _context26.sent;
                _context26.next = 5;
                return method.call();

              case 5:
                info = _context26.sent;
                return _context26.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function getRemoveDelegatorLockupDuration() {
        return _getRemoveDelegatorLockupDuration.apply(this, arguments);
      }

      return getRemoveDelegatorLockupDuration;
    }()
  }, {
    key: "getRemoveDelegatorEvalDuration",
    value: function () {
      var _getRemoveDelegatorEvalDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                _context27.next = 2;
                return this.getMethod('getRemoveDelegatorEvalDuration');

              case 2:
                method = _context27.sent;
                _context27.next = 5;
                return method.call();

              case 5:
                info = _context27.sent;
                return _context27.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getRemoveDelegatorEvalDuration() {
        return _getRemoveDelegatorEvalDuration.apply(this, arguments);
      }

      return getRemoveDelegatorEvalDuration;
    }()
  }, {
    key: "getGovernanceAddress",
    value: function () {
      var _getGovernanceAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.getMethod('getGovernanceAddress');

              case 2:
                method = _context28.sent;
                _context28.next = 5;
                return method.call();

              case 5:
                info = _context28.sent;
                return _context28.abrupt("return", info);

              case 7:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getGovernanceAddress() {
        return _getGovernanceAddress.apply(this, arguments);
      }

      return getGovernanceAddress;
    }()
  }, {
    key: "getServiceProviderFactoryAddress",
    value: function () {
      var _getServiceProviderFactoryAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.next = 2;
                return this.getMethod('getServiceProviderFactoryAddress');

              case 2:
                method = _context29.sent;
                _context29.next = 5;
                return method.call();

              case 5:
                info = _context29.sent;
                return _context29.abrupt("return", info);

              case 7:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getServiceProviderFactoryAddress() {
        return _getServiceProviderFactoryAddress.apply(this, arguments);
      }

      return getServiceProviderFactoryAddress;
    }()
  }, {
    key: "getClaimsManagerAddress",
    value: function () {
      var _getClaimsManagerAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this.getMethod('getClaimsManagerAddress');

              case 2:
                method = _context30.sent;
                _context30.next = 5;
                return method.call();

              case 5:
                info = _context30.sent;
                return _context30.abrupt("return", info);

              case 7:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getClaimsManagerAddress() {
        return _getClaimsManagerAddress.apply(this, arguments);
      }

      return getClaimsManagerAddress;
    }()
  }, {
    key: "getStakingAddress",
    value: function () {
      var _getStakingAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                _context31.next = 2;
                return this.getMethod('getStakingAddress');

              case 2:
                method = _context31.sent;
                _context31.next = 5;
                return method.call();

              case 5:
                info = _context31.sent;
                return _context31.abrupt("return", info);

              case 7:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getStakingAddress() {
        return _getStakingAddress.apply(this, arguments);
      }

      return getStakingAddress;
    }()
  }, {
    key: "getSPMinDelegationAmount",
    value: function () {
      var _getSPMinDelegationAmount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(_ref8) {
        var serviceProvider, method, info;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                serviceProvider = _ref8.serviceProvider;
                _context32.next = 3;
                return this.getMethod('getSPMinDelegationAmount', serviceProvider);

              case 3:
                method = _context32.sent;
                _context32.next = 6;
                return method.call();

              case 6:
                info = _context32.sent;
                return _context32.abrupt("return", Utils.toBN(info));

              case 8:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getSPMinDelegationAmount(_x28) {
        return _getSPMinDelegationAmount.apply(this, arguments);
      }

      return getSPMinDelegationAmount;
    }()
  }, {
    key: "updateSPMinDelegationAmount",
    value: function () {
      var _updateSPMinDelegationAmount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(_ref9) {
        var serviceProvider, amount, method;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                serviceProvider = _ref9.serviceProvider, amount = _ref9.amount;
                _context33.next = 3;
                return this.getMethod('updateSPMinDelegationAmount', serviceProvider, amount);

              case 3:
                method = _context33.sent;
                _context33.next = 6;
                return this.web3Manager.sendTransaction(method);

              case 6:
                return _context33.abrupt("return", _context33.sent);

              case 7:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function updateSPMinDelegationAmount(_x29) {
        return _updateSPMinDelegationAmount.apply(this, arguments);
      }

      return updateSPMinDelegationAmount;
    }()
  }, {
    key: "updateRemoveDelegatorLockupDuration",
    value: function () {
      var _updateRemoveDelegatorLockupDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(duration) {
        var method;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                _context34.next = 2;
                return this.getGovernedMethod('updateRemoveDelegatorLockupDuration', duration);

              case 2:
                method = _context34.sent;
                _context34.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                return _context34.abrupt("return", _context34.sent);

              case 6:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function updateRemoveDelegatorLockupDuration(_x30) {
        return _updateRemoveDelegatorLockupDuration.apply(this, arguments);
      }

      return updateRemoveDelegatorLockupDuration;
    }()
  }, {
    key: "updateUndelegateLockupDuration",
    value: function () {
      var _updateUndelegateLockupDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(duration) {
        var method;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                _context35.next = 2;
                return this.getGovernedMethod('updateUndelegateLockupDuration', duration);

              case 2:
                method = _context35.sent;
                _context35.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                return _context35.abrupt("return", _context35.sent);

              case 6:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function updateUndelegateLockupDuration(_x31) {
        return _updateUndelegateLockupDuration.apply(this, arguments);
      }

      return updateUndelegateLockupDuration;
    }()
  }]);

  return DelegateManagerClient;
}(GovernedContractClient);

var ClaimsManagerClient = /*#__PURE__*/function (_ContractClient) {
  _inherits(ClaimsManagerClient, _ContractClient);

  var _super = _createSuper(ClaimsManagerClient);

  function ClaimsManagerClient() {
    var _this;

    _classCallCheck(this, ClaimsManagerClient);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "web3Manager", void 0);

    return _this;
  }

  _createClass(ClaimsManagerClient, [{
    key: "getFundingRoundBlockDiff",
    value:
    /* ------- GETTERS ------- */
    // Get the duration of a funding round in blocks
    function () {
      var _getFundingRoundBlockDiff = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getMethod('getFundingRoundBlockDiff');

              case 2:
                method = _context.sent;
                _context.next = 5;
                return method.call();

              case 5:
                info = _context.sent;
                return _context.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getFundingRoundBlockDiff() {
        return _getFundingRoundBlockDiff.apply(this, arguments);
      }

      return getFundingRoundBlockDiff;
    }() // Get the last block where a funding round was initiated

  }, {
    key: "getLastFundedBlock",
    value: function () {
      var _getLastFundedBlock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getMethod('getLastFundedBlock');

              case 2:
                method = _context2.sent;
                _context2.next = 5;
                return method.call();

              case 5:
                info = _context2.sent;
                return _context2.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getLastFundedBlock() {
        return _getLastFundedBlock.apply(this, arguments);
      }

      return getLastFundedBlock;
    }() // Get the amount funded per round in wei

  }, {
    key: "getFundsPerRound",
    value: function () {
      var _getFundsPerRound = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getMethod('getFundsPerRound');

              case 2:
                method = _context3.sent;
                _context3.next = 5;
                return method.call();

              case 5:
                info = _context3.sent;
                return _context3.abrupt("return", Utils.toBN(info));

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getFundsPerRound() {
        return _getFundsPerRound.apply(this, arguments);
      }

      return getFundsPerRound;
    }() // Get the total amount claimed in the current round

  }, {
    key: "getTotalClaimedInRound",
    value: function () {
      var _getTotalClaimedInRound = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getMethod('getTotalClaimedInRound');

              case 2:
                method = _context4.sent;
                _context4.next = 5;
                return method.call();

              case 5:
                info = _context4.sent;
                return _context4.abrupt("return", Utils.toBN(info));

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getTotalClaimedInRound() {
        return _getTotalClaimedInRound.apply(this, arguments);
      }

      return getTotalClaimedInRound;
    }() // Get the Governance address

  }, {
    key: "getGovernanceAddress",
    value: function () {
      var _getGovernanceAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getMethod('getGovernanceAddress');

              case 2:
                method = _context5.sent;
                _context5.next = 5;
                return method.call();

              case 5:
                info = _context5.sent;
                return _context5.abrupt("return", info);

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getGovernanceAddress() {
        return _getGovernanceAddress.apply(this, arguments);
      }

      return getGovernanceAddress;
    }() // Get the ServiceProviderFactory address

  }, {
    key: "getServiceProviderFactoryAddress",
    value: function () {
      var _getServiceProviderFactoryAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getMethod('getServiceProviderFactoryAddress');

              case 2:
                method = _context6.sent;
                _context6.next = 5;
                return method.call();

              case 5:
                info = _context6.sent;
                return _context6.abrupt("return", info);

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getServiceProviderFactoryAddress() {
        return _getServiceProviderFactoryAddress.apply(this, arguments);
      }

      return getServiceProviderFactoryAddress;
    }() // Get the DelegateManager address

  }, {
    key: "getDelegateManagerAddress",
    value: function () {
      var _getDelegateManagerAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getMethod('getDelegateManagerAddress');

              case 2:
                method = _context7.sent;
                _context7.next = 5;
                return method.call();

              case 5:
                info = _context7.sent;
                return _context7.abrupt("return", info);

              case 7:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getDelegateManagerAddress() {
        return _getDelegateManagerAddress.apply(this, arguments);
      }

      return getDelegateManagerAddress;
    }() // Get the Staking address

  }, {
    key: "getStakingAddress",
    value: function () {
      var _getStakingAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getMethod('getStakingAddress');

              case 2:
                method = _context8.sent;
                _context8.next = 5;
                return method.call();

              case 5:
                info = _context8.sent;
                return _context8.abrupt("return", info);

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getStakingAddress() {
        return _getStakingAddress.apply(this, arguments);
      }

      return getStakingAddress;
    }() // Returns boolean indicating whether a claim is considered pending

  }, {
    key: "claimPending",
    value: function () {
      var _claimPending = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(address) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.getMethod('claimPending', address);

              case 2:
                method = _context9.sent;
                _context9.next = 5;
                return method.call();

              case 5:
                info = _context9.sent;
                return _context9.abrupt("return", info);

              case 7:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function claimPending(_x) {
        return _claimPending.apply(this, arguments);
      }

      return claimPending;
    }() // Returns boolean indicating whether a claim is considered pending

  }, {
    key: "initiateRound",
    value: function () {
      var _initiateRound = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var txRetries,
            method,
            _args10 = arguments;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                txRetries = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : 5;
                _context10.next = 3;
                return this.getMethod('initiateRound');

              case 3:
                method = _context10.sent;
                _context10.next = 6;
                return this.web3Manager.sendTransaction(method, null, null, txRetries);

              case 6:
                return _context10.abrupt("return", _context10.sent);

              case 7:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function initiateRound() {
        return _initiateRound.apply(this, arguments);
      }

      return initiateRound;
    }() // Fetches the claim processed events

  }, {
    key: "getClaimProcessedEvents",
    value: function () {
      var _getClaimProcessedEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(_ref) {
        var claimer, _ref$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                claimer = _ref.claimer, _ref$queryStartBlock = _ref.queryStartBlock, queryStartBlock = _ref$queryStartBlock === void 0 ? 0 : _ref$queryStartBlock;
                _context11.next = 3;
                return this.getContract();

              case 3:
                contract = _context11.sent;
                _context11.next = 6;
                return contract.getPastEvents('ClaimProcessed', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _claimer: claimer
                  }
                });

              case 6:
                events = _context11.sent;
                return _context11.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    claimer: event.returnValues['_claimer'],
                    rewards: Utils.toBN(event.returnValues['_rewards']),
                    oldTotal: Utils.toBN(event.returnValues['_oldTotal']),
                    newTotal: Utils.toBN(event.returnValues['_newTotal'])
                  };
                }));

              case 8:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getClaimProcessedEvents(_x2) {
        return _getClaimProcessedEvents.apply(this, arguments);
      }

      return getClaimProcessedEvents;
    }()
  }]);

  return ClaimsManagerClient;
}(ContractClient);

var ClaimDistributionClient = /*#__PURE__*/function (_ContractClient) {
  _inherits(ClaimDistributionClient, _ContractClient);

  var _super = _createSuper(ClaimDistributionClient);

  function ClaimDistributionClient() {
    _classCallCheck(this, ClaimDistributionClient);

    return _super.apply(this, arguments);
  }

  _createClass(ClaimDistributionClient, [{
    key: "isClaimed",
    value: // ===================== Contract Methods =====================

    /**
     * Calls the contract method to check if the claim index has been claimed
     */
    function () {
      var _isClaimed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(index) {
        var method, isClaimed;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getMethod('isClaimed', index);

              case 2:
                method = _context.sent;
                _context.next = 5;
                return method.call();

              case 5:
                isClaimed = _context.sent;
                return _context.abrupt("return", isClaimed);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function isClaimed(_x) {
        return _isClaimed.apply(this, arguments);
      }

      return isClaimed;
    }()
    /**
     * Proxies the calls the contract method to make a claim
     * @param index
     * @param account
     * @param amount
     * @param merkleProof
     * @returns transaction
     */

  }, {
    key: "claim",
    value: function () {
      var _claim = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(index, account, amount, merkleProof) {
        var method, contractAddress, tx;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getMethod('claim', index, account, amount, merkleProof);

              case 2:
                method = _context2.sent;
                _context2.next = 5;
                return this.getAddress();

              case 5:
                contractAddress = _context2.sent;
                _context2.next = 8;
                return this.web3Manager.relayTransaction(method, contractAddress, account);

              case 8:
                tx = _context2.sent;
                return _context2.abrupt("return", tx);

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function claim(_x2, _x3, _x4, _x5) {
        return _claim.apply(this, arguments);
      }

      return claim;
    }()
  }]);

  return ClaimDistributionClient;
}(ContractClient);

var WormholeClient = /*#__PURE__*/function () {
  function WormholeClient(ethWeb3Manager, contractABI, contractAddress, audiusTokenClient) {
    _classCallCheck(this, WormholeClient);

    _defineProperty$1(this, "ethWeb3Manager", void 0);

    _defineProperty$1(this, "contractABI", void 0);

    _defineProperty$1(this, "contractAddress", void 0);

    _defineProperty$1(this, "web3", void 0);

    _defineProperty$1(this, "audiusTokenClient", void 0);

    _defineProperty$1(this, "WormholeContract", void 0);

    this.ethWeb3Manager = ethWeb3Manager;
    this.contractABI = contractABI;
    this.contractAddress = contractAddress;
    this.web3 = this.ethWeb3Manager.getWeb3();
    this.audiusTokenClient = audiusTokenClient;
    this.WormholeContract = new this.web3.eth.Contract(this.contractABI, this.contractAddress);
  } // Get the name of the contract


  _createClass(WormholeClient, [{
    key: "nonces",
    value: function () {
      var _nonces = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(wallet) {
        var nonce, number;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.WormholeContract.methods.nonces(wallet).call({
                  _audiusBustCache: Date.now()
                });

              case 2:
                nonce = _context.sent;
                number = this.web3.utils.toBN(nonce).toNumber();
                return _context.abrupt("return", number);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function nonces(_x) {
        return _nonces.apply(this, arguments);
      }

      return nonces;
    }()
    /* ------- SETTERS ------- */

  }, {
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(fromAcct, wormholeAddress, relayer) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                method = this.WormholeContract.methods.initialize(this.audiusTokenClient.contractAddress, wormholeAddress);
                _context2.next = 3;
                return this.ethWeb3Manager.relayTransaction(method, this.contractAddress, fromAcct, relayer,
                /* retries */
                0);

              case 3:
                tx = _context2.sent;
                return _context2.abrupt("return", {
                  txReceipt: tx
                });

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function initialize(_x2, _x3, _x4) {
        return _initialize.apply(this, arguments);
      }

      return initialize;
    }()
    /**
     * Transfers in eth from the user's wallet to the wormhole contract and
     * specifies a solana wallet to realized the tokens in SOL
     */

  }, {
    key: "transferTokens",
    value: function () {
      var _transferTokens = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(fromAcct, amount, chainId, solanaAccount, arbiterFee, deadline, signedDigest, relayer) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                method = this.WormholeContract.methods.transferTokens(fromAcct, amount, chainId, solanaAccount, arbiterFee, deadline, signedDigest.v, signedDigest.r, signedDigest.s);
                _context3.next = 3;
                return this.ethWeb3Manager.relayTransaction(method, this.contractAddress, fromAcct, relayer,
                /* retries */
                0, null);

              case 3:
                tx = _context3.sent;
                return _context3.abrupt("return", tx);

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function transferTokens(_x5, _x6, _x7, _x8, _x9, _x10, _x11, _x12) {
        return _transferTokens.apply(this, arguments);
      }

      return transferTokens;
    }()
  }]);

  return WormholeClient;
}();

var EthRewardsManagerClient = /*#__PURE__*/function (_ContractClient) {
  _inherits(EthRewardsManagerClient, _ContractClient);

  var _super = _createSuper(EthRewardsManagerClient);

  function EthRewardsManagerClient() {
    _classCallCheck(this, EthRewardsManagerClient);

    return _super.apply(this, arguments);
  }

  _createClass(EthRewardsManagerClient, [{
    key: "token",
    value:
    /* ------- GETTERS ------- */
    // Get the token used by the contract
    function () {
      var _token = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getMethod('token');

              case 2:
                method = _context.sent;
                _context.next = 5;
                return method.call();

              case 5:
                info = _context.sent;
                return _context.abrupt("return", info);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function token() {
        return _token.apply(this, arguments);
      }

      return token;
    }() // Get the Governance address

  }, {
    key: "getGovernanceAddress",
    value: function () {
      var _getGovernanceAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getMethod('getGovernanceAddress');

              case 2:
                method = _context2.sent;
                _context2.next = 5;
                return method.call();

              case 5:
                info = _context2.sent;
                return _context2.abrupt("return", info);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getGovernanceAddress() {
        return _getGovernanceAddress.apply(this, arguments);
      }

      return getGovernanceAddress;
    }() // Get the recipient address

  }, {
    key: "getRecipientAddress",
    value: function () {
      var _getRecipientAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getMethod('getRecipientAddress');

              case 2:
                method = _context3.sent;
                _context3.next = 5;
                return method.call();

              case 5:
                info = _context3.sent;
                return _context3.abrupt("return", info);

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getRecipientAddress() {
        return _getRecipientAddress.apply(this, arguments);
      }

      return getRecipientAddress;
    }() // Get the anti abuse oracle addresses

  }, {
    key: "getAntiAbuseOracleAddresses",
    value: function () {
      var _getAntiAbuseOracleAddresses = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getMethod('getAntiAbuseOracleAddresses');

              case 2:
                method = _context4.sent;
                _context4.next = 5;
                return method.call();

              case 5:
                info = _context4.sent;
                return _context4.abrupt("return", info);

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAntiAbuseOracleAddresses() {
        return _getAntiAbuseOracleAddresses.apply(this, arguments);
      }

      return getAntiAbuseOracleAddresses;
    }()
  }]);

  return EthRewardsManagerClient;
}(ContractClient);

var TrustedNotifierManagerClient = /*#__PURE__*/function (_GovernedContractClie) {
  _inherits(TrustedNotifierManagerClient, _GovernedContractClie);

  var _super = _createSuper(TrustedNotifierManagerClient);

  function TrustedNotifierManagerClient() {
    _classCallCheck(this, TrustedNotifierManagerClient);

    return _super.apply(this, arguments);
  }

  _createClass(TrustedNotifierManagerClient, [{
    key: "registerNotifier",
    value:
    /**
     * Register Trusted Notifier with specified fields (wallet, endpoint, email)
     * @notice Only callable by Governance contract
     * @notice All fields must be unique and non-falsey
     * @notice New Trusted Notifier is assigned an auto-incremented integer ID
     * @returns Newly assigned integer ID
     */
    function () {
      var _registerNotifier = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(wallet, endpoint, email) {
        var privateKey,
            method,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                privateKey = _args.length > 3 && _args[3] !== undefined ? _args[3] : null;
                _context.next = 3;
                return this.getGovernedMethod('registerNotifier', wallet, endpoint, email);

              case 3:
                method = _context.sent;
                _context.t0 = this.web3Manager;
                _context.t1 = method;
                _context.next = 8;
                return this.governanceClient.getAddress();

              case 8:
                _context.t2 = _context.sent;
                _context.t3 = privateKey;
                _context.next = 12;
                return _context.t0.sendTransaction.call(_context.t0, _context.t1, _context.t2, _context.t3);

              case 12:
                return _context.abrupt("return", _context.sent);

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function registerNotifier(_x, _x2, _x3) {
        return _registerNotifier.apply(this, arguments);
      }

      return registerNotifier;
    }()
    /**
     * Deregister Trusted Notifier associated with wallet
     * @notice Only callable by Governance contract or wallet
     * @returns ID of deregistered Trusted Notifier
     */

  }, {
    key: "deregisterNotifier",
    value: function () {
      var _deregisterNotifier = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(wallet) {
        var privateKey,
            method,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                privateKey = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;
                _context2.next = 3;
                return this.getGovernedMethod('deregisterNotifier', wallet);

              case 3:
                method = _context2.sent;
                _context2.t0 = this.web3Manager;
                _context2.t1 = method;
                _context2.next = 8;
                return this.governanceClient.getAddress();

              case 8:
                _context2.t2 = _context2.sent;
                _context2.t3 = privateKey;
                _context2.next = 12;
                return _context2.t0.sendTransaction.call(_context2.t0, _context2.t1, _context2.t2, _context2.t3);

              case 12:
                return _context2.abrupt("return", _context2.sent);

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function deregisterNotifier(_x4) {
        return _deregisterNotifier.apply(this, arguments);
      }

      return deregisterNotifier;
    }()
  }, {
    key: "getLatestNotifierID",
    value: function () {
      var _getLatestNotifierID = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var method, ID;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getMethod('getLatestNotifierID');

              case 2:
                method = _context3.sent;
                _context3.next = 5;
                return method.call();

              case 5:
                ID = _context3.sent;
                return _context3.abrupt("return", parseInt(ID));

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getLatestNotifierID() {
        return _getLatestNotifierID.apply(this, arguments);
      }

      return getLatestNotifierID;
    }()
    /**
     * Returns all TrustedNotifier info associated with ID
     */

  }, {
    key: "getNotifierForID",
    value: function () {
      var _getNotifierForID = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(ID) {
        var method, notifierInfo;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getMethod('getNotifierForID', ID);

              case 2:
                method = _context4.sent;
                _context4.next = 5;
                return method.call();

              case 5:
                notifierInfo = _context4.sent;
                return _context4.abrupt("return", {
                  wallet: notifierInfo.wallet,
                  endpoint: notifierInfo.endpoint.replace(/\/$/, ''),
                  email: notifierInfo.email.replace(/\/$/, '')
                });

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getNotifierForID(_x5) {
        return _getNotifierForID.apply(this, arguments);
      }

      return getNotifierForID;
    }()
    /**
     * Returns all TrustedNotifier info associated with wallet
     */

  }, {
    key: "getNotifierForWallet",
    value: function () {
      var _getNotifierForWallet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(wallet) {
        var method, notifierInfo;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getMethod('getNotifierForWallet', wallet);

              case 2:
                method = _context5.sent;
                _context5.next = 5;
                return method.call();

              case 5:
                notifierInfo = _context5.sent;
                return _context5.abrupt("return", {
                  ID: notifierInfo.ID,
                  endpoint: notifierInfo.endpoint.replace(/\/$/, ''),
                  email: notifierInfo.email.replace(/\/$/, '')
                });

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getNotifierForWallet(_x6) {
        return _getNotifierForWallet.apply(this, arguments);
      }

      return getNotifierForWallet;
    }()
    /**
     * Returns all TrustedNotifier info associated with endpoint
     */

  }, {
    key: "getNotifierForEndpoint",
    value: function () {
      var _getNotifierForEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(endpoint) {
        var method, notifierInfo;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getMethod('getNotifierForEndpoint', endpoint);

              case 2:
                method = _context6.sent;
                _context6.next = 5;
                return method.call();

              case 5:
                notifierInfo = _context6.sent;
                return _context6.abrupt("return", {
                  ID: notifierInfo.ID,
                  wallet: notifierInfo.wallet,
                  email: notifierInfo.email.replace(/\/$/, '')
                });

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getNotifierForEndpoint(_x7) {
        return _getNotifierForEndpoint.apply(this, arguments);
      }

      return getNotifierForEndpoint;
    }()
    /**
     * Returns all TrustedNotifier info associated with email
     */

  }, {
    key: "getNotifierForEmail",
    value: function () {
      var _getNotifierForEmail = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(email) {
        var method, notifierInfo;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getMethod('getNotifierForEmail', email);

              case 2:
                method = _context7.sent;
                _context7.next = 5;
                return method.call();

              case 5:
                notifierInfo = _context7.sent;
                return _context7.abrupt("return", {
                  ID: notifierInfo.ID,
                  wallet: notifierInfo.wallet,
                  endpoint: notifierInfo.endpoint.replace(/\/$/, '')
                });

              case 7:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getNotifierForEmail(_x8) {
        return _getNotifierForEmail.apply(this, arguments);
      }

      return getNotifierForEmail;
    }()
  }]);

  return TrustedNotifierManagerClient;
}(GovernedContractClient);

var abi$b = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "MinterAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "MinterRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "Paused",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "PauserAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "PauserRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "Unpaused",
		type: "event"
	},
	{
		constant: true,
		inputs: [
		],
		name: "DOMAIN_SEPARATOR",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "PERMIT_TYPEHASH",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "addMinter",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "addPauser",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "spender",
				type: "address"
			}
		],
		name: "allowance",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "burn",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "burnFrom",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "decimals",
		outputs: [
			{
				internalType: "uint8",
				name: "",
				type: "uint8"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "subtractedValue",
				type: "uint256"
			}
		],
		name: "decreaseAllowance",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "addedValue",
				type: "uint256"
			}
		],
		name: "increaseAllowance",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "isMinter",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "isPauser",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "mint",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "name",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "nonces",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "pause",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "paused",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceMinter",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renouncePauser",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "symbol",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "totalSupply",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "transfer",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "unpause",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "string",
				name: "name",
				type: "string"
			},
			{
				internalType: "string",
				name: "symbol",
				type: "string"
			},
			{
				internalType: "uint8",
				name: "decimals",
				type: "uint8"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "governance",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "deadline",
				type: "uint256"
			},
			{
				internalType: "uint8",
				name: "v",
				type: "uint8"
			},
			{
				internalType: "bytes32",
				name: "r",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "s",
				type: "bytes32"
			}
		],
		name: "permit",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];

var abi$a = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "ContractAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "ContractRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_oldAddress",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_newAddress",
				type: "address"
			}
		],
		name: "ContractUpgraded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "addContract",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			}
		],
		name: "removeContract",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "_newAddress",
				type: "address"
			}
		],
		name: "upgradeContract",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_version",
				type: "uint256"
			}
		],
		name: "getContract",
		outputs: [
			{
				internalType: "address",
				name: "contractAddr",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			}
		],
		name: "getContract",
		outputs: [
			{
				internalType: "address",
				name: "contractAddr",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			}
		],
		name: "getContractVersionCount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];

var abi$9 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newExecutionDelay",
				type: "uint256"
			}
		],
		name: "ExecutionDelayUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_targetContractAddress",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_callValue",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "string",
				name: "_functionSignature",
				type: "string"
			},
			{
				indexed: true,
				internalType: "bytes",
				name: "_callData",
				type: "bytes"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "_returnData",
				type: "bytes"
			}
		],
		name: "GuardianTransactionExecuted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newGuardianAddress",
				type: "address"
			}
		],
		name: "GuardianshipTransferred",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newMaxInProgressProposals",
				type: "uint256"
			}
		],
		name: "MaxInProgressProposalsUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "enum Governance.Outcome",
				name: "_outcome",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voteMagnitudeYes",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voteMagnitudeNo",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_numVotes",
				type: "uint256"
			}
		],
		name: "ProposalOutcomeEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_proposer",
				type: "address"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_name",
				type: "string"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_description",
				type: "string"
			}
		],
		name: "ProposalSubmitted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bool",
				name: "_success",
				type: "bool"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "_returnData",
				type: "bytes"
			}
		],
		name: "ProposalTransactionExecuted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "ProposalVetoed",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_voter",
				type: "address"
			},
			{
				indexed: true,
				internalType: "enum Governance.Vote",
				name: "_vote",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voterStake",
				type: "uint256"
			}
		],
		name: "ProposalVoteSubmitted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_voter",
				type: "address"
			},
			{
				indexed: true,
				internalType: "enum Governance.Vote",
				name: "_vote",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voterStake",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "enum Governance.Vote",
				name: "_previousVote",
				type: "uint8"
			}
		],
		name: "ProposalVoteUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newRegistryAddress",
				type: "address"
			}
		],
		name: "RegistryAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newVotingPeriod",
				type: "uint256"
			}
		],
		name: "VotingPeriodUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newVotingQuorumPercent",
				type: "uint256"
			}
		],
		name: "VotingQuorumPercentUpdated",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_registryAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_votingPeriod",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_executionDelay",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_votingQuorumPercent",
				type: "uint256"
			},
			{
				internalType: "uint16",
				name: "_maxInProgressProposals",
				type: "uint16"
			},
			{
				internalType: "address",
				name: "_guardianAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_targetContractRegistryKey",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_callValue",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "_functionSignature",
				type: "string"
			},
			{
				internalType: "bytes",
				name: "_callData",
				type: "bytes"
			},
			{
				internalType: "string",
				name: "_name",
				type: "string"
			},
			{
				internalType: "string",
				name: "_description",
				type: "string"
			}
		],
		name: "submitProposal",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				internalType: "enum Governance.Vote",
				name: "_vote",
				type: "uint8"
			}
		],
		name: "submitVote",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				internalType: "enum Governance.Vote",
				name: "_vote",
				type: "uint8"
			}
		],
		name: "updateVote",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "evaluateProposalOutcome",
		outputs: [
			{
				internalType: "enum Governance.Outcome",
				name: "",
				type: "uint8"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "vetoProposal",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_stakingAddress",
				type: "address"
			}
		],
		name: "setStakingAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProviderFactoryAddress",
				type: "address"
			}
		],
		name: "setServiceProviderFactoryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_delegateManagerAddress",
				type: "address"
			}
		],
		name: "setDelegateManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_votingPeriod",
				type: "uint256"
			}
		],
		name: "setVotingPeriod",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_votingQuorumPercent",
				type: "uint256"
			}
		],
		name: "setVotingQuorumPercent",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint16",
				name: "_newMaxInProgressProposals",
				type: "uint16"
			}
		],
		name: "setMaxInProgressProposals",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_newExecutionDelay",
				type: "uint256"
			}
		],
		name: "setExecutionDelay",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_targetContractRegistryKey",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_callValue",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "_functionSignature",
				type: "string"
			},
			{
				internalType: "bytes",
				name: "_callData",
				type: "bytes"
			}
		],
		name: "guardianExecuteTransaction",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_newGuardianAddress",
				type: "address"
			}
		],
		name: "transferGuardianship",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "getProposalById",
		outputs: [
			{
				internalType: "uint256",
				name: "proposalId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "proposer",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "submissionBlockNumber",
				type: "uint256"
			},
			{
				internalType: "bytes32",
				name: "targetContractRegistryKey",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "targetContractAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "callValue",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "functionSignature",
				type: "string"
			},
			{
				internalType: "bytes",
				name: "callData",
				type: "bytes"
			},
			{
				internalType: "enum Governance.Outcome",
				name: "outcome",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "voteMagnitudeYes",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "voteMagnitudeNo",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "numVotes",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "getProposalTargetContractHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_voter",
				type: "address"
			}
		],
		name: "getVoteInfoByProposalAndVoter",
		outputs: [
			{
				internalType: "enum Governance.Vote",
				name: "vote",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "voteMagnitude",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGuardianAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getStakingAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderFactoryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDelegateManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getVotingPeriod",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getVotingQuorumPercent",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRegistryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isGovernanceAddress",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "pure",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getMaxInProgressProposals",
		outputs: [
			{
				internalType: "uint16",
				name: "",
				type: "uint16"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getExecutionDelay",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getInProgressProposals",
		outputs: [
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "inProgressProposalsAreUpToDate",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];

var abi$8 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_serviceTypeMin",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_serviceTypeMax",
				type: "uint256"
			}
		],
		name: "ServiceTypeAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "ServiceTypeRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceVersion",
				type: "bytes32"
			}
		],
		name: "SetServiceVersion",
		type: "event"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_serviceTypeMin",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_serviceTypeMax",
				type: "uint256"
			}
		],
		name: "addServiceType",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "removeServiceType",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "getServiceTypeInfo",
		outputs: [
			{
				internalType: "bool",
				name: "isValid",
				type: "bool"
			},
			{
				internalType: "uint256",
				name: "minStake",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "maxStake",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getValidServiceTypes",
		outputs: [
			{
				internalType: "bytes32[]",
				name: "",
				type: "bytes32[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "serviceTypeIsValid",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "_serviceVersion",
				type: "bytes32"
			}
		],
		name: "setServiceVersion",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_versionIndex",
				type: "uint256"
			}
		],
		name: "getVersion",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "getCurrentVersion",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "getNumberOfVersions",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "_serviceVersion",
				type: "bytes32"
			}
		],
		name: "serviceVersionIsValid",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];

var abi$7 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newClaimsManagerAddress",
				type: "address"
			}
		],
		name: "ClaimsManagerAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_lockupDuration",
				type: "uint256"
			}
		],
		name: "DecreaseStakeLockupDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_decreaseAmount",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_lockupExpiryBlock",
				type: "uint256"
			}
		],
		name: "DecreaseStakeRequestCancelled",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_decreaseAmount",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_newStakeAmount",
				type: "uint256"
			}
		],
		name: "DecreaseStakeRequestEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_decreaseAmount",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_lockupExpiryBlock",
				type: "uint256"
			}
		],
		name: "DecreaseStakeRequested",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newDelegateManagerAddress",
				type: "address"
			}
		],
		name: "DelegateManagerAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_spID",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_updatedWallet",
				type: "address"
			}
		],
		name: "DelegateOwnerWalletUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_requestedCut",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_finalCut",
				type: "uint256"
			}
		],
		name: "DeployerCutUpdateRequestCancelled",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_updatedCut",
				type: "uint256"
			}
		],
		name: "DeployerCutUpdateRequestEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_updatedCut",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_lockupExpiryBlock",
				type: "uint256"
			}
		],
		name: "DeployerCutUpdateRequested",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_spID",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_endpoint",
				type: "string"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_unstakeAmount",
				type: "uint256"
			}
		],
		name: "DeregisteredServiceProvider",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_oldEndpoint",
				type: "string"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_newEndpoint",
				type: "string"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_spID",
				type: "uint256"
			}
		],
		name: "EndpointUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newGovernanceAddress",
				type: "address"
			}
		],
		name: "GovernanceAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_increaseAmount",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_newStakeAmount",
				type: "uint256"
			}
		],
		name: "IncreasedStake",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_spID",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_endpoint",
				type: "string"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_stakeAmount",
				type: "uint256"
			}
		],
		name: "RegisteredServiceProvider",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newServiceTypeManagerAddress",
				type: "address"
			}
		],
		name: "ServiceTypeManagerAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newStakingAddress",
				type: "address"
			}
		],
		name: "StakingAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_lockupDuration",
				type: "uint256"
			}
		],
		name: "UpdateDeployerCutLockupDurationUpdated",
		type: "event"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_claimsManagerAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_decreaseStakeLockupDuration",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_deployerCutLockupDuration",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "string",
				name: "_endpoint",
				type: "string"
			},
			{
				internalType: "uint256",
				name: "_stakeAmount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_delegateOwnerWallet",
				type: "address"
			}
		],
		name: "register",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "string",
				name: "_endpoint",
				type: "string"
			}
		],
		name: "deregister",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_increaseStakeAmount",
				type: "uint256"
			}
		],
		name: "increaseStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_decreaseStakeAmount",
				type: "uint256"
			}
		],
		name: "requestDecreaseStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_account",
				type: "address"
			}
		],
		name: "cancelDecreaseStakeRequest",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "decreaseStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "string",
				name: "_endpoint",
				type: "string"
			},
			{
				internalType: "address",
				name: "_updatedDelegateOwnerWallet",
				type: "address"
			}
		],
		name: "updateDelegateOwnerWallet",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "string",
				name: "_oldEndpoint",
				type: "string"
			},
			{
				internalType: "string",
				name: "_newEndpoint",
				type: "string"
			}
		],
		name: "updateEndpoint",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_cut",
				type: "uint256"
			}
		],
		name: "requestUpdateDeployerCut",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "cancelUpdateDeployerCut",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "updateDeployerCut",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "updateServiceProviderStake",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateDecreaseStakeLockupDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateDeployerCutLockupDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderDeployerCutBase",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDeployerCutLockupDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "getTotalServiceTypeProviders",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "string",
				name: "_endpoint",
				type: "string"
			}
		],
		name: "getServiceProviderIdFromEndpoint",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_ownerAddress",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "getServiceProviderIdsFromAddress",
		outputs: [
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_serviceId",
				type: "uint256"
			}
		],
		name: "getServiceEndpointInfo",
		outputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "string",
				name: "endpoint",
				type: "string"
			},
			{
				internalType: "uint256",
				name: "blockNumber",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "delegateOwnerWallet",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "getServiceProviderDetails",
		outputs: [
			{
				internalType: "uint256",
				name: "deployerStake",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "deployerCut",
				type: "uint256"
			},
			{
				internalType: "bool",
				name: "validBounds",
				type: "bool"
			},
			{
				internalType: "uint256",
				name: "numberOfEndpoints",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "minAccountStake",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "maxAccountStake",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "getPendingDecreaseStakeRequest",
		outputs: [
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "lockupExpiryBlock",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "getPendingUpdateDeployerCutRequest",
		outputs: [
			{
				internalType: "uint256",
				name: "newDeployerCut",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "lockupExpiryBlock",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDecreaseStakeLockupDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "validateAccountStakeBalance",
		outputs: [
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getStakingAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDelegateManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceTypeManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getClaimsManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "setStakingAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "setDelegateManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "setServiceTypeManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "setClaimsManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];

var abi$6 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "user",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "total",
				type: "uint256"
			}
		],
		name: "Slashed",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "user",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "total",
				type: "uint256"
			}
		],
		name: "Staked",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "user",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "total",
				type: "uint256"
			}
		],
		name: "Unstaked",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_claimsManager",
				type: "address"
			}
		],
		name: "setClaimsManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_spFactory",
				type: "address"
			}
		],
		name: "setServiceProviderFactoryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_delegateManager",
				type: "address"
			}
		],
		name: "setDelegateManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_stakerAccount",
				type: "address"
			}
		],
		name: "stakeRewards",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_stakerAccount",
				type: "address"
			}
		],
		name: "updateClaimHistory",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_slashAddress",
				type: "address"
			}
		],
		name: "slash",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "stakeFor",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "unstakeFor",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegatorAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "delegateStakeFor",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegatorAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "undelegateStakeFor",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "token",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "supportsHistory",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			}
		],
		name: "lastStakedFor",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			}
		],
		name: "lastClaimedFor",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_blockNumber",
				type: "uint256"
			}
		],
		name: "totalStakedForAt",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_blockNumber",
				type: "uint256"
			}
		],
		name: "totalStakedAt",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getClaimsManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderFactoryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDelegateManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			}
		],
		name: "isStaker",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			}
		],
		name: "totalStakedFor",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "totalStaked",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];

var abi$5 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_claimer",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_rewards",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_newTotal",
				type: "uint256"
			}
		],
		name: "Claim",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newClaimsManagerAddress",
				type: "address"
			}
		],
		name: "ClaimsManagerAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newGovernanceAddress",
				type: "address"
			}
		],
		name: "GovernanceAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_increaseAmount",
				type: "uint256"
			}
		],
		name: "IncreaseDelegatedStake",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_maxDelegators",
				type: "uint256"
			}
		],
		name: "MaxDelegatorsUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_minDelegationAmount",
				type: "uint256"
			}
		],
		name: "MinDelegationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_removeDelegatorEvalDuration",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorEvalDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_removeDelegatorLockupDuration",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorLockupDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "RemoveDelegatorRequestCancelled",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_unstakedAmount",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorRequestEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_lockupExpiryBlock",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorRequested",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_spMinDelegationAmount",
				type: "uint256"
			}
		],
		name: "SPMinDelegationAmountUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newServiceProviderFactoryAddress",
				type: "address"
			}
		],
		name: "ServiceProviderFactoryAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_target",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_newTotal",
				type: "uint256"
			}
		],
		name: "Slash",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newStakingAddress",
				type: "address"
			}
		],
		name: "StakingAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_undelegateLockupDuration",
				type: "uint256"
			}
		],
		name: "UndelegateLockupDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "UndelegateStakeRequestCancelled",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "UndelegateStakeRequestEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_lockupExpiryBlock",
				type: "uint256"
			}
		],
		name: "UndelegateStakeRequested",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_undelegateLockupDuration",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_targetSP",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "delegateStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_target",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "requestUndelegateStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "cancelUndelegateStakeRequest",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "undelegateStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "claimRewards",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_slashAddress",
				type: "address"
			}
		],
		name: "slash",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "requestRemoveDelegator",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "cancelRemoveDelegatorRequest",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "removeDelegator",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_spMinDelegationAmount",
				type: "uint256"
			}
		],
		name: "updateSPMinDelegationAmount",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateUndelegateLockupDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_maxDelegators",
				type: "uint256"
			}
		],
		name: "updateMaxDelegators",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_minDelegationAmount",
				type: "uint256"
			}
		],
		name: "updateMinDelegationAmount",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateRemoveDelegatorLockupDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateRemoveDelegatorEvalDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_stakingAddress",
				type: "address"
			}
		],
		name: "setStakingAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_spFactory",
				type: "address"
			}
		],
		name: "setServiceProviderFactoryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_claimsManagerAddress",
				type: "address"
			}
		],
		name: "setClaimsManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_sp",
				type: "address"
			}
		],
		name: "getDelegatorsList",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "getTotalDelegatorStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_sp",
				type: "address"
			}
		],
		name: "getTotalDelegatedToServiceProvider",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_sp",
				type: "address"
			}
		],
		name: "getTotalLockedDelegationForServiceProvider",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "getDelegatorStakeForServiceProvider",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "getPendingUndelegateRequest",
		outputs: [
			{
				internalType: "address",
				name: "target",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "lockupExpiryBlock",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "getPendingRemoveDelegatorRequest",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "getSPMinDelegationAmount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getUndelegateLockupDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getMaxDelegators",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getMinDelegationAmount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRemoveDelegatorLockupDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRemoveDelegatorEvalDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderFactoryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getClaimsManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getStakingAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];

var abi$4 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_claimer",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_rewards",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_oldTotal",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_newTotal",
				type: "uint256"
			}
		],
		name: "ClaimProcessed",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newCommunityPoolAddress",
				type: "address"
			}
		],
		name: "CommunityPoolAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_transferAddress",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "CommunityRewardsTransferred",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newDelegateManagerAddress",
				type: "address"
			}
		],
		name: "DelegateManagerAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "FundingAmountUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_blockDifference",
				type: "uint256"
			}
		],
		name: "FundingRoundBlockDiffUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newGovernanceAddress",
				type: "address"
			}
		],
		name: "GovernanceAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "RecurringCommunityFundingAmountUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_blockNumber",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_roundNumber",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_fundAmount",
				type: "uint256"
			}
		],
		name: "RoundInitiated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newServiceProviderFactoryAddress",
				type: "address"
			}
		],
		name: "ServiceProviderFactoryAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newStakingAddress",
				type: "address"
			}
		],
		name: "StakingAddressUpdated",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getFundingRoundBlockDiff",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getLastFundedBlock",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getFundsPerRound",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getTotalClaimedInRound",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderFactoryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDelegateManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getStakingAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getCommunityPoolAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRecurringCommunityFundingAmount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_stakingAddress",
				type: "address"
			}
		],
		name: "setStakingAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProviderFactoryAddress",
				type: "address"
			}
		],
		name: "setServiceProviderFactoryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_delegateManagerAddress",
				type: "address"
			}
		],
		name: "setDelegateManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initiateRound",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_claimer",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_totalLockedForSP",
				type: "uint256"
			}
		],
		name: "processClaim",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_newAmount",
				type: "uint256"
			}
		],
		name: "updateFundingAmount",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_sp",
				type: "address"
			}
		],
		name: "claimPending",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_newFundingRoundBlockDiff",
				type: "uint256"
			}
		],
		name: "updateFundingRoundBlockDiff",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_newRecurringCommunityFundingAmount",
				type: "uint256"
			}
		],
		name: "updateRecurringCommunityFundingAmount",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_newCommunityPoolAddress",
				type: "address"
			}
		],
		name: "updateCommunityPoolAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];

var abi$3 = [
	{
		inputs: [
			{
				internalType: "address",
				name: "_token",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "_merkleRoot",
				type: "bytes32"
			}
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "index",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "Claimed",
		type: "event"
	},
	{
		inputs: [
		],
		name: "merkleRoot",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function",
		constant: true
	},
	{
		inputs: [
		],
		name: "token",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function",
		constant: true
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "index",
				type: "uint256"
			}
		],
		name: "isClaimed",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function",
		constant: true
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "index",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "bytes32[]",
				name: "merkleProof",
				type: "bytes32[]"
			}
		],
		name: "claim",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];

var abi$2 = [
	{
		constant: true,
		inputs: [
		],
		name: "DOMAIN_SEPARATOR",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "TRANSFER_TOKENS_TYPEHASH",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "nonces",
		outputs: [
			{
				internalType: "uint32",
				name: "",
				type: "uint32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "token",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_wormholeAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint16",
				name: "recipientChain",
				type: "uint16"
			},
			{
				internalType: "bytes32",
				name: "recipient",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "arbiterFee",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "deadline",
				type: "uint256"
			},
			{
				internalType: "uint8",
				name: "v",
				type: "uint8"
			},
			{
				internalType: "bytes32",
				name: "r",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "s",
				type: "bytes32"
			}
		],
		name: "transferTokens",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];

var abi$1 = [
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_wormholeAddress",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "_recipient",
				type: "bytes32"
			},
			{
				internalType: "address[]",
				name: "_antiAbuseOracleAddresses",
				type: "address[]"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_recipient",
				type: "bytes32"
			}
		],
		name: "setRecipientAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address[]",
				name: "_antiAbuseOracleAddresses",
				type: "address[]"
			}
		],
		name: "setAntiAbuseOracleAddresses",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "arbiterFee",
				type: "uint256"
			},
			{
				internalType: "uint32",
				name: "_nonce",
				type: "uint32"
			}
		],
		name: "transferToSolana",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "token",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRecipientAddress",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getAntiAbuseOracleAddresses",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];

var abi = [
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_initialNotifierWallet",
				type: "address"
			},
			{
				internalType: "string",
				name: "_initialNotiferEndpoint",
				type: "string"
			},
			{
				internalType: "string",
				name: "_initialNotiferEmail",
				type: "string"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_wallet",
				type: "address"
			},
			{
				internalType: "string",
				name: "_endpoint",
				type: "string"
			},
			{
				internalType: "string",
				name: "_email",
				type: "string"
			}
		],
		name: "registerNotifier",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_wallet",
				type: "address"
			}
		],
		name: "deregisterNotifier",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getLatestNotifierID",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_ID",
				type: "uint256"
			}
		],
		name: "getNotifierForID",
		outputs: [
			{
				internalType: "address",
				name: "wallet",
				type: "address"
			},
			{
				internalType: "string",
				name: "endpoint",
				type: "string"
			},
			{
				internalType: "string",
				name: "email",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_wallet",
				type: "address"
			}
		],
		name: "getNotifierForWallet",
		outputs: [
			{
				internalType: "uint256",
				name: "ID",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "endpoint",
				type: "string"
			},
			{
				internalType: "string",
				name: "email",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "string",
				name: "_endpoint",
				type: "string"
			}
		],
		name: "getNotifierForEndpoint",
		outputs: [
			{
				internalType: "uint256",
				name: "ID",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "wallet",
				type: "address"
			},
			{
				internalType: "string",
				name: "email",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "string",
				name: "_email",
				type: "string"
			}
		],
		name: "getNotifierForEmail",
		outputs: [
			{
				internalType: "uint256",
				name: "ID",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "wallet",
				type: "address"
			},
			{
				internalType: "string",
				name: "endpoint",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];

var GovernanceRegistryKey = 'Governance';
var ServiceTypeManagerProxyKey = 'ServiceTypeManagerProxy';
var ServiceProviderFactoryRegistryKey = 'ServiceProviderFactory';
var StakingProxyKey = 'StakingProxy';
var DelegateManagerRegistryKey = 'DelegateManager';
var ClaimsManagerProxyKey = 'ClaimsManagerProxy';
var ClaimDistributionRegistryKey = 'ClaimDistribution';
var EthRewardsManagerProxyKey = 'EthRewardsManagerProxy';
var TrustedNotifierManagerProxyKey = 'TrustedNotifierManagerProxy';
var TWO_MINUTES = 2 * 60 * 1000;
var serviceType = Object.freeze({
  DISCOVERY_PROVIDER: 'discovery-node',
  CREATOR_NODE: 'content-node'
});
var serviceTypeList = Object.values(serviceType);
var EthContracts = /*#__PURE__*/function () {
  function EthContracts(_ref) {
    var ethWeb3Manager = _ref.ethWeb3Manager,
        tokenContractAddress = _ref.tokenContractAddress,
        registryAddress = _ref.registryAddress,
        claimDistributionContractAddress = _ref.claimDistributionContractAddress,
        wormholeContractAddress = _ref.wormholeContractAddress,
        _ref$isServer = _ref.isServer,
        isServer = _ref$isServer === void 0 ? false : _ref$isServer,
        _ref$logger = _ref.logger,
        logger = _ref$logger === void 0 ? console : _ref$logger,
        _ref$isDebug = _ref.isDebug,
        isDebug = _ref$isDebug === void 0 ? false : _ref$isDebug;

    _classCallCheck(this, EthContracts);

    _defineProperty$1(this, "ethWeb3Manager", void 0);

    _defineProperty$1(this, "tokenContractAddress", void 0);

    _defineProperty$1(this, "claimDistributionContractAddress", void 0);

    _defineProperty$1(this, "wormholeContractAddress", void 0);

    _defineProperty$1(this, "registryAddress", void 0);

    _defineProperty$1(this, "isServer", void 0);

    _defineProperty$1(this, "logger", void 0);

    _defineProperty$1(this, "isDebug", void 0);

    _defineProperty$1(this, "expectedServiceVersions", void 0);

    _defineProperty$1(this, "AudiusTokenClient", void 0);

    _defineProperty$1(this, "RegistryClient", void 0);

    _defineProperty$1(this, "StakingProxyClient", void 0);

    _defineProperty$1(this, "GovernanceClient", void 0);

    _defineProperty$1(this, "ClaimsManagerClient", void 0);

    _defineProperty$1(this, "EthRewardsManagerClient", void 0);

    _defineProperty$1(this, "ServiceTypeManagerClient", void 0);

    _defineProperty$1(this, "ServiceProviderFactoryClient", void 0);

    _defineProperty$1(this, "DelegateManagerClient", void 0);

    _defineProperty$1(this, "ClaimDistributionClient", void 0);

    _defineProperty$1(this, "WormholeClient", void 0);

    _defineProperty$1(this, "TrustedNotifierManagerClient", void 0);

    _defineProperty$1(this, "contractClients", void 0);

    _defineProperty$1(this, "_regressedMode", void 0);

    _defineProperty$1(this, "contracts", void 0);

    _defineProperty$1(this, "contractAddresses", void 0);

    this.ethWeb3Manager = ethWeb3Manager;
    this.tokenContractAddress = tokenContractAddress;
    this.claimDistributionContractAddress = claimDistributionContractAddress;
    this.wormholeContractAddress = wormholeContractAddress;
    this.registryAddress = registryAddress;
    this.isServer = isServer;
    this.logger = logger;
    this.isDebug = isDebug;
    this.expectedServiceVersions = null;
    this.AudiusTokenClient = new AudiusTokenClient(this.ethWeb3Manager, abi$b, this.tokenContractAddress);
    this.RegistryClient = new RegistryClient(this.ethWeb3Manager, abi$a, this.registryAddress);
    this.getRegistryAddressForContract = this.getRegistryAddressForContract.bind(this);
    this.StakingProxyClient = new StakingProxyClient(this.ethWeb3Manager, abi$6, StakingProxyKey, this.getRegistryAddressForContract, this.AudiusTokenClient, this.logger);
    this.GovernanceClient = new GovernanceClient(this.ethWeb3Manager, abi$9, GovernanceRegistryKey, this.getRegistryAddressForContract, this.AudiusTokenClient, this.StakingProxyClient, this.logger);
    this.ClaimsManagerClient = new ClaimsManagerClient(this.ethWeb3Manager, abi$4, ClaimsManagerProxyKey, this.getRegistryAddressForContract, this.logger);
    this.EthRewardsManagerClient = new EthRewardsManagerClient(this.ethWeb3Manager, abi$1, EthRewardsManagerProxyKey, this.getRegistryAddressForContract, this.logger);
    this.ServiceTypeManagerClient = new ServiceTypeManagerClient(this.ethWeb3Manager, abi$8, ServiceTypeManagerProxyKey, this.getRegistryAddressForContract, this.GovernanceClient, this.logger);
    this.ServiceProviderFactoryClient = new ServiceProviderFactoryClient(this.ethWeb3Manager, abi$7, ServiceProviderFactoryRegistryKey, this.getRegistryAddressForContract, this.AudiusTokenClient, this.StakingProxyClient, this.GovernanceClient, this.logger, this.isDebug);
    this.DelegateManagerClient = new DelegateManagerClient(this.ethWeb3Manager, abi$5, DelegateManagerRegistryKey, this.getRegistryAddressForContract, this.AudiusTokenClient, this.StakingProxyClient, this.GovernanceClient, this.logger);

    if (this.claimDistributionContractAddress) {
      this.ClaimDistributionClient = new ClaimDistributionClient(this.ethWeb3Manager, abi$3, ClaimDistributionRegistryKey, this.getRegistryAddressForContract, this.logger, this.claimDistributionContractAddress);
    }

    this.WormholeClient = new WormholeClient(this.ethWeb3Manager, abi$2, this.wormholeContractAddress, this.AudiusTokenClient);
    this.TrustedNotifierManagerClient = new TrustedNotifierManagerClient(this.ethWeb3Manager, abi, TrustedNotifierManagerProxyKey, this.getRegistryAddressForContract, this.GovernanceClient, this.logger);
    this.contractClients = [this.ServiceTypeManagerClient, this.StakingProxyClient, this.ServiceProviderFactoryClient]; // Whether or not we are running in `regressed` mode, meaning we were
    // unable to select a discovery provider that was up-to-date. Clients may
    // want to consider blocking writes.

    this._regressedMode = false;
  }

  _createClass(EthContracts, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(!this.ethWeb3Manager || !this.tokenContractAddress || !this.registryAddress)) {
                  _context2.next = 2;
                  break;
                }

                throw new Error('Failed to initialize EthContracts');

              case 2:
                if (!this.isServer) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 5;
                return Promise.all(this.contractClients.map( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(client) {
                    return regeneratorRuntime.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.next = 2;
                            return client.init();

                          case 2:
                            return _context.abrupt("return", _context.sent);

                          case 3:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function (_x) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
    /**
     * Estabilishes that connection to discovery providers has regressed
     */

  }, {
    key: "enterRegressedMode",
    value: function enterRegressedMode() {
      var _this = this;

      console.info('Entering regressed mode');
      this._regressedMode = true;
      setTimeout(function () {
        console.info('Leaving regressed mode');
        _this._regressedMode = false;
      }, TWO_MINUTES);
    }
  }, {
    key: "isInRegressedMode",
    value: function isInRegressedMode() {
      return this._regressedMode;
    }
  }, {
    key: "getRegistryAddressForContract",
    value: function () {
      var _getRegistryAddressForContract = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(contractName) {
        var _this$contracts, _this$contractAddress;

        var address;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names
                this.contracts = (_this$contracts = this.contracts) !== null && _this$contracts !== void 0 ? _this$contracts : _defineProperty$1({}, this.registryAddress, 'registry');
                this.contractAddresses = (_this$contractAddress = this.contractAddresses) !== null && _this$contractAddress !== void 0 ? _this$contractAddress : {
                  registry: this.registryAddress
                };

                if (this.contractAddresses[contractName]) {
                  _context3.next = 8;
                  break;
                }

                _context3.next = 5;
                return this.RegistryClient.getContract(contractName);

              case 5:
                address = _context3.sent;
                this.contracts[address] = contractName;
                this.contractAddresses[contractName] = address;

              case 8:
                return _context3.abrupt("return", this.contractAddresses[contractName]);

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getRegistryAddressForContract(_x2) {
        return _getRegistryAddressForContract.apply(this, arguments);
      }

      return getRegistryAddressForContract;
    }()
  }, {
    key: "getCurrentVersion",
    value: function () {
      var _getCurrentVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(serviceType) {
        var version;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                _context4.next = 3;
                return this.ServiceTypeManagerClient.getCurrentVersion(serviceType);

              case 3:
                version = _context4.sent;
                return _context4.abrupt("return", version);

              case 7:
                _context4.prev = 7;
                _context4.t0 = _context4["catch"](0);
                console.log("Error retrieving version for ".concat(serviceType));
                return _context4.abrupt("return", '');

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[0, 7]]);
      }));

      function getCurrentVersion(_x3) {
        return _getCurrentVersion.apply(this, arguments);
      }

      return getCurrentVersion;
    }()
    /*
     * Determine the latest version for deployed services such as discovery provider and cache
     */

  }, {
    key: "getExpectedServiceVersions",
    value: function () {
      var _getExpectedServiceVersions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var _this2 = this;

        var versions, expectedVersions;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return Promise.all(serviceTypeList.map( /*#__PURE__*/function () {
                  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(serviceType) {
                    return regeneratorRuntime.wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            _context5.next = 2;
                            return _this2.getCurrentVersion(serviceType);

                          case 2:
                            return _context5.abrupt("return", _context5.sent);

                          case 3:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function (_x4) {
                    return _ref4.apply(this, arguments);
                  };
                }()));

              case 2:
                versions = _context6.sent;
                expectedVersions = serviceTypeList.reduce(function (map, serviceType, i) {
                  if (versions[i]) {
                    map[serviceType] = versions[i];
                  }

                  return map;
                }, {});
                return _context6.abrupt("return", expectedVersions);

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function getExpectedServiceVersions() {
        return _getExpectedServiceVersions.apply(this, arguments);
      }

      return getExpectedServiceVersions;
    }()
    /**
     * Determine whether major and minor versions match for two version strings
     * Version string 2 must have equivalent major/minor versions and a patch >= version1
     * @param version1 string 1
     * @param version2 string 2
     */

  }, {
    key: "isValidSPVersion",
    value: function isValidSPVersion(version1, version2) {
      return semver__default["default"].major(version1) === semver__default["default"].major(version2) && semver__default["default"].minor(version1) === semver__default["default"].minor(version2) && semver__default["default"].patch(version2) >= semver__default["default"].patch(version1);
    }
  }, {
    key: "getServiceProviderList",
    value: function () {
      var _getServiceProviderList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(spType) {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.ServiceProviderFactoryClient.getServiceProviderList(spType);

              case 2:
                return _context7.abrupt("return", _context7.sent);

              case 3:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getServiceProviderList(_x5) {
        return _getServiceProviderList.apply(this, arguments);
      }

      return getServiceProviderList;
    }()
  }, {
    key: "getNumberOfVersions",
    value: function () {
      var _getNumberOfVersions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(spType) {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.ServiceTypeManagerClient.getNumberOfVersions(spType);

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getNumberOfVersions(_x6) {
        return _getNumberOfVersions.apply(this, arguments);
      }

      return getNumberOfVersions;
    }()
  }, {
    key: "getVersion",
    value: function () {
      var _getVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(spType, queryIndex) {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.ServiceTypeManagerClient.getVersion(spType, queryIndex);

              case 2:
                return _context9.abrupt("return", _context9.sent);

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getVersion(_x7, _x8) {
        return _getVersion.apply(this, arguments);
      }

      return getVersion;
    }()
  }, {
    key: "getServiceTypeInfo",
    value: function () {
      var _getServiceTypeInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(spType) {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.ServiceTypeManagerClient.getServiceTypeInfo(spType);

              case 2:
                return _context10.abrupt("return", _context10.sent);

              case 3:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getServiceTypeInfo(_x9) {
        return _getServiceTypeInfo.apply(this, arguments);
      }

      return getServiceTypeInfo;
    }()
  }]);

  return EthContracts;
}();
/**
 * Determines whether version2's major/minor versions are greater than or
 * equal to version1's major/minor.
 * @param version1 string 1
 * @param version2 string 2
 */

var isVersionAtLeastSameMajorMinor = function isVersionAtLeastSameMajorMinor(version1, version2) {
  var version1MajorMinor = "".concat(semver__default["default"].major(version1), ".").concat(semver__default["default"].minor(version1), ".0");
  var version2MajorMinor = "".concat(semver__default["default"].major(version2), ".").concat(semver__default["default"].minor(version2), ".0");
  return semver__default["default"].gte(version2MajorMinor, version1MajorMinor);
};

/**
 * Converts a BN to a Uint8Array of length 8, in little endian notation.
 * Useful for when Rust wants a u64 (8 * 8) represented as a byte array.
 * Ex: https://github.com/AudiusProject/audius-protocol/blob/main/solana-programs/reward-manager/program/src/processor.rs#L389
 */
var padBNToUint8Array = function padBNToUint8Array(bn) {
  return bn.toArray('le', 8);
};

var AUDIO_DECMIALS = 18;
var WAUDIO_DECMIALS = 8;
var CURRENT_USER_EXISTS_LOCAL_STORAGE_KEY = '@audius/libs:found-user';
var AuthHeaders;

(function (AuthHeaders) {
  AuthHeaders["MESSAGE"] = "Encoded-Data-Message";
  AuthHeaders["SIGNATURE"] = "Encoded-Data-Signature";
})(AuthHeaders || (AuthHeaders = {}));

var SolanaUtils = /*#__PURE__*/function () {
  function SolanaUtils() {
    _classCallCheck(this, SolanaUtils);
  }

  _createClass(SolanaUtils, null, [{
    key: "signBytes",
    value:
    /**
     * Signs arbitrary bytes
     */
    function signBytes(bytes, ethPrivateKey) {
      var msgHash = keccak256__default["default"](bytes);
      var ethPrivateKeyArr = Buffer.from(ethPrivateKey, 'hex');
      var signatureObj = secp256k1__default["default"].ecdsaSign(Uint8Array.from(msgHash), ethPrivateKeyArr);
      var signature = Buffer.from(signatureObj.signature);
      return {
        signature: signature,
        recoveryId: signatureObj.recid
      };
    }
    /**
     * Puts an instruction in a serializable form that our relay can understand.
     * Note we are faking the return type for callers to work with it easier
     */

  }, {
    key: "prepareInstructionForRelay",
    value: function prepareInstructionForRelay(instruction) {
      return {
        programId: instruction.programId.toString(),
        data: instruction.data,
        keys: instruction.keys.map(function (_ref) {
          var isSigner = _ref.isSigner,
              pubkey = _ref.pubkey,
              isWritable = _ref.isWritable;
          return {
            pubkey: pubkey.toString(),
            isSigner: isSigner,
            isWritable: isWritable
          };
        })
      };
    }
    /**
     * Constructs a transfer ID
     */

  }, {
    key: "constructTransferId",
    value: function constructTransferId(challengeId, specifier) {
      return "".concat(challengeId, ":").concat(specifier);
    }
    /**
     * Constructs an attestation from inputs.
     */

  }, {
    key: "constructAttestation",
    value: function constructAttestation(recipientEthAddress, tokenAmount, transferId, oracleAddress) {
      var encoder = new TextEncoder();
      var userBytes = SolanaUtils.ethAddressToArray(recipientEthAddress);
      var transferIdBytes = encoder.encode(transferId);
      var amountBytes = padBNToUint8Array(tokenAmount);
      var items = oracleAddress ? [userBytes, amountBytes, transferIdBytes, SolanaUtils.ethAddressToArray(oracleAddress)] : [userBytes, amountBytes, transferIdBytes];
      var sep = encoder.encode('_');
      var res = items.slice(1).reduce(function (prev, cur) {
        return Uint8Array.of.apply(Uint8Array, _toConsumableArray(prev).concat(_toConsumableArray(sep), _toConsumableArray(cur)));
      }, Uint8Array.from(items[0]));
      return res;
    }
    /**
     * Converts "UI" wAudio (i.e. 5) into properly denominated BN representation - (i.e. 5 * 10 ^ 8)
     */

  }, {
    key: "uiAudioToBNWaudio",
    value: function uiAudioToBNWaudio(amount) {
      return new BN__default["default"](amount * Math.pow(10, WAUDIO_DECMIALS));
    }
    /**
     * Derives a program address from a program ID and pubkey as seed.
     * Optionally takes in seeds.
     * Returns the new pubkey and bump seeds.
     */

  }, {
    key: "findProgramAddressFromPubkey",
    value: function () {
      var _findProgramAddressFromPubkey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(programId, pubkey, seed) {
        var seedsArr;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                seedsArr = [pubkey.toBytes().slice(0, 32)];

                if (seed) {
                  seedsArr.push(seed);
                }

                _context.next = 4;
                return solanaWeb3.PublicKey.findProgramAddress(seedsArr, programId);

              case 4:
                return _context.abrupt("return", _context.sent);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function findProgramAddressFromPubkey(_x, _x2, _x3) {
        return _findProgramAddressFromPubkey.apply(this, arguments);
      }

      return findProgramAddressFromPubkey;
    }()
    /**
     * Finds a program address, using both seeds, pubkey, and the derived authority.
     * Return [authority, derivedAddress, and bumpSeeds]
     *
     */

  }, {
    key: "findProgramAddressWithAuthority",
    value: function () {
      var _findProgramAddressWithAuthority = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(programId, address, seed) {
        var _yield$SolanaUtils$fi, _yield$SolanaUtils$fi2, authority, _yield$SolanaUtils$fi3, _yield$SolanaUtils$fi4, derivedAddress, bumpSeed;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return SolanaUtils.findProgramAddressFromPubkey(programId, address);

              case 2:
                _yield$SolanaUtils$fi = _context2.sent;
                _yield$SolanaUtils$fi2 = _slicedToArray(_yield$SolanaUtils$fi, 1);
                authority = _yield$SolanaUtils$fi2[0];
                _context2.next = 7;
                return SolanaUtils.findProgramAddressFromPubkey(programId, authority, seed);

              case 7:
                _yield$SolanaUtils$fi3 = _context2.sent;
                _yield$SolanaUtils$fi4 = _slicedToArray(_yield$SolanaUtils$fi3, 2);
                derivedAddress = _yield$SolanaUtils$fi4[0];
                bumpSeed = _yield$SolanaUtils$fi4[1];
                return _context2.abrupt("return", [authority, derivedAddress, bumpSeed]);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function findProgramAddressWithAuthority(_x4, _x5, _x6) {
        return _findProgramAddressWithAuthority.apply(this, arguments);
      }

      return findProgramAddressWithAuthority;
    }()
    /**
     * Converts an eth address hex represenatation to an array of Uint8s in big endian notation
     * @param ethAddress
     */

  }, {
    key: "ethAddressToArray",
    value: function ethAddressToArray(ethAddress) {
      var strippedEthAddress = ethAddress.replace('0x', ''); // Need to pad the array to length 20 - otherwise, hex eth keys starting with '0' would
      // result in truncated arrays, while eth spec is always 20 bytes

      return Uint8Array.of.apply(Uint8Array, _toConsumableArray(new BN__default["default"](strippedEthAddress, 'hex').toArray('be', 20)));
    } // Safely create pubkey from nullable val

  }, {
    key: "newPublicKeyNullable",
    value: function newPublicKeyNullable(val) {
      return val ? new solanaWeb3.PublicKey(val) : null;
    }
  }]);

  return SolanaUtils;
}();

/**
 * All errors returned by RewardsManager
 */
var RewardsManagerError = {
  // The owner of the input isn't set to the program address generated by the program.
  INCORRECT_OWNER: 'INCORRECT_OWNER',
  // Signature with an already met principal
  SIGN_COLLISION: 'SIGN_COLLISION',
  // Unexpected signer met
  WRONG_SIGNER: 'WRONG_SIGNER',
  // Isn't enough signers keys
  NOT_ENOUGH_SIGNERS: 'NOT_ENOUGH_SIGNERS',
  // Secp256 instruction missing
  SECP256_INSTRUCTION_MISSING: 'SECP256_INSTRUCTION_MISSING',
  // Instruction load error
  INSTRUCTION_LOAD_ERROR: 'INSTRUCTION_LOAD_ERROR',
  // Repeated senders
  REPEATED_SENDERS: 'REPEATED_SENDERS',
  // Signature verification failed
  SIGNATURE_VERIFICATION_FAILED: 'SIGNATURE_VERIFICATION_FAILED',
  // Some signers have same operators
  OPERATOR_COLLISION: 'OPERATOR_COLLISION',
  // Funds already sent
  ALREADY_SENT: 'ALREADY_SENT',
  // Incorrect messages
  INCORRECT_MESSAGES: 'INCORRECT_MESSAGES',
  // Messages overflow
  MESSAGE_OVERFLOW: 'MESSAGE_OVERFLOW',
  // Math overflow
  MATH_OVERFLOW: 'MATH_OVERFLOW',
  // Invalid recipient
  INVALID_RECIPIENT: 'INVALID_RECIPIENT',
  // Unmapped error
  UNKNOWN: 'UNKNOWN',
  fromErrorCode: function fromErrorCode(code) {
    var _errors$code;

    var errors = [RewardsManagerError.INCORRECT_OWNER, RewardsManagerError.SIGN_COLLISION, RewardsManagerError.WRONG_SIGNER, RewardsManagerError.NOT_ENOUGH_SIGNERS, RewardsManagerError.SECP256_INSTRUCTION_MISSING, RewardsManagerError.INSTRUCTION_LOAD_ERROR, RewardsManagerError.REPEATED_SENDERS, RewardsManagerError.SIGNATURE_VERIFICATION_FAILED, RewardsManagerError.OPERATOR_COLLISION, RewardsManagerError.ALREADY_SENT, RewardsManagerError.INCORRECT_MESSAGES, RewardsManagerError.MESSAGE_OVERFLOW, RewardsManagerError.MATH_OVERFLOW, RewardsManagerError.INVALID_RECIPIENT];
    return (_errors$code = errors[code]) !== null && _errors$code !== void 0 ? _errors$code : RewardsManagerError.UNKNOWN;
  }
};
var ClaimableProgramError = {
  // Signature verification failed
  SIGNATURE_VERIFICATION_FAILED: 'SIGNATURE_VERIFICATION_FAILED',
  /// Secp256 instruction losing
  SECP256_INSTRUCTION_LOSING: 'SECP256_INSTRUCTION_LOSING',
  /// Instruction load error
  INSTRUCTION_LOAD_ERROR: 'INSTRUCTION_LOAD_ERROR',
  /// User nonce verification error
  NONCE_VERIFICATION_ERROR: 'NONCE_VERIFICATION_ERROR',
  // Unmapped error
  UNKNOWN: 'UNKNOWN',
  fromErrorCode: function fromErrorCode(code) {
    var _errors$code2;

    var errors = [ClaimableProgramError.SIGNATURE_VERIFICATION_FAILED, ClaimableProgramError.SECP256_INSTRUCTION_LOSING, ClaimableProgramError.INSTRUCTION_LOAD_ERROR, ClaimableProgramError.NONCE_VERIFICATION_ERROR];
    return (_errors$code2 = errors[code]) !== null && _errors$code2 !== void 0 ? _errors$code2 : ClaimableProgramError.UNKNOWN;
  }
};

var encoder$1 = new TextEncoder();
var TRANSFER_NONCE_PREFIX = 'N_';
/**
 * Derives the 'transfer nonce account' - the account which contains the nonce for transfers
 * and is used to prevent replay attacks
 */

var deriveTransferNonceAccount = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
    var ethAddress, mintKey, claimableTokenProgramKey, ethAddressArr, seed, res;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            ethAddress = _ref.ethAddress, mintKey = _ref.mintKey, claimableTokenProgramKey = _ref.claimableTokenProgramKey;
            ethAddressArr = SolanaUtils.ethAddressToArray(ethAddress);
            seed = Uint8Array.from([].concat(_toConsumableArray(encoder$1.encode(TRANSFER_NONCE_PREFIX)), _toConsumableArray(ethAddressArr)));
            _context.next = 5;
            return SolanaUtils.findProgramAddressWithAuthority(claimableTokenProgramKey, mintKey, seed);

          case 5:
            res = _context.sent;
            return _context.abrupt("return", res[1]);

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function deriveTransferNonceAccount(_x) {
    return _ref2.apply(this, arguments);
  };
}();

var NonceAccount = /*#__PURE__*/_createClass(function NonceAccount(_ref3) {
  var version = _ref3.version,
      nonce = _ref3.nonce;

  _classCallCheck(this, NonceAccount);

  _defineProperty$1(this, "version", void 0);

  _defineProperty$1(this, "nonce", void 0);

  this.version = version;
  this.nonce = nonce;
});

var NonceAccountSchema = new Map([[NonceAccount, {
  kind: 'struct',
  fields: [['version', 'u8'], ['nonce', 'u64']]
}]]);
/**
 * Retrieves the nonce account for transfers, if non-existant it returns 0
 */

function getAccountNonce(_x2) {
  return _getAccountNonce.apply(this, arguments);
}
/**
 * Transfer wAUDIO between wallets on solana
 */


function _getAccountNonce() {
  _getAccountNonce = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref4) {
    var connection, ethAddress, mintKey, claimableTokenProgramKey, nonce, transferNonceAccount, accInfo, nonceAccount;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            connection = _ref4.connection, ethAddress = _ref4.ethAddress, mintKey = _ref4.mintKey, claimableTokenProgramKey = _ref4.claimableTokenProgramKey;
            nonce = new BN__default["default"](0);
            _context3.next = 4;
            return deriveTransferNonceAccount({
              ethAddress: ethAddress,
              mintKey: mintKey,
              claimableTokenProgramKey: claimableTokenProgramKey
            });

          case 4:
            transferNonceAccount = _context3.sent;
            _context3.next = 7;
            return connection.getAccountInfoAndContext(transferNonceAccount, 'confirmed');

          case 7:
            accInfo = _context3.sent;

            if (accInfo.value) {
              nonceAccount = borsh.deserialize(NonceAccountSchema, NonceAccount, accInfo.value.data);
              nonce = nonceAccount.nonce;
            }

            return _context3.abrupt("return", {
              accountNonce: transferNonceAccount,
              nonce: nonce
            });

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _getAccountNonce.apply(this, arguments);
}

var TransferInstructionData = /*#__PURE__*/_createClass(function TransferInstructionData(_ref5) {
  var targetPubKey = _ref5.targetPubKey,
      amount = _ref5.amount,
      nonce = _ref5.nonce;

  _classCallCheck(this, TransferInstructionData);

  _defineProperty$1(this, "target_pubkey", void 0);

  _defineProperty$1(this, "amount", void 0);

  _defineProperty$1(this, "nonce", void 0);

  this.target_pubkey = targetPubKey;
  this.amount = amount;
  this.nonce = nonce;
});

var transferInstructionDataSchema = new Map([[TransferInstructionData, {
  kind: 'struct',
  fields: [['target_pubkey', [32]], ['amount', 'u64'], ['nonce', 'u64']]
}]]);
/**
 * transferWAudioBalance transfers wrapped Audio from one generated solana account to another.
 * For it to work, you have to have the eth private key belonging to the eth public key
 * that generated the solana account
 */

function transferWAudioBalance(_x3) {
  return _transferWAudioBalance.apply(this, arguments);
}

function _transferWAudioBalance() {
  _transferWAudioBalance = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(args) {
    var instructions;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return createTransferInstructions(args);

          case 2:
            instructions = _context4.sent;
            _context4.next = 5;
            return args.transactionHandler.handleTransaction({
              instructions: instructions,
              errorMapping: ClaimableProgramError,
              feePayerOverride: args.feePayerKey
            });

          case 5:
            return _context4.abrupt("return", _context4.sent);

          case 6:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _transferWAudioBalance.apply(this, arguments);
}

var createTransferInstructions = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref6) {
    var amount, senderEthAddress, senderEthPrivateKey, senderSolanaAddress, recipientSolanaAddress, claimableTokenPDA, solanaTokenProgramKey, feePayerKey, claimableTokenProgramKey, connection, mintKey, _ref6$instructionInde, instructionIndex, _ref6$nonceOffset, nonceOffset, senderSolanaPubkey, recipientPubkey, _yield$getAccountNonc, accountNonce, nonce, accounts, ethPrivateKeyArr, ethPubkey, instructionData, serializedInstructionData, _SolanaUtils$signByte, signature, recoveryId, secpTransactionInstruction, ethAddressArr, transferDataInstr, transferInstruction;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            amount = _ref6.amount, senderEthAddress = _ref6.senderEthAddress, senderEthPrivateKey = _ref6.senderEthPrivateKey, senderSolanaAddress = _ref6.senderSolanaAddress, recipientSolanaAddress = _ref6.recipientSolanaAddress, claimableTokenPDA = _ref6.claimableTokenPDA, solanaTokenProgramKey = _ref6.solanaTokenProgramKey, feePayerKey = _ref6.feePayerKey, claimableTokenProgramKey = _ref6.claimableTokenProgramKey, connection = _ref6.connection, mintKey = _ref6.mintKey, _ref6$instructionInde = _ref6.instructionIndex, instructionIndex = _ref6$instructionInde === void 0 ? 0 : _ref6$instructionInde, _ref6$nonceOffset = _ref6.nonceOffset, nonceOffset = _ref6$nonceOffset === void 0 ? 0 : _ref6$nonceOffset;
            senderSolanaPubkey = new solanaWeb3.PublicKey(senderSolanaAddress);
            recipientPubkey = new solanaWeb3.PublicKey(recipientSolanaAddress);
            _context2.next = 5;
            return getAccountNonce({
              connection: connection,
              mintKey: mintKey,
              ethAddress: senderEthAddress,
              claimableTokenProgramKey: claimableTokenProgramKey
            });

          case 5:
            _yield$getAccountNonc = _context2.sent;
            accountNonce = _yield$getAccountNonc.accountNonce;
            nonce = _yield$getAccountNonc.nonce;
            accounts = [// 0. `[sw]` Fee payer
            {
              pubkey: feePayerKey,
              isSigner: true,
              isWritable: false
            }, // 1. `[w]` Token acc from which tokens will be send (bank account)
            {
              pubkey: senderSolanaPubkey,
              isSigner: false,
              isWritable: true
            }, // 2. `[w]` Receiver token acc
            {
              pubkey: recipientPubkey,
              isSigner: false,
              isWritable: true
            }, // 3. `[w]` Nonce Account
            {
              pubkey: accountNonce,
              isSigner: false,
              isWritable: true
            }, // 4. `[r]` Banks token account authority
            {
              pubkey: claimableTokenPDA,
              isSigner: false,
              isWritable: false
            }, // 5. `[r]` Sysvar Rent id
            {
              pubkey: solanaWeb3.SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }, // 6. `[r]` Sysvar instruction id
            {
              pubkey: solanaWeb3.SYSVAR_INSTRUCTIONS_PUBKEY,
              isSigner: false,
              isWritable: false
            }, // 7. `[r]` System program id
            {
              pubkey: solanaWeb3.SystemProgram.programId,
              isSigner: false,
              isWritable: false
            }, // 8. `[r]` SPL token account id
            {
              pubkey: solanaTokenProgramKey,
              isSigner: false,
              isWritable: false
            }]; // eth pubkey is different from the ethAddress - addresses are len 20, pub keys are len 64

            ethPrivateKeyArr = Buffer.from(senderEthPrivateKey, 'hex');
            ethPubkey = secp256k1__default["default"].publicKeyCreate(ethPrivateKeyArr, false).slice(1);
            instructionData = new TransferInstructionData({
              targetPubKey: recipientPubkey.toBuffer(),
              amount: amount,
              nonce: nonce.addn(nonceOffset)
            });
            serializedInstructionData = borsh.serialize(transferInstructionDataSchema, instructionData);
            _SolanaUtils$signByte = SolanaUtils.signBytes(Buffer.from(serializedInstructionData), senderEthPrivateKey), signature = _SolanaUtils$signByte.signature, recoveryId = _SolanaUtils$signByte.recoveryId;
            secpTransactionInstruction = solanaWeb3.Secp256k1Program.createInstructionWithPublicKey({
              publicKey: Buffer.from(ethPubkey),
              message: Buffer.from(serializedInstructionData),
              signature: signature,
              recoveryId: recoveryId,
              instructionIndex: instructionIndex
            });
            ethAddressArr = SolanaUtils.ethAddressToArray(senderEthAddress);
            transferDataInstr = Uint8Array.of.apply(Uint8Array, [1].concat(_toConsumableArray(ethAddressArr)));
            transferInstruction = new solanaWeb3.TransactionInstruction({
              keys: accounts,
              programId: claimableTokenProgramKey.toString(),
              data: Buffer.from(transferDataInstr)
            });
            return _context2.abrupt("return", [secpTransactionInstruction, transferInstruction]);

          case 19:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function createTransferInstructions(_x4) {
    return _ref7.apply(this, arguments);
  };
}();

var CreateTokenAccountInstructionData = /*#__PURE__*/_createClass(function CreateTokenAccountInstructionData(_ref) {
  var ethAddress = _ref.ethAddress;

  _classCallCheck(this, CreateTokenAccountInstructionData);

  _defineProperty$1(this, "hashed_eth_pk", void 0);

  this.hashed_eth_pk = ethAddress;
});

var createTokenAccountInstructionSchema = new Map([[CreateTokenAccountInstructionData, {
  kind: 'struct',
  fields: [['hashed_eth_pk', [20]]]
}]]);
/**
 * Gets the back account address for a user given their ethAddress
 */

var getBankAccountAddress = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(ethAddress, claimableTokenPDA, solanaTokenProgramKey) {
    var ethAddressArr, b58EthAddress, accountToGenerate;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            ethAddressArr = SolanaUtils.ethAddressToArray(ethAddress); // We b58 encode our eth address to use as seed later on

            b58EthAddress = bs58__default["default"].encode(ethAddressArr);
            _context.next = 4;
            return solanaWeb3.PublicKey.createWithSeed(
            /* from pubkey / base */
            claimableTokenPDA,
            /* seed */
            b58EthAddress,
            /* programId / owner */
            solanaTokenProgramKey);

          case 4:
            accountToGenerate = _context.sent;
            return _context.abrupt("return", accountToGenerate);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getBankAccountAddress(_x, _x2, _x3) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * createUserBank deterministically creates a Solana wAudio token account
 * from a provided ethAddress
 */

var createUserBankFrom = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref3) {
    var ethAddress, claimableTokenPDAKey, feePayerKey, mintKey, solanaTokenProgramKey, claimableTokenProgramKey, transactionHandler, recentBlockhash, ethAddressArr, instructionData, serializedInstructionData, serializedInstructionEnum, accountToGenerate, accounts, instructions;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            ethAddress = _ref3.ethAddress, claimableTokenPDAKey = _ref3.claimableTokenPDAKey, feePayerKey = _ref3.feePayerKey, mintKey = _ref3.mintKey, solanaTokenProgramKey = _ref3.solanaTokenProgramKey, claimableTokenProgramKey = _ref3.claimableTokenProgramKey, transactionHandler = _ref3.transactionHandler, recentBlockhash = _ref3.recentBlockhash;
            // Create instruction data
            ethAddressArr = SolanaUtils.ethAddressToArray(ethAddress);
            instructionData = new CreateTokenAccountInstructionData({
              ethAddress: ethAddressArr
            });
            serializedInstructionData = borsh.serialize(createTokenAccountInstructionSchema, instructionData); // 0th index in the Rust instruction enum

            serializedInstructionEnum = Uint8Array.of.apply(Uint8Array, [0].concat(_toConsumableArray(serializedInstructionData))); // Create the account we aim to generate

            _context2.next = 7;
            return getBankAccountAddress(ethAddress, claimableTokenPDAKey, solanaTokenProgramKey);

          case 7:
            accountToGenerate = _context2.sent;
            accounts = [// 0. `[sw]` Account to pay for creating token acc
            {
              pubkey: feePayerKey,
              isSigner: true,
              isWritable: true
            }, // 1. `[r]` Mint account
            {
              pubkey: mintKey,
              isSigner: false,
              isWritable: false
            }, // 2. `[r]` Base acc used in PDA token acc (need because of create_with_seed instruction)
            {
              pubkey: claimableTokenPDAKey,
              isSigner: false,
              isWritable: false
            }, // 3. `[w]` PDA token account to create
            {
              pubkey: accountToGenerate,
              isSigner: false,
              isWritable: true
            }, // `[r]` Rent id
            {
              pubkey: solanaWeb3.SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }, // 5. `[r]` SPL token account id
            {
              pubkey: solanaTokenProgramKey,
              isSigner: false,
              isWritable: false
            }, // 6. `[r]` System program id
            {
              pubkey: solanaWeb3.SystemProgram.programId,
              isSigner: false,
              isWritable: false
            }];
            instructions = [new solanaWeb3.TransactionInstruction({
              keys: accounts,
              programId: claimableTokenProgramKey.toString(),
              data: Buffer.from(serializedInstructionEnum)
            })];
            _context2.next = 12;
            return transactionHandler.handleTransaction({
              instructions: instructions,
              recentBlockhash: recentBlockhash,
              feePayerOverride: feePayerKey
            });

          case 12:
            return _context2.abrupt("return", _context2.sent);

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function createUserBankFrom(_x4) {
    return _ref4.apply(this, arguments);
  };
}();

/**
 * Finds the associated token address given a solana wallet public key
 */

function findAssociatedTokenAddress(_x) {
  return _findAssociatedTokenAddress.apply(this, arguments);
}
/**
 * Gets token account information (e.g. balance, ownership, etc.)
 */

function _findAssociatedTokenAddress() {
  _findAssociatedTokenAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
    var solanaWalletKey, mintKey, solanaTokenProgramKey, addresses;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            solanaWalletKey = _ref.solanaWalletKey, mintKey = _ref.mintKey, solanaTokenProgramKey = _ref.solanaTokenProgramKey;
            _context.next = 3;
            return solanaWeb3.PublicKey.findProgramAddress([solanaWalletKey.toBuffer(), solanaTokenProgramKey.toBuffer(), mintKey.toBuffer()], splToken.ASSOCIATED_TOKEN_PROGRAM_ID);

          case 3:
            addresses = _context.sent;
            return _context.abrupt("return", addresses[0]);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _findAssociatedTokenAddress.apply(this, arguments);
}

function getTokenAccountInfo(_x2) {
  return _getTokenAccountInfo.apply(this, arguments);
}
/**
 * Creates an associated token account for a given solana account (a wallet)
 */

function _getTokenAccountInfo() {
  _getTokenAccountInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {
    var tokenAccountAddressKey, mintKey, solanaTokenProgramKey, connection, token, info;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            tokenAccountAddressKey = _ref2.tokenAccountAddressKey, mintKey = _ref2.mintKey, solanaTokenProgramKey = _ref2.solanaTokenProgramKey, connection = _ref2.connection;
            token = new splToken.Token(connection, mintKey, solanaTokenProgramKey, randomKeyPair); // Fetch token info with 'processed commitment to get any recently changed amounts.
            // NOTE: Our version of spl-token omits the second argument
            // in the type definitions even though it's actually available,
            // so we suppress error until we can upgrade.
            // @ts-expect-error

            _context2.next = 4;
            return token.getAccountInfo(tokenAccountAddressKey, 'processed');

          case 4:
            info = _context2.sent;
            return _context2.abrupt("return", info);

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _getTokenAccountInfo.apply(this, arguments);
}

function createAssociatedTokenAccount(_x3) {
  return _createAssociatedTokenAccount.apply(this, arguments);
}

function _createAssociatedTokenAccount() {
  _createAssociatedTokenAccount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref3) {
    var feePayerKey, solanaWalletKey, mintKey, solanaTokenProgramKey, connection, identityService, associatedTokenAddress, accounts, _yield$connection$get, blockhash, transactionData, response;

    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            feePayerKey = _ref3.feePayerKey, solanaWalletKey = _ref3.solanaWalletKey, mintKey = _ref3.mintKey, solanaTokenProgramKey = _ref3.solanaTokenProgramKey, connection = _ref3.connection, identityService = _ref3.identityService;
            _context3.next = 3;
            return findAssociatedTokenAddress({
              solanaWalletKey: solanaWalletKey,
              mintKey: mintKey,
              solanaTokenProgramKey: solanaTokenProgramKey
            });

          case 3:
            associatedTokenAddress = _context3.sent;
            accounts = [// 0. `[sw]` Funding account (must be a system account)
            {
              pubkey: feePayerKey,
              isSigner: true,
              isWritable: true
            }, // 1. `[w]` Associated token account address to be created
            {
              pubkey: associatedTokenAddress,
              isSigner: false,
              isWritable: true
            }, // 2. `[r]` Wallet address for the new associated token account
            {
              pubkey: solanaWalletKey,
              isSigner: false,
              isWritable: false
            }, // 3. `[r]` The token mint for the new associated token account
            {
              pubkey: mintKey,
              isSigner: false,
              isWritable: false
            }, // 4. `[r]` System program
            {
              pubkey: solanaWeb3.SystemProgram.programId,
              isSigner: false,
              isWritable: false
            }, // 5. `[r]` SPL Token program
            {
              pubkey: solanaTokenProgramKey,
              isSigner: false,
              isWritable: false
            }, // 6. `[r]` Rent sysvar
            {
              pubkey: solanaWeb3.SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }];
            _context3.next = 7;
            return connection.getLatestBlockhash();

          case 7:
            _yield$connection$get = _context3.sent;
            blockhash = _yield$connection$get.blockhash;
            transactionData = {
              recentBlockhash: blockhash,
              instructions: [{
                keys: accounts.map(function (account) {
                  return {
                    pubkey: account.pubkey.toString(),
                    isSigner: account.isSigner,
                    isWritable: account.isWritable
                  };
                }),
                programId: splToken.ASSOCIATED_TOKEN_PROGRAM_ID.toString(),
                data: Buffer.from([])
              }]
            };
            _context3.next = 12;
            return identityService === null || identityService === void 0 ? void 0 : identityService.solanaRelay(transactionData);

          case 12:
            response = _context3.sent;
            return _context3.abrupt("return", response);

          case 14:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _createAssociatedTokenAccount.apply(this, arguments);
}

var MIN_WAUDIO_AMOUNT = new BN__default["default"]('10000000000'); // 10^10

/**
 * Converts Wei Audio (BN) to wAudio (BN).
 * wAudio has only 8 digits of precision vs. 18 in Wei Audio.
 * The amount must be >= 10^10 and have no remainder when divided by 10^10.
 */

var wAudioFromWeiAudio = function wAudioFromWeiAudio(amount) {
  if (amount.lt(MIN_WAUDIO_AMOUNT)) {
    throw new Error("".concat(amount.toString(), " is below minimum bounds ").concat(MIN_WAUDIO_AMOUNT.toString()));
  } // @ts-expect-error divmod not in types for some reason


  var _amount$divmod = amount.divmod(MIN_WAUDIO_AMOUNT),
      div = _amount$divmod.div,
      mod = _amount$divmod.mod;

  if (!mod.isZero()) {
    throw new Error("".concat(amount.toString(), " is too precise for conversion to wAudio. Remainder: ").concat(mod.toString()));
  }

  return div;
};

/**
 * Handles sending Solana transactions, either directly via `sendAndConfirmTransaction`,
 * or via IdentityService's relay.
 */

var TransactionHandler = /*#__PURE__*/function () {
  /**
   * Creates an instance of TransactionHandler.
   */
  function TransactionHandler(_ref) {
    var connection = _ref.connection,
        useRelay = _ref.useRelay,
        _ref$identityService = _ref.identityService,
        identityService = _ref$identityService === void 0 ? null : _ref$identityService,
        _ref$feePayerKeypairs = _ref.feePayerKeypairs,
        feePayerKeypairs = _ref$feePayerKeypairs === void 0 ? null : _ref$feePayerKeypairs,
        _ref$skipPreflight = _ref.skipPreflight,
        skipPreflight = _ref$skipPreflight === void 0 ? true : _ref$skipPreflight,
        _ref$retryTimeoutMs = _ref.retryTimeoutMs,
        retryTimeoutMs = _ref$retryTimeoutMs === void 0 ? 60000 : _ref$retryTimeoutMs,
        _ref$pollingFrequency = _ref.pollingFrequencyMs,
        pollingFrequencyMs = _ref$pollingFrequency === void 0 ? 300 : _ref$pollingFrequency,
        _ref$sendingFrequency = _ref.sendingFrequencyMs,
        sendingFrequencyMs = _ref$sendingFrequency === void 0 ? 300 : _ref$sendingFrequency;

    _classCallCheck(this, TransactionHandler);

    _defineProperty$1(this, "connection", void 0);

    _defineProperty$1(this, "useRelay", void 0);

    _defineProperty$1(this, "identityService", void 0);

    _defineProperty$1(this, "feePayerKeypairs", void 0);

    _defineProperty$1(this, "skipPreflight", void 0);

    _defineProperty$1(this, "retryTimeoutMs", void 0);

    _defineProperty$1(this, "pollingFrequencyMs", void 0);

    _defineProperty$1(this, "sendingFrequencyMs", void 0);

    this.connection = connection;
    this.useRelay = useRelay;
    this.identityService = identityService;
    this.feePayerKeypairs = feePayerKeypairs;
    this.skipPreflight = skipPreflight;
    this.retryTimeoutMs = retryTimeoutMs;
    this.pollingFrequencyMs = pollingFrequencyMs;
    this.sendingFrequencyMs = sendingFrequencyMs;
  }
  /**
   * Primary method to send a Solana transaction.
   */


  _createClass(TransactionHandler, [{
    key: "handleTransaction",
    value: function () {
      var _handleTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref2) {
        var instructions, _ref2$errorMapping, errorMapping, _ref2$recentBlockhash, recentBlockhash, _ref2$logger, logger, _ref2$skipPreflight, skipPreflight, _ref2$feePayerOverrid, feePayerOverride, _ref2$sendBlockhash, sendBlockhash, _ref2$signatures, signatures, _ref2$retry, retry, result;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                instructions = _ref2.instructions, _ref2$errorMapping = _ref2.errorMapping, errorMapping = _ref2$errorMapping === void 0 ? null : _ref2$errorMapping, _ref2$recentBlockhash = _ref2.recentBlockhash, recentBlockhash = _ref2$recentBlockhash === void 0 ? null : _ref2$recentBlockhash, _ref2$logger = _ref2.logger, logger = _ref2$logger === void 0 ? console : _ref2$logger, _ref2$skipPreflight = _ref2.skipPreflight, skipPreflight = _ref2$skipPreflight === void 0 ? false : _ref2$skipPreflight, _ref2$feePayerOverrid = _ref2.feePayerOverride, feePayerOverride = _ref2$feePayerOverrid === void 0 ? null : _ref2$feePayerOverrid, _ref2$sendBlockhash = _ref2.sendBlockhash, sendBlockhash = _ref2$sendBlockhash === void 0 ? false : _ref2$sendBlockhash, _ref2$signatures = _ref2.signatures, signatures = _ref2$signatures === void 0 ? null : _ref2$signatures, _ref2$retry = _ref2.retry, retry = _ref2$retry === void 0 ? true : _ref2$retry;
                result = null;

                if (!this.useRelay) {
                  _context.next = 8;
                  break;
                }

                _context.next = 5;
                return this._relayTransaction(instructions, recentBlockhash, skipPreflight, feePayerOverride, sendBlockhash, signatures, retry);

              case 5:
                result = _context.sent;
                _context.next = 11;
                break;

              case 8:
                _context.next = 10;
                return this._locallyConfirmTransaction(instructions, recentBlockhash, logger, skipPreflight, feePayerOverride, signatures, retry);

              case 10:
                result = _context.sent;

              case 11:
                if (result.error && result.errorCode !== null && errorMapping) {
                  result.errorCode = errorMapping.fromErrorCode(result.errorCode);
                }

                return _context.abrupt("return", result);

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function handleTransaction(_x) {
        return _handleTransaction.apply(this, arguments);
      }

      return handleTransaction;
    }()
  }, {
    key: "_relayTransaction",
    value: function () {
      var _relayTransaction2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(instructions, recentBlockhash, skipPreflight) {
        var feePayerOverride,
            sendBlockhash,
            signatures,
            retry,
            relayable,
            transactionData,
            _this$identityService,
            _response$transaction,
            response,
            error,
            _e$response,
            _e$response$data,
            errorCode,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                feePayerOverride = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : null;
                sendBlockhash = _args2.length > 4 ? _args2[4] : undefined;
                signatures = _args2.length > 5 ? _args2[5] : undefined;
                retry = _args2.length > 6 ? _args2[6] : undefined;
                relayable = instructions.map(SolanaUtils.prepareInstructionForRelay);
                transactionData = {
                  signatures: signatures,
                  instructions: relayable,
                  skipPreflight: skipPreflight === null ? this.skipPreflight : skipPreflight,
                  feePayerOverride: feePayerOverride ? feePayerOverride.toString() : null,
                  retry: retry
                };

                if (!(sendBlockhash || Array.isArray(signatures))) {
                  _context2.next = 15;
                  break;
                }

                if (!(recentBlockhash !== null && recentBlockhash !== void 0)) {
                  _context2.next = 11;
                  break;
                }

                _context2.t0 = recentBlockhash;
                _context2.next = 14;
                break;

              case 11:
                _context2.next = 13;
                return this.connection.getLatestBlockhash('confirmed');

              case 13:
                _context2.t0 = _context2.sent.blockhash;

              case 14:
                transactionData.recentBlockhash = _context2.t0;

              case 15:
                _context2.prev = 15;
                _context2.next = 18;
                return (_this$identityService = this.identityService) === null || _this$identityService === void 0 ? void 0 : _this$identityService.solanaRelay(transactionData);

              case 18:
                response = _context2.sent;
                return _context2.abrupt("return", {
                  res: (_response$transaction = response === null || response === void 0 ? void 0 : response.transactionSignature) !== null && _response$transaction !== void 0 ? _response$transaction : null,
                  error: null,
                  errorCode: null
                });

              case 22:
                _context2.prev = 22;
                _context2.t1 = _context2["catch"](15);
                error = null;

                if (_typeof(_context2.t1) === 'object' && _context2.t1 !== null) {
                  error = ((_e$response = _context2.t1.response) === null || _e$response === void 0 ? void 0 : (_e$response$data = _e$response.data) === null || _e$response$data === void 0 ? void 0 : _e$response$data.error) || _context2.t1.message;
                }

                errorCode = error ? this._parseSolanaErrorCode(error) : null;
                return _context2.abrupt("return", {
                  res: null,
                  error: error,
                  errorCode: errorCode
                });

              case 28:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[15, 22]]);
      }));

      function _relayTransaction(_x2, _x3, _x4) {
        return _relayTransaction2.apply(this, arguments);
      }

      return _relayTransaction;
    }()
  }, {
    key: "_locallyConfirmTransaction",
    value: function () {
      var _locallyConfirmTransaction2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(instructions, recentBlockhash, logger, skipPreflight) {
        var _this = this,
            _this$feePayerKeypair,
            _recentBlockhash;

        var feePayerOverride,
            signatures,
            retry,
            feePayerKeypairOverride,
            feePayerAccount,
            tx,
            rawTransaction,
            sendRawTransaction,
            txid,
            errorCode,
            error,
            done,
            sendCount,
            startTime,
            _errorCode,
            _error,
            _args5 = arguments;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                feePayerOverride = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : null;
                signatures = _args5.length > 5 && _args5[5] !== undefined ? _args5[5] : null;
                retry = _args5.length > 6 && _args5[6] !== undefined ? _args5[6] : true;

                feePayerKeypairOverride = function () {
                  if (feePayerOverride && _this.feePayerKeypairs) {
                    var stringFeePayer = feePayerOverride.toString();
                    return _this.feePayerKeypairs.find(function (keypair) {
                      return keypair.publicKey.toString() === stringFeePayer;
                    });
                  }

                  return null;
                }();

                feePayerAccount = feePayerKeypairOverride !== null && feePayerKeypairOverride !== void 0 ? feePayerKeypairOverride : (_this$feePayerKeypair = this.feePayerKeypairs) === null || _this$feePayerKeypair === void 0 ? void 0 : _this$feePayerKeypair[0];

                if (feePayerAccount) {
                  _context5.next = 8;
                  break;
                }

                logger.error('transactionHandler: Local feepayer keys missing for direct confirmation!');
                return _context5.abrupt("return", {
                  res: null,
                  error: 'Missing keys',
                  errorCode: null
                });

              case 8:
                if (!((_recentBlockhash = recentBlockhash) !== null && _recentBlockhash !== void 0)) {
                  _context5.next = 12;
                  break;
                }

                _context5.t0 = _recentBlockhash;
                _context5.next = 15;
                break;

              case 12:
                _context5.next = 14;
                return this.connection.getLatestBlockhash('confirmed');

              case 14:
                _context5.t0 = _context5.sent.blockhash;

              case 15:
                recentBlockhash = _context5.t0;
                // Construct the txn
                tx = new solanaWeb3.Transaction({
                  recentBlockhash: recentBlockhash
                });
                instructions.forEach(function (i) {
                  return tx.add(i);
                });
                tx.feePayer = feePayerAccount.publicKey;
                tx.sign(feePayerAccount);

                if (Array.isArray(signatures)) {
                  signatures.forEach(function (_ref3) {
                    var publicKey = _ref3.publicKey,
                        signature = _ref3.signature;
                    tx.addSignature(new solanaWeb3.PublicKey(publicKey), signature);
                  });
                }

                rawTransaction = tx.serialize(); // Send the txn

                sendRawTransaction = /*#__PURE__*/function () {
                  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.next = 2;
                            return _this.connection.sendRawTransaction(rawTransaction, {
                              skipPreflight: skipPreflight === null ? _this.skipPreflight : skipPreflight,
                              preflightCommitment: 'processed',
                              maxRetries: retry ? 0 : undefined
                            });

                          case 2:
                            return _context3.abrupt("return", _context3.sent);

                          case 3:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function sendRawTransaction() {
                    return _ref4.apply(this, arguments);
                  };
                }();

                _context5.prev = 23;
                _context5.next = 26;
                return sendRawTransaction();

              case 26:
                txid = _context5.sent;
                _context5.next = 36;
                break;

              case 29:
                _context5.prev = 29;
                _context5.t1 = _context5["catch"](23);
                // Rarely, this intiial send will fail
                logger.warn("transactionHandler: Initial send failed: ".concat(_context5.t1));
                errorCode = null;
                error = null;

                if (_context5.t1 instanceof Error) {
                  error = _context5.t1.message;
                  errorCode = this._parseSolanaErrorCode(error);
                }

                return _context5.abrupt("return", {
                  res: null,
                  error: error,
                  errorCode: errorCode
                });

              case 36:
                done = false; // Start up resubmission loop

                sendCount = 0;
                startTime = Date.now();

                if (retry) {

                  _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                    var elapsed;
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            elapsed = Date.now() - startTime; // eslint-disable-next-line no-unmodified-loop-condition

                          case 1:
                            if (!(!done && elapsed < _this.retryTimeoutMs)) {
                              _context4.next = 9;
                              break;
                            }

                            try {
                              sendRawTransaction();
                            } catch (e) {
                              logger.warn("transactionHandler: error in send loop: ".concat(e, " for txId ").concat(txid));
                            }

                            sendCount++;
                            _context4.next = 6;
                            return delay(_this.sendingFrequencyMs);

                          case 6:
                            elapsed = Date.now() - startTime;
                            _context4.next = 1;
                            break;

                          case 9:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }))();
                } // Await for tx confirmation


                _context5.prev = 40;
                _context5.next = 43;
                return this._awaitTransactionSignatureConfirmation(txid, logger);

              case 43:
                done = true;
                logger.info("transactionHandler: finished for txid ".concat(txid, " with ").concat(sendCount, " retries"));
                return _context5.abrupt("return", {
                  res: txid,
                  error: null,
                  errorCode: null
                });

              case 48:
                _context5.prev = 48;
                _context5.t2 = _context5["catch"](40);
                logger.warn("transactionHandler: error in awaitTransactionSignature: ".concat(JSON.stringify(_context5.t2), ", ").concat(txid));
                done = true;
                _errorCode = null;
                _error = null;

                if (_context5.t2 instanceof Error) {
                  _error = _context5.t2.message;
                  _errorCode = this._parseSolanaErrorCode(_error);
                }

                return _context5.abrupt("return", {
                  res: null,
                  error: _error,
                  errorCode: _errorCode
                });

              case 56:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[23, 29], [40, 48]]);
      }));

      function _locallyConfirmTransaction(_x5, _x6, _x7, _x8) {
        return _locallyConfirmTransaction2.apply(this, arguments);
      }

      return _locallyConfirmTransaction;
    }()
  }, {
    key: "_awaitTransactionSignatureConfirmation",
    value: function () {
      var _awaitTransactionSignatureConfirmation2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(txid, logger) {
        var _this2 = this;

        var done, result;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                done = false;
                _context8.next = 3;
                return new Promise(function (resolve, reject) {

                  _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
                    return regeneratorRuntime.wrap(function _callee7$(_context7) {
                      while (1) {
                        switch (_context7.prev = _context7.next) {
                          case 0:
                            // Setup timeout if nothing else finishes
                            setTimeout(function () {
                              if (done) {
                                return;
                              }

                              done = true;
                              var message = "transactionHandler: Timed out in await, ".concat(txid);
                              logger.warn(message);
                              reject(new Error(message));
                            }, _this2.retryTimeoutMs); // Setup WS listener

                            // Setup WS listener
                            try {
                              _this2.connection.onSignature(txid, function (result) {
                                if (done) return;
                                done = true;

                                if (result.err) {
                                  var err = JSON.stringify(result.err);
                                  logger.warn("transactionHandler: Error in onSignature ".concat(txid, ", ").concat(err));
                                  reject(new Error(err));
                                } else {
                                  resolve(txid);
                                }
                              }, 'processed');
                            } catch (e) {
                              done = true;
                              logger.error("transactionHandler: WS error in setup ".concat(txid, ", ").concat(e));
                            } // Setup polling


                          case 2:
                            if (done) {
                              _context7.next = 9;
                              break;
                            }

                            _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
                              var signatureStatuses, _result, err;

                              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                                while (1) {
                                  switch (_context6.prev = _context6.next) {
                                    case 0:
                                      _context6.prev = 0;
                                      _context6.next = 3;
                                      return _this2.connection.getSignatureStatuses([txid]);

                                    case 3:
                                      signatureStatuses = _context6.sent;
                                      _result = signatureStatuses === null || signatureStatuses === void 0 ? void 0 : signatureStatuses.value[0]; // Early return this iteration if already done, or no result

                                      if (!(done || !_result)) {
                                        _context6.next = 7;
                                        break;
                                      }

                                      return _context6.abrupt("return");

                                    case 7:
                                      if (!_result.err) {
                                        _context6.next = 13;
                                        break;
                                      }

                                      err = JSON.stringify(_result.err);
                                      logger.error("transactionHandler: polling saw result error: ".concat(err, ", tx: ").concat(txid));
                                      done = true;
                                      reject(new Error(err));
                                      return _context6.abrupt("return");

                                    case 13:
                                      if (_result.confirmations !== null && _result.confirmations !== 0 || _result.confirmationStatus === 'confirmed' || _result.confirmationStatus === 'finalized') {
                                        _context6.next = 15;
                                        break;
                                      }

                                      return _context6.abrupt("return");

                                    case 15:
                                      // Otherwise, we made it
                                      done = true;
                                      resolve(txid);
                                      _context6.next = 22;
                                      break;

                                    case 19:
                                      _context6.prev = 19;
                                      _context6.t0 = _context6["catch"](0);

                                      if (!done) {
                                        logger.error("transactionHandler: REST polling connection error: ".concat(_context6.t0, ", tx: ").concat(txid));
                                      }

                                    case 22:
                                    case "end":
                                      return _context6.stop();
                                  }
                                }
                              }, _callee6, null, [[0, 19]]);
                            }))();

                            _context7.next = 7;
                            return delay(_this2.pollingFrequencyMs);

                          case 7:
                            _context7.next = 2;
                            break;

                          case 9:
                          case "end":
                            return _context7.stop();
                        }
                      }
                    }, _callee7);
                  }))();
                });

              case 3:
                result = _context8.sent;
                done = true;
                return _context8.abrupt("return", result);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));

      function _awaitTransactionSignatureConfirmation(_x9, _x10) {
        return _awaitTransactionSignatureConfirmation2.apply(this, arguments);
      }

      return _awaitTransactionSignatureConfirmation;
    }()
    /**
     * Attempts to parse an error code out of a message of the form:
     * "... custom program error: 0x1", where the return in this case would be the number 1.
     * Returns null for unparsable strings.
     */

  }, {
    key: "_parseSolanaErrorCode",
    value: function _parseSolanaErrorCode(errorMessage) {
      if (!errorMessage) return null; // Match on custom solana program errors

      var matcher = /(?:custom program error: 0x)(.*)$/;
      var res = errorMessage.match(matcher);
      if (res && res.length === 2) return res[1] ? parseInt(res[1], 16) || null : null; // Match on custom anchor errors

      var matcher2 = /(?:"Custom":)(\d+)/;
      var res2 = errorMessage.match(matcher2);
      if (res2 && res2.length === 2) return res2[1] ? parseInt(res2[1], 10) || null : null;
      return null;
    }
  }]);

  return TransactionHandler;
}();

function delay(_x11) {
  return _delay.apply(this, arguments);
}

function _delay() {
  _delay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(ms) {
    return regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return new Promise(function (resolve) {
              return setTimeout(resolve, ms);
            });

          case 2:
            return _context9.abrupt("return", _context9.sent);

          case 3:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _delay.apply(this, arguments);
}

var SENDER_SEED_PREFIX = 'S_';
var VERIFY_TRANSFER_SEED_PREFIX = 'V_';
var TRANSFER_PREFIX = 'T_';
var ADD_SENDER_MESSAGE_PREFIX = 'add'; // Enum cases for instructions

var CREATE_SENDER_PUBLIC_ENUM_VALUE = 4;
var SUBMIT_INSTRUCTION_ENUM_VALUE = 6;
var EVALUATE_INSTRUCTION_ENUM_VALUE = 7;
var ATTESTATION_INSTRUCTIONS_PER_TRANSACTION = 4;
var encoder = new TextEncoder();

var SubmitAttestationInstructionData = /*#__PURE__*/_createClass(function SubmitAttestationInstructionData(_ref) {
  var transferId = _ref.transferId;

  _classCallCheck(this, SubmitAttestationInstructionData);

  _defineProperty$1(this, "id", void 0);

  this.id = transferId;
});

var submitAttestationInstructionSchema = new Map([[SubmitAttestationInstructionData, {
  kind: 'struct',
  fields: [['id', 'string']]
}]]);

var ValidateAttestationsInstructionData = /*#__PURE__*/_createClass(function ValidateAttestationsInstructionData(_ref2) {
  var amount = _ref2.amount,
      id = _ref2.id,
      ethRecipient = _ref2.ethRecipient;

  _classCallCheck(this, ValidateAttestationsInstructionData);

  _defineProperty$1(this, "amount", void 0);

  _defineProperty$1(this, "id", void 0);

  _defineProperty$1(this, "eth_recipient", void 0);

  this.amount = amount;
  this.id = id;
  this.eth_recipient = ethRecipient;
});

var validateAttestationsInstructionSchema = new Map([[ValidateAttestationsInstructionData, {
  kind: 'struct',
  fields: [['amount', 'u64'], ['id', 'string'], ['eth_recipient', [20]]]
}]]);

var CreateSenderPublicInstructionData = /*#__PURE__*/_createClass(function CreateSenderPublicInstructionData(_ref3) {
  var ethAddress = _ref3.ethAddress,
      operator = _ref3.operator;

  _classCallCheck(this, CreateSenderPublicInstructionData);

  _defineProperty$1(this, "eth_address", void 0);

  _defineProperty$1(this, "operator", void 0);

  this.eth_address = ethAddress;
  this.operator = operator;
});

var createSenderPublicInstructionSchema = new Map([[CreateSenderPublicInstructionData, {
  kind: 'struct',
  fields: [['eth_address', [20]], ['operator', [20]]]
}]]);
function submitAttestations(_x) {
  return _submitAttestations.apply(this, arguments);
}
/**
 * Creates a new rewards signer (one that can attest)
 */

function _submitAttestations() {
  _submitAttestations = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(_ref4) {
    var rewardManagerProgramId, rewardManagerAccount, attestations, oracleAttestation, challengeId, specifier, feePayer, recipientEthAddress, tokenAmount, transactionHandler, _ref4$instructionsPer, instructionsPerTransaction, _ref4$logger, logger, transferId, _yield$deriveMessageA3, _yield$deriveMessageA4, rewardManagerAuthority, derivedMessageAccount, encodedSenderMessage, instructions, encodedOracleMessage, oracleSecp, oracleTransfer, bucketedInstructions, results, _iterator, _step, _res$error, res;

    return regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            rewardManagerProgramId = _ref4.rewardManagerProgramId, rewardManagerAccount = _ref4.rewardManagerAccount, attestations = _ref4.attestations, oracleAttestation = _ref4.oracleAttestation, challengeId = _ref4.challengeId, specifier = _ref4.specifier, feePayer = _ref4.feePayer, recipientEthAddress = _ref4.recipientEthAddress, tokenAmount = _ref4.tokenAmount, transactionHandler = _ref4.transactionHandler, _ref4$instructionsPer = _ref4.instructionsPerTransaction, instructionsPerTransaction = _ref4$instructionsPer === void 0 ? ATTESTATION_INSTRUCTIONS_PER_TRANSACTION : _ref4$instructionsPer, _ref4$logger = _ref4.logger, logger = _ref4$logger === void 0 ? console : _ref4$logger;
            // Construct combined transfer ID
            transferId = SolanaUtils.constructTransferId(challengeId, specifier); // Derive the message account we'll use to store the attestations

            _context9.next = 4;
            return deriveMessageAccount(transferId, rewardManagerProgramId, rewardManagerAccount);

          case 4:
            _yield$deriveMessageA3 = _context9.sent;
            _yield$deriveMessageA4 = _slicedToArray(_yield$deriveMessageA3, 2);
            rewardManagerAuthority = _yield$deriveMessageA4[0];
            derivedMessageAccount = _yield$deriveMessageA4[1];
            encodedSenderMessage = SolanaUtils.constructAttestation(recipientEthAddress, tokenAmount, transferId, oracleAttestation.ethAddress); // Add instructions from DN attestations - each attestation
            // needs a pairing of SECP recovery instruction and submit
            // attestation instruction.

            _context9.next = 11;
            return Promise.all(attestations.reduce(function (instructions, meta, i) {
              var secpInstruction = Promise.resolve(generateAttestationSecpInstruction({
                attestationMeta: meta,
                instructionIndex: 2 * i % instructionsPerTransaction,
                encodedSenderMessage: encodedSenderMessage
              }));
              var verifyInstruction = generateSubmitAttestationInstruction({
                attestationMeta: meta,
                derivedMessageAccount: derivedMessageAccount,
                rewardManagerAccount: rewardManagerAccount,
                rewardManagerProgramId: rewardManagerProgramId,
                rewardManagerAuthority: rewardManagerAuthority,
                transferId: transferId,
                feePayer: feePayer
              });
              return [].concat(_toConsumableArray(instructions), [secpInstruction, verifyInstruction]);
            }, []));

          case 11:
            instructions = _context9.sent;
            encodedOracleMessage = SolanaUtils.constructAttestation(recipientEthAddress, tokenAmount, transferId); // Add instructions from oracle attestation

            oracleSecp = generateAttestationSecpInstruction({
              attestationMeta: oracleAttestation,
              instructionIndex: instructions.length % instructionsPerTransaction,
              encodedSenderMessage: encodedOracleMessage
            });
            _context9.next = 16;
            return generateSubmitAttestationInstruction({
              attestationMeta: oracleAttestation,
              derivedMessageAccount: derivedMessageAccount,
              rewardManagerAccount: rewardManagerAccount,
              rewardManagerProgramId: rewardManagerProgramId,
              rewardManagerAuthority: rewardManagerAuthority,
              transferId: transferId,
              feePayer: feePayer
            });

          case 16:
            oracleTransfer = _context9.sent;
            // Break the instructions up into multiple transactions as per `instructionsPerTransaction`
            instructions = [].concat(_toConsumableArray(instructions), [oracleSecp, oracleTransfer]);
            bucketedInstructions = instructions.reduce(function (acc, cur) {
              var instruction = acc[acc.length - 1];

              if (instruction && instruction.length < instructionsPerTransaction) {
                instruction.push(cur);
              } else {
                acc.push([cur]);
              }

              return acc;
            }, [[]]);
            _context9.next = 21;
            return Promise.all(bucketedInstructions.map( /*#__PURE__*/function () {
              var _ref18 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(i) {
                return regeneratorRuntime.wrap(function _callee8$(_context8) {
                  while (1) {
                    switch (_context8.prev = _context8.next) {
                      case 0:
                        _context8.next = 2;
                        return transactionHandler.handleTransaction({
                          instructions: i,
                          errorMapping: RewardsManagerError,
                          logger: logger,
                          skipPreflight: false,
                          feePayerOverride: feePayer,
                          sendBlockhash: false
                        });

                      case 2:
                        return _context8.abrupt("return", _context8.sent);

                      case 3:
                      case "end":
                        return _context8.stop();
                    }
                  }
                }, _callee8);
              }));

              return function (_x16) {
                return _ref18.apply(this, arguments);
              };
            }()));

          case 21:
            results = _context9.sent;
            logger.info("submitAttestations: submitted attestations with results: ".concat(JSON.stringify(results))); // If there's any error in any of the transactions, just return that one

            _iterator = _createForOfIteratorHelper(results);
            _context9.prev = 24;

            _iterator.s();

          case 26:
            if ((_step = _iterator.n()).done) {
              _context9.next = 32;
              break;
            }

            res = _step.value;

            if (!((_res$error = res.error) !== null && _res$error !== void 0 ? _res$error : res.errorCode)) {
              _context9.next = 30;
              break;
            }

            return _context9.abrupt("return", res);

          case 30:
            _context9.next = 26;
            break;

          case 32:
            _context9.next = 37;
            break;

          case 34:
            _context9.prev = 34;
            _context9.t0 = _context9["catch"](24);

            _iterator.e(_context9.t0);

          case 37:
            _context9.prev = 37;

            _iterator.f();

            return _context9.finish(37);

          case 40:
            return _context9.abrupt("return", results[0]);

          case 41:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9, null, [[24, 34, 37, 40]]);
  }));
  return _submitAttestations.apply(this, arguments);
}

function createSender(_x2) {
  return _createSender.apply(this, arguments);
}
/**
 * Evaluates previously submitted attestations, disbursing if successful.
 */

function _createSender() {
  _createSender = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(_ref5) {
    var rewardManagerProgramId, rewardManagerAccount, senderEthAddress, feePayer, operatorEthAddress, attestations, transactionHandler, _yield$SolanaUtils$fi5, _yield$SolanaUtils$fi6, rewardManagerAuthority, encodedSenderMessage, signerEthAddresses, signerInstructions, createSenderInstruction, instructions;

    return regeneratorRuntime.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            rewardManagerProgramId = _ref5.rewardManagerProgramId, rewardManagerAccount = _ref5.rewardManagerAccount, senderEthAddress = _ref5.senderEthAddress, feePayer = _ref5.feePayer, operatorEthAddress = _ref5.operatorEthAddress, attestations = _ref5.attestations, transactionHandler = _ref5.transactionHandler;
            _context10.next = 3;
            return SolanaUtils.findProgramAddressFromPubkey(rewardManagerProgramId, rewardManagerAccount);

          case 3:
            _yield$SolanaUtils$fi5 = _context10.sent;
            _yield$SolanaUtils$fi6 = _slicedToArray(_yield$SolanaUtils$fi5, 1);
            rewardManagerAuthority = _yield$SolanaUtils$fi6[0];
            encodedSenderMessage = constructCreateSenderMessage(senderEthAddress, rewardManagerAccount);
            signerEthAddresses = attestations.map(function (meta) {
              return meta.ethAddress;
            });
            signerInstructions = attestations.map(function (meta, i) {
              return generateCreateSenderSecpInstruction({
                attestationMeta: meta,
                instructionIndex: i,
                encodedSenderMessage: encodedSenderMessage
              });
            });
            _context10.next = 11;
            return generateCreateSenderInstruction({
              senderEthAddress: senderEthAddress,
              operatorEthAddress: operatorEthAddress,
              rewardManagerAccount: rewardManagerAccount,
              rewardManagerAuthority: rewardManagerAuthority,
              rewardManagerProgramId: rewardManagerProgramId,
              feePayer: feePayer,
              signerEthAddresses: signerEthAddresses
            });

          case 11:
            createSenderInstruction = _context10.sent;
            instructions = [].concat(_toConsumableArray(signerInstructions), [createSenderInstruction]);
            _context10.next = 15;
            return transactionHandler.handleTransaction({
              instructions: instructions,
              errorMapping: RewardsManagerError,
              feePayerOverride: feePayer
            });

          case 15:
            return _context10.abrupt("return", _context10.sent);

          case 16:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));
  return _createSender.apply(this, arguments);
}

var evaluateAttestations = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref6) {
    var rewardManagerProgramId, rewardManagerAccount, rewardManagerTokenSource, challengeId, specifier, recipientEthAddress, userBankProgramAccount, oracleEthAddress, feePayer, tokenAmount, transactionHandler, _ref6$logger, logger, transferId, _yield$deriveMessageA, _yield$deriveMessageA2, rewardManagerAuthority, verifiedMessagesAccount, transferAccount, recipientBankAccount, derivedAAOAddress, accounts, instructionData, serializedInstructionData, serializedInstructionEnum, transferInstruction;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            rewardManagerProgramId = _ref6.rewardManagerProgramId, rewardManagerAccount = _ref6.rewardManagerAccount, rewardManagerTokenSource = _ref6.rewardManagerTokenSource, challengeId = _ref6.challengeId, specifier = _ref6.specifier, recipientEthAddress = _ref6.recipientEthAddress, userBankProgramAccount = _ref6.userBankProgramAccount, oracleEthAddress = _ref6.oracleEthAddress, feePayer = _ref6.feePayer, tokenAmount = _ref6.tokenAmount, transactionHandler = _ref6.transactionHandler, _ref6$logger = _ref6.logger, logger = _ref6$logger === void 0 ? console : _ref6$logger;
            // Get transfer ID
            transferId = SolanaUtils.constructTransferId(challengeId, specifier); // Derive the messages account we previously stored attestations in

            _context.next = 4;
            return deriveMessageAccount(transferId, rewardManagerProgramId, rewardManagerAccount);

          case 4:
            _yield$deriveMessageA = _context.sent;
            _yield$deriveMessageA2 = _slicedToArray(_yield$deriveMessageA, 2);
            rewardManagerAuthority = _yield$deriveMessageA2[0];
            verifiedMessagesAccount = _yield$deriveMessageA2[1];
            _context.next = 10;
            return deriveTransferAccount(transferId, rewardManagerProgramId, rewardManagerAccount);

          case 10:
            transferAccount = _context.sent;
            _context.next = 13;
            return getBankAccountAddress(recipientEthAddress, userBankProgramAccount, splToken.TOKEN_PROGRAM_ID);

          case 13:
            recipientBankAccount = _context.sent;
            _context.next = 16;
            return deriveSolanaSenderFromEthAddress(oracleEthAddress, rewardManagerProgramId, rewardManagerAccount);

          case 16:
            derivedAAOAddress = _context.sent;
            // Construct the requried accounts
            ///   0. `[]` Verified messages
            ///   1. `[]` Reward manager
            ///   2. `[]` Reward manager authority
            ///   3. `[]` Reward token source
            ///   4. `[]` Reward token recipient
            ///   5. `[]` Transfer account
            ///   6. `[]` Bot oracle
            ///   7. `[]` Payer
            ///   8. `[]` Sysvar rent
            ///   9. `[]` Token program id
            ///  10. `[]` System program id
            accounts = [{
              pubkey: verifiedMessagesAccount,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: rewardManagerAccount,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: rewardManagerAuthority,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: rewardManagerTokenSource,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: recipientBankAccount,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: transferAccount,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: derivedAAOAddress,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: feePayer,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: solanaWeb3.SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: splToken.TOKEN_PROGRAM_ID,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: solanaWeb3.SystemProgram.programId,
              isSigner: false,
              isWritable: false
            }]; // Construct the instruction data

            instructionData = new ValidateAttestationsInstructionData({
              amount: tokenAmount.toNumber(),
              id: transferId,
              ethRecipient: SolanaUtils.ethAddressToArray(recipientEthAddress)
            });
            serializedInstructionData = borsh.serialize(validateAttestationsInstructionSchema, instructionData);
            serializedInstructionEnum = Buffer.from(Uint8Array.of.apply(Uint8Array, [EVALUATE_INSTRUCTION_ENUM_VALUE].concat(_toConsumableArray(serializedInstructionData))));
            transferInstruction = new solanaWeb3.TransactionInstruction({
              keys: accounts,
              programId: rewardManagerProgramId,
              data: serializedInstructionEnum
            });
            _context.next = 24;
            return transactionHandler.handleTransaction({
              instructions: [transferInstruction],
              errorMapping: RewardsManagerError,
              logger: logger,
              skipPreflight: false,
              feePayerOverride: feePayer,
              sendBlockhash: false
            });

          case 24:
            return _context.abrupt("return", _context.sent);

          case 25:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function evaluateAttestations(_x3) {
    return _ref7.apply(this, arguments);
  };
}();
/**
 *
 * Helper function to generate a submit attestation instruction.
 */

var generateSubmitAttestationInstruction = /*#__PURE__*/function () {
  var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref8) {
    var attestationMeta, derivedMessageAccount, rewardManagerAccount, rewardManagerAuthority, rewardManagerProgramId, feePayer, transferId, derivedSender, verifyInstructionAccounts, instructionData, serializedInstructionData, serializedInstructionEnum;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            attestationMeta = _ref8.attestationMeta, derivedMessageAccount = _ref8.derivedMessageAccount, rewardManagerAccount = _ref8.rewardManagerAccount, rewardManagerAuthority = _ref8.rewardManagerAuthority, rewardManagerProgramId = _ref8.rewardManagerProgramId, feePayer = _ref8.feePayer, transferId = _ref8.transferId;
            _context2.next = 3;
            return deriveSolanaSenderFromEthAddress(attestationMeta.ethAddress, rewardManagerProgramId, rewardManagerAccount);

          case 3:
            derivedSender = _context2.sent;
            ///   Submit attestations
            ///   0. `[writable]` Verified messages - New or existing account PDA storing verified messages
            ///   1. `[]` Reward manager
            ///   2. `[]` Reward manager authority
            ///   3. `[signer]` Funder
            ///   4. `[]` Sender
            ///   5. `[]` Sysvar rent
            ///   6. `[]` Instruction info
            ///   7. `[]` System program id
            verifyInstructionAccounts = [{
              pubkey: derivedMessageAccount,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: rewardManagerAccount,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: rewardManagerAuthority,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: feePayer,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: derivedSender,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: solanaWeb3.SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: solanaWeb3.SYSVAR_INSTRUCTIONS_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: solanaWeb3.SystemProgram.programId,
              isSigner: false,
              isWritable: false
            }];
            instructionData = new SubmitAttestationInstructionData({
              transferId: transferId
            });
            serializedInstructionData = borsh.serialize(submitAttestationInstructionSchema, instructionData);
            serializedInstructionEnum = Buffer.from(Uint8Array.of.apply(Uint8Array, [SUBMIT_INSTRUCTION_ENUM_VALUE].concat(_toConsumableArray(serializedInstructionData))));
            return _context2.abrupt("return", new solanaWeb3.TransactionInstruction({
              keys: verifyInstructionAccounts,
              programId: rewardManagerProgramId,
              data: serializedInstructionEnum
            }));

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function generateSubmitAttestationInstruction(_x4) {
    return _ref9.apply(this, arguments);
  };
}();
/**
 * Encodes a given signature to a 64 byte array for SECP recovery
 */


var encodeSignature = function encodeSignature(signature) {
  // Perform signature manipulations:
  // - remove the 0x prefix for BN
  // - lose the final byte / recovery ID: the secp instruction constructor
  //   requires only 'r', 's' from the signature, while 'v', the recovery ID,
  //   is passed as a separate argument.
  //   https://medium.com/mycrypto/the-magic-of-digital-signatures-on-ethereum-98fe184dc9c7
  //
  var strippedSignature = signature.replace('0x', '');
  var recoveryIdStr = strippedSignature.slice(strippedSignature.length - 2);
  var recoveryId = new BN__default["default"](recoveryIdStr, 'hex').toNumber();
  strippedSignature = strippedSignature.slice(0, strippedSignature.length - 2); // Pad to 64 bytes - otherwise, signatures starting with '0' would result
  // in < 64 byte arrays

  var encodedSignature = Uint8Array.of.apply(Uint8Array, _toConsumableArray(new BN__default["default"](strippedSignature, 'hex').toArray('be', 64)));
  return {
    encodedSignature: encodedSignature,
    recoveryId: recoveryId
  };
};

var generateAttestationSecpInstruction = function generateAttestationSecpInstruction(_ref10) {
  var attestationMeta = _ref10.attestationMeta,
      instructionIndex = _ref10.instructionIndex,
      encodedSenderMessage = _ref10.encodedSenderMessage;

  var _encodeSignature = encodeSignature(attestationMeta.signature),
      encodedSignature = _encodeSignature.encodedSignature,
      recoveryId = _encodeSignature.recoveryId;

  return solanaWeb3.Secp256k1Program.createInstructionWithEthAddress({
    ethAddress: SolanaUtils.ethAddressToArray(attestationMeta.ethAddress),
    message: encodedSenderMessage,
    signature: encodedSignature,
    recoveryId: recoveryId,
    instructionIndex: instructionIndex
  });
};

var generateCreateSenderSecpInstruction = function generateCreateSenderSecpInstruction(_ref11) {
  var attestationMeta = _ref11.attestationMeta,
      instructionIndex = _ref11.instructionIndex,
      encodedSenderMessage = _ref11.encodedSenderMessage;

  var _encodeSignature2 = encodeSignature(attestationMeta.signature),
      encodedSignature = _encodeSignature2.encodedSignature,
      recoveryId = _encodeSignature2.recoveryId;

  return solanaWeb3.Secp256k1Program.createInstructionWithEthAddress({
    ethAddress: attestationMeta.ethAddress,
    message: encodedSenderMessage,
    signature: encodedSignature,
    recoveryId: recoveryId,
    instructionIndex: instructionIndex
  });
};
/**
 *
 * Helper function generate a create sender instruction.
 */


var generateCreateSenderInstruction = /*#__PURE__*/function () {
  var _ref13 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_ref12) {
    var senderEthAddress, operatorEthAddress, rewardManagerAccount, rewardManagerAuthority, rewardManagerProgramId, feePayer, signerEthAddresses, derivedSenderSolanaAddress, signerSolanaPubKeys, createSenderInstructionAccounts, createSenderPublicInstructionData, serializedInstructionData, serializedInstructionEnum;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            senderEthAddress = _ref12.senderEthAddress, operatorEthAddress = _ref12.operatorEthAddress, rewardManagerAccount = _ref12.rewardManagerAccount, rewardManagerAuthority = _ref12.rewardManagerAuthority, rewardManagerProgramId = _ref12.rewardManagerProgramId, feePayer = _ref12.feePayer, signerEthAddresses = _ref12.signerEthAddresses;
            _context4.next = 3;
            return deriveSolanaSenderFromEthAddress(senderEthAddress, rewardManagerProgramId, rewardManagerAccount);

          case 3:
            derivedSenderSolanaAddress = _context4.sent;
            _context4.next = 6;
            return Promise.all(signerEthAddresses.map( /*#__PURE__*/function () {
              var _ref14 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(signerEthAddress) {
                return regeneratorRuntime.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.next = 2;
                        return deriveSolanaSenderFromEthAddress(signerEthAddress, rewardManagerProgramId, rewardManagerAccount);

                      case 2:
                        return _context3.abrupt("return", _context3.sent);

                      case 3:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function (_x6) {
                return _ref14.apply(this, arguments);
              };
            }()));

          case 6:
            signerSolanaPubKeys = _context4.sent;
            /// 0. `[]` Reward manager
            /// 1. `[]` Reward manager authority
            /// 2. `[signer]` Funder
            /// 3. `[writable]` new_sender
            /// 4. `[]` Bunch of senders which prove creating another one
            createSenderInstructionAccounts = [{
              pubkey: rewardManagerAccount,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: rewardManagerAuthority,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: feePayer,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: derivedSenderSolanaAddress,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: solanaWeb3.SYSVAR_INSTRUCTIONS_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: solanaWeb3.SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: solanaWeb3.SystemProgram.programId,
              isSigner: false,
              isWritable: false
            }].concat(_toConsumableArray(signerSolanaPubKeys.map(function (pubkey) {
              return {
                pubkey: pubkey,
                isSigner: false,
                isWritable: false
              };
            })));
            createSenderPublicInstructionData = new CreateSenderPublicInstructionData({
              ethAddress: SolanaUtils.ethAddressToArray(senderEthAddress),
              operator: SolanaUtils.ethAddressToArray(operatorEthAddress)
            });
            serializedInstructionData = borsh.serialize(createSenderPublicInstructionSchema, createSenderPublicInstructionData);
            serializedInstructionEnum = Buffer.from(Uint8Array.of.apply(Uint8Array, [CREATE_SENDER_PUBLIC_ENUM_VALUE].concat(_toConsumableArray(serializedInstructionData))));
            return _context4.abrupt("return", new solanaWeb3.TransactionInstruction({
              keys: createSenderInstructionAccounts,
              programId: rewardManagerProgramId,
              data: serializedInstructionEnum
            }));

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function generateCreateSenderInstruction(_x5) {
    return _ref13.apply(this, arguments);
  };
}(); // Misc

/**
 * Derives the Solana account associated with a given sender Eth address.
 */


var deriveSolanaSenderFromEthAddress = /*#__PURE__*/function () {
  var _ref15 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(ethAddress, rewardManagerProgramId, rewardManagerAccount) {
    var ethAddressArr, encodedPrefix, _yield$SolanaUtils$fi, _yield$SolanaUtils$fi2, derivedSender;

    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            ethAddressArr = SolanaUtils.ethAddressToArray(ethAddress);
            encodedPrefix = encoder.encode(SENDER_SEED_PREFIX);
            _context5.next = 4;
            return SolanaUtils.findProgramAddressWithAuthority(rewardManagerProgramId, rewardManagerAccount, new Uint8Array([].concat(_toConsumableArray(encodedPrefix), _toConsumableArray(ethAddressArr))));

          case 4:
            _yield$SolanaUtils$fi = _context5.sent;
            _yield$SolanaUtils$fi2 = _slicedToArray(_yield$SolanaUtils$fi, 2);
            derivedSender = _yield$SolanaUtils$fi2[1];
            return _context5.abrupt("return", derivedSender);

          case 8:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function deriveSolanaSenderFromEthAddress(_x7, _x8, _x9) {
    return _ref15.apply(this, arguments);
  };
}();
/**
 * Constructs a create signer message for an existing "signer" eth address
 * @param {string} ethAddress
 * @returns {Uint8Array}
 */

var constructCreateSenderMessage = function constructCreateSenderMessage(ethAddress, rewardManagerAccount) {
  var encodedPrefix = encoder.encode(ADD_SENDER_MESSAGE_PREFIX);
  var ethAddressArr = SolanaUtils.ethAddressToArray(ethAddress);
  var rewardManagerAccountArr = rewardManagerAccount.toBytes();
  var items = [encodedPrefix, rewardManagerAccountArr, ethAddressArr];
  var res = items.slice(1).reduce(function (prev, cur) {
    return Uint8Array.of.apply(Uint8Array, _toConsumableArray(prev).concat(_toConsumableArray(cur)));
  }, Uint8Array.from(items[0]));
  return res;
};
/**
 * Derives the 'transfer account' - the account which represents a single successful disbursement
 * and is used to dedupe - from the transferId and other info
 */


var deriveTransferAccount = /*#__PURE__*/function () {
  var _ref16 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(transferId, rewardProgramId, rewardManager) {
    var seed, _yield$SolanaUtils$fi3, _yield$SolanaUtils$fi4, derivedAddress;

    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            seed = Uint8Array.from([].concat(_toConsumableArray(encoder.encode(TRANSFER_PREFIX)), _toConsumableArray(encoder.encode(transferId))));
            _context6.next = 3;
            return SolanaUtils.findProgramAddressWithAuthority(rewardProgramId, rewardManager, seed);

          case 3:
            _yield$SolanaUtils$fi3 = _context6.sent;
            _yield$SolanaUtils$fi4 = _slicedToArray(_yield$SolanaUtils$fi3, 2);
            derivedAddress = _yield$SolanaUtils$fi4[1];
            return _context6.abrupt("return", derivedAddress);

          case 7:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function deriveTransferAccount(_x10, _x11, _x12) {
    return _ref16.apply(this, arguments);
  };
}();
/**
 * Derives the account to store messages for a single challenge
 */


var deriveMessageAccount = /*#__PURE__*/function () {
  var _ref17 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(transferId, rewardsProgramId, rewardManager) {
    var encodedPrefix, encodedTransferId, seeds;
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            encodedPrefix = encoder.encode(VERIFY_TRANSFER_SEED_PREFIX);
            encodedTransferId = encoder.encode(transferId);
            seeds = Uint8Array.from([].concat(_toConsumableArray(encodedPrefix), _toConsumableArray(encodedTransferId)));
            _context7.next = 5;
            return SolanaUtils.findProgramAddressWithAuthority(rewardsProgramId, rewardManager, seeds);

          case 5:
            return _context7.abrupt("return", _context7.sent);

          case 6:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));

  return function deriveMessageAccount(_x13, _x14, _x15) {
    return _ref17.apply(this, arguments);
  };
}();

var DEFAULT_MINT = 'audio';
var MEMO_PROGRAM_ID = new solanaWeb3.PublicKey('Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo'); // Somewhat arbitrary close-to-zero number of Sol. For context, creating a UserBank costs ~0.002 SOL.
// Without this padding, we could reach some low non-zero number of SOL where transactions would fail
// despite a remaining balance.

var ZERO_SOL_EPSILON = 0.005;
var SOL_PER_LAMPORT = 0.000000001; // Generous default connection confirmation timeout to better cope with RPC congestion

var DEFAULT_CONNECTION_CONFIRMATION_TIMEOUT_MS = 180 * 1000;
/**
 * SolanaWeb3Manager acts as the interface to solana contracts from a client.
 * It wraps methods to create and lookup user banks, transfer balances, and
 * interact with the @solana/web3 library.
 *
 * Note: Callers of this class should specify all $AUDIO amounts in units of wei.
 * The internals of this class should handle the conversion from wei AUDIO to wormhole
 * $AUDIO amounts.
 */

var SolanaWeb3Manager = /*#__PURE__*/function () {
  function SolanaWeb3Manager(solanaWeb3Config, identityService, web3Manager) {
    _classCallCheck(this, SolanaWeb3Manager);

    _defineProperty$1(this, "solanaWeb3Config", void 0);

    _defineProperty$1(this, "identityService", void 0);

    _defineProperty$1(this, "web3Manager", void 0);

    _defineProperty$1(this, "solanaWeb3", void 0);

    _defineProperty$1(this, "splToken", void 0);

    _defineProperty$1(this, "solanaClusterEndpoint", void 0);

    _defineProperty$1(this, "transactionHandler", void 0);

    _defineProperty$1(this, "connection", void 0);

    _defineProperty$1(this, "mints", void 0);

    _defineProperty$1(this, "claimableTokenPDAs", void 0);

    _defineProperty$1(this, "solanaTokenAddress", void 0);

    _defineProperty$1(this, "solanaTokenKey", void 0);

    _defineProperty$1(this, "feePayerAddress", void 0);

    _defineProperty$1(this, "feePayerKey", void 0);

    _defineProperty$1(this, "claimableTokenProgramKey", void 0);

    _defineProperty$1(this, "rewardManagerProgramId", void 0);

    _defineProperty$1(this, "rewardManagerProgramPDA", void 0);

    _defineProperty$1(this, "rewardManagerTokenPDA", void 0);

    this.solanaWeb3Config = solanaWeb3Config;
    this.identityService = identityService;
    this.web3Manager = web3Manager;
    this.solanaWeb3 = solanaWeb3__default["default"];
    this.splToken = splToken__default["default"];
  }

  _createClass(SolanaWeb3Manager, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this$solanaWeb3Confi, solanaClusterEndpoint, mintAddress, usdcMintAddress, solanaTokenAddress, feePayerAddress, claimableTokenProgramAddress, rewardsManagerProgramId, rewardsManagerProgramPDA, rewardsManagerTokenPDA, useRelay, feePayerKeypairs, confirmationTimeout, _feePayerKeypairs$, audioPDA, usdcPDA;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this$solanaWeb3Confi = this.solanaWeb3Config, solanaClusterEndpoint = _this$solanaWeb3Confi.solanaClusterEndpoint, mintAddress = _this$solanaWeb3Confi.mintAddress, usdcMintAddress = _this$solanaWeb3Confi.usdcMintAddress, solanaTokenAddress = _this$solanaWeb3Confi.solanaTokenAddress, feePayerAddress = _this$solanaWeb3Confi.feePayerAddress, claimableTokenProgramAddress = _this$solanaWeb3Confi.claimableTokenProgramAddress, rewardsManagerProgramId = _this$solanaWeb3Confi.rewardsManagerProgramId, rewardsManagerProgramPDA = _this$solanaWeb3Confi.rewardsManagerProgramPDA, rewardsManagerTokenPDA = _this$solanaWeb3Confi.rewardsManagerTokenPDA, useRelay = _this$solanaWeb3Confi.useRelay, feePayerKeypairs = _this$solanaWeb3Confi.feePayerKeypairs, confirmationTimeout = _this$solanaWeb3Confi.confirmationTimeout;
                this.solanaClusterEndpoint = solanaClusterEndpoint;
                this.connection = new solanaWeb3.Connection(this.solanaClusterEndpoint, {
                  confirmTransactionInitialTimeout: confirmationTimeout || DEFAULT_CONNECTION_CONFIRMATION_TIMEOUT_MS
                });
                this.transactionHandler = new TransactionHandler({
                  connection: this.connection,
                  useRelay: useRelay,
                  identityService: this.identityService,
                  feePayerKeypairs: feePayerKeypairs
                });
                this.mints = {
                  audio: SolanaUtils.newPublicKeyNullable(mintAddress),
                  usdc: SolanaUtils.newPublicKeyNullable(usdcMintAddress)
                };
                this.solanaTokenAddress = solanaTokenAddress;
                this.solanaTokenKey = SolanaUtils.newPublicKeyNullable(solanaTokenAddress);

                if (feePayerAddress) {
                  this.feePayerAddress = feePayerAddress;
                  this.feePayerKey = SolanaUtils.newPublicKeyNullable(feePayerAddress);
                } else if (feePayerKeypairs !== null && feePayerKeypairs !== void 0 && feePayerKeypairs.length) {
                  this.feePayerAddress = feePayerKeypairs[0].publicKey;
                  this.feePayerKey = SolanaUtils.newPublicKeyNullable((_feePayerKeypairs$ = feePayerKeypairs[0]) === null || _feePayerKeypairs$ === void 0 ? void 0 : _feePayerKeypairs$.publicKey);
                }

                this.claimableTokenProgramKey = SolanaUtils.newPublicKeyNullable(claimableTokenProgramAddress);

                if (!this.claimableTokenProgramKey) {
                  _context.next = 15;
                  break;
                }

                _context.next = 12;
                return SolanaUtils.findProgramAddressFromPubkey(this.claimableTokenProgramKey, this.mints.audio);

              case 12:
                _context.t0 = _context.sent[0].toString();
                _context.next = 16;
                break;

              case 15:
                _context.t0 = null;

              case 16:
                audioPDA = _context.t0;

                if (!this.claimableTokenProgramKey) {
                  _context.next = 23;
                  break;
                }

                _context.next = 20;
                return SolanaUtils.findProgramAddressFromPubkey(this.claimableTokenProgramKey, this.mints.usdc);

              case 20:
                _context.t1 = _context.sent[0].toString();
                _context.next = 24;
                break;

              case 23:
                _context.t1 = '';

              case 24:
                usdcPDA = _context.t1;
                this.claimableTokenPDAs = {
                  audio: SolanaUtils.newPublicKeyNullable(audioPDA),
                  usdc: SolanaUtils.newPublicKeyNullable(usdcPDA)
                };
                this.rewardManagerProgramId = SolanaUtils.newPublicKeyNullable(rewardsManagerProgramId);
                this.rewardManagerProgramPDA = SolanaUtils.newPublicKeyNullable(rewardsManagerProgramPDA);
                this.rewardManagerTokenPDA = SolanaUtils.newPublicKeyNullable(rewardsManagerTokenPDA);

              case 29:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "doesUserbankExist",
    value: function () {
      var _doesUserbankExist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _ref,
            ethAddress,
            _ref$mint,
            mint,
            userbank,
            tokenAccount,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, ethAddress = _ref.ethAddress, _ref$mint = _ref.mint, mint = _ref$mint === void 0 ? DEFAULT_MINT : _ref$mint;
                _context2.next = 3;
                return this.deriveUserBank({
                  ethAddress: ethAddress,
                  mint: mint
                });

              case 3:
                userbank = _context2.sent;
                _context2.next = 6;
                return this.getTokenAccountInfo(userbank.toString(), mint);

              case 6:
                tokenAccount = _context2.sent;
                return _context2.abrupt("return", !!tokenAccount);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function doesUserbankExist() {
        return _doesUserbankExist.apply(this, arguments);
      }

      return doesUserbankExist;
    }()
    /**
     * Creates a solana bank account, either for optional `ethAddress` or from the web3 provider's eth address
     */

  }, {
    key: "createUserBank",
    value: function () {
      var _createUserBank = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref2) {
        var feePayerOverride, ethAddress, _ref2$mint, mint;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                feePayerOverride = _ref2.feePayerOverride, ethAddress = _ref2.ethAddress, _ref2$mint = _ref2.mint, mint = _ref2$mint === void 0 ? DEFAULT_MINT : _ref2$mint;

                if (this.web3Manager) {
                  _context3.next = 3;
                  break;
                }

                throw new Error('A web3Manager is required for this solanaWeb3Manager method');

              case 3:
                _context3.next = 5;
                return createUserBankFrom({
                  ethAddress: ethAddress !== null && ethAddress !== void 0 ? ethAddress : this.web3Manager.getWalletAddress(),
                  claimableTokenPDAKey: this.claimableTokenPDAs[mint],
                  feePayerKey: SolanaUtils.newPublicKeyNullable(feePayerOverride) || this.feePayerKey,
                  mintKey: this.mints[mint],
                  solanaTokenProgramKey: this.solanaTokenKey,
                  claimableTokenProgramKey: this.claimableTokenProgramKey,
                  transactionHandler: this.transactionHandler
                });

              case 5:
                return _context3.abrupt("return", _context3.sent);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function createUserBank(_x) {
        return _createUserBank.apply(this, arguments);
      }

      return createUserBank;
    }()
    /**
     * Creates a userbank if needed.
     * Returns the userbank address as `userbank` if it was created or already existed, or `error` if it failed to create.
     */

  }, {
    key: "createUserBankIfNeeded",
    value: function () {
      var _createUserBankIfNeeded = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_ref3) {
        var feePayerOverride, ethAddress, _ref3$mint, mint, didExist, response, derived;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                feePayerOverride = _ref3.feePayerOverride, ethAddress = _ref3.ethAddress, _ref3$mint = _ref3.mint, mint = _ref3$mint === void 0 ? DEFAULT_MINT : _ref3$mint;
                _context4.next = 3;
                return this.doesUserbankExist({
                  ethAddress: ethAddress,
                  mint: mint
                });

              case 3:
                didExist = _context4.sent;

                if (didExist) {
                  _context4.next = 10;
                  break;
                }

                _context4.next = 7;
                return this.createUserBank({
                  feePayerOverride: feePayerOverride,
                  ethAddress: ethAddress,
                  mint: mint
                });

              case 7:
                response = _context4.sent;

                if (!response.error) {
                  _context4.next = 10;
                  break;
                }

                return _context4.abrupt("return", {
                  error: response.error,
                  errorCode: response.errorCode
                });

              case 10:
                _context4.next = 12;
                return this.deriveUserBank({
                  ethAddress: ethAddress,
                  mint: mint
                });

              case 12:
                derived = _context4.sent;
                return _context4.abrupt("return", {
                  userbank: derived,
                  didExist: didExist
                });

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function createUserBankIfNeeded(_x2) {
        return _createUserBankIfNeeded.apply(this, arguments);
      }

      return createUserBankIfNeeded;
    }()
    /**
     * Creates a token account for the provided solana address (a wallet)
     * See https://spl.solana.com/associated-token-account
     */

  }, {
    key: "createAssociatedTokenAccount",
    value: function () {
      var _createAssociatedTokenAccount2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(solanaAddress) {
        var mint,
            _args5 = arguments;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                mint = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : DEFAULT_MINT;
                _context5.next = 3;
                return createAssociatedTokenAccount({
                  feePayerKey: this.feePayerKey,
                  solanaWalletKey: new solanaWeb3.PublicKey(solanaAddress),
                  mintKey: this.mints[mint],
                  solanaTokenProgramKey: this.solanaTokenKey,
                  connection: this.connection,
                  identityService: this.identityService
                });

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function createAssociatedTokenAccount$1(_x3) {
        return _createAssociatedTokenAccount2.apply(this, arguments);
      }

      return createAssociatedTokenAccount$1;
    }()
    /**
     * Finds the user bank token account for a provided solana address (a wallet) for the given mint
     * See https://spl.solana.com/associated-token-account
     */

  }, {
    key: "findAssociatedTokenAddress",
    value: function () {
      var _findAssociatedTokenAddress2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(solanaAddress) {
        var mint,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                mint = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : DEFAULT_MINT;
                _context6.next = 3;
                return findAssociatedTokenAddress({
                  solanaWalletKey: new solanaWeb3.PublicKey(solanaAddress),
                  mintKey: this.mints[mint],
                  solanaTokenProgramKey: this.solanaTokenKey
                });

              case 3:
                return _context6.abrupt("return", _context6.sent);

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function findAssociatedTokenAddress$1(_x4) {
        return _findAssociatedTokenAddress2.apply(this, arguments);
      }

      return findAssociatedTokenAddress$1;
    }()
    /**
     * Gets a solana bank account from `ethAddress` or the current web3 provider's eth address.
     */

  }, {
    key: "deriveUserBank",
    value: function () {
      var _deriveUserBank = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var _ref4,
            ethAddress,
            _ref4$mint,
            mint,
            derivationSourceAddress,
            bank,
            _args7 = arguments;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _ref4 = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {}, ethAddress = _ref4.ethAddress, _ref4$mint = _ref4.mint, mint = _ref4$mint === void 0 ? DEFAULT_MINT : _ref4$mint;

                if (this.web3Manager) {
                  _context7.next = 3;
                  break;
                }

                throw new Error('A web3Manager is required for this solanaWeb3Manager method');

              case 3:
                derivationSourceAddress = ethAddress !== null && ethAddress !== void 0 ? ethAddress : this.web3Manager.getWalletAddress();
                _context7.next = 6;
                return getBankAccountAddress(derivationSourceAddress, this.claimableTokenPDAs[mint], this.solanaTokenKey);

              case 6:
                bank = _context7.sent;
                return _context7.abrupt("return", bank);

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function deriveUserBank() {
        return _deriveUserBank.apply(this, arguments);
      }

      return deriveUserBank;
    }()
    /**
     * Gets the info for a user bank/wAudio token account given a spl-token address.
     * If the address is not a valid token account, returns `null`
     */

  }, {
    key: "getTokenAccountInfo",
    value: function () {
      var _getTokenAccountInfo2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(solanaAddress) {
        var mint,
            res,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                mint = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : DEFAULT_MINT;
                _context8.prev = 1;
                _context8.next = 4;
                return getTokenAccountInfo({
                  tokenAccountAddressKey: new solanaWeb3.PublicKey(solanaAddress),
                  mintKey: this.mints[mint],
                  solanaTokenProgramKey: this.solanaTokenKey,
                  connection: this.connection
                });

              case 4:
                res = _context8.sent;
                return _context8.abrupt("return", res);

              case 8:
                _context8.prev = 8;
                _context8.t0 = _context8["catch"](1);
                return _context8.abrupt("return", null);

              case 11:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[1, 8]]);
      }));

      function getTokenAccountInfo$1(_x5) {
        return _getTokenAccountInfo2.apply(this, arguments);
      }

      return getTokenAccountInfo$1;
    }()
    /**
     * Gets the SPL waudio balance for a solana address in wei with 18 decimals
     */

  }, {
    key: "getWAudioBalance",
    value: function () {
      var _getWAudioBalance = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(solanaAddress) {
        var tokenAccount, associatedTokenAccount, decimals;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.prev = 0;
                _context9.next = 3;
                return this.getTokenAccountInfo(solanaAddress);

              case 3:
                tokenAccount = _context9.sent;

                if (tokenAccount) {
                  _context9.next = 13;
                  break;
                }

                _context9.next = 7;
                return this.findAssociatedTokenAddress(solanaAddress);

              case 7:
                associatedTokenAccount = _context9.sent;
                _context9.next = 10;
                return this.getTokenAccountInfo(associatedTokenAccount.toString());

              case 10:
                tokenAccount = _context9.sent;

                if (tokenAccount) {
                  _context9.next = 13;
                  break;
                }

                return _context9.abrupt("return", null);

              case 13:
                // Multiply by 10^10 to maintain same decimals as eth $AUDIO
                decimals = AUDIO_DECMIALS - WAUDIO_DECMIALS;
                return _context9.abrupt("return", tokenAccount.amount.mul(Utils.toBN('1'.padEnd(decimals + 1, '0'))));

              case 17:
                _context9.prev = 17;
                _context9.t0 = _context9["catch"](0);
                return _context9.abrupt("return", null);

              case 20:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[0, 17]]);
      }));

      function getWAudioBalance(_x6) {
        return _getWAudioBalance.apply(this, arguments);
      }

      return getWAudioBalance;
    }()
    /**
     * Transfers audio from the web3 provider's eth address
     * @param {string} recipientSolanaAddress
     *  Recipient solana address which is either a user bank, wAudio token account,
     *  or a solana account. In the last case, an associated token account is created
     *  if one does not already exist for the solana account
     * @param {BN} amount the amount of $AUDIO to send in wei units of $AUDIO.
     * **IMPORTANT NOTE**
     * wAudio (Solana) does not support 10^-18 (wei) units of $AUDIO. The smallest
     * demarcation on that side is 10^-8, so the $AUDIO amount must be >= 10^8 and have no
     * remainder after a division with 10^8 or this method will throw.
     *
     * Generally speaking, callers into the solanaWeb3Manager should use BN.js representation
     * of wei $AUDIO for all method calls
     */

  }, {
    key: "transferWAudio",
    value: function () {
      var _transferWAudio = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(recipientSolanaAddress, amount) {
        var tokenAccountInfo, associatedTokenAccount, wAudioAmount, ethAddress, senderSolanaAddress;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (this.web3Manager) {
                  _context10.next = 2;
                  break;
                }

                throw new Error('A web3Manager is required for this solanaWeb3Manager method');

              case 2:
                _context10.next = 4;
                return this.getTokenAccountInfo(recipientSolanaAddress);

              case 4:
                tokenAccountInfo = _context10.sent;

                if (tokenAccountInfo) {
                  _context10.next = 18;
                  break;
                }

                console.info('Provided recipient solana address was not a token account'); // If not, check to see if it already has an associated token account.

                _context10.next = 9;
                return this.findAssociatedTokenAddress(recipientSolanaAddress);

              case 9:
                associatedTokenAccount = _context10.sent;
                _context10.next = 12;
                return this.getTokenAccountInfo(associatedTokenAccount.toString());

              case 12:
                tokenAccountInfo = _context10.sent;

                if (tokenAccountInfo) {
                  _context10.next = 17;
                  break;
                }

                console.info('Provided recipient solana address has no associated token account, creating');
                _context10.next = 17;
                return this.createAssociatedTokenAccount(recipientSolanaAddress);

              case 17:
                recipientSolanaAddress = associatedTokenAccount.toString();

              case 18:
                console.info("Transfering ".concat(amount.toString(), " wei $AUDIO to ").concat(recipientSolanaAddress));
                wAudioAmount = wAudioFromWeiAudio(amount);
                ethAddress = this.web3Manager.getWalletAddress();
                _context10.next = 23;
                return getBankAccountAddress(ethAddress, this.claimableTokenPDAs.audio, this.solanaTokenKey);

              case 23:
                senderSolanaAddress = _context10.sent;
                _context10.next = 26;
                return transferWAudioBalance({
                  amount: wAudioAmount,
                  senderEthAddress: ethAddress,
                  feePayerKey: this.feePayerKey,
                  senderEthPrivateKey: this.web3Manager.getOwnerWalletPrivateKey(),
                  senderSolanaAddress: senderSolanaAddress,
                  recipientSolanaAddress: recipientSolanaAddress,
                  claimableTokenPDA: this.claimableTokenPDAs.audio,
                  solanaTokenProgramKey: this.solanaTokenKey,
                  claimableTokenProgramKey: this.claimableTokenProgramKey,
                  connection: this.connection,
                  mintKey: this.mints.audio,
                  transactionHandler: this.transactionHandler
                });

              case 26:
                return _context10.abrupt("return", _context10.sent);

              case 27:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function transferWAudio(_x7, _x8) {
        return _transferWAudio.apply(this, arguments);
      }

      return transferWAudio;
    }()
    /**
     * Purchases USDC gated content
     * @param params.id the id of the content, eg. the track ID
     * @param params.type the type of the content, eg. "track"
     * @param params.blocknumber the blocknumber the content was last updated
     * @param params.splits map of address to USDC amount, used to split the price amoung several stakeholders
     * @returns the transaction signature and/or an error
     */

  }, {
    key: "purchaseContent",
    value: function () {
      var _purchaseContent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(_ref5) {
        var id, type, blocknumber, splits, totalAmount, senderEthAddress, senderSolanaAddress, instructions, memoInstruction;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                id = _ref5.id, type = _ref5.type, blocknumber = _ref5.blocknumber, splits = _ref5.splits;

                if (this.web3Manager) {
                  _context11.next = 3;
                  break;
                }

                throw new Error('A web3Manager is required for this solanaWeb3Manager method');

              case 3:
                if (!(Object.values(splits).length !== 1)) {
                  _context11.next = 5;
                  break;
                }

                throw new Error('Purchasing content only supports a single split. Specifying more splits coming soon!');

              case 5:
                totalAmount = Object.values(splits).reduce(function (sum, split) {
                  return split instanceof BN__default["default"] ? sum.add(split) : sum.addn(split);
                }, new BN__default["default"](0));
                senderEthAddress = this.web3Manager.getWalletAddress();
                _context11.next = 9;
                return getBankAccountAddress(senderEthAddress, this.claimableTokenPDAs.usdc, this.solanaTokenKey);

              case 9:
                senderSolanaAddress = _context11.sent;
                _context11.next = 12;
                return createTransferInstructions({
                  amount: totalAmount,
                  feePayerKey: this.feePayerKey,
                  senderEthAddress: senderEthAddress,
                  senderEthPrivateKey: this.web3Manager.getOwnerWalletPrivateKey(),
                  senderSolanaAddress: senderSolanaAddress,
                  recipientSolanaAddress: Object.keys(splits)[0],
                  claimableTokenPDA: this.claimableTokenPDAs.usdc,
                  solanaTokenProgramKey: this.solanaTokenKey,
                  claimableTokenProgramKey: this.claimableTokenProgramKey,
                  connection: this.connection,
                  mintKey: this.mints.usdc
                });

              case 12:
                instructions = _context11.sent;
                memoInstruction = new solanaWeb3.TransactionInstruction({
                  keys: [{
                    pubkey: new solanaWeb3.PublicKey(this.feePayerKey),
                    isSigner: true,
                    isWritable: true
                  }],
                  programId: MEMO_PROGRAM_ID,
                  data: Buffer.from("".concat(type, ":").concat(id, ":").concat(blocknumber))
                });
                _context11.next = 16;
                return this.transactionHandler.handleTransaction({
                  instructions: [].concat(_toConsumableArray(instructions), [memoInstruction]),
                  skipPreflight: true,
                  feePayerOverride: this.feePayerKey
                });

              case 16:
                return _context11.abrupt("return", _context11.sent);

              case 17:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function purchaseContent(_x9) {
        return _purchaseContent.apply(this, arguments);
      }

      return purchaseContent;
    }()
    /**
     * Submits attestations for challenge completion to the RewardsManager program on Solana.
     */

  }, {
    key: "submitChallengeAttestations",
    value: function () {
      var _submitChallengeAttestations = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(_ref6) {
        var _SolanaUtils$newPubli;

        var attestations, oracleAttestation, challengeId, specifier, recipientEthAddress, tokenAmount, instructionsPerTransaction, _ref6$logger, logger, _ref6$feePayerOverrid, feePayerOverride;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                attestations = _ref6.attestations, oracleAttestation = _ref6.oracleAttestation, challengeId = _ref6.challengeId, specifier = _ref6.specifier, recipientEthAddress = _ref6.recipientEthAddress, tokenAmount = _ref6.tokenAmount, instructionsPerTransaction = _ref6.instructionsPerTransaction, _ref6$logger = _ref6.logger, logger = _ref6$logger === void 0 ? console : _ref6$logger, _ref6$feePayerOverrid = _ref6.feePayerOverride, feePayerOverride = _ref6$feePayerOverrid === void 0 ? null : _ref6$feePayerOverrid;
                _context12.next = 3;
                return submitAttestations({
                  rewardManagerProgramId: this.rewardManagerProgramId,
                  rewardManagerAccount: this.rewardManagerProgramPDA,
                  attestations: attestations,
                  oracleAttestation: oracleAttestation,
                  challengeId: challengeId,
                  specifier: specifier,
                  feePayer: (_SolanaUtils$newPubli = SolanaUtils.newPublicKeyNullable(feePayerOverride)) !== null && _SolanaUtils$newPubli !== void 0 ? _SolanaUtils$newPubli : this.feePayerKey,
                  recipientEthAddress: recipientEthAddress,
                  tokenAmount: tokenAmount,
                  transactionHandler: this.transactionHandler,
                  instructionsPerTransaction: instructionsPerTransaction,
                  logger: logger
                });

              case 3:
                return _context12.abrupt("return", _context12.sent);

              case 4:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function submitChallengeAttestations(_x10) {
        return _submitChallengeAttestations.apply(this, arguments);
      }

      return submitChallengeAttestations;
    }()
    /**
     * Evaluates existing submitted attestations, disbursing if successful.
     */

  }, {
    key: "evaluateChallengeAttestations",
    value: function () {
      var _evaluateChallengeAttestations = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref7) {
        var _SolanaUtils$newPubli2;

        var challengeId, specifier, recipientEthAddress, oracleEthAddress, tokenAmount, _ref7$logger, logger, _ref7$feePayerOverrid, feePayerOverride;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                challengeId = _ref7.challengeId, specifier = _ref7.specifier, recipientEthAddress = _ref7.recipientEthAddress, oracleEthAddress = _ref7.oracleEthAddress, tokenAmount = _ref7.tokenAmount, _ref7$logger = _ref7.logger, logger = _ref7$logger === void 0 ? console : _ref7$logger, _ref7$feePayerOverrid = _ref7.feePayerOverride, feePayerOverride = _ref7$feePayerOverrid === void 0 ? null : _ref7$feePayerOverrid;
                _context13.next = 3;
                return evaluateAttestations({
                  rewardManagerProgramId: this.rewardManagerProgramId,
                  rewardManagerAccount: this.rewardManagerProgramPDA,
                  rewardManagerTokenSource: this.rewardManagerTokenPDA,
                  challengeId: challengeId,
                  specifier: specifier,
                  recipientEthAddress: recipientEthAddress,
                  userBankProgramAccount: this.claimableTokenPDAs.audio,
                  oracleEthAddress: oracleEthAddress,
                  feePayer: (_SolanaUtils$newPubli2 = SolanaUtils.newPublicKeyNullable(feePayerOverride)) !== null && _SolanaUtils$newPubli2 !== void 0 ? _SolanaUtils$newPubli2 : this.feePayerKey,
                  tokenAmount: tokenAmount,
                  transactionHandler: this.transactionHandler,
                  logger: logger
                });

              case 3:
                return _context13.abrupt("return", _context13.sent);

              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function evaluateChallengeAttestations(_x11) {
        return _evaluateChallengeAttestations.apply(this, arguments);
      }

      return evaluateChallengeAttestations;
    }()
    /**
     * Creates a new rewards signer (one that can attest)
     */

  }, {
    key: "createSender",
    value: function () {
      var _createSender2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(_ref8) {
        var _SolanaUtils$newPubli3;

        var senderEthAddress, operatorEthAddress, attestations, _ref8$feePayerOverrid, feePayerOverride;

        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                senderEthAddress = _ref8.senderEthAddress, operatorEthAddress = _ref8.operatorEthAddress, attestations = _ref8.attestations, _ref8$feePayerOverrid = _ref8.feePayerOverride, feePayerOverride = _ref8$feePayerOverrid === void 0 ? null : _ref8$feePayerOverrid;
                _context14.next = 3;
                return createSender({
                  rewardManagerProgramId: this.rewardManagerProgramId,
                  rewardManagerAccount: this.rewardManagerProgramPDA,
                  senderEthAddress: senderEthAddress,
                  feePayer: (_SolanaUtils$newPubli3 = SolanaUtils.newPublicKeyNullable(feePayerOverride)) !== null && _SolanaUtils$newPubli3 !== void 0 ? _SolanaUtils$newPubli3 : this.feePayerKey,
                  operatorEthAddress: operatorEthAddress,
                  attestations: attestations,
                  identityService: this.identityService,
                  transactionHandler: this.transactionHandler
                });

              case 3:
                return _context14.abrupt("return", _context14.sent);

              case 4:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function createSender$1(_x12) {
        return _createSender2.apply(this, arguments);
      }

      return createSender$1;
    }()
    /**
     * Gets the balance of a PublicKey, in SOL
     */

  }, {
    key: "getBalance",
    value: function () {
      var _getBalance = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(_ref9) {
        var publicKey, lamports;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                publicKey = _ref9.publicKey;
                _context15.next = 3;
                return this.connection.getBalance(publicKey);

              case 3:
                lamports = _context15.sent;
                return _context15.abrupt("return", lamports * SOL_PER_LAMPORT);

              case 5:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getBalance(_x13) {
        return _getBalance.apply(this, arguments);
      }

      return getBalance;
    }()
    /**
     * Gets whether a PublicKey has a usable balance
     */

  }, {
    key: "hasBalance",
    value: function () {
      var _hasBalance = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(_ref10) {
        var publicKey, _ref10$epsilon, epsilon, balance;

        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                publicKey = _ref10.publicKey, _ref10$epsilon = _ref10.epsilon, epsilon = _ref10$epsilon === void 0 ? ZERO_SOL_EPSILON : _ref10$epsilon;
                _context16.next = 3;
                return this.getBalance({
                  publicKey: publicKey
                });

              case 3:
                balance = _context16.sent;
                return _context16.abrupt("return", balance > epsilon);

              case 5:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function hasBalance(_x14) {
        return _hasBalance.apply(this, arguments);
      }

      return hasBalance;
    }()
  }, {
    key: "getSolBalance",
    value: function () {
      var _getSolBalance = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(address) {
        var publicKey, balance, balanceBN;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                publicKey = new solanaWeb3.PublicKey(address);
                _context17.next = 3;
                return this.getBalance({
                  publicKey: publicKey
                });

              case 3:
                balance = _context17.sent;
                balanceBN = Utils.toBN(balance * solanaWeb3.LAMPORTS_PER_SOL);
                return _context17.abrupt("return", balanceBN);

              case 6:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getSolBalance(_x15) {
        return _getSolBalance.apply(this, arguments);
      }

      return getSolBalance;
    }()
  }, {
    key: "getSlot",
    value: function () {
      var _getSlot = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.connection.getSlot('processed');

              case 2:
                return _context18.abrupt("return", _context18.sent);

              case 3:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getSlot() {
        return _getSlot.apply(this, arguments);
      }

      return getSlot;
    }()
  }, {
    key: "getRandomFeePayer",
    value: function () {
      var _getRandomFeePayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
        var _this$identityService;

        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return (_this$identityService = this.identityService) === null || _this$identityService === void 0 ? void 0 : _this$identityService.getRandomFeePayer();

              case 2:
                return _context19.abrupt("return", _context19.sent);

              case 3:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getRandomFeePayer() {
        return _getRandomFeePayer.apply(this, arguments);
      }

      return getRandomFeePayer;
    }()
    /**
     * Gets whether a given node registered on eth with `senderEthAddress` is registered on Solana
     */

  }, {
    key: "getIsDiscoveryNodeRegistered",
    value: function () {
      var _getIsDiscoveryNodeRegistered = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(senderEthAddress) {
        var derivedSenderSolanaAddress, res;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return deriveSolanaSenderFromEthAddress(senderEthAddress, this.rewardManagerProgramId, this.rewardManagerProgramPDA);

              case 2:
                derivedSenderSolanaAddress = _context20.sent;
                _context20.next = 5;
                return this.connection.getAccountInfo(derivedSenderSolanaAddress);

              case 5:
                res = _context20.sent;
                return _context20.abrupt("return", !!res);

              case 7:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getIsDiscoveryNodeRegistered(_x16) {
        return _getIsDiscoveryNodeRegistered.apply(this, arguments);
      }

      return getIsDiscoveryNodeRegistered;
    }()
  }, {
    key: "findProgramAddress",
    value: function () {
      var _findProgramAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(programId, pubkey) {
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return solanaWeb3.PublicKey.findProgramAddress([pubkey.toBytes().slice(0, 32)], programId);

              case 2:
                return _context21.abrupt("return", _context21.sent);

              case 3:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21);
      }));

      function findProgramAddress(_x17, _x18) {
        return _findProgramAddress.apply(this, arguments);
      }

      return findProgramAddress;
    }()
    /**
     * Finds a 'derived' address by finding a programAddress with
     * seeds array  as first 32 bytes of base + seeds
     * @returns the program address
     */

  }, {
    key: "findDerivedAddress",
    value: function () {
      var _findDerivedAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(programId, base, seed) {
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return solanaWeb3.PublicKey.findProgramAddress([base.toBytes().slice(0, 32), seed], programId);

              case 2:
                return _context22.abrupt("return", _context22.sent);

              case 3:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22);
      }));

      function findDerivedAddress(_x19, _x20, _x21) {
        return _findDerivedAddress.apply(this, arguments);
      }

      return findDerivedAddress;
    }()
    /**
     * Finds the target PDA with the base audius admin as the initial seed
     * In conjunction with the secondary seed as the users id in bytes
     */

  }, {
    key: "findDerivedPair",
    value: function () {
      var _findDerivedPair = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(programId, adminAccount, seed) {
        var _yield$this$findProgr, _yield$this$findProgr2, baseAuthorityAccount, derivedAddressInfo, derivedAddress, bumpSeed;

        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                programId = SolanaUtils.newPublicKeyNullable(programId);
                adminAccount = SolanaUtils.newPublicKeyNullable(adminAccount);
                _context23.next = 4;
                return this.findProgramAddress(programId, adminAccount);

              case 4:
                _yield$this$findProgr = _context23.sent;
                _yield$this$findProgr2 = _slicedToArray(_yield$this$findProgr, 1);
                baseAuthorityAccount = _yield$this$findProgr2[0];
                _context23.next = 9;
                return this.findDerivedAddress(programId, baseAuthorityAccount, seed);

              case 9:
                derivedAddressInfo = _context23.sent;
                derivedAddress = derivedAddressInfo[0];
                bumpSeed = derivedAddressInfo[1];
                return _context23.abrupt("return", {
                  baseAuthorityAccount: baseAuthorityAccount,
                  derivedAddress: derivedAddress,
                  bumpSeed: bumpSeed
                });

              case 13:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function findDerivedPair(_x22, _x23, _x24) {
        return _findDerivedPair.apply(this, arguments);
      }

      return findDerivedPair;
    }()
    /**
     * Given the eth address buffer from the account, convert to hex
     * @returns hex string of input bytes
     */

  }, {
    key: "deriveEthWalletFromAddress",
    value: function () {
      var _deriveEthWalletFromAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(accountEthAddress) {
        var encodedEthAddress;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                encodedEthAddress = Buffer.from(accountEthAddress).toString('hex');

                if (!encodedEthAddress.startsWith('0x')) {
                  encodedEthAddress = '0x' + encodedEthAddress;
                }

                return _context24.abrupt("return", encodedEthAddress);

              case 3:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24);
      }));

      function deriveEthWalletFromAddress(_x25) {
        return _deriveEthWalletFromAddress.apply(this, arguments);
      }

      return deriveEthWalletFromAddress;
    }()
  }, {
    key: "createTransferInstructionsFromCurrentUser",
    value: function () {
      var _createTransferInstructionsFromCurrentUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(_ref11) {
        var _this$web3Manager;

        var amount, feePayerKey, senderSolanaAddress, recipientSolanaAddress, _ref11$mint, mint, _ref11$instructionInd, instructionIndex, instructions;

        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                amount = _ref11.amount, feePayerKey = _ref11.feePayerKey, senderSolanaAddress = _ref11.senderSolanaAddress, recipientSolanaAddress = _ref11.recipientSolanaAddress, _ref11$mint = _ref11.mint, mint = _ref11$mint === void 0 ? DEFAULT_MINT : _ref11$mint, _ref11$instructionInd = _ref11.instructionIndex, instructionIndex = _ref11$instructionInd === void 0 ? 0 : _ref11$instructionInd;
                _context25.next = 3;
                return createTransferInstructions({
                  amount: amount,
                  feePayerKey: feePayerKey,
                  senderEthAddress: (_this$web3Manager = this.web3Manager) === null || _this$web3Manager === void 0 ? void 0 : _this$web3Manager.getWalletAddress(),
                  senderEthPrivateKey: this.web3Manager.getOwnerWalletPrivateKey(),
                  senderSolanaAddress: senderSolanaAddress,
                  recipientSolanaAddress: recipientSolanaAddress,
                  claimableTokenPDA: this.claimableTokenPDAs[mint],
                  solanaTokenProgramKey: this.solanaTokenKey,
                  claimableTokenProgramKey: this.claimableTokenProgramKey,
                  connection: this.connection,
                  mintKey: this.mints[mint],
                  instructionIndex: instructionIndex
                });

              case 3:
                instructions = _context25.sent;
                return _context25.abrupt("return", instructions);

              case 5:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function createTransferInstructionsFromCurrentUser(_x26) {
        return _createTransferInstructionsFromCurrentUser.apply(this, arguments);
      }

      return createTransferInstructionsFromCurrentUser;
    }()
  }]);

  return SolanaWeb3Manager;
}();

var Services = Object.freeze({
  IDENTITY_SERVICE: 'Identity Service',
  HEDGEHOG: 'Hedgehog',
  DISCOVERY_PROVIDER: 'Discovery Provider',
  CREATOR_NODE: 'Creator Node',
  COMSTOCK: 'Comstock',
  SOLANA_WEB3_MANAGER: 'Solana Web3 Manager'
});
var Base = /*#__PURE__*/function () {
  function Base(userStateManager, identityService, hedgehog, discoveryProvider, web3Manager, contracts, ethWeb3Manager, ethContracts, solanaWeb3Manager, wormholeClient, creatorNode, comstock, isServer) {
    var _this$_serviceMapping;

    var logger = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : console;

    _classCallCheck(this, Base);

    _defineProperty$1(this, "userStateManager", void 0);

    _defineProperty$1(this, "identityService", void 0);

    _defineProperty$1(this, "hedgehog", void 0);

    _defineProperty$1(this, "discoveryProvider", void 0);

    _defineProperty$1(this, "web3Manager", void 0);

    _defineProperty$1(this, "contracts", void 0);

    _defineProperty$1(this, "ethWeb3Manager", void 0);

    _defineProperty$1(this, "ethContracts", void 0);

    _defineProperty$1(this, "solanaWeb3Manager", void 0);

    _defineProperty$1(this, "wormholeClient", void 0);

    _defineProperty$1(this, "creatorNode", void 0);

    _defineProperty$1(this, "comstock", void 0);

    _defineProperty$1(this, "isServer", void 0);

    _defineProperty$1(this, "logger", console);

    _defineProperty$1(this, "_serviceMapping", void 0);

    this.userStateManager = userStateManager;
    this.identityService = identityService;
    this.hedgehog = hedgehog;
    this.discoveryProvider = discoveryProvider;
    this.web3Manager = web3Manager;
    this.contracts = contracts;
    this.ethWeb3Manager = ethWeb3Manager;
    this.ethContracts = ethContracts;
    this.solanaWeb3Manager = solanaWeb3Manager;
    this.wormholeClient = wormholeClient;
    this.creatorNode = creatorNode;
    this.comstock = comstock;
    this.isServer = isServer;
    this.logger = logger;
    this._serviceMapping = (_this$_serviceMapping = {}, _defineProperty$1(_this$_serviceMapping, Services.IDENTITY_SERVICE, this.identityService), _defineProperty$1(_this$_serviceMapping, Services.HEDGEHOG, this.hedgehog), _defineProperty$1(_this$_serviceMapping, Services.DISCOVERY_PROVIDER, this.discoveryProvider), _defineProperty$1(_this$_serviceMapping, Services.CREATOR_NODE, this.creatorNode), _defineProperty$1(_this$_serviceMapping, Services.COMSTOCK, this.comstock), _defineProperty$1(_this$_serviceMapping, Services.SOLANA_WEB3_MANAGER, this.solanaWeb3Manager), _this$_serviceMapping);
  }

  _createClass(Base, [{
    key: "REQUIRES",
    value: function REQUIRES() {
      var _this = this;

      for (var _len = arguments.length, services = new Array(_len), _key = 0; _key < _len; _key++) {
        services[_key] = arguments[_key];
      }

      services.forEach(function (s) {
        if (!_this._serviceMapping[s]) return Base._missingService.apply(Base, services);
      });
    }
  }, {
    key: "IS_OBJECT",
    value: function IS_OBJECT(o) {
      if (_typeof(o) !== 'object') return Base._invalidType('object');
    }
  }, {
    key: "OBJECT_HAS_PROPS",
    value: function OBJECT_HAS_PROPS(o, props, requiredProps) {
      var missingProps = [];
      props.forEach(function (prop) {
        if (!Object.prototype.hasOwnProperty.call(o, prop)) missingProps.push(prop);
      });
      if (missingProps.length > 0) return Base._missingProps(missingProps);
      var missingRequiredProps = [];
      requiredProps.forEach(function (prop) {
        if (!Object.prototype.hasOwnProperty.call(o, prop) || o[prop] === '') missingRequiredProps.push(prop);
      });
      if (missingRequiredProps.length > 0) return Base._missingPropValues(missingRequiredProps);
    }
  }, {
    key: "FILE_IS_VALID",
    value: function FILE_IS_VALID(file) {
      if (this.isServer) {
        if (!file || _typeof(file) !== 'object' || typeof file.pipe !== 'function' || !file.readable) {
          return Base._invalidFile();
        }
      } else {
        if (!file || _typeof(file) !== 'object') {
          return Base._missingFile();
        }
      }
    }
    /* ------- PRIVATE  ------- */

  }], [{
    key: "_missingService",
    value: function _missingService() {
      for (var _len2 = arguments.length, serviceNames = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        serviceNames[_key2] = arguments[_key2];
      }

      throw new Error("Requires the following services: ".concat(serviceNames.join(', ')));
    }
  }, {
    key: "_invalidType",
    value: function _invalidType(type) {
      throw new Error("Argument must be of type ".concat(type));
    }
  }, {
    key: "_missingProps",
    value: function _missingProps(props) {
      throw new Error("Missing props ".concat(props.join(', ')));
    }
  }, {
    key: "_missingPropValues",
    value: function _missingPropValues(props) {
      throw new Error("Missing field values ".concat(props.join(', ')));
    }
  }, {
    key: "_invalidFile",
    value: function _invalidFile() {
      throw new Error('Expected file as readable stream');
    }
  }, {
    key: "_missingFile",
    value: function _missingFile() {
      throw new Error('Missing or malformed file');
    }
  }]);

  return Base;
}();

var decodeHashId$3 = Utils.decodeHashId;
var GetAttestationError = Object.freeze({
  CHALLENGE_INCOMPLETE: 'CHALLENGE_INCOMPLETE',
  ALREADY_DISBURSED: 'ALREADY_DISBURSED',
  INVALID_ORACLE: 'INVALID_ORACLE',
  MISSING_CHALLENGES: 'MISSING_CHALLENGES',
  INVALID_INPUT: 'INVALID_INPUT',
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  HCAPTCHA: 'HCAPTCHA',
  COGNITO_FLOW: 'COGNITO_FLOW',
  DISCOVERY_NODE_ATTESTATION_ERROR: 'DISCOVERY_NODE_ATTESTATION_ERROR',
  DISCOVERY_NODE_UNKNOWN_RESPONSE: 'DISCOVERY_NODE_UNKNOWN_RESPONSE',
  AAO_ATTESTATION_ERROR: 'AAO_ATTESTATION_ERROR',
  AAO_ATTESTATION_REJECTION: 'AAO_ATTESTATION_REJECTION',
  AAO_ATTESTATION_UNKNOWN_RESPONSE: 'AAO_ATTESTATION_UNKNOWN_RESPONSE',
  UNKNOWN_ERROR: 'UNKNOWN_ERROR'
});
var AggregateAttestationError = Object.freeze({
  INSUFFICIENT_DISCOVERY_NODE_COUNT: 'INSUFFICIENT_DISCOVERY_NODE_COUNT',
  UNKNOWN_ERROR: 'UNKNOWN_ERROR'
});
var GetSenderAttestationError = Object.freeze({
  REQUEST_FOR_ATTESTATION_FAILED: 'REQUEST_FOR_ATTESTATION_FAILED'
});
/**
 * Combined error type for `SubmitAndEvaluate`
 */

var SubmitAndEvaluateError = Object.freeze(_objectSpread2(_objectSpread2(_objectSpread2({}, GetAttestationError), AggregateAttestationError), RewardsManagerError));
var AttestationPhases = Object.freeze({
  SANITY_CHECKS: 'SANITY_CHECKS',
  AGGREGATE_ATTESTATIONS: 'AGGREGATE_ATTESTATIONS',
  SUBMIT_ATTESTATIONS: 'SUBMIT_ATTESTATIONS',
  EVALUATE_ATTESTATIONS: 'EVALUATE_ATTESTATIONS'
});
var AAO_REQUEST_TIMEOUT_MS = 15 * 1000;
var WRAPPED_AUDIO_PRECISION = Math.pow(10, WAUDIO_DECMIALS);
var Rewards = /*#__PURE__*/function (_Base) {
  _inherits(Rewards, _Base);

  var _super = _createSuper(Rewards);

  function Rewards(ServiceProvider) {
    var _this;

    _classCallCheck(this, Rewards);

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "ServiceProvider", void 0);

    _this.ServiceProvider = ServiceProvider;
    return _this;
  }
  /**
   * Top level method to aggregate attestations, submit them to RewardsManager, and evalute the result.
   */


  _createClass(Rewards, [{
    key: "submitAndEvaluate",
    value: function () {
      var _submitAndEvaluate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
        var challengeId, encodedUserId, handle, recipientEthAddress, specifier, oracleEthAddress, amount, quorumSize, AAOEndpoint, instructionsPerTransaction, _ref$maxAggregationAt, maxAggregationAttempts, _ref$endpoints, endpoints, _ref$logger, logger, _ref$feePayerOverride, feePayerOverride, phase, nodesToReselect, aaoErrorCode, _yield$this$aggregate, discoveryNodeAttestations, aaoAttestation, aggregateError, errorCode, erroringNodes, fullTokenAmount, _yield$this$solanaWeb, submitErrorCode, submitError, shouldRetryInSeperateTransactions, _yield$this$solanaWeb2, evaluateErrorCode, evaluateError, err, log;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                challengeId = _ref.challengeId, encodedUserId = _ref.encodedUserId, handle = _ref.handle, recipientEthAddress = _ref.recipientEthAddress, specifier = _ref.specifier, oracleEthAddress = _ref.oracleEthAddress, amount = _ref.amount, quorumSize = _ref.quorumSize, AAOEndpoint = _ref.AAOEndpoint, instructionsPerTransaction = _ref.instructionsPerTransaction, _ref$maxAggregationAt = _ref.maxAggregationAttempts, maxAggregationAttempts = _ref$maxAggregationAt === void 0 ? 20 : _ref$maxAggregationAt, _ref$endpoints = _ref.endpoints, endpoints = _ref$endpoints === void 0 ? null : _ref$endpoints, _ref$logger = _ref.logger, logger = _ref$logger === void 0 ? console : _ref$logger, _ref$feePayerOverride = _ref.feePayerOverride, feePayerOverride = _ref$feePayerOverride === void 0 ? null : _ref$feePayerOverride;
                nodesToReselect = null;
                aaoErrorCode = null;
                _context.prev = 3;
                phase = AttestationPhases.SANITY_CHECKS; // fail if amount is a decimal

                if (!(Number(amount) !== amount || amount % 1 !== 0)) {
                  _context.next = 7;
                  break;
                }

                throw new Error('Invalid amount');

              case 7:
                // Aggregate
                logger.info("submitAndEvaluate: aggregating attestations for userId [".concat(decodeHashId$3(encodedUserId), "], challengeId [").concat(challengeId, "]"));
                phase = AttestationPhases.AGGREGATE_ATTESTATIONS;
                _context.next = 11;
                return this.aggregateAttestations({
                  challengeId: challengeId,
                  encodedUserId: encodedUserId,
                  handle: handle,
                  specifier: specifier,
                  oracleEthAddress: oracleEthAddress,
                  amount: amount,
                  quorumSize: quorumSize,
                  AAOEndpoint: AAOEndpoint,
                  endpoints: endpoints,
                  logger: logger,
                  maxAttempts: maxAggregationAttempts
                });

              case 11:
                _yield$this$aggregate = _context.sent;
                discoveryNodeAttestations = _yield$this$aggregate.discoveryNodeAttestations;
                aaoAttestation = _yield$this$aggregate.aaoAttestation;
                aggregateError = _yield$this$aggregate.error;
                errorCode = _yield$this$aggregate.aaoErrorCode;
                erroringNodes = _yield$this$aggregate.erroringNodes;

                if (!aggregateError) {
                  _context.next = 21;
                  break;
                }

                nodesToReselect = erroringNodes;
                aaoErrorCode = errorCode;
                throw new Error(aggregateError);

              case 21:
                // Submit
                logger.info("submitAndEvaluate: submitting for challenge [".concat(challengeId, "], userId: [").concat(decodeHashId$3(encodedUserId), "] with [").concat(discoveryNodeAttestations === null || discoveryNodeAttestations === void 0 ? void 0 : discoveryNodeAttestations.length, "] DN and [").concat(aaoAttestation ? 1 : 0, "] oracle attestations."));
                fullTokenAmount = new BN__default["default"](amount * WRAPPED_AUDIO_PRECISION);
                phase = AttestationPhases.SUBMIT_ATTESTATIONS; // @ts-expect-error the return types are a bit strange here

                _context.next = 26;
                return this.solanaWeb3Manager.submitChallengeAttestations({
                  attestations: discoveryNodeAttestations,
                  oracleAttestation: aaoAttestation,
                  challengeId: challengeId,
                  specifier: specifier,
                  recipientEthAddress: recipientEthAddress,
                  tokenAmount: fullTokenAmount,
                  instructionsPerTransaction: instructionsPerTransaction,
                  logger: logger,
                  feePayerOverride: feePayerOverride
                });

              case 26:
                _yield$this$solanaWeb = _context.sent;
                submitErrorCode = _yield$this$solanaWeb.errorCode;
                submitError = _yield$this$solanaWeb.error;

                if (!(submitErrorCode || submitError)) {
                  _context.next = 38;
                  break;
                }

                shouldRetryInSeperateTransactions = submitErrorCode === RewardsManagerError.REPEATED_SENDERS || submitErrorCode === RewardsManagerError.SIGN_COLLISION || submitErrorCode === RewardsManagerError.OPERATOR_COLLISION; // If we have sender collisions, we should
                // submit one attestation per transaction and try to get
                // into a good state.
                // TODO: in the case this retry fails, we still proceed
                // to evaluate phase and will error there (not ideal)

                if (!shouldRetryInSeperateTransactions) {
                  _context.next = 37;
                  break;
                }

                logger.warn("submitAndEvaluate: saw repeat senders for userId [".concat(decodeHashId$3(encodedUserId), "] challengeId: [").concat(challengeId, "] with err: ").concat(submitErrorCode, ", breaking up into individual transactions"));
                _context.next = 35;
                return this.solanaWeb3Manager.submitChallengeAttestations({
                  attestations: discoveryNodeAttestations,
                  oracleAttestation: aaoAttestation,
                  challengeId: challengeId,
                  specifier: specifier,
                  recipientEthAddress: recipientEthAddress,
                  tokenAmount: fullTokenAmount,
                  instructionsPerTransaction: 2,
                  logger: logger,
                  feePayerOverride: feePayerOverride
                });

              case 35:
                _context.next = 38;
                break;

              case 37:
                throw new Error(submitErrorCode || submitError);

              case 38:
                // Evaluate
                logger.info("submitAndEvaluate: evaluating for challenge [".concat(challengeId, "], userId: [").concat(decodeHashId$3(encodedUserId), "]"));
                phase = AttestationPhases.EVALUATE_ATTESTATIONS;
                _context.next = 42;
                return this.solanaWeb3Manager.evaluateChallengeAttestations({
                  challengeId: challengeId,
                  specifier: specifier,
                  recipientEthAddress: recipientEthAddress,
                  oracleEthAddress: oracleEthAddress,
                  tokenAmount: fullTokenAmount,
                  logger: logger,
                  feePayerOverride: feePayerOverride
                });

              case 42:
                _yield$this$solanaWeb2 = _context.sent;
                evaluateErrorCode = _yield$this$solanaWeb2.errorCode;
                evaluateError = _yield$this$solanaWeb2.error;

                if (!(evaluateErrorCode !== null && evaluateErrorCode !== void 0 ? evaluateErrorCode : evaluateError)) {
                  _context.next = 47;
                  break;
                }

                throw new Error(evaluateErrorCode !== null && evaluateErrorCode !== void 0 ? evaluateErrorCode : evaluateError);

              case 47:
                return _context.abrupt("return", {
                  success: true,
                  error: null,
                  aaoErrorCode: aaoErrorCode,
                  phase: null,
                  nodesToReselect: null
                });

              case 50:
                _context.prev = 50;
                _context.t0 = _context["catch"](3);
                err = _context.t0.message;
                log = err === GetAttestationError.COGNITO_FLOW || err === GetAttestationError.HCAPTCHA ? logger.info : logger.error;
                log("submitAndEvaluate: failed for userId: [".concat(decodeHashId$3(encodedUserId), "] challenge-id [").concat(challengeId, "] at phase [").concat(phase, "] with err: ").concat(err));
                return _context.abrupt("return", {
                  success: false,
                  error: err,
                  aaoErrorCode: aaoErrorCode,
                  phase: phase,
                  nodesToReselect: nodesToReselect
                });

              case 56:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[3, 50]]);
      }));

      function submitAndEvaluate(_x) {
        return _submitAndEvaluate.apply(this, arguments);
      }

      return submitAndEvaluate;
    }()
    /**
     * Aggregates attestations from Discovery Nodes and AAO.
     */

  }, {
    key: "aggregateAttestations",
    value: function () {
      var _aggregateAttestations = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {
        var challengeId, encodedUserId, handle, specifier, oracleEthAddress, amount, quorumSize, AAOEndpoint, maxAttempts, _ref2$endpoints, endpoints, _ref2$logger, logger, aaoAttestation, _yield$this$getAAOAtt, success, aaoErrorCode, aaoAttestationError, err, discoveryNodeAttestationResults, discoveryNodeSuccesses, discoveryNodeErrors, error, erroringNodes, _err;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                challengeId = _ref2.challengeId, encodedUserId = _ref2.encodedUserId, handle = _ref2.handle, specifier = _ref2.specifier, oracleEthAddress = _ref2.oracleEthAddress, amount = _ref2.amount, quorumSize = _ref2.quorumSize, AAOEndpoint = _ref2.AAOEndpoint, maxAttempts = _ref2.maxAttempts, _ref2$endpoints = _ref2.endpoints, endpoints = _ref2$endpoints === void 0 ? null : _ref2$endpoints, _ref2$logger = _ref2.logger, logger = _ref2$logger === void 0 ? console : _ref2$logger;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);

                if (!endpoints) {
                  _context2.next = 6;
                  break;
                }

                endpoints = lodash.sampleSize(endpoints, quorumSize);
                _context2.next = 9;
                break;

              case 6:
                _context2.next = 8;
                return this.ServiceProvider.getUniquelyOwnedDiscoveryNodes({
                  quorumSize: quorumSize
                });

              case 8:
                endpoints = _context2.sent;

              case 9:
                if (!(endpoints.length < quorumSize)) {
                  _context2.next = 12;
                  break;
                }

                logger.error("Tried to fetch [".concat(quorumSize, "] attestations, but only found [").concat(endpoints.length, "] registered nodes."));
                return _context2.abrupt("return", {
                  discoveryNodeAttestations: null,
                  aaoAttestation: null,
                  error: AggregateAttestationError.INSUFFICIENT_DISCOVERY_NODE_COUNT,
                  aaoErrorCode: null,
                  erroringNodes: null
                });

              case 12:
                // First attempt AAO
                aaoAttestation = null;
                _context2.prev = 13;
                _context2.next = 16;
                return this.getAAOAttestation({
                  challengeId: challengeId,
                  specifier: specifier,
                  handle: handle,
                  amount: amount,
                  AAOEndpoint: AAOEndpoint,
                  oracleEthAddress: oracleEthAddress
                });

              case 16:
                _yield$this$getAAOAtt = _context2.sent;
                success = _yield$this$getAAOAtt.success;
                aaoErrorCode = _yield$this$getAAOAtt.aaoErrorCode;
                aaoAttestationError = _yield$this$getAAOAtt.error;

                if (!aaoAttestationError) {
                  _context2.next = 22;
                  break;
                }

                return _context2.abrupt("return", {
                  discoveryNodeAttestations: null,
                  aaoAttestation: null,
                  error: aaoAttestationError,
                  aaoErrorCode: aaoErrorCode,
                  erroringNodes: null
                });

              case 22:
                aaoAttestation = success;
                _context2.next = 30;
                break;

              case 25:
                _context2.prev = 25;
                _context2.t0 = _context2["catch"](13);
                err = _context2.t0.message;
                logger.error("Failed to aggregate attestations for user [".concat(decodeHashId$3(encodedUserId), "], challenge-id: [").concat(challengeId, "] with err: ").concat(err));
                return _context2.abrupt("return", {
                  discoveryNodeAttestations: null,
                  aaoAttestation: null,
                  error: GetAttestationError.AAO_ATTESTATION_ERROR,
                  aaoErrorCode: null,
                  erroringNodes: null
                });

              case 30:
                _context2.prev = 30;
                _context2.next = 33;
                return this._getDiscoveryAttestationsWithRetries({
                  endpoints: endpoints,
                  challengeId: challengeId,
                  encodedUserId: encodedUserId,
                  specifier: specifier,
                  oracleEthAddress: oracleEthAddress,
                  logger: logger,
                  maxAttempts: maxAttempts
                });

              case 33:
                discoveryNodeAttestationResults = _context2.sent;
                discoveryNodeSuccesses = discoveryNodeAttestationResults.map(function (r) {
                  return r.success;
                });
                discoveryNodeErrors = discoveryNodeAttestationResults.map(function (r) {
                  return r.error;
                });
                error = discoveryNodeErrors.find(Boolean);

                if (!error) {
                  _context2.next = 40;
                  break;
                }

                // Propagate out the specific nodes that errored
                erroringNodes = discoveryNodeAttestationResults.filter(function (r) {
                  return r.error;
                }).map(function (r) {
                  return r.endpoint;
                });
                return _context2.abrupt("return", {
                  discoveryNodeAttestations: null,
                  aaoAttestation: null,
                  error: error,
                  erroringNodes: erroringNodes
                });

              case 40:
                return _context2.abrupt("return", {
                  discoveryNodeAttestations: discoveryNodeSuccesses,
                  aaoAttestation: aaoAttestation,
                  error: null,
                  aaoErrorCode: null,
                  erroringNodes: null
                });

              case 43:
                _context2.prev = 43;
                _context2.t1 = _context2["catch"](30);
                _err = _context2.t1.message;
                logger.error("Failed to aggregate attestations for user [".concat(decodeHashId$3(encodedUserId), "], challenge-id: [").concat(challengeId, "] with err: ").concat(_err));
                return _context2.abrupt("return", {
                  discoveryNodeAttestations: null,
                  aaoAttestation: null,
                  error: GetAttestationError.DISCOVERY_NODE_ATTESTATION_ERROR,
                  aaoErrorCode: null,
                  erroringNodes: null
                });

              case 48:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[13, 25], [30, 43]]);
      }));

      function aggregateAttestations(_x2) {
        return _aggregateAttestations.apply(this, arguments);
      }

      return aggregateAttestations;
    }()
    /**
     * Retrieves a Discovery Node attestation for a given userId.
     */

  }, {
    key: "getChallengeAttestation",
    value: function () {
      var _getChallengeAttestation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref3) {
        var challengeId, encodedUserId, specifier, oracleEthAddress, discoveryProviderEndpoint, _ref3$logger, logger, res, meta, err, mappedErr;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                challengeId = _ref3.challengeId, encodedUserId = _ref3.encodedUserId, specifier = _ref3.specifier, oracleEthAddress = _ref3.oracleEthAddress, discoveryProviderEndpoint = _ref3.discoveryProviderEndpoint, _ref3$logger = _ref3.logger, logger = _ref3$logger === void 0 ? console : _ref3$logger;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context3.prev = 2;
                _context3.next = 5;
                return this.discoveryProvider.getChallengeAttestation(challengeId, encodedUserId, specifier, oracleEthAddress, discoveryProviderEndpoint);

              case 5:
                res = _context3.sent;
                meta = {
                  ethAddress: res.owner_wallet,
                  signature: res.attestation
                };
                return _context3.abrupt("return", {
                  success: meta,
                  error: null
                });

              case 10:
                _context3.prev = 10;
                _context3.t0 = _context3["catch"](2);
                err = _context3.t0.message;
                logger.error("Failed to get challenge attestation for userId [".concat(decodeHashId$3(encodedUserId), "] challengeId [").concat(challengeId, "]from ").concat(discoveryProviderEndpoint, " with ").concat(err));
                mappedErr = GetAttestationError[err] || GetAttestationError.DISCOVERY_NODE_UNKNOWN_RESPONSE;
                return _context3.abrupt("return", {
                  success: null,
                  error: mappedErr
                });

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 10]]);
      }));

      function getChallengeAttestation(_x3) {
        return _getChallengeAttestation.apply(this, arguments);
      }

      return getChallengeAttestation;
    }()
  }, {
    key: "getUndisbursedChallenges",
    value: function () {
      var _getUndisbursedChallenges = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _ref4,
            limit,
            offset,
            completedBlockNumber,
            encodedUserId,
            _ref4$logger,
            logger,
            res,
            error,
            _args4 = arguments;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _ref4 = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {
                  logger: console
                }, limit = _ref4.limit, offset = _ref4.offset, completedBlockNumber = _ref4.completedBlockNumber, encodedUserId = _ref4.encodedUserId, _ref4$logger = _ref4.logger, logger = _ref4$logger === void 0 ? console : _ref4$logger;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context4.prev = 2;
                _context4.next = 5;
                return this.discoveryProvider.getUndisbursedChallenges(limit, offset, completedBlockNumber, encodedUserId);

              case 5:
                res = _context4.sent;
                return _context4.abrupt("return", {
                  success: res
                });

              case 9:
                _context4.prev = 9;
                _context4.t0 = _context4["catch"](2);
                error = _context4.t0.message;
                logger.error("Failed to get undisbursed challenges with error: ".concat(error));
                return _context4.abrupt("return", {
                  error: error
                });

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[2, 9]]);
      }));

      function getUndisbursedChallenges() {
        return _getUndisbursedChallenges.apply(this, arguments);
      }

      return getUndisbursedChallenges;
    }()
    /**
     * Retrieves an AAO attestation for a given user handle.
     */

  }, {
    key: "getAAOAttestation",
    value: function () {
      var _getAAOAttestation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref5) {
        var challengeId, specifier, handle, amount, AAOEndpoint, oracleEthAddress, _ref5$logger, logger, data, request, response, _response$data, result, errorCode, needs, mappedErr, err;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                challengeId = _ref5.challengeId, specifier = _ref5.specifier, handle = _ref5.handle, amount = _ref5.amount, AAOEndpoint = _ref5.AAOEndpoint, oracleEthAddress = _ref5.oracleEthAddress, _ref5$logger = _ref5.logger, logger = _ref5$logger === void 0 ? console : _ref5$logger;
                data = {
                  challengeId: challengeId,
                  challengeSpecifier: specifier,
                  amount: amount
                };
                request = {
                  method: 'post',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  url: "".concat(AAOEndpoint, "/attestation/").concat(handle),
                  timeout: AAO_REQUEST_TIMEOUT_MS,
                  data: data
                };
                _context5.prev = 3;
                _context5.next = 6;
                return axios__default["default"](request);

              case 6:
                response = _context5.sent;
                // if attestation is successful, 'result' represents a signature
                // otherwise, 'result' is false
                // - there may or may not be a value for `needs` if the attestation fails
                // - depending on whether the user can take an action to attempt remediation
                _response$data = response.data, result = _response$data.result, errorCode = _response$data.errorCode, needs = _response$data.needs;

                if (result) {
                  _context5.next = 12;
                  break;
                }

                logger.error("Failed to get AAO attestation".concat(needs ? ": needs ".concat(needs) : ''));
                mappedErr = needs ? GetAttestationError[needs] || GetAttestationError.AAO_ATTESTATION_UNKNOWN_RESPONSE : GetAttestationError.AAO_ATTESTATION_REJECTION;
                return _context5.abrupt("return", {
                  success: null,
                  aaoErrorCode: errorCode,
                  error: mappedErr
                });

              case 12:
                return _context5.abrupt("return", {
                  success: {
                    signature: result,
                    ethAddress: oracleEthAddress
                  },
                  aaoErrorCode: null,
                  error: null
                });

              case 15:
                _context5.prev = 15;
                _context5.t0 = _context5["catch"](3);
                err = _context5.t0.message;
                logger.error("Failed to get AAO attestation: ".concat(err));
                return _context5.abrupt("return", {
                  success: null,
                  aaoErrorCode: null,
                  error: GetAttestationError.AAO_ATTESTATION_ERROR
                });

              case 20:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[3, 15]]);
      }));

      function getAAOAttestation(_x4) {
        return _getAAOAttestation.apply(this, arguments);
      }

      return getAAOAttestation;
    }()
  }, {
    key: "_getDiscoveryAttestationsWithRetries",
    value: function () {
      var _getDiscoveryAttestationsWithRetries2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(_ref6) {
        var _this2 = this;

        var endpoints, challengeId, encodedUserId, specifier, oracleEthAddress, logger, maxAttempts, retryCount, unrecoverableError, completedAttestations, needsAttestations, attestations;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                endpoints = _ref6.endpoints, challengeId = _ref6.challengeId, encodedUserId = _ref6.encodedUserId, specifier = _ref6.specifier, oracleEthAddress = _ref6.oracleEthAddress, logger = _ref6.logger, maxAttempts = _ref6.maxAttempts;
                retryCount = 0;
                unrecoverableError = false;
                completedAttestations = [];
                needsAttestations = endpoints;

              case 5:
                logger.info("Aggregating attestations with retries challenge: ".concat(challengeId, ", userId: ").concat(encodedUserId, ", endpoints: ").concat(needsAttestations, ", attempt ").concat(retryCount));

                if (!(retryCount > 0)) {
                  _context7.next = 9;
                  break;
                }

                _context7.next = 9;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, 2000);
                });

              case 9:
                _context7.next = 11;
                return Promise.all(needsAttestations.map( /*#__PURE__*/function () {
                  var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(endpoint) {
                    var res;
                    return regeneratorRuntime.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.next = 2;
                            return _this2.getChallengeAttestation({
                              challengeId: challengeId,
                              encodedUserId: encodedUserId,
                              specifier: specifier,
                              oracleEthAddress: oracleEthAddress,
                              discoveryProviderEndpoint: endpoint,
                              logger: logger
                            });

                          case 2:
                            res = _context6.sent;
                            return _context6.abrupt("return", {
                              endpoint: endpoint,
                              res: res
                            });

                          case 4:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6);
                  }));

                  return function (_x6) {
                    return _ref7.apply(this, arguments);
                  };
                }()));

              case 11:
                attestations = _context7.sent;
                needsAttestations = [];
                attestations.forEach(function (a) {
                  // If it's a retryable error
                  var isRetryable = a.res.error === GetAttestationError.CHALLENGE_INCOMPLETE || a.res.error === GetAttestationError.MISSING_CHALLENGES;

                  if (isRetryable) {
                    needsAttestations.push(a.endpoint);
                    logger.info("Node ".concat(a.endpoint, " challenge still incomplete for challenge [").concat(challengeId, "], userId: ").concat(encodedUserId)); // If final attempt, make sure we return the result

                    if (retryCount === maxAttempts) {
                      completedAttestations.push(_objectSpread2(_objectSpread2({}, a.res), {}, {
                        endpoint: a.endpoint
                      }));
                    }
                  } else {
                    completedAttestations.push(_objectSpread2(_objectSpread2({}, a.res), {}, {
                      endpoint: a.endpoint
                    }));

                    if (a.res.error) {
                      unrecoverableError = true;
                    }
                  }
                });
                retryCount++;

              case 15:
                if (needsAttestations.length && retryCount <= maxAttempts) {
                  _context7.next = 5;
                  break;
                }

              case 16:
                if (needsAttestations.length || unrecoverableError) {
                  logger.info("Failed to aggregate attestations for challenge [".concat(challengeId, "], userId: [").concat(decodeHashId$3(encodedUserId), "]"));
                } else {
                  logger.info("Successfully aggregated attestations for challenge [".concat(challengeId, "], userId: [").concat(decodeHashId$3(encodedUserId), "]"));
                }

                return _context7.abrupt("return", completedAttestations);

              case 18:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function _getDiscoveryAttestationsWithRetries(_x5) {
        return _getDiscoveryAttestationsWithRetries2.apply(this, arguments);
      }

      return _getDiscoveryAttestationsWithRetries;
    }()
    /**
     * Creates a new discovery node sender for rewards. A sender may
     * attest in user challenge completion to issue rewards.
     *
     * This method queries other discovery nodes asking for attestation of
     * a given new senderEthAddress (delegate wallet) and operatorEthAddress (owner wallet).
     * Those attestations are bundled
     */

  }, {
    key: "createSenderPublic",
    value: function () {
      var _createSenderPublic = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(_ref8) {
        var _this3 = this;

        var senderEthAddress, operatorEthAddress, endpoints, _ref8$numAttestations, numAttestations, feePayerOverride, attestEndpoints, error, attestations, receipt;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                senderEthAddress = _ref8.senderEthAddress, operatorEthAddress = _ref8.operatorEthAddress, endpoints = _ref8.endpoints, _ref8$numAttestations = _ref8.numAttestations, numAttestations = _ref8$numAttestations === void 0 ? 3 : _ref8$numAttestations, feePayerOverride = _ref8.feePayerOverride;

                if (!endpoints) {
                  _context10.next = 5;
                  break;
                }

                attestEndpoints = lodash.sampleSize(endpoints, numAttestations);
                _context10.next = 8;
                break;

              case 5:
                _context10.next = 7;
                return this.ServiceProvider.getUniquelyOwnedDiscoveryNodes({
                  quorumSize: numAttestations,
                  useWhitelist: false,
                  filter: function () {
                    var _filter = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(node) {
                      var isRegistered;
                      return regeneratorRuntime.wrap(function _callee8$(_context8) {
                        while (1) {
                          switch (_context8.prev = _context8.next) {
                            case 0:
                              _context8.next = 2;
                              return _this3.solanaWeb3Manager.getIsDiscoveryNodeRegistered(node.delegateOwnerWallet);

                            case 2:
                              isRegistered = _context8.sent;
                              return _context8.abrupt("return", isRegistered);

                            case 4:
                            case "end":
                              return _context8.stop();
                          }
                        }
                      }, _callee8);
                    }));

                    function filter(_x8) {
                      return _filter.apply(this, arguments);
                    }

                    return filter;
                  }()
                });

              case 7:
                attestEndpoints = _context10.sent;

              case 8:
                if (!(attestEndpoints.length < numAttestations)) {
                  _context10.next = 10;
                  break;
                }

                throw new Error("Not enough other nodes found, need ".concat(numAttestations, ", found ").concat(attestEndpoints.length));

              case 10:
                error = null;
                _context10.next = 13;
                return Promise.all(attestEndpoints.map( /*#__PURE__*/function () {
                  var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(attestEndpoint) {
                    var res;
                    return regeneratorRuntime.wrap(function _callee9$(_context9) {
                      while (1) {
                        switch (_context9.prev = _context9.next) {
                          case 0:
                            _context9.prev = 0;
                            _context9.next = 3;
                            return _this3.discoveryProvider.getCreateSenderAttestation(senderEthAddress, attestEndpoint);

                          case 3:
                            res = _context9.sent;
                            return _context9.abrupt("return", {
                              ethAddress: res.owner_wallet,
                              signature: res.attestation
                            });

                          case 7:
                            _context9.prev = 7;
                            _context9.t0 = _context9["catch"](0);
                            console.error(_context9.t0);
                            error = true;
                            return _context9.abrupt("return", undefined);

                          case 12:
                          case "end":
                            return _context9.stop();
                        }
                      }
                    }, _callee9, null, [[0, 7]]);
                  }));

                  return function (_x9) {
                    return _ref9.apply(this, arguments);
                  };
                }()));

              case 13:
                attestations = _context10.sent;

                if (!error) {
                  _context10.next = 17;
                  break;
                }

                console.error("Failed to get attestations from other nodes ".concat(attestEndpoints));
                return _context10.abrupt("return", {
                  success: null,
                  error: GetSenderAttestationError.REQUEST_FOR_ATTESTATION_FAILED
                });

              case 17:
                _context10.next = 19;
                return this.solanaWeb3Manager.createSender({
                  senderEthAddress: senderEthAddress,
                  operatorEthAddress: operatorEthAddress,
                  attestations: attestations,
                  feePayerOverride: feePayerOverride
                });

              case 19:
                receipt = _context10.sent;
                return _context10.abrupt("return", receipt);

              case 21:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function createSenderPublic(_x7) {
        return _createSenderPublic.apply(this, arguments);
      }

      return createSenderPublic;
    }()
    /**
     * Logs results of an attestation to identity.
     */

  }, {
    key: "sendAttestationResult",
    value: function () {
      var _sendAttestationResult = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(_ref10) {
        var status, userId, challengeId, amount, error, phase, source, specifier, reason;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                status = _ref10.status, userId = _ref10.userId, challengeId = _ref10.challengeId, amount = _ref10.amount, error = _ref10.error, phase = _ref10.phase, source = _ref10.source, specifier = _ref10.specifier, reason = _ref10.reason;
                _context11.next = 3;
                return this.identityService.sendAttestationResult({
                  status: status,
                  userId: userId,
                  challengeId: challengeId,
                  amount: amount,
                  error: error,
                  phase: phase,
                  source: source,
                  specifier: specifier,
                  reason: reason
                });

              case 3:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function sendAttestationResult(_x10) {
        return _sendAttestationResult.apply(this, arguments);
      }

      return sendAttestationResult;
    }()
  }]);

  return Rewards;
}(Base);

var decodeHashId$2 = Utils.decodeHashId;

var errors = _objectSpread2(_objectSpread2({}, SubmitAndEvaluateError), {}, {
  USERBANK_CREATION: 'USERBANK_CREATION'
});

var AAO_ERRORS = new Set([errors.AAO_ATTESTATION_REJECTION, errors.AAO_ATTESTATION_UNKNOWN_RESPONSE]); // Account for errors from DN aggregation + Solana program
// CHALLENGE_INCOMPLETE and MISSING_CHALLENGES are already handled in the `submitAndEvaluate` flow -
// safe to assume those won't work if we see them at this point.

var NEEDS_RESELECT_ERRORS = new Set([errors.INSUFFICIENT_DISCOVERY_NODE_COUNT, errors.CHALLENGE_INCOMPLETE, errors.MISSING_CHALLENGES]);
var ALREADY_COMPLETE_ERRORS = new Set([errors.ALREADY_DISBURSED, errors.ALREADY_SENT]); // `BaseRewardsReporter` is intended to be subclassed, and provides
// "reporting" functionality to RewardsAttester (i.e. posts to Slack if something notable happens)

var BaseRewardsReporter = /*#__PURE__*/function () {
  function BaseRewardsReporter() {
    _classCallCheck(this, BaseRewardsReporter);
  }

  _createClass(BaseRewardsReporter, [{
    key: "reportSuccess",
    value: function () {
      var _reportSuccess = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function reportSuccess(_x) {
        return _reportSuccess.apply(this, arguments);
      }

      return reportSuccess;
    }()
  }, {
    key: "reportRetry",
    value: function () {
      var _reportRetry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function reportRetry(_x2) {
        return _reportRetry.apply(this, arguments);
      }

      return reportRetry;
    }()
  }, {
    key: "reportFailure",
    value: function () {
      var _reportFailure = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function reportFailure(_x3) {
        return _reportFailure.apply(this, arguments);
      }

      return reportFailure;
    }()
  }, {
    key: "reportAAORejection",
    value: function () {
      var _reportAAORejection = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function reportAAORejection(_x4) {
        return _reportAAORejection.apply(this, arguments);
      }

      return reportAAORejection;
    }()
  }]);

  return BaseRewardsReporter;
}();

var MAX_DISBURSED_CACHE_SIZE = 100;
var SOLANA_EST_SEC_PER_SLOT = 0.5;
var POA_SEC_PER_BLOCK = 1;
var MAX_DISCOVERY_NODE_BLOCKLIST_LEN = 10;
/**
 * Class to encapsulate logic for calculating disbursement delay thresholds.
 * Periodically polls Solana to get slot production rate.
 * Caches old values (`allowedStalenessSec`) for current POA block & Solana slot to reduce RPC
 * overhead.
 *
 * Exposes `getPOABlockThreshold` and `getSolanaSlotThreshold`
 *
 * @class ThresholdCalculator
 */

var AttestationDelayCalculator = /*#__PURE__*/function () {
  function AttestationDelayCalculator(_ref) {
    var libs = _ref.libs,
        runBehindSec = _ref.runBehindSec,
        allowedStalenessSec = _ref.allowedStalenessSec,
        blockOffset = _ref.blockOffset,
        _ref$solanaPollingInt = _ref.solanaPollingInterval,
        solanaPollingInterval = _ref$solanaPollingInt === void 0 ? 30 : _ref$solanaPollingInt,
        _ref$logger = _ref.logger,
        logger = _ref$logger === void 0 ? console : _ref$logger;

    _classCallCheck(this, AttestationDelayCalculator);

    _defineProperty$1(this, "libs", void 0);

    _defineProperty$1(this, "solanaSecPerSlot", void 0);

    _defineProperty$1(this, "runBehindSec", void 0);

    _defineProperty$1(this, "lastSolanaThreshold", void 0);

    _defineProperty$1(this, "lastPOAThreshold", void 0);

    _defineProperty$1(this, "allowedStalenessSec", void 0);

    _defineProperty$1(this, "solanaPollingInterval", void 0);

    _defineProperty$1(this, "logger", void 0);

    _defineProperty$1(this, "intervalHandle", void 0);

    _defineProperty$1(this, "blockOffset", void 0);

    this.libs = libs;
    this.solanaSecPerSlot = SOLANA_EST_SEC_PER_SLOT;
    this.runBehindSec = runBehindSec;
    this.lastSolanaThreshold = null;
    this.lastPOAThreshold = null;
    this.allowedStalenessSec = allowedStalenessSec;
    this.solanaPollingInterval = solanaPollingInterval;
    this.logger = logger;
    this.intervalHandle = null;
    this.blockOffset = blockOffset;
  }

  _createClass(AttestationDelayCalculator, [{
    key: "start",
    value: function () {
      var _start = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var _this = this;

        var oldSlot;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.libs.solanaWeb3Manager.getSlot();

              case 2:
                oldSlot = _context6.sent;
                // eslint-disable-next-line
                this.intervalHandle = setInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
                  var newSlot, diff;
                  return regeneratorRuntime.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return _this.libs.solanaWeb3Manager.getSlot();

                        case 2:
                          newSlot = _context5.sent;
                          diff = _this.solanaPollingInterval / (newSlot - oldSlot);
                          _this.solanaSecPerSlot = diff;

                          _this.logger.info("Setting Solana seconds per slot to ".concat(diff));

                          oldSlot = newSlot;

                        case 7:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                })), this.solanaPollingInterval * 1000);

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function start() {
        return _start.apply(this, arguments);
      }

      return start;
    }()
  }, {
    key: "stop",
    value: function stop() {
      if (this.intervalHandle) {
        clearInterval(this.intervalHandle);
      }
    }
  }, {
    key: "getPOABlockThreshold",
    value: function () {
      var _getPOABlockThreshold = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var currentBlock, threshold;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(this.lastPOAThreshold && (Date.now() - this.lastPOAThreshold.time) / 1000 < this.allowedStalenessSec)) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt("return", this.lastPOAThreshold.threshold);

              case 2:
                _context7.t0 = Number;
                _context7.next = 5;
                return this.libs.web3Manager.getWeb3().eth.getBlockNumber();

              case 5:
                _context7.t1 = _context7.sent;
                _context7.t2 = (0, _context7.t0)(_context7.t1);
                _context7.t3 = this.blockOffset;
                currentBlock = _context7.t2 + _context7.t3;
                threshold = currentBlock - this.runBehindSec / POA_SEC_PER_BLOCK;
                this.lastPOAThreshold = {
                  threshold: threshold,
                  time: Date.now()
                };
                return _context7.abrupt("return", threshold);

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getPOABlockThreshold() {
        return _getPOABlockThreshold.apply(this, arguments);
      }

      return getPOABlockThreshold;
    }()
  }, {
    key: "getSolanaSlotThreshold",
    value: function () {
      var _getSolanaSlotThreshold = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var currentSlot, threshold;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!(this.lastSolanaThreshold && (Date.now() - this.lastSolanaThreshold.time) / 1000 < this.allowedStalenessSec)) {
                  _context8.next = 2;
                  break;
                }

                return _context8.abrupt("return", this.lastSolanaThreshold.threshold);

              case 2:
                _context8.next = 4;
                return this.libs.solanaWeb3Manager.getSlot();

              case 4:
                currentSlot = _context8.sent;
                threshold = currentSlot - this.runBehindSec / this.solanaSecPerSlot;
                this.lastSolanaThreshold = {
                  threshold: threshold,
                  time: Date.now()
                };
                return _context8.abrupt("return", threshold);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getSolanaSlotThreshold() {
        return _getSolanaSlotThreshold.apply(this, arguments);
      }

      return getSolanaSlotThreshold;
    }()
  }]);

  return AttestationDelayCalculator;
}();
/**
 * `RewardsAttester` is responsible for repeatedly attesting for completed rewards.
 *
 * **Implementation**
 *
 * `RewardsAttester` attempts to attest for `parallelization` rewards in parallel.
 * It won't move onto the next batch of rewards until every reward in that batch has
 * either succeeded or failed attestation. It retries errors that might be due to DN
 * timing issues, and skips AAO errors and some Solana program errors.
 *
 * Internally, state is tracked with two variables: `offset` and `startingBlock`.
 * `startingBlock` represents which block it start requesting attestations from, while `offset` determines
 * where within those results we offset. AAO rejected rewards
 * are never cleared from the DN rewards queue, so we have to move past them either with `offset` or `startingBlock`.
 * `RewardsAttester` accepts callbacks (`updateValues`) for a client to persist these values periodically.
 *
 * RewardsAttester will fetch a single large list of undisbursed rewards (`undisbursedQueue`), and
 * process that entire list before fetching new undisbursed rewards. It also maintains a list of
 * recently processed rewards, and filters those out when re-fetching new undisbursed rewards.
 */

var RewardsAttester = /*#__PURE__*/function () {
  // Stores a set of identifiers representing
  // recently disbursed challenges.
  // Stored as an array to make it simpler to prune
  // old entries
  // Stores a queue of undisbursed challenges
  // How long wait wait before retrying
  // How much we increase the cooldown between attempts:
  // coolDown = min(cooldownMsec * backoffExponent ^ retryCount, maxCooldownMsec)
  // Maximum time to wait before retrying
  // Maximum number of retries before moving on
  // Get override starting block for manually setting indexing start
  // Calculate delay

  /**
   * Creates an instance of RewardsAttester.
   * @memberof RewardsAttester
   */
  function RewardsAttester(_ref3) {
    var libs = _ref3.libs,
        startingBlock = _ref3.startingBlock,
        offset = _ref3.offset,
        parallelization = _ref3.parallelization,
        _ref3$logger = _ref3.logger,
        logger = _ref3$logger === void 0 ? console : _ref3$logger,
        quorumSize = _ref3.quorumSize,
        aaoEndpoint = _ref3.aaoEndpoint,
        aaoAddress = _ref3.aaoAddress,
        _ref3$updateValues = _ref3.updateValues,
        updateValues = _ref3$updateValues === void 0 ? function () {} : _ref3$updateValues,
        _ref3$getStartingBloc = _ref3.getStartingBlockOverride,
        getStartingBlockOverride = _ref3$getStartingBloc === void 0 ? function () {
      return null;
    } : _ref3$getStartingBloc,
        _ref3$maxRetries = _ref3.maxRetries,
        maxRetries = _ref3$maxRetries === void 0 ? 5 : _ref3$maxRetries,
        _ref3$reporter = _ref3.reporter,
        reporter = _ref3$reporter === void 0 ? new BaseRewardsReporter() : _ref3$reporter,
        _ref3$challengeIdsDen = _ref3.challengeIdsDenyList,
        challengeIdsDenyList = _ref3$challengeIdsDen === void 0 ? [] : _ref3$challengeIdsDen,
        _ref3$endpoints = _ref3.endpoints,
        endpoints = _ref3$endpoints === void 0 ? [] : _ref3$endpoints,
        _ref3$runBehindSec = _ref3.runBehindSec,
        runBehindSec = _ref3$runBehindSec === void 0 ? 0 : _ref3$runBehindSec,
        _ref3$isSolanaChallen = _ref3.isSolanaChallenge,
        isSolanaChallenge = _ref3$isSolanaChallen === void 0 ? function (_) {
      return true;
    } : _ref3$isSolanaChallen,
        _ref3$feePayerOverrid = _ref3.feePayerOverride,
        feePayerOverride = _ref3$feePayerOverrid === void 0 ? null : _ref3$feePayerOverrid,
        _ref3$maxAggregationA = _ref3.maxAggregationAttempts,
        maxAggregationAttempts = _ref3$maxAggregationA === void 0 ? 20 : _ref3$maxAggregationA,
        _ref3$updateStateCall = _ref3.updateStateCallback,
        updateStateCallback = _ref3$updateStateCall === void 0 ? /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(_) {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));

      return function (_x5) {
        return _ref4.apply(this, arguments);
      };
    }() : _ref3$updateStateCall,
        _ref3$maxCooldownMsec = _ref3.maxCooldownMsec,
        maxCooldownMsec = _ref3$maxCooldownMsec === void 0 ? 15000 : _ref3$maxCooldownMsec,
        blockOffset = _ref3.blockOffset;

    _classCallCheck(this, RewardsAttester);

    _defineProperty$1(this, "startingBlock", void 0);

    _defineProperty$1(this, "offset", void 0);

    _defineProperty$1(this, "recentlyDisbursedQueue", void 0);

    _defineProperty$1(this, "_shouldStop", void 0);

    _defineProperty$1(this, "endpoints", void 0);

    _defineProperty$1(this, "undisbursedQueue", void 0);

    _defineProperty$1(this, "attesterState", void 0);

    _defineProperty$1(this, "parallelization", void 0);

    _defineProperty$1(this, "aaoEndpoint", void 0);

    _defineProperty$1(this, "aaoAddress", void 0);

    _defineProperty$1(this, "endpointPool", void 0);

    _defineProperty$1(this, "challengeIdsDenyList", void 0);

    _defineProperty$1(this, "discoveryNodeBlocklist", void 0);

    _defineProperty$1(this, "libs", void 0);

    _defineProperty$1(this, "logger", void 0);

    _defineProperty$1(this, "quorumSize", void 0);

    _defineProperty$1(this, "reporter", void 0);

    _defineProperty$1(this, "maxRetries", void 0);

    _defineProperty$1(this, "maxAggregationAttempts", void 0);

    _defineProperty$1(this, "updateValues", void 0);

    _defineProperty$1(this, "cooldownMsec", void 0);

    _defineProperty$1(this, "backoffExponent", void 0);

    _defineProperty$1(this, "maxCooldownMsec", void 0);

    _defineProperty$1(this, "getStartingBlockOverride", void 0);

    _defineProperty$1(this, "feePayerOverride", void 0);

    _defineProperty$1(this, "delayCalculator", void 0);

    _defineProperty$1(this, "isSolanaChallenge", void 0);

    _defineProperty$1(this, "_updateStateCallback", void 0);

    this.libs = libs;
    this.logger = logger;
    this.parallelization = parallelization;
    this.startingBlock = startingBlock;
    this.offset = offset;
    this.quorumSize = quorumSize;
    this.aaoEndpoint = aaoEndpoint;
    this.aaoAddress = aaoAddress;
    this.reporter = reporter;
    this.endpoints = endpoints;
    this.endpointPool = new Set(endpoints);
    this.maxRetries = maxRetries;
    this.maxAggregationAttempts = maxAggregationAttempts;
    this.updateValues = updateValues;
    this.challengeIdsDenyList = _construct(Set, _toConsumableArray(challengeIdsDenyList));
    this.undisbursedQueue = [];
    this.recentlyDisbursedQueue = [];
    this.cooldownMsec = 2000;
    this.backoffExponent = 1.8;
    this.maxCooldownMsec = maxCooldownMsec;
    this.getStartingBlockOverride = getStartingBlockOverride;
    this.feePayerOverride = feePayerOverride;
    this.attesterState = {
      phase: 'HALTED',
      lastSuccessChallengeTime: null,
      lastChallengeTime: null,
      lastActionTime: Date.now()
    }; // Calculate delay

    this.delayCalculator = new AttestationDelayCalculator({
      libs: libs,
      runBehindSec: runBehindSec,
      logger: logger,
      allowedStalenessSec: 5,
      blockOffset: blockOffset
    });
    this.isSolanaChallenge = isSolanaChallenge;
    this._performSingleAttestation = this._performSingleAttestation.bind(this);
    this._disbursementToKey = this._disbursementToKey.bind(this);
    this._shouldStop = false;
    this._updateStateCallback = updateStateCallback;
    this.discoveryNodeBlocklist = [];
  }
  /**
   * Begin attestation loop. Entry point for identity attestations
   *
   * @memberof RewardsAttester
   */


  _createClass(RewardsAttester, [{
    key: "start",
    value: function () {
      var _start2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var pool, _yield$this$_refillQu, error, toAttest, _yield$this$_attestIn, highestBlock, offset, successCount;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this.logger.info("Starting attester with:\n      quorum size: ".concat(this.quorumSize, ",       parallelization: ").concat(this.parallelization, "       AAO endpoint: ").concat(this.aaoEndpoint, "       AAO address: ").concat(this.aaoAddress, "       endpoints: ").concat(this.endpoints, "\n    ")); // If a list of endpoints was not specified,
                // set the pool to the entire list of discovery providers.
                // This overrides any configured whitelist for the service selector.

                if (!(this.endpointPool.size === 0)) {
                  _context10.next = 6;
                  break;
                }

                _context10.next = 4;
                return this.libs.discoveryProvider.serviceSelector.getServices();

              case 4:
                pool = _context10.sent;
                this.endpointPool = new Set(pool);

              case 6:
                _context10.next = 8;
                return this._selectDiscoveryNodes();

              case 8:
                _context10.next = 10;
                return this.delayCalculator.start();

              case 10:
                if (this._shouldStop) {
                  _context10.next = 52;
                  break;
                }

                _context10.prev = 11;
                _context10.next = 14;
                return this._awaitFeePayerBalance();

              case 14:
                _context10.next = 16;
                return this._checkForStartingBlockOverride();

              case 16:
                _context10.next = 18;
                return this._refillQueueIfNecessary();

              case 18:
                _yield$this$_refillQu = _context10.sent;
                error = _yield$this$_refillQu.error;

                if (!error) {
                  _context10.next = 23;
                  break;
                }

                this.logger.error("Got error trying to refill challenges: [".concat(error, "]"));
                throw new Error(error);

              case 23:
                if (this.undisbursedQueue.length) {
                  _context10.next = 30;
                  break;
                }

                this.logger.info('No undisbursed challenges. Sleeping...');
                _context10.next = 27;
                return this._updatePhase('SLEEPING');

              case 27:
                _context10.next = 29;
                return this._delay(1000);

              case 29:
                return _context10.abrupt("continue", 10);

              case 30:
                // Get undisbursed rewards
                toAttest = this.undisbursedQueue.splice(0, this.parallelization); // Attest for batch in parallel

                _context10.next = 33;
                return this._attestInParallel(toAttest);

              case 33:
                _yield$this$_attestIn = _context10.sent;
                highestBlock = _yield$this$_attestIn.highestBlock;
                offset = _yield$this$_attestIn.offset;
                successCount = _yield$this$_attestIn.successCount;

                // Set state
                // Set offset:
                // - If same startingBlock as before, add offset
                // - If new startingBlock, set offset
                if (highestBlock && this.startingBlock === highestBlock - 1) {
                  this.offset += offset;
                } else {
                  this.offset = offset;
                }

                this.logger.info("Updating values: startingBlock: ".concat(this.startingBlock, ", offset: ").concat(this.offset));
                this.startingBlock = highestBlock ? highestBlock - 1 : this.startingBlock; // Set the recently disbursed set

                this._addRecentlyDisbursed(toAttest); // run the `updateValues` callback


                _context10.next = 43;
                return this.updateValues({
                  startingBlock: this.startingBlock,
                  offset: this.offset,
                  successCount: successCount
                });

              case 43:
                _context10.next = 50;
                break;

              case 45:
                _context10.prev = 45;
                _context10.t0 = _context10["catch"](11);
                this.logger.error("Got error: ".concat(_context10.t0, ", sleeping"));
                _context10.next = 50;
                return this._delay(1000);

              case 50:
                _context10.next = 10;
                break;

              case 52:
                this._shouldStop = false;

              case 53:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[11, 45]]);
      }));

      function start() {
        return _start2.apply(this, arguments);
      }

      return start;
    }()
  }, {
    key: "stop",
    value: function () {
      var _stop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                this._shouldStop = true;
                this.delayCalculator.stop();

              case 2:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function stop() {
        return _stop.apply(this, arguments);
      }

      return stop;
    }()
    /**
     * Called from the client to attest challenges
     */

  }, {
    key: "processChallenges",
    value: function () {
      var _processChallenges = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(challenges) {
        var toProcess, toAttest, _yield$this$_attestIn2, _errors;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this._selectDiscoveryNodes();

              case 2:
                toProcess = _toConsumableArray(challenges);

              case 3:
                if (!toProcess.length) {
                  _context12.next = 23;
                  break;
                }

                _context12.prev = 4;
                this.logger.info("Processing ".concat(toProcess.length, " challenges"));
                toAttest = toProcess.splice(0, this.parallelization);
                _context12.next = 9;
                return this._attestInParallel(toAttest);

              case 9:
                _yield$this$_attestIn2 = _context12.sent;
                _errors = _yield$this$_attestIn2.accumulatedErrors;

                if (!(_errors !== null && _errors !== void 0 && _errors.length)) {
                  _context12.next = 14;
                  break;
                }

                this.logger.error("Got errors in processChallenges: ".concat(JSON.stringify(_errors)));
                return _context12.abrupt("return", {
                  errors: _errors
                });

              case 14:
                _context12.next = 21;
                break;

              case 16:
                _context12.prev = 16;
                _context12.t0 = _context12["catch"](4);
                this.logger.error("Got error: ".concat(_context12.t0, ", sleeping"));
                _context12.next = 21;
                return this._delay(1000);

              case 21:
                _context12.next = 3;
                break;

              case 23:
                return _context12.abrupt("return", {});

              case 24:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[4, 16]]);
      }));

      function processChallenges(_x6) {
        return _processChallenges.apply(this, arguments);
      }

      return processChallenges;
    }()
    /**
     * Updates attester config
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "updateConfig",
    value: function updateConfig(_ref5) {
      var aaoEndpoint = _ref5.aaoEndpoint,
          aaoAddress = _ref5.aaoAddress,
          endpoints = _ref5.endpoints,
          challengeIdsDenyList = _ref5.challengeIdsDenyList,
          parallelization = _ref5.parallelization;
      this.logger.info("Updating attester with config aaoEndpoint: ".concat(aaoEndpoint, ", aaoAddress: ").concat(aaoAddress, ", endpoints: ").concat(endpoints, ", challengeIdsDenyList: ").concat(challengeIdsDenyList, ", parallelization: ").concat(parallelization));
      this.aaoEndpoint = aaoEndpoint || this.aaoEndpoint;
      this.aaoAddress = aaoAddress || this.aaoAddress;
      this.endpoints = endpoints || this.endpoints;
      this.challengeIdsDenyList = challengeIdsDenyList ? _construct(Set, _toConsumableArray(challengeIdsDenyList)) : this.challengeIdsDenyList;
      this.parallelization = parallelization || this.parallelization;
    }
    /**
     * Sleeps until the feePayer has a usable Sol balance.
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "_awaitFeePayerBalance",
    value: function () {
      var _awaitFeePayerBalance2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
        var _this2 = this;

        var getHasBalance;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                getHasBalance = /*#__PURE__*/function () {
                  var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
                    return regeneratorRuntime.wrap(function _callee13$(_context13) {
                      while (1) {
                        switch (_context13.prev = _context13.next) {
                          case 0:
                            _context13.next = 2;
                            return _this2.libs.solanaWeb3Manager.hasBalance({
                              publicKey: _this2.libs.solanaWeb3Manager.feePayerKey
                            });

                          case 2:
                            return _context13.abrupt("return", _context13.sent);

                          case 3:
                          case "end":
                            return _context13.stop();
                        }
                      }
                    }, _callee13);
                  }));

                  return function getHasBalance() {
                    return _ref6.apply(this, arguments);
                  };
                }();

              case 1:
                _context14.next = 3;
                return getHasBalance();

              case 3:
                if (_context14.sent) {
                  _context14.next = 9;
                  break;
                }

                this.logger.warn('No usable balance. Waiting...');
                _context14.next = 7;
                return this._delay(2000);

              case 7:
                _context14.next = 1;
                break;

              case 9:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function _awaitFeePayerBalance() {
        return _awaitFeePayerBalance2.apply(this, arguments);
      }

      return _awaitFeePayerBalance;
    }()
    /**
     * Returns the override feePayer if set, otherwise a random fee payer from among the list of existing fee payers.
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "_getFeePayer",
    value: function _getFeePayer() {
      if (this.feePayerOverride) {
        return this.feePayerOverride;
      }

      var feePayerKeypairs = this.libs.solanaWeb3Manager.solanaWeb3Config.feePayerKeypairs;

      if (feePayerKeypairs !== null && feePayerKeypairs !== void 0 && feePayerKeypairs.length) {
        var randomFeePayerIndex = Math.floor(Math.random() * feePayerKeypairs.length);
        return feePayerKeypairs[randomFeePayerIndex].publicKey.toString();
      }

      return null;
    }
    /**
     * Escape hatch for manually setting starting block.
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "_checkForStartingBlockOverride",
    value: function () {
      var _checkForStartingBlockOverride2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
        var override;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this.getStartingBlockOverride();

              case 2:
                override = _context15.sent;

                if (!(override === null || override === undefined)) {
                  _context15.next = 5;
                  break;
                }

                return _context15.abrupt("return");

              case 5:
                this.logger.info("Setting starting block override: ".concat(override, ", emptying recent disbursed queue"));
                this.startingBlock = override;
                this.offset = 0;
                this.recentlyDisbursedQueue = [];
                this.undisbursedQueue = [];
                this.discoveryNodeBlocklist = [];

              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function _checkForStartingBlockOverride() {
        return _checkForStartingBlockOverride2.apply(this, arguments);
      }

      return _checkForStartingBlockOverride;
    }()
    /**
     * Main method to attest for a bucket of challenges in parallel.
     *
     * Algorithm:
     * - Gets `this.parallelization` undisbursed challenges from the queue, refilling it from DN if necessary.
     * - Call `_performSingleAttestation` on those in parallel.
     * - For challenges that failed, either keep retrying or discard them, depending on the error.
     * - Set offset and startingBlock
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "_attestInParallel",
    value: function () {
      var _attestInParallel2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(toAttest) {
        var _this3 = this;

        var poaAttestations, highestBlock, retryCount, successful, noRetry, needsAttestation, shouldReselect, accumulatedErrors, successCount, offset, failingNodes, _failingNodes, results, _yield$this$_processR;

        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                this.logger.info("Attesting in parallel with startingBlock: ".concat(this.startingBlock, ", offset: ").concat(this.offset, ", parallelization: ").concat(this.parallelization));
                _context16.next = 3;
                return this._updatePhase('ATTESTING');

              case 3:
                // Get the highest block number, ignoring Solana based challenges (i.e. listens) which have a significantly higher
                // slot and throw off this calculation.
                // TODO: [AUD-1217] we should handle this in a less hacky way, possibly by
                // attesting for Solana + POA challenges separately.
                poaAttestations = toAttest.filter(function (_ref7) {
                  var challengeId = _ref7.challengeId;
                  return !_this3.isSolanaChallenge(challengeId);
                });
                highestBlock = poaAttestations.length ? Math.max.apply(Math, _toConsumableArray(poaAttestations.map(function (e) {
                  return e.completedBlocknumber;
                }))) : null;
                retryCount = 0;
                successful = [];
                noRetry = [];
                needsAttestation = toAttest;
                shouldReselect = false;
                accumulatedErrors = [];
                successCount = 0;
                offset = 0;
                failingNodes = [];

              case 14:
                _context16.next = 16;
                return this._updatePhase('ATTESTING');

              case 16:
                if (!(retryCount !== 0)) {
                  _context16.next = 19;
                  break;
                }

                _context16.next = 19;
                return this._backoff(retryCount);

              case 19:
                this.logger.info("Attestation attempt ".concat(retryCount + 1, ", max ").concat(this.maxRetries));

                if (!shouldReselect) {
                  _context16.next = 23;
                  break;
                }

                _context16.next = 23;
                return this._selectDiscoveryNodes();

              case 23:
                _context16.next = 25;
                return Promise.all(needsAttestation.map(this._performSingleAttestation));

              case 25:
                results = _context16.sent;
                _context16.next = 28;
                return this._processResponses(results, retryCount === this.maxRetries - 1);

              case 28:
                _yield$this$_processR = _context16.sent;
                successful = _yield$this$_processR.successful;
                noRetry = _yield$this$_processR.noRetry;
                needsAttestation = _yield$this$_processR.needsRetry;
                shouldReselect = _yield$this$_processR.shouldReselect;
                failingNodes = _yield$this$_processR.failingNodes;

                // Add failing nodes to the blocklist, trimming out oldest nodes if necessary
                if ((_failingNodes = failingNodes) !== null && _failingNodes !== void 0 && _failingNodes.length) {
                  (function () {
                    var existing = new Set(_this3.discoveryNodeBlocklist);
                    failingNodes.forEach(function (n) {
                      if (!existing.has(n)) {
                        _this3.discoveryNodeBlocklist.push(n);
                      }
                    });
                    _this3.discoveryNodeBlocklist = _this3.discoveryNodeBlocklist.slice(-1 * MAX_DISCOVERY_NODE_BLOCKLIST_LEN);
                  })();
                }

                successCount += successful.length;
                accumulatedErrors = [].concat(_toConsumableArray(accumulatedErrors), _toConsumableArray(noRetry)); // Increment offset by the # of errors we're not retrying that have the max block #.
                //
                // Note: any successfully completed rewards will eventually be flushed from the
                // disbursable queue on DN, but ignored rewards will stay stuck in that list, so we
                // have to move past them with offset if they're not already moved past with `startingBlock`.

                offset += noRetry.filter(function (_ref8) {
                  var completedBlocknumber = _ref8.completedBlocknumber;
                  return completedBlocknumber === highestBlock;
                }).length;
                retryCount++;

              case 39:
                if (needsAttestation.length && retryCount < this.maxRetries) {
                  _context16.next = 14;
                  break;
                }

              case 40:
                if (retryCount === this.maxRetries) {
                  this.logger.error("Gave up with ".concat(retryCount, " retries"));
                }

                return _context16.abrupt("return", {
                  accumulatedErrors: accumulatedErrors,
                  highestBlock: highestBlock,
                  offset: offset,
                  successCount: successCount
                });

              case 42:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function _attestInParallel(_x7) {
        return _attestInParallel2.apply(this, arguments);
      }

      return _attestInParallel;
    }()
    /**
     * Attempts to attest for a single challenge.
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "_performSingleAttestation",
    value: function () {
      var _performSingleAttestation2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(_ref9) {
        var challengeId, userId, specifier, amount, handle, wallet, completedBlocknumber, feePayerOverride, res, _yield$this$libs$Rewa, success, error, aaoErrorCode, phase, nodesToReselect;

        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                challengeId = _ref9.challengeId, userId = _ref9.userId, specifier = _ref9.specifier, amount = _ref9.amount, handle = _ref9.handle, wallet = _ref9.wallet, completedBlocknumber = _ref9.completedBlocknumber;
                this.logger.info("Attempting to attest for userId [".concat(decodeHashId$2(userId), "], challengeId: [").concat(challengeId, "], quorum size: [").concat(this.quorumSize, "]}"));
                feePayerOverride = this._getFeePayer();

                if (feePayerOverride) {
                  _context17.next = 5;
                  break;
                }

                throw Error('Unexpectedly missing feepayer override');

              case 5:
                _context17.next = 7;
                return this.libs.solanaWeb3Manager.createUserBankIfNeeded({
                  feePayerOverride: feePayerOverride,
                  ethAddress: wallet
                });

              case 7:
                res = _context17.sent;

                if (!('error' in res)) {
                  _context17.next = 13;
                  break;
                }

                this.logger.error("Failed to create user bank for user [".concat(decodeHashId$2(userId), "]"), res.error);
                return _context17.abrupt("return", {
                  challengeId: challengeId,
                  userId: userId,
                  specifier: specifier,
                  amount: amount,
                  handle: handle,
                  wallet: wallet,
                  completedBlocknumber: completedBlocknumber,
                  error: errors.USERBANK_CREATION
                });

              case 13:
                if (!res.didExist) {
                  this.logger.info("Created user bank for user [".concat(decodeHashId$2(userId), "]"));
                } else {
                  this.logger.info("User bank already exists for user [".concat(decodeHashId$2(userId), "]"));
                }

              case 14:
                _context17.next = 16;
                return this.libs.Rewards.submitAndEvaluate({
                  challengeId: challengeId,
                  encodedUserId: userId,
                  handle: handle,
                  recipientEthAddress: wallet,
                  specifier: specifier,
                  oracleEthAddress: this.aaoAddress,
                  amount: amount,
                  quorumSize: this.quorumSize,
                  AAOEndpoint: this.aaoEndpoint,
                  endpoints: this.endpoints,
                  logger: this.logger,
                  feePayerOverride: feePayerOverride,
                  maxAggregationAttempts: this.maxAggregationAttempts
                });

              case 16:
                _yield$this$libs$Rewa = _context17.sent;
                success = _yield$this$libs$Rewa.success;
                error = _yield$this$libs$Rewa.error;
                aaoErrorCode = _yield$this$libs$Rewa.aaoErrorCode;
                phase = _yield$this$libs$Rewa.phase;
                nodesToReselect = _yield$this$libs$Rewa.nodesToReselect;

                if (!success) {
                  _context17.next = 25;
                  break;
                }

                this.logger.info("Successfully attestested for challenge [".concat(challengeId, "] for user [").concat(decodeHashId$2(userId), "], amount [").concat(amount, "]!"));
                return _context17.abrupt("return", {
                  challengeId: challengeId,
                  userId: userId,
                  specifier: specifier,
                  amount: amount,
                  handle: handle,
                  wallet: wallet,
                  completedBlocknumber: completedBlocknumber,
                  nodesToReselect: null
                });

              case 25:
                // Handle error path
                this.logger.error("Failed to attest for challenge [".concat(challengeId, "] for user [").concat(decodeHashId$2(userId), "], amount [").concat(amount, "], oracle: [").concat(this.aaoAddress, "] at phase: [").concat(phase, "] with error [").concat(error, "]"));
                return _context17.abrupt("return", {
                  challengeId: challengeId,
                  userId: userId,
                  specifier: specifier,
                  amount: amount,
                  handle: handle,
                  wallet: wallet,
                  completedBlocknumber: completedBlocknumber,
                  error: error,
                  aaoErrorCode: aaoErrorCode,
                  phase: phase,
                  nodesToReselect: nodesToReselect
                });

              case 27:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function _performSingleAttestation(_x8) {
        return _performSingleAttestation2.apply(this, arguments);
      }

      return _performSingleAttestation;
    }()
  }, {
    key: "_selectDiscoveryNodes",
    value: function () {
      var _selectDiscoveryNodes2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
        var _yield$this$libs$disc;

        var startTime, endpoints, blockSet;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this._updatePhase('SELECTING_NODES');

              case 2:
                this.logger.info("Selecting discovery nodes with blocklist ".concat(JSON.stringify(this.discoveryNodeBlocklist)));
                startTime = Date.now();
                _context18.next = 6;
                return this.libs.discoveryProvider.serviceSelector.findAll({
                  verbose: true,
                  whitelist: this.endpointPool.size > 0 ? this.endpointPool : null
                });

              case 6:
                _context18.t1 = _yield$this$libs$disc = _context18.sent.filter(Boolean);
                _context18.t0 = _context18.t1 !== null;

                if (!_context18.t0) {
                  _context18.next = 10;
                  break;
                }

                _context18.t0 = _yield$this$libs$disc !== void 0;

              case 10:
                if (!_context18.t0) {
                  _context18.next = 14;
                  break;
                }

                _context18.t2 = _yield$this$libs$disc;
                _context18.next = 15;
                break;

              case 14:
                _context18.t2 = [];

              case 15:
                endpoints = _context18.t2;
                // Filter out blocklisted nodes
                blockSet = new Set(this.discoveryNodeBlocklist);
                endpoints = _toConsumableArray(endpoints).filter(function (e) {
                  return !blockSet.has(e.endpoint);
                });
                _context18.next = 20;
                return this.libs.Rewards.ServiceProvider.getUniquelyOwnedDiscoveryNodes({
                  quorumSize: this.quorumSize,
                  discoveryNodes: endpoints
                });

              case 20:
                this.endpoints = _context18.sent;
                this.logger.info("Selected new discovery nodes in ".concat((Date.now() - startTime) / 1000, " seconds: [").concat(this.endpoints, "]"));

              case 22:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function _selectDiscoveryNodes() {
        return _selectDiscoveryNodes2.apply(this, arguments);
      }

      return _selectDiscoveryNodes;
    }()
    /**
     * Fetches new undisbursed rewards and inserts them into the undisbursedQueue
     * if the queue is currently empty.
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "_refillQueueIfNecessary",
    value: function () {
      var _refillQueueIfNecessary2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
        var _this4 = this;

        var res, disbursable;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!this.undisbursedQueue.length) {
                  _context19.next = 2;
                  break;
                }

                return _context19.abrupt("return", {});

              case 2:
                this.logger.info("Refilling queue with startingBlock: ".concat(this.startingBlock, ", offset: ").concat(this.offset, ", recently disbursed: ").concat(JSON.stringify(this.recentlyDisbursedQueue)));
                _context19.next = 5;
                return this._updatePhase('REFILLING_QUEUE');

              case 5:
                _context19.next = 7;
                return this.libs.Rewards.getUndisbursedChallenges({
                  offset: this.offset,
                  completedBlockNumber: this.startingBlock.toString(),
                  logger: this.logger
                });

              case 7:
                res = _context19.sent;

                if (!('error' in res)) {
                  _context19.next = 10;
                  break;
                }

                return _context19.abrupt("return", {
                  error: res.error
                });

              case 10:
                disbursable = res.success;

                if (disbursable.length) {
                  this.logger.info("Got challenges: ".concat(disbursable.map(function (_ref10 // eslint-disable-line
                  ) {
                    var challenge_id = _ref10.challenge_id,
                        user_id = _ref10.user_id,
                        specifier = _ref10.specifier;
                    return "".concat(challenge_id, "-").concat(user_id, "-").concat(specifier);
                  }))); // eslint-disable-line
                } // Map to camelCase, and filter out
                // any challenges in the denylist or recently disbursed set


                this.undisbursedQueue = disbursable.map(function (_ref11) {
                  var challenge_id = _ref11.challenge_id,
                      user_id = _ref11.user_id,
                      specifier = _ref11.specifier,
                      amount = _ref11.amount,
                      handle = _ref11.handle,
                      wallet = _ref11.wallet,
                      completed_blocknumber = _ref11.completed_blocknumber;
                  return {
                    challengeId: challenge_id,
                    userId: user_id,
                    specifier: specifier,
                    amount: amount,
                    handle: handle,
                    wallet: wallet,
                    completedBlocknumber: completed_blocknumber
                  };
                }).filter(function (d) {
                  return !(_this4.challengeIdsDenyList.has(d.challengeId) || new Set(_this4.recentlyDisbursedQueue).has(_this4._disbursementToKey(d)));
                }); // Filter out recently disbursed challenges

                if (!this.undisbursedQueue.length) {
                  _context19.next = 17;
                  break;
                }

                _context19.next = 16;
                return this._filterRecentlyCompleted(this.undisbursedQueue);

              case 16:
                this.undisbursedQueue = _context19.sent;

              case 17:
                this.logger.info("Got ".concat(disbursable.length, " undisbursed challenges").concat(this.undisbursedQueue.length !== disbursable.length ? ", filtered out [".concat(disbursable.length - this.undisbursedQueue.length, "] challenges.") : '.'));
                return _context19.abrupt("return", {});

              case 19:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function _refillQueueIfNecessary() {
        return _refillQueueIfNecessary2.apply(this, arguments);
      }

      return _refillQueueIfNecessary;
    }()
    /**
     * Processes responses from `_performSingleAttestation`,
     * bucketing errors into those that need retry and those that should be skipped.
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "_processResponses",
    value: function () {
      var _processResponses2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(responses, isFinalAttempt) {
        var _this5 = this;

        var noRetry, successful, allErrors, stillIncomplete, needsRetry, shouldReselect, failingNodes, now, update;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                noRetry = [];
                successful = []; // Filter our successful responses

                allErrors = responses.filter(function (res) {
                  if (!res.error) {
                    var _decodeHashId;

                    successful.push(res);

                    _this5.reporter.reportSuccess({
                      userId: (_decodeHashId = decodeHashId$2(res.userId)) !== null && _decodeHashId !== void 0 ? _decodeHashId : -1,
                      challengeId: res.challengeId,
                      amount: res.amount,
                      specifier: res.specifier
                    });

                    return false;
                  }

                  return true;
                }); // Filter out responses that are already disbursed

                stillIncomplete = allErrors.filter(function (_ref12) {
                  var error = _ref12.error;
                  return !ALREADY_COMPLETE_ERRORS.has(error);
                }); // Filter to errors needing retry

                needsRetry = stillIncomplete.filter(function (res) {
                  var _decodeHashId2;

                  var report = {
                    userId: (_decodeHashId2 = decodeHashId$2(res.userId)) !== null && _decodeHashId2 !== void 0 ? _decodeHashId2 : -1,
                    challengeId: res.challengeId,
                    amount: res.amount,
                    error: res.error,
                    phase: res.phase,
                    specifier: res.specifier,
                    reason: 'unknown'
                  };

                  function getIsAAOError(err) {
                    return !!err && AAO_ERRORS.has(err);
                  }

                  var error = res.error;
                  var isAAOError = getIsAAOError(error); // Filter out and handle unretryable AAO errors

                  if (isAAOError) {
                    var _errors$HCAPTCHA$erro;

                    noRetry.push(res);
                    var errorType = (_errors$HCAPTCHA$erro = {}, _defineProperty$1(_errors$HCAPTCHA$erro, errors.HCAPTCHA, 'hcaptcha'), _defineProperty$1(_errors$HCAPTCHA$erro, errors.COGNITO_FLOW, 'cognito'), _defineProperty$1(_errors$HCAPTCHA$erro, errors.AAO_ATTESTATION_REJECTION, 'rejection'), _defineProperty$1(_errors$HCAPTCHA$erro, errors.AAO_ATTESTATION_UNKNOWN_RESPONSE, 'unknown'), _errors$HCAPTCHA$erro)[error];
                    report.reason = errorType;

                    _this5.reporter.reportAAORejection(report);
                  } else if (isFinalAttempt) {
                    // Final attempt at retries,
                    // should be classified as noRetry
                    // and reported as a failure
                    noRetry.push(res);

                    _this5.reporter.reportFailure(report);
                  } else {
                    // Otherwise, retry it
                    _this5.reporter.reportRetry(report);
                  }

                  return !isAAOError && !isFinalAttempt;
                });

                if (needsRetry.length) {
                  this.logger.info("Handling errors: ".concat(JSON.stringify(needsRetry.map(function (_ref13) {
                    var error = _ref13.error,
                        phase = _ref13.phase;
                    return {
                      error: error,
                      phase: phase
                    };
                  }))));
                } // Reselect if necessary


                shouldReselect = needsRetry.some(function (_ref14) {
                  var error = _ref14.error;
                  return NEEDS_RESELECT_ERRORS.has(error);
                });
                failingNodes = [];

                if (shouldReselect) {
                  failingNodes = _toConsumableArray(needsRetry.reduce(function (acc, cur) {
                    if (cur.nodesToReselect) {
                      var _cur$nodesToReselect;

                      (_cur$nodesToReselect = cur.nodesToReselect) === null || _cur$nodesToReselect === void 0 ? void 0 : _cur$nodesToReselect.forEach(function (n) {
                        return acc.add(n);
                      });
                    }

                    return acc;
                  }, new Set()));
                  this.logger.info("Failing nodes: ".concat(JSON.stringify(failingNodes)));
                } // Update state


                now = Date.now();
                update = {
                  lastChallengeTime: now
                };

                if (successful.length) {
                  update = _objectSpread2(_objectSpread2({}, update), {}, {
                    lastSuccessChallengeTime: now
                  });
                }

                _context20.next = 14;
                return this._updateState(update);

              case 14:
                return _context20.abrupt("return", {
                  successful: successful,
                  noRetry: noRetry,
                  needsRetry: needsRetry,
                  shouldReselect: shouldReselect,
                  failingNodes: failingNodes
                });

              case 15:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function _processResponses(_x9, _x10) {
        return _processResponses2.apply(this, arguments);
      }

      return _processResponses;
    }()
  }, {
    key: "_disbursementToKey",
    value: function _disbursementToKey(_ref15) {
      var challengeId = _ref15.challengeId,
          userId = _ref15.userId,
          specifier = _ref15.specifier;
      return "".concat(challengeId, "_").concat(userId, "_").concat(specifier);
    }
  }, {
    key: "_backoff",
    value: function () {
      var _backoff2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(retryCount) {
        var backoff;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                backoff = Math.min(this.cooldownMsec * Math.pow(this.backoffExponent, retryCount), this.maxCooldownMsec);
                this.logger.info("Waiting [".concat(backoff, "] msec"));
                _context21.next = 4;
                return this._updatePhase('RETRY_BACKOFF');

              case 4:
                _context21.next = 6;
                return this._delay(backoff);

              case 6:
                return _context21.abrupt("return", _context21.sent);

              case 7:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function _backoff(_x11) {
        return _backoff2.apply(this, arguments);
      }

      return _backoff;
    }()
  }, {
    key: "_delay",
    value: function () {
      var _delay2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(waitTime) {
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, waitTime);
                });

              case 2:
                return _context22.abrupt("return", _context22.sent);

              case 3:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22);
      }));

      function _delay(_x12) {
        return _delay2.apply(this, arguments);
      }

      return _delay;
    }()
  }, {
    key: "_addRecentlyDisbursed",
    value: function _addRecentlyDisbursed(challenges) {
      var _this$recentlyDisburs;

      var ids = challenges.map(this._disbursementToKey);

      (_this$recentlyDisburs = this.recentlyDisbursedQueue).push.apply(_this$recentlyDisburs, _toConsumableArray(ids));

      if (this.recentlyDisbursedQueue.length > MAX_DISBURSED_CACHE_SIZE) {
        this.recentlyDisbursedQueue.splice(0, this.recentlyDisbursedQueue.length - MAX_DISBURSED_CACHE_SIZE);
      }
    }
  }, {
    key: "_filterRecentlyCompleted",
    value: function () {
      var _filterRecentlyCompleted2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(challenges) {
        var _this6 = this;

        var _yield$Promise$all, _yield$Promise$all2, poaThreshold, solanaThreshold, res;

        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return Promise.all([this.delayCalculator.getPOABlockThreshold(), this.delayCalculator.getSolanaSlotThreshold()]);

              case 2:
                _yield$Promise$all = _context23.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                poaThreshold = _yield$Promise$all2[0];
                solanaThreshold = _yield$Promise$all2[1];
                this.logger.info("Filtering with POA threshold: ".concat(poaThreshold, ", Solana threshold: ").concat(solanaThreshold));
                res = challenges.filter(function (c) {
                  return c.completedBlocknumber <= (_this6.isSolanaChallenge(c.challengeId) ? solanaThreshold : poaThreshold);
                });

                if (res.length < challenges.length) {
                  this.logger.info("Filtered out ".concat(challenges.length - res.length, " recent challenges"));
                }

                return _context23.abrupt("return", res);

              case 10:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function _filterRecentlyCompleted(_x13) {
        return _filterRecentlyCompleted2.apply(this, arguments);
      }

      return _filterRecentlyCompleted;
    }()
  }, {
    key: "_updateState",
    value: function () {
      var _updateState2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(newState) {
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.prev = 0;
                this.attesterState = _objectSpread2(_objectSpread2(_objectSpread2({}, this.attesterState), newState), {}, {
                  lastActionTime: Date.now()
                });
                _context24.next = 4;
                return this._updateStateCallback(this.attesterState);

              case 4:
                _context24.next = 9;
                break;

              case 6:
                _context24.prev = 6;
                _context24.t0 = _context24["catch"](0);
                this.logger.error("Got error updating state: ".concat(_context24.t0));

              case 9:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this, [[0, 6]]);
      }));

      function _updateState(_x14) {
        return _updateState2.apply(this, arguments);
      }

      return _updateState;
    }()
  }, {
    key: "_updatePhase",
    value: function () {
      var _updatePhase2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(phase) {
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this._updateState({
                  phase: phase
                });

              case 2:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function _updatePhase(_x15) {
        return _updatePhase2.apply(this, arguments);
      }

      return _updatePhase;
    }()
  }]);

  return RewardsAttester;
}();

var Action;

(function (Action) {
  Action["CREATE"] = "Create";
  Action["UPDATE"] = "Update";
  Action["DELETE"] = "Delete";
  Action["VERIFY"] = "Verify";
  Action["FOLLOW"] = "Follow";
  Action["UNFOLLOW"] = "Unfollow";
  Action["SAVE"] = "Save";
  Action["UNSAVE"] = "Unsave";
  Action["REPOST"] = "Repost";
  Action["UNREPOST"] = "Unrepost";
  Action["SUBSCRIBE"] = "Subscribe";
  Action["UNSUBSCRIBE"] = "Unsubscribe";
  Action["VIEW"] = "View";
  Action["VIEW_PLAYLIST"] = "ViewPlaylist";
})(Action || (Action = {}));

var EntityType;

(function (EntityType) {
  EntityType["PLAYLIST"] = "Playlist";
  EntityType["TRACK"] = "Track";
  EntityType["USER"] = "User";
  EntityType["USER_REPLICA_SET"] = "UserReplicaSet";
  EntityType["NOTIFICATION"] = "Notification";
})(EntityType || (EntityType = {}));
/**
 * Generic management of Audius Data entities
 **/


var EntityManagerClient = /*#__PURE__*/function (_ContractClient) {
  _inherits(EntityManagerClient, _ContractClient);

  var _super = _createSuper(EntityManagerClient);

  function EntityManagerClient() {
    _classCallCheck(this, EntityManagerClient);

    return _super.apply(this, arguments);
  }

  _createClass(EntityManagerClient, [{
    key: "getManageEntityParams",
    value: function () {
      var _getManageEntityParams = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(userId, entityType, entityId, action, metadataMultihash, privateKey) {
        var nonce, chainId, contractAddress, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                nonce = signatureSchemas.getNonce();
                _context.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context.sent;
                _context.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context.sent;
                signatureData = signatureSchemas.generators.getManageEntityData(chainId, contractAddress, userId, entityType, entityId, action, metadataMultihash, nonce);

                if (!privateKey) {
                  _context.next = 12;
                  break;
                }

                sig = sigUtil__default["default"].signTypedData(safeBuffer.Buffer.from(privateKey, 'hex'), {
                  data: signatureData
                });
                _context.next = 15;
                break;

              case 12:
                _context.next = 14;
                return this.web3Manager.signTypedData(signatureData);

              case 14:
                sig = _context.sent;

              case 15:
                _context.next = 17;
                return this.getMethod('manageEntity', userId, entityType, entityId, action, metadataMultihash, nonce, sig);

              case 17:
                method = _context.sent;
                return _context.abrupt("return", [method.encodeABI(), contractAddress]);

              case 19:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getManageEntityParams(_x, _x2, _x3, _x4, _x5, _x6) {
        return _getManageEntityParams.apply(this, arguments);
      }

      return getManageEntityParams;
    }()
    /**
     * Calls the manage entity method on chain
     * @param {number} userId The numeric user id
     * @param {EntityType} entityType The type of entity being modified
     * @param {number} entityId The id of the entity
     * @param {Action} action Action being performed on the entity
     * @param {string} metadata CID multihash or metadata associated with action
     * @param {string}privateKey The private key used to sign the transaction
     */

  }, {
    key: "manageEntity",
    value: function () {
      var _manageEntity = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(userId, entityType, entityId, action, metadata, privateKey) {
        var nonce, chainId, contractAddress, nethermindContractAddress, signatureData, sig, method, nethermindMethod, nethermindSignatureData, nethermindSig, tx;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                nonce = signatureSchemas.getNonce();
                _context2.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context2.sent;
                _context2.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context2.sent;
                _context2.next = 9;
                return this.getNethermindAddress();

              case 9:
                nethermindContractAddress = _context2.sent;
                signatureData = signatureSchemas.generators.getManageEntityData(chainId, contractAddress, userId, entityType, entityId, action, metadata, nonce);

                if (!privateKey) {
                  _context2.next = 15;
                  break;
                }

                sig = sigUtil__default["default"].signTypedData(safeBuffer.Buffer.from(privateKey, 'hex'), {
                  data: signatureData
                });
                _context2.next = 18;
                break;

              case 15:
                _context2.next = 17;
                return this.web3Manager.signTypedData(signatureData);

              case 17:
                sig = _context2.sent;

              case 18:
                _context2.next = 20;
                return this.getMethod('manageEntity', userId, entityType, entityId, action, metadata, nonce, sig);

              case 20:
                method = _context2.sent;

                if (!nethermindContractAddress) {
                  _context2.next = 29;
                  break;
                }

                nethermindSignatureData = signatureSchemas.generators.getManageEntityData(1056800, // TODO get from chain after web3Manager uses nethermind only
                nethermindContractAddress, userId, entityType, entityId, action, metadata, nonce);
                _context2.next = 25;
                return this.web3Manager.signTypedData(nethermindSignatureData);

              case 25:
                nethermindSig = _context2.sent;
                _context2.next = 28;
                return this.getMethod('manageEntity', userId, entityType, entityId, action, metadata, nonce, nethermindSig);

              case 28:
                nethermindMethod = _context2.sent;

              case 29:
                _context2.next = 31;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress, undefined, undefined, nethermindContractAddress, nethermindMethod);

              case 31:
                tx = _context2.sent;
                return _context2.abrupt("return", {
                  txReceipt: tx
                });

              case 33:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function manageEntity(_x7, _x8, _x9, _x10, _x11, _x12) {
        return _manageEntity.apply(this, arguments);
      }

      return manageEntity;
    }()
  }]);

  return EntityManagerClient;
}(ContractClient);

_defineProperty$1(EntityManagerClient, "Action", Action);

_defineProperty$1(EntityManagerClient, "EntityType", EntityType);

var AudiusContracts = /*#__PURE__*/function () {
  function AudiusContracts(web3Manager, registryAddress, entityManagerAddress, isServer) {
    var logger = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : console;

    _classCallCheck(this, AudiusContracts);

    _defineProperty$1(this, "web3Manager", void 0);

    _defineProperty$1(this, "registryAddress", void 0);

    _defineProperty$1(this, "entityManagerAddress", void 0);

    _defineProperty$1(this, "isServer", void 0);

    _defineProperty$1(this, "logger", void 0);

    _defineProperty$1(this, "EntityManagerClient", void 0);

    _defineProperty$1(this, "contractClients", void 0);

    _defineProperty$1(this, "contracts", void 0);

    _defineProperty$1(this, "contractAddresses", void 0);

    _defineProperty$1(this, "getEmptyRegistryAddress", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return Promise.resolve('');

            case 2:
              return _context.abrupt("return", _context.sent);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));

    this.web3Manager = web3Manager;
    this.registryAddress = registryAddress;
    this.entityManagerAddress = entityManagerAddress;
    this.isServer = isServer;
    this.logger = logger;
    this.contractClients = [];

    if (this.entityManagerAddress) {
      this.EntityManagerClient = new EntityManagerClient(this.web3Manager, abi$e, 'EntityManager', this.getEmptyRegistryAddress, this.logger, this.entityManagerAddress);
      this.contractClients.push(this.EntityManagerClient);
    }
  }

  _createClass(AudiusContracts, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.isServer) {
                  _context3.next = 3;
                  break;
                }

                _context3.next = 3;
                return Promise.all(this.contractClients.map( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(client) {
                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return client.init();

                          case 2:
                            return _context2.abrupt("return", _context2.sent);

                          case 3:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function (_x) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }]);

  return AudiusContracts;
}();

var getTrackListens = function getTrackListens() {
  var timeFrame = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var idsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var startTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var endTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var limit = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var offset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
  var queryUrl = 'tracks/listens/';

  if (timeFrame != null) {
    switch (timeFrame) {
      case 'day':
      case 'week':
      case 'month':
      case 'year':
      case 'millennium':
        break;

      default:
        throw new Error('Invalid timeFrame value provided');
    }

    queryUrl += timeFrame;
  }

  var queryParams = {};

  if (idsArray !== null) {
    queryParams.id = idsArray;
  }

  if (limit !== null) {
    queryParams.limit = limit;
  }

  if (offset !== null) {
    queryParams.offset = offset;
  }

  if (startTime != null) {
    queryParams.start = startTime;
  }

  if (endTime != null) {
    queryParams.end = endTime;
  }

  var req = {
    url: queryUrl,
    method: 'get',
    params: queryParams
  };
  return req;
};

var TransactionMetadataType;

(function (TransactionMetadataType) {
  TransactionMetadataType["PURCHASE_SOL_AUDIO_SWAP"] = "PURCHASE_SOL_AUDIO_SWAP";
})(TransactionMetadataType || (TransactionMetadataType = {}));

var IdentityService = /*#__PURE__*/function () {
  function IdentityService(_ref) {
    var identityServiceEndpoint = _ref.identityServiceEndpoint;

    _classCallCheck(this, IdentityService);

    _defineProperty$1(this, "identityServiceEndpoint", void 0);

    _defineProperty$1(this, "web3Manager", void 0);

    this.identityServiceEndpoint = identityServiceEndpoint;
    this.web3Manager = null;
  }

  _createClass(IdentityService, [{
    key: "setWeb3Manager",
    value: function setWeb3Manager(web3Manager) {
      this.web3Manager = web3Manager;
    }
    /* ------- HEDGEHOG AUTH ------- */

  }, {
    key: "getFn",
    value: function () {
      var _getFn = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._makeRequest({
                  url: '/authentication',
                  method: 'get',
                  params: params
                });

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getFn(_x) {
        return _getFn.apply(this, arguments);
      }

      return getFn;
    }()
  }, {
    key: "setAuthFn",
    value: function () {
      var _setAuthFn = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(obj) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._makeRequest({
                  url: '/authentication',
                  method: 'post',
                  data: obj
                });

              case 2:
                return _context2.abrupt("return", _context2.sent);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setAuthFn(_x2) {
        return _setAuthFn.apply(this, arguments);
      }

      return setAuthFn;
    }()
  }, {
    key: "setUserFn",
    value: function () {
      var _setUserFn = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(obj) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._makeRequest({
                  url: '/user',
                  method: 'post',
                  data: obj
                });

              case 2:
                return _context3.abrupt("return", _context3.sent);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function setUserFn(_x3) {
        return _setUserFn.apply(this, arguments);
      }

      return setUserFn;
    }()
  }, {
    key: "getUserEvents",
    value: function () {
      var _getUserEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(walletAddress) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._makeRequest({
                  url: '/userEvents',
                  method: 'get',
                  params: {
                    walletAddress: walletAddress
                  }
                });

              case 2:
                return _context4.abrupt("return", _context4.sent);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getUserEvents(_x4) {
        return _getUserEvents.apply(this, arguments);
      }

      return getUserEvents;
    }()
  }, {
    key: "sendRecoveryInfo",
    value: function () {
      var _sendRecoveryInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(obj) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._makeRequest({
                  url: '/recovery',
                  method: 'post',
                  data: obj
                });

              case 2:
                return _context5.abrupt("return", _context5.sent);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function sendRecoveryInfo(_x5) {
        return _sendRecoveryInfo.apply(this, arguments);
      }

      return sendRecoveryInfo;
    }()
    /**
     * Check if an email address has been previously registered.
     */

  }, {
    key: "checkIfEmailRegistered",
    value: function () {
      var _checkIfEmailRegistered = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(email) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this._makeRequest({
                  url: '/users/check',
                  method: 'get',
                  params: {
                    email: email
                  }
                });

              case 2:
                return _context6.abrupt("return", _context6.sent);

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function checkIfEmailRegistered(_x6) {
        return _checkIfEmailRegistered.apply(this, arguments);
      }

      return checkIfEmailRegistered;
    }()
  }, {
    key: "getUserEmail",
    value: function () {
      var _getUserEmail = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var headers;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._signData();

              case 2:
                headers = _context7.sent;

                if (!(headers[AuthHeaders.MESSAGE] && headers[AuthHeaders.SIGNATURE])) {
                  _context7.next = 9;
                  break;
                }

                _context7.next = 6;
                return this._makeRequest({
                  url: '/user/email',
                  method: 'get',
                  headers: headers
                });

              case 6:
                return _context7.abrupt("return", _context7.sent);

              case 9:
                throw new Error('Cannot get user email - user is not authenticated');

              case 10:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getUserEmail() {
        return _getUserEmail.apply(this, arguments);
      }

      return getUserEmail;
    }()
    /**
     * Associates a user with a twitter uuid.
     * @param uuid from the Twitter API
     * @param userId
     * @param handle User handle
     */

  }, {
    key: "associateTwitterUser",
    value: function () {
      var _associateTwitterUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(uuid, userId, handle) {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._makeRequest({
                  url: '/twitter/associate',
                  method: 'post',
                  data: {
                    uuid: uuid,
                    userId: userId,
                    handle: handle
                  }
                });

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function associateTwitterUser(_x7, _x8, _x9) {
        return _associateTwitterUser.apply(this, arguments);
      }

      return associateTwitterUser;
    }()
    /**
     * Associates a user with an instagram uuid.
     * @param uuid from the Instagram API
     * @param userId
     * @param handle
     */

  }, {
    key: "associateInstagramUser",
    value: function () {
      var _associateInstagramUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(uuid, userId, handle) {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._makeRequest({
                  url: '/instagram/associate',
                  method: 'post',
                  data: {
                    uuid: uuid,
                    userId: userId,
                    handle: handle
                  }
                });

              case 2:
                return _context9.abrupt("return", _context9.sent);

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function associateInstagramUser(_x10, _x11, _x12) {
        return _associateInstagramUser.apply(this, arguments);
      }

      return associateInstagramUser;
    }()
    /**
     * Associates a user with an TikTok uuid.
     * @param uuid from the TikTok API
     * @param userId
     * @param handle
     */

  }, {
    key: "associateTikTokUser",
    value: function () {
      var _associateTikTokUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(uuid, userId, handle) {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this._makeRequest({
                  url: '/tiktok/associate',
                  method: 'post',
                  data: {
                    uuid: uuid,
                    userId: userId,
                    handle: handle
                  }
                });

              case 2:
                return _context10.abrupt("return", _context10.sent);

              case 3:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function associateTikTokUser(_x13, _x14, _x15) {
        return _associateTikTokUser.apply(this, arguments);
      }

      return associateTikTokUser;
    }()
    /**
     * Logs a track listen for a given user id.
     * @param trackId
     * @param userId
     * @param listenerAddress if logging this listen on behalf of another IP address, pass through here
     * @param signatureData if logging this listen via a 3p service, a signed piece of data proving authenticity
     */

  }, {
    key: "logTrackListen",
    value: function () {
      var _logTrackListen = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(trackId, userId, listenerAddress, signatureData) {
        var solanaListen,
            data,
            request,
            _args11 = arguments;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                solanaListen = _args11.length > 4 && _args11[4] !== undefined ? _args11[4] : false;
                data = {
                  userId: userId,
                  solanaListen: solanaListen
                };

                if (signatureData) {
                  data.signature = signatureData.signature;
                  data.timestamp = signatureData.timestamp;
                }

                request = {
                  url: "/tracks/".concat(trackId, "/listen"),
                  method: 'post',
                  data: data
                };

                if (listenerAddress) {
                  request.headers = {
                    'x-forwarded-for': listenerAddress
                  };
                }

                _context11.next = 7;
                return this._makeRequest(request);

              case 7:
                return _context11.abrupt("return", _context11.sent);

              case 8:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function logTrackListen(_x16, _x17, _x18, _x19) {
        return _logTrackListen.apply(this, arguments);
      }

      return logTrackListen;
    }()
    /**
     * Return listen history tracks for a given user id.
     * @param userId - User ID
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */

  }, {
    key: "getListenHistoryTracks",
    value: function () {
      var _getListenHistoryTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(userId) {
        var limit,
            offset,
            req,
            _args12 = arguments;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                limit = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : 100;
                offset = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : 0;
                req = {
                  method: 'get',
                  url: '/tracks/history',
                  params: {
                    userId: userId,
                    limit: limit,
                    offset: offset
                  }
                };
                _context12.next = 5;
                return this._makeRequest(req);

              case 5:
                return _context12.abrupt("return", _context12.sent);

              case 6:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getListenHistoryTracks(_x20) {
        return _getListenHistoryTracks.apply(this, arguments);
      }

      return getListenHistoryTracks;
    }()
    /**
     * Looks up a Twitter account by handle.
     * @returns twitter API response.
     */

  }, {
    key: "lookupTwitterHandle",
    value: function () {
      var _lookupTwitterHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(handle) {
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!handle) {
                  _context13.next = 6;
                  break;
                }

                _context13.next = 3;
                return this._makeRequest({
                  url: '/twitter/handle_lookup',
                  method: 'get',
                  params: {
                    handle: handle
                  }
                });

              case 3:
                return _context13.abrupt("return", _context13.sent);

              case 6:
                throw new Error('No handle passed into function lookupTwitterHandle');

              case 7:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function lookupTwitterHandle(_x21) {
        return _lookupTwitterHandle.apply(this, arguments);
      }

      return lookupTwitterHandle;
    }()
    /**
     * Gets tracks trending on Audius.
     * @param timeFrame one of day, week, month, or year
     * @param idsArray track ids
     * @param limit
     * @param offset
     */

  }, {
    key: "getTrendingTracks",
    value: function () {
      var _getTrendingTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
        var timeFrame,
            idsArray,
            limit,
            offset,
            queryUrl,
            queryParams,
            _args14 = arguments;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                timeFrame = _args14.length > 0 && _args14[0] !== undefined ? _args14[0] : null;
                idsArray = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : null;
                limit = _args14.length > 2 && _args14[2] !== undefined ? _args14[2] : null;
                offset = _args14.length > 3 && _args14[3] !== undefined ? _args14[3] : null;
                queryUrl = '/tracks/trending/';

                if (!(timeFrame != null)) {
                  _context14.next = 12;
                  break;
                }

                _context14.t0 = timeFrame;
                _context14.next = _context14.t0 === 'day' ? 9 : _context14.t0 === 'week' ? 9 : _context14.t0 === 'month' ? 9 : _context14.t0 === 'year' ? 9 : 10;
                break;

              case 9:
                return _context14.abrupt("break", 11);

              case 10:
                throw new Error('Invalid timeFrame value provided');

              case 11:
                queryUrl += timeFrame;

              case 12:
                queryParams = {};

                if (idsArray !== null) {
                  queryParams.id = idsArray;
                }

                if (limit !== null) {
                  queryParams.limit = limit;
                }

                if (offset !== null) {
                  queryParams.offset = offset;
                }

                _context14.next = 18;
                return this._makeRequest({
                  url: queryUrl,
                  method: 'get',
                  params: queryParams
                });

              case 18:
                return _context14.abrupt("return", _context14.sent);

              case 19:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getTrendingTracks() {
        return _getTrendingTracks.apply(this, arguments);
      }

      return getTrendingTracks;
    }()
    /**
     * Gets listens for tracks bucketted by timeFrame.
     * @param timeFrame one of day, week, month, or year
     * @param idsArray track ids
     * @param startTime parseable by Date.parse
     * @param endTime parseable by Date.parse
     * @param limit
     * @param offset
     */

  }, {
    key: "getTrackListens",
    value: function () {
      var _getTrackListens2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
        var timeFrame,
            idsArray,
            startTime,
            endTime,
            limit,
            offset,
            req,
            _args15 = arguments;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                timeFrame = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : null;
                idsArray = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : null;
                startTime = _args15.length > 2 && _args15[2] !== undefined ? _args15[2] : null;
                endTime = _args15.length > 3 && _args15[3] !== undefined ? _args15[3] : null;
                limit = _args15.length > 4 && _args15[4] !== undefined ? _args15[4] : null;
                offset = _args15.length > 5 && _args15[5] !== undefined ? _args15[5] : null;
                req = getTrackListens(timeFrame, idsArray, startTime, endTime, limit, offset);
                _context15.next = 9;
                return this._makeRequest(req);

              case 9:
                return _context15.abrupt("return", _context15.sent);

              case 10:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getTrackListens$1() {
        return _getTrackListens2.apply(this, arguments);
      }

      return getTrackListens$1;
    }()
  }, {
    key: "createUserRecord",
    value: function () {
      var _createUserRecord = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(email, walletAddress) {
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this._makeRequest({
                  url: '/user',
                  method: 'post',
                  data: {
                    username: email,
                    walletAddress: walletAddress
                  }
                });

              case 2:
                return _context16.abrupt("return", _context16.sent);

              case 3:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function createUserRecord(_x22, _x23) {
        return _createUserRecord.apply(this, arguments);
      }

      return createUserRecord;
    }()
  }, {
    key: "relay",
    value: function () {
      var _relay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(contractRegistryKey, contractAddress, senderAddress, encodedABI, gasLimit) {
        var handle,
            nethermindContractAddress,
            nethermindEncodedAbi,
            _args17 = arguments;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                handle = _args17.length > 5 && _args17[5] !== undefined ? _args17[5] : null;
                nethermindContractAddress = _args17.length > 6 ? _args17[6] : undefined;
                nethermindEncodedAbi = _args17.length > 7 ? _args17[7] : undefined;
                _context17.next = 5;
                return this._makeRequest({
                  url: '/relay',
                  method: 'post',
                  data: {
                    contractRegistryKey: contractRegistryKey,
                    contractAddress: contractAddress,
                    senderAddress: senderAddress,
                    encodedABI: encodedABI,
                    gasLimit: gasLimit,
                    handle: handle,
                    nethermindContractAddress: nethermindContractAddress,
                    nethermindEncodedAbi: nethermindEncodedAbi
                  }
                });

              case 5:
                return _context17.abrupt("return", _context17.sent);

              case 6:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function relay(_x24, _x25, _x26, _x27, _x28) {
        return _relay.apply(this, arguments);
      }

      return relay;
    }()
  }, {
    key: "ethRelay",
    value: function () {
      var _ethRelay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(contractAddress, senderAddress, encodedABI, gasLimit) {
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this._makeRequest({
                  url: '/eth_relay',
                  method: 'post',
                  data: {
                    contractAddress: contractAddress,
                    senderAddress: senderAddress,
                    encodedABI: encodedABI,
                    gasLimit: gasLimit
                  }
                });

              case 2:
                return _context18.abrupt("return", _context18.sent);

              case 3:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function ethRelay(_x29, _x30, _x31, _x32) {
        return _ethRelay.apply(this, arguments);
      }

      return ethRelay;
    }()
  }, {
    key: "wormholeRelay",
    value: function () {
      var _wormholeRelay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(_ref2) {
        var senderAddress, permit, transferTokens;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                senderAddress = _ref2.senderAddress, permit = _ref2.permit, transferTokens = _ref2.transferTokens;
                _context19.next = 3;
                return this._makeRequest({
                  url: '/wormhole_relay',
                  method: 'post',
                  data: {
                    senderAddress: senderAddress,
                    permit: permit,
                    transferTokens: transferTokens
                  }
                });

              case 3:
                return _context19.abrupt("return", _context19.sent);

              case 4:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function wormholeRelay(_x33) {
        return _wormholeRelay.apply(this, arguments);
      }

      return wormholeRelay;
    }()
    /**
     * Gets the correct wallet that will relay a txn for `senderAddress`
     * @param senderAddress wallet
     */

  }, {
    key: "getEthRelayer",
    value: function () {
      var _getEthRelayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(senderAddress) {
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this._makeRequest({
                  url: '/eth_relayer',
                  method: 'get',
                  params: {
                    wallet: senderAddress
                  }
                });

              case 2:
                return _context20.abrupt("return", _context20.sent);

              case 3:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getEthRelayer(_x34) {
        return _getEthRelayer.apply(this, arguments);
      }

      return getEthRelayer;
    }()
  }, {
    key: "getRandomFeePayer",
    value: function () {
      var _getRandomFeePayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21() {
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this._makeRequest({
                  url: '/solana/random_fee_payer',
                  method: 'get',
                  headers: {
                    'Content-Type': 'application/json'
                  }
                });

              case 2:
                return _context21.abrupt("return", _context21.sent);

              case 3:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getRandomFeePayer() {
        return _getRandomFeePayer.apply(this, arguments);
      }

      return getRandomFeePayer;
    }() // Relays tx data through the solana relay endpoint

  }, {
    key: "solanaRelay",
    value: function () {
      var _solanaRelay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(transactionData) {
        var headers;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this._signData();

              case 2:
                headers = _context22.sent;
                _context22.next = 5;
                return this._makeRequest({
                  url: '/solana/relay',
                  method: 'post',
                  data: transactionData,
                  headers: headers
                });

              case 5:
                return _context22.abrupt("return", _context22.sent);

              case 6:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function solanaRelay(_x35) {
        return _solanaRelay.apply(this, arguments);
      }

      return solanaRelay;
    }()
  }, {
    key: "solanaRelayRaw",
    value: function () {
      var _solanaRelayRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(transactionData) {
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this._makeRequest({
                  url: '/solana/relay/raw',
                  method: 'post',
                  data: transactionData
                });

              case 2:
                return _context23.abrupt("return", _context23.sent);

              case 3:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function solanaRelayRaw(_x36) {
        return _solanaRelayRaw.apply(this, arguments);
      }

      return solanaRelayRaw;
    }()
  }, {
    key: "getMinimumDelegationAmount",
    value: function () {
      var _getMinimumDelegationAmount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(wallet) {
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this._makeRequest({
                  url: "/protocol/".concat(wallet, "/delegation/minimum"),
                  method: 'get'
                });

              case 2:
                return _context24.abrupt("return", _context24.sent);

              case 3:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getMinimumDelegationAmount(_x37) {
        return _getMinimumDelegationAmount.apply(this, arguments);
      }

      return getMinimumDelegationAmount;
    }()
  }, {
    key: "updateMinimumDelegationAmount",
    value: function () {
      var _updateMinimumDelegationAmount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(wallet, minimumDelegationAmount, signedData) {
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this._makeRequest({
                  url: "/protocol/".concat(wallet, "/delegation/minimum"),
                  method: 'post',
                  headers: signedData,
                  data: {
                    minimumDelegationAmount: minimumDelegationAmount
                  }
                });

              case 2:
                return _context25.abrupt("return", _context25.sent);

              case 3:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function updateMinimumDelegationAmount(_x38, _x39, _x40) {
        return _updateMinimumDelegationAmount.apply(this, arguments);
      }

      return updateMinimumDelegationAmount;
    }()
    /**
     * Sends an attestation result to identity.
     *
     */

  }, {
    key: "sendAttestationResult",
    value: function () {
      var _sendAttestationResult = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(data) {
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this._makeRequest({
                  url: '/rewards/attestation_result',
                  method: 'post',
                  data: data
                });

              case 2:
                return _context26.abrupt("return", _context26.sent);

              case 3:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function sendAttestationResult(_x41) {
        return _sendAttestationResult.apply(this, arguments);
      }

      return sendAttestationResult;
    }()
    /**
     * Post a reaction to identity.
     */

  }, {
    key: "submitReaction",
    value: function () {
      var _submitReaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(data) {
        var headers;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                _context27.next = 2;
                return this._signData();

              case 2:
                headers = _context27.sent;
                _context27.next = 5;
                return this._makeRequest({
                  url: '/reactions',
                  method: 'post',
                  data: data,
                  headers: headers
                });

              case 5:
                return _context27.abrupt("return", _context27.sent);

              case 6:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function submitReaction(_x42) {
        return _submitReaction.apply(this, arguments);
      }

      return submitReaction;
    }()
    /**
     * Gets $AUDIO purchase metadata
     */

  }, {
    key: "getUserBankTransactionMetadata",
    value: function () {
      var _getUserBankTransactionMetadata = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(transactionId) {
        var _metadatas$0$metadata, _metadatas$;

        var headers, metadatas;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this._signData();

              case 2:
                headers = _context28.sent;
                _context28.next = 5;
                return this._makeRequest({
                  url: "/transaction_metadata?id=".concat(transactionId),
                  method: 'get',
                  headers: headers
                });

              case 5:
                metadatas = _context28.sent;
                return _context28.abrupt("return", (_metadatas$0$metadata = (_metadatas$ = metadatas[0]) === null || _metadatas$ === void 0 ? void 0 : _metadatas$.metadata) !== null && _metadatas$0$metadata !== void 0 ? _metadatas$0$metadata : null);

              case 7:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getUserBankTransactionMetadata(_x43) {
        return _getUserBankTransactionMetadata.apply(this, arguments);
      }

      return getUserBankTransactionMetadata;
    }()
    /**
     * Saves $AUDIO purchase metadata
     */

  }, {
    key: "saveUserBankTransactionMetadata",
    value: function () {
      var _saveUserBankTransactionMetadata = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(data) {
        var headers;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.next = 2;
                return this._signData();

              case 2:
                headers = _context29.sent;
                _context29.next = 5;
                return this._makeRequest({
                  url: '/transaction_metadata',
                  method: 'post',
                  data: data,
                  headers: headers
                });

              case 5:
                return _context29.abrupt("return", _context29.sent);

              case 6:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function saveUserBankTransactionMetadata(_x44) {
        return _saveUserBankTransactionMetadata.apply(this, arguments);
      }

      return saveUserBankTransactionMetadata;
    }()
  }, {
    key: "createStripeSession",
    value: function () {
      var _createStripeSession = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(data) {
        var headers;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this._signData();

              case 2:
                headers = _context30.sent;
                _context30.next = 5;
                return this._makeRequest({
                  url: '/stripe/session',
                  method: 'post',
                  data: data,
                  headers: headers
                });

              case 5:
                return _context30.abrupt("return", _context30.sent);

              case 6:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function createStripeSession(_x45) {
        return _createStripeSession.apply(this, arguments);
      }

      return createStripeSession;
    }()
    /* ------- INTERNAL FUNCTIONS ------- */

  }, {
    key: "_makeRequest",
    value: function () {
      var _makeRequest2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(axiosRequestObj) {
        var requestId, resp, _error$response, _error$response$data, error;

        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                axiosRequestObj.baseURL = this.identityServiceEndpoint;
                requestId = uuid();
                axiosRequestObj.headers = _objectSpread2(_objectSpread2({}, axiosRequestObj.headers || {}), {}, {
                  'X-Request-ID': requestId
                }); // Axios throws for non-200 responses

                _context31.prev = 3;
                _context31.next = 6;
                return axios__default["default"](axiosRequestObj);

              case 6:
                resp = _context31.sent;

                if (resp.data) {
                  _context31.next = 9;
                  break;
                }

                throw new Error("Identity response missing data field for url: ".concat(axiosRequestObj.url, ", req-id: ").concat(requestId));

              case 9:
                return _context31.abrupt("return", resp.data);

              case 12:
                _context31.prev = 12;
                _context31.t0 = _context31["catch"](3);
                error = _context31.t0;

                if ((_error$response = error.response) !== null && _error$response !== void 0 && (_error$response$data = _error$response.data) !== null && _error$response$data !== void 0 && _error$response$data.error) {
                  console.error("Server returned error for requestId ".concat(requestId, ": [").concat(error.response.status.toString(), "] ").concat(error.response.data.error));
                }

                throw error;

              case 17:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this, [[3, 12]]);
      }));

      function _makeRequest(_x46) {
        return _makeRequest2.apply(this, arguments);
      }

      return _makeRequest;
    }()
  }, {
    key: "_signData",
    value: function () {
      var _signData2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32() {
        var _this$web3Manager, _ref3, unixTs, message, signature;

        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                if (!this.web3Manager) {
                  _context32.next = 9;
                  break;
                }

                unixTs = Math.round(new Date().getTime() / 1000); // current unix timestamp (sec)

                message = "Click sign to authenticate with identity service: ".concat(unixTs);
                _context32.next = 5;
                return (_this$web3Manager = this.web3Manager) === null || _this$web3Manager === void 0 ? void 0 : _this$web3Manager.sign(Buffer.from(message, 'utf-8'));

              case 5:
                signature = _context32.sent;
                return _context32.abrupt("return", (_ref3 = {}, _defineProperty$1(_ref3, AuthHeaders.MESSAGE, message), _defineProperty$1(_ref3, AuthHeaders.SIGNATURE, signature), _ref3));

              case 9:
                return _context32.abrupt("return", {});

              case 10:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function _signData() {
        return _signData2.apply(this, arguments);
      }

      return _signData;
    }()
  }]);

  return IdentityService;
}();

var Comstock = /*#__PURE__*/function () {
  function Comstock(comstockEndpoint) {
    _classCallCheck(this, Comstock);

    _defineProperty$1(this, "comstockEndpoint", void 0);

    this.comstockEndpoint = comstockEndpoint;
  }

  _createClass(Comstock, [{
    key: "getComstock",
    value: function () {
      var _getComstock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(obj) {
        var result;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._makeRequest({
                  url: '/wallet_lookup',
                  method: 'get',
                  params: obj
                });

              case 2:
                result = _context.sent;
                return _context.abrupt("return", result);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getComstock(_x) {
        return _getComstock.apply(this, arguments);
      }

      return getComstock;
    }()
    /* ------- INTERNAL FUNCTIONS ------- */

  }, {
    key: "_makeRequest",
    value: function () {
      var _makeRequest2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(axiosRequestObj) {
        var resp, _error$response, _error$response$data, error;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                axiosRequestObj.baseURL = this.comstockEndpoint; // Axios throws for non-200 responses

                _context2.prev = 1;
                _context2.next = 4;
                return axios__default["default"](axiosRequestObj);

              case 4:
                resp = _context2.sent;
                return _context2.abrupt("return", resp.data);

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](1);
                error = _context2.t0;

                if (!((_error$response = error.response) !== null && _error$response !== void 0 && (_error$response$data = _error$response.data) !== null && _error$response$data !== void 0 && _error$response$data.error)) {
                  _context2.next = 13;
                  break;
                }

                throw new Error("Server returned error: [".concat(error.response.status.toString(), "] ").concat(error.response.data.error));

              case 13:
                throw error;

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 8]]);
      }));

      function _makeRequest(_x2) {
        return _makeRequest2.apply(this, arguments);
      }

      return _makeRequest;
    }()
  }]);

  return Comstock;
}();

var Hedgehog = /*#__PURE__*/_createClass( // TODO - update this comment
// This is some black magic going on here. The audiusServiceEndpoint is passed in along with the
// requestToAudiusService function reference. When setFn and getFn call self.requestToAudiusService,
// the context of `this` that's used is the HedgehogWrapper class, not the AudiusWeb3 class.
// Therefore, we need to define this.audiusServiceEndpoint, to satisfy all the deps of the
// requestToAudiusService and make it execute correctly
function Hedgehog(_ref) {
  var _this = this;

  var identityService = _ref.identityService,
      _ref$useLocalStorage = _ref.useLocalStorage,
      useLocalStorage = _ref$useLocalStorage === void 0 ? true : _ref$useLocalStorage,
      localStorage = _ref.localStorage,
      _ref$createKey = _ref.createKey,
      createKey = _ref$createKey === void 0 ? hedgehog.getPlatformCreateKey() : _ref$createKey;

  _classCallCheck(this, Hedgehog);

  _defineProperty$1(this, "identityService", void 0);

  _defineProperty$1(this, "getFn", void 0);

  _defineProperty$1(this, "setAuthFn", void 0);

  _defineProperty$1(this, "setUserFn", void 0);

  _defineProperty$1(this, "instance", void 0);

  this.identityService = identityService;

  this.getFn = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(obj) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this.identityService.getFn(obj);

            case 2:
              return _context.abrupt("return", _context.sent);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }();

  this.setAuthFn = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(obj) {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return _this.identityService.setAuthFn(obj);

            case 2:
              return _context2.abrupt("return", _context2.sent);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x2) {
      return _ref3.apply(this, arguments);
    };
  }();

  this.setUserFn = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(obj) {
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return _this.identityService.setUserFn(obj);

            case 2:
              return _context3.abrupt("return", _context3.sent);

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x3) {
      return _ref4.apply(this, arguments);
    };
  }();

  var hedgehog$1 = new hedgehog.Hedgehog(this.getFn, this.setAuthFn, this.setUserFn, useLocalStorage, localStorage, createKey); // we override the login function here because getFn needs both lookupKey and email
  // in identity service, but hedgehog only sends lookupKey

  hedgehog$1.login = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(email, password) {
      var lookupKey, data, _yield$WalletManager$, walletObj, entropy;

      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return hedgehog.WalletManager.createAuthLookupKey(email, password, createKey);

            case 2:
              lookupKey = _context4.sent;
              _context4.next = 5;
              return _this.getFn({
                lookupKey: lookupKey,
                username: email
              });

            case 5:
              data = _context4.sent;

              if (!(data !== null && data !== void 0 && data.iv && data.cipherText)) {
                _context4.next = 18;
                break;
              }

              _context4.next = 9;
              return hedgehog.WalletManager.decryptCipherTextAndRetrieveWallet(password, data.iv, data.cipherText, createKey);

            case 9:
              _yield$WalletManager$ = _context4.sent;
              walletObj = _yield$WalletManager$.walletObj;
              entropy = _yield$WalletManager$.entropy;
              // set wallet property on the class
              hedgehog$1.wallet = walletObj; // set entropy in localStorage

              _context4.next = 15;
              return hedgehog.WalletManager.setEntropyInLocalStorage(entropy, hedgehog$1.localStorage);

            case 15:
              return _context4.abrupt("return", walletObj);

            case 18:
              throw new Error('No account record for user');

            case 19:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function (_x4, _x5) {
      return _ref5.apply(this, arguments);
    };
  }();
  /**
   * Generate secure credentials to allow login
   */
  // @ts-expect-error -- adding our own custom method to hedgehog


  hedgehog$1.generateRecoveryInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
    var entropy, btoa, currentHost, recoveryInfo;
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return hedgehog.WalletManager.getEntropyFromLocalStorage(hedgehog$1.localStorage);

          case 2:
            entropy = _context5.sent;

            if (!(entropy === null)) {
              _context5.next = 5;
              break;
            }

            throw new Error('generateRecoveryLink - missing entropy');

          case 5:
            if (typeof window !== 'undefined' && window && window.btoa) {
              btoa = window.btoa;
              currentHost = window.location.origin;
            } else {
              btoa = function btoa(str) {
                return Buffer.from(str, 'binary').toString('base64');
              };

              currentHost = 'localhost';
            }

            recoveryInfo = {
              login: btoa(entropy),
              host: currentHost
            };
            return _context5.abrupt("return", recoveryInfo);

          case 8:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  this.instance = hedgehog$1;
});

var $schema$2 = "http://json-schema.org/draft-07/schema#";
var $ref$2 = "#/definitions/Track";
var definitions$2 = {
	Track: {
		type: "object",
		additionalProperties: true,
		$comment: "Additional properties enabled because the data return by discovery providers may contain other properties like blockhash, is_current, which are not strictly part of the metadata.",
		properties: {
			title: {
				type: "string",
				"default": null
			},
			preview_cid: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			audio_upload_id: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			preview_start_seconds: {
				type: [
					"float",
					"null"
				],
				"default": null
			},
			cover_art: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			cover_art_sizes: {
				$comment: "type can be null if attached as a stem",
				type: [
					"string",
					"null"
				],
				"default": null
			},
			tags: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			genre: {
				$comment: "genre can be null if attached as a stem",
				type: [
					"string",
					"null"
				],
				"default": null
			},
			mood: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			credits_splits: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			create_date: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			release_date: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			file_type: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			description: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			license: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			isrc: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			iswc: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			track_segments: {
				type: "array",
				minItems: 0,
				items: {
					$ref: "#/definitions/TrackSegment"
				},
				"default": [
				],
				$comment: "default set to empty array to unblock stalling indexing. if set to null, discprov db will reject because of not-NULL constraint"
			},
			is_unlisted: {
				type: "boolean",
				"default": false
			},
			field_visibility: {
				type: "object",
				$ref: "#/definitions/FieldVisibility",
				"default": {
					mood: true,
					tags: true,
					genre: true,
					share: true,
					play_count: true,
					remixes: true
				}
			},
			download: {
				type: [
					"object",
					"null"
				],
				$ref: "#/definitions/Download",
				"default": {
					cid: null,
					is_downloadable: false,
					requires_follow: false
				}
			},
			stem_of: {
				type: [
					"object",
					"null"
				],
				$ref: "#/definitions/StemOf",
				"default": null
			},
			remix_of: {
				type: [
					"object",
					"null"
				],
				$ref: "#/definitions/RemixOf",
				"default": null
			},
			is_premium: {
				type: "boolean",
				"default": false
			},
			premium_conditions: {
				type: [
					"object",
					"null"
				],
				items: {
					oneOf: [
						{
							type: "null"
						},
						{
							$ref: "#/definitions/PremiumConditionsNFTCollection"
						},
						{
							$ref: "#/definitions/PremiumConditionsFollowUserId"
						},
						{
							$ref: "#/definitions/PremiumConditionsTipUserId"
						}
					]
				}
			},
			is_playlist_upload: {
				type: "boolean",
				"default": false
			},
			ai_attribution_user_id: {
				type: [
					"integer",
					"null"
				],
				"default": null
			}
		},
		required: [
			"cover_art",
			"cover_art_sizes",
			"create_date",
			"credits_splits",
			"description",
			"download",
			"field_visibility",
			"file_type",
			"genre",
			"is_unlisted",
			"isrc",
			"iswc",
			"length",
			"license",
			"mood",
			"release_date",
			"remix_of",
			"stem_of",
			"tags",
			"title",
			"track_segments",
			"is_premium",
			"premium_conditions",
			"is_playlist_upload"
		],
		title: "Track"
	},
	RemixOf: {
		type: [
			"object",
			"null"
		],
		additionalProperties: false,
		properties: {
			tracks: {
				type: "array",
				minItems: 1,
				items: {
					$ref: "#/definitions/TrackElement"
				}
			}
		},
		required: [
			"tracks"
		],
		title: "RemixOf"
	},
	TrackElement: {
		type: "object",
		additionalProperties: false,
		properties: {
			parent_track_id: {
				type: "integer"
			}
		},
		required: [
			"parent_track_id"
		],
		title: "TrackElement"
	},
	Download: {
		type: [
			"object",
			"null"
		],
		additionalProperties: false,
		properties: {
			cid: {
				type: [
					"string",
					"null"
				]
			},
			is_downloadable: {
				type: "boolean"
			},
			requires_follow: {
				type: "boolean"
			}
		},
		required: [
			"cid",
			"is_downloadable",
			"requires_follow"
		],
		title: "Download"
	},
	FieldVisibility: {
		type: "object",
		additionalProperties: false,
		properties: {
			mood: {
				type: "boolean"
			},
			tags: {
				type: "boolean"
			},
			genre: {
				type: "boolean"
			},
			share: {
				type: "boolean"
			},
			play_count: {
				type: "boolean"
			},
			remixes: {
				type: "boolean"
			}
		},
		required: [
		],
		$comment: "No required fields for FieldVisibility because it causes backwards compatibility issues. If we added a new property, we don't want old records to fail if all properties are not specified(and overwrite the values with the defaults), but we also don't want to set new properties especially on the discovery provider because then we'd be writing properties not present in the metadata written on chain.",
		title: "FieldVisibility"
	},
	StemOf: {
		type: [
			"object",
			"null"
		],
		additionalProperties: false,
		properties: {
			category: {
				type: "string"
			},
			parent_track_id: {
				type: "integer"
			}
		},
		required: [
			"category",
			"parent_track_id"
		],
		title: "StemOf"
	},
	TrackSegment: {
		type: "object",
		additionalProperties: false,
		properties: {
			duration: {
				type: "number"
			},
			multihash: {
				type: "string",
				$ref: "#/definitions/CID"
			}
		},
		required: [
			"duration",
			"multihash"
		],
		title: "TrackSegment"
	},
	CID: {
		type: [
			"string",
			"null"
		],
		minLength: 46,
		maxLength: 46,
		pattern: "^Qm[a-zA-Z0-9]{44}$",
		title: "CID"
	},
	PremiumConditionsNFTCollection: {
		type: "object",
		additionalProperties: false,
		properties: {
			nft_collection: {
				type: "object",
				items: {
					oneOf: [
						{
							$ref: "#/definitions/PremiumConditionsEthNFTCollection"
						},
						{
							$ref: "#/definitions/PremiumConditionsSolNFTCollection"
						}
					]
				}
			}
		},
		required: [
			"nft_collection"
		],
		title: "PremiumConditionsNFTCollection"
	},
	PremiumConditionsEthNFTCollection: {
		type: "object",
		additionalProperties: false,
		properties: {
			chain: {
				type: "string",
				"const": "eth"
			},
			address: {
				type: "string"
			},
			standard: {
				"enum": [
					"ERC721",
					"ERC1155"
				]
			},
			name: {
				type: "string"
			},
			slug: {
				type: "string"
			},
			imageUrl: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			externalLink: {
				type: [
					"string",
					"null"
				],
				"default": null
			}
		},
		required: [
			"chain",
			"address",
			"standard",
			"name",
			"slug"
		],
		title: "PremiumConditionsEthNFTCollection"
	},
	PremiumConditionsSolNFTCollection: {
		type: "object",
		additionalProperties: false,
		properties: {
			chain: {
				type: "string",
				"const": "sol"
			},
			address: {
				type: "string"
			},
			name: {
				type: "string"
			},
			imageUrl: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			externalLink: {
				type: [
					"string",
					"null"
				],
				"default": null
			}
		},
		required: [
			"chain",
			"address",
			"name"
		],
		title: "PremiumConditionsSolNFTCollection"
	},
	PremiumConditionsFollowUserId: {
		type: "object",
		additionalProperties: false,
		properties: {
			follow_user_id: {
				type: "number"
			}
		},
		required: [
			"follow_user_id"
		],
		title: "PremiumConditionsFollowUserId"
	},
	PremiumConditionsTipUserId: {
		type: "object",
		additionalProperties: false,
		properties: {
			tip_user_id: {
				type: "number"
			}
		},
		required: [
			"tip_user_id"
		],
		title: "PremiumConditionsTipUserId"
	}
};
var TrackSchema = {
	$schema: $schema$2,
	$ref: $ref$2,
	definitions: definitions$2
};

var $schema$1 = "http://json-schema.org/draft-07/schema#";
var $ref$1 = "#/definitions/User";
var definitions$1 = {
	User: {
		type: "object",
		additionalProperties: true,
		properties: {
			name: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			profile_picture: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			profile_picture_sizes: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			cover_photo: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			cover_photo_sizes: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			bio: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			location: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			associated_wallets: {
				$ref: "#/definitions/AssociatedWallets"
			},
			associated_sol_wallets: {
				$ref: "#/definitions/AssociatedSOLWallets"
			},
			collectibles: {
				$ref: "#/definitions/Collectibles"
			},
			playlist_library: {
				$ref: "#/definitions/PlaylistLibrary"
			},
			events: {
				$ref: "#/definitions/Events"
			},
			is_deactivated: {
				type: "boolean",
				"default": false
			},
			artist_pick_track_id: {
				type: [
					"integer",
					"null"
				],
				"default": null
			}
		},
		required: [
			"bio",
			"cover_photo",
			"cover_photo_sizes",
			"location",
			"name",
			"profile_picture",
			"profile_picture_sizes",
			"artist_pick_track_id"
		],
		title: "User"
	},
	CID: {
		type: [
			"string",
			"null"
		],
		minLength: 46,
		maxLength: 46,
		pattern: "^Qm[a-zA-Z0-9]{44}$",
		title: "CID"
	},
	AssociatedWallets: {
		type: [
			"object",
			"null"
		],
		"default": null,
		patternProperties: {
			"^0x[a-fA-F0-9]{40}$": {
				$ref: "#/definitions/WalletMetadata"
			}
		},
		additionalProperties: false,
		properties: {
		},
		required: [
		],
		$comment: "",
		title: "AssociatedWallets"
	},
	AssociatedSOLWallets: {
		type: [
			"object",
			"null"
		],
		"default": null,
		patternProperties: {
			"^[1-9A-HJ-NP-Za-km-z]{32,44}$": {
				$ref: "#/definitions/WalletMetadata"
			}
		},
		additionalProperties: false,
		properties: {
		},
		required: [
		],
		$comment: "",
		title: "AssociatedSOLWallets"
	},
	WalletMetadata: {
		type: [
			"object"
		],
		additionalProperties: true,
		properties: {
			signature: {
				type: "string"
			}
		},
		required: [
			"signature"
		],
		$comment: "",
		title: "WalletMetadata"
	},
	Collectible: {
		type: "object",
		additionalProperties: false
	},
	Collectibles: {
		type: [
			"object",
			"null"
		],
		"default": null,
		additionalProperties: {
			$ref: "#/definitions/Collectible"
		},
		properties: {
			order: {
				type: "array",
				items: {
					type: "string"
				}
			}
		},
		required: [
			"order"
		]
	},
	PlaylistIdentifier: {
		properties: {
			type: {
				type: "string",
				"const": "playlist"
			},
			playlist_id: {
				type: "integer"
			}
		}
	},
	ExplorePlaylistIdentifier: {
		properties: {
			type: {
				type: "string",
				"const": "explore_playlist"
			},
			playlist_id: {
				type: "string",
				pattern: "^[a-zA-Z /-?]+$"
			}
		}
	},
	PlaylistLibraryIdentifier: {
		oneOf: [
			{
				$ref: "#/definitions/PlaylistIdentifier"
			},
			{
				$ref: "#/definitions/ExplorePlaylistIdentifier"
			}
		]
	},
	PlaylistLibraryFolder: {
		properties: {
			type: {
				type: "string",
				"const": "folder"
			},
			id: {
				type: "string"
			},
			name: {
				type: "string"
			},
			contents: {
				type: "array",
				items: {
					oneOf: [
						{
							$ref: "#/definitions/PlaylistLibraryFolder"
						},
						{
							$ref: "#/definitions/PlaylistLibraryIdentifier"
						}
					]
				}
			}
		}
	},
	PlaylistLibrary: {
		type: [
			"object",
			"null"
		],
		"default": null,
		properties: {
			contents: {
				type: "array",
				items: {
					oneOf: [
						{
							$ref: "#/definitions/PlaylistLibraryFolder"
						},
						{
							$ref: "#/definitions/PlaylistLibraryIdentifier"
						}
					]
				}
			}
		}
	},
	Events: {
		type: [
			"object",
			"null"
		],
		"default": null,
		properties: {
			referrer: {
				type: "integer"
			},
			is_mobile_user: {
				type: "boolean"
			}
		}
	}
};
var UserSchema = {
	$schema: $schema$1,
	$ref: $ref$1,
	definitions: definitions$1
};

var $schema = "http://json-schema.org/draft-07/schema#";
var $ref = "#/definitions/Playlist";
var definitions = {
	Playlist: {
		type: "object",
		additionalProperties: true,
		properties: {
			playlist_id: {
				type: [
					"integer",
					"null"
				],
				"default": null
			},
			playlist_contents: {
				type: "object",
				$ref: "#/definitions/PlaylistContents",
				"default": {
					track_ids: [
					]
				}
			},
			playlist_name: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			playlist_image_sizes_multihash: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			description: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			is_album: {
				type: "boolean",
				"default": null
			},
			is_private: {
				type: "boolean",
				"default": null
			},
			is_image_autogenerated: {
				type: "boolean",
				"default": false
			}
		},
		required: [
			"playlist_name",
			"playlist_id",
			"description",
			"is_album",
			"is_private"
		],
		title: "Playlist"
	},
	CID: {
		type: [
			"string",
			"null"
		],
		minLength: 46,
		maxLength: 46,
		pattern: "^Qm[a-zA-Z0-9]{44}$",
		title: "CID"
	},
	PlaylistContents: {
		type: "object",
		additionalProperties: false,
		properties: {
			track_ids: {
				type: "array",
				"default": [
				]
			}
		},
		title: "PlaylistContents"
	}
};
var PlaylistSchema = {
	$schema: $schema,
	$ref: $ref,
	definitions: definitions
};

var trackSchemaType = 'TrackSchema';
var userSchemaType = 'UserSchema';
var playlistSchemaType = 'PlaylistSchema';
var SchemaValidator = /*#__PURE__*/function () {
  function SchemaValidator() {
    _classCallCheck(this, SchemaValidator);

    _defineProperty$1(this, "schemas", void 0);
  }

  _createClass(SchemaValidator, [{
    key: "init",
    value: function init() {
      var _this$schemas,
          _this = this;

      /**
       * Fully formed schemas object looks like the below
       * {
       *   'TrackSchema': {
       *     schema: <schemaJSON>,
       *     baseDefinition: 'String', //name of base definition property in schema
       *     validate: function // returns error if not validated correctly, otherwise null
       *   },
       *   'UserSchema': ...
       * }
       *
       * validate works like this `this.UserSchema.validate(userObj)`
       */
      this.schemas = (_this$schemas = {}, _defineProperty$1(_this$schemas, trackSchemaType, {
        schema: TrackSchema,
        baseDefinition: 'Track'
      }), _defineProperty$1(_this$schemas, userSchemaType, {
        schema: UserSchema,
        baseDefinition: 'User'
      }), _defineProperty$1(_this$schemas, playlistSchemaType, {
        schema: PlaylistSchema,
        baseDefinition: 'Playlist'
      }), _this$schemas);

      var _loop = function _loop(schemaType) {
        var typedSchemaType = schemaType;

        _this.schemas[typedSchemaType].validate = function (obj) {
          var _this$schemas2;

          _this.addMissingFields(obj, typedSchemaType);

          var result = jsonschema.validate(obj, (_this$schemas2 = _this.schemas) === null || _this$schemas2 === void 0 ? void 0 : _this$schemas2[typedSchemaType].schema);
          if (result.errors.length > 0) throw new Error("".concat(schemaType, " validation failed with errors: ").concat(JSON.stringify(result.errors)));
        };
      };

      for (var schemaType in this.schemas) {
        _loop(schemaType);
      }
    }
  }, {
    key: "getSchemas",
    value: function getSchemas() {
      return this.schemas;
    }
  }, {
    key: "addMissingFields",
    value: function addMissingFields(obj, schemaType) {
      if (!this.schemas) {
        return;
      } // schema is the entire imporoted schema, including all the definitions for JSON fields


      var _this$schemas$schemaT = this.schemas[schemaType],
          schema = _this$schemas$schemaT.schema,
          baseDefinition = _this$schemas$schemaT.baseDefinition; // schemaTypeObj is only the subset of the schema with only one definition for main schema type

      var schemaTypeObj = schema.definitions[baseDefinition]; // iterate through every required property, ensuring it exists or setting a default value

      if (schemaTypeObj && 'required' in schemaTypeObj) {
        schemaTypeObj.required.forEach(function (req) {
          if (!Object.prototype.hasOwnProperty.call(obj, req)) {
            if (Object.prototype.hasOwnProperty.call(schemaTypeObj.properties[req], 'default')) {
              var _schemaTypeObj$proper;

              obj[req] = (_schemaTypeObj$proper = schemaTypeObj.properties[req]) === null || _schemaTypeObj$proper === void 0 ? void 0 : _schemaTypeObj$proper["default"];
            } else throw new Error("Could not set default value for missing field ".concat(req));
          }
        });
      }
    }
  }]);

  return SchemaValidator;
}();

var wait = Utils.wait;
var MAX_TRACK_TRANSCODE_TIMEOUT = 3600000; // 1 hour

var MAX_IMAGE_RESIZE_TIMEOUT_MS = 5 * 60000; // 5 minutes

var POLL_STATUS_INTERVAL = 3000; // 3s
// Currently only supports a single logged-in audius user

var CreatorNode = /*#__PURE__*/function () {
  /* Static Utils */

  /* -------------- */

  /**
   * Constructs a service class for a creator node
   */
  function CreatorNode(web3Manager, creatorNodeEndpoint, isServer, userStateManager, schemas) {
    var passList = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var blockList = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    var monitoringCallbacks = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
    var storageNodeSelector = arguments.length > 8 ? arguments[8] : undefined;

    _classCallCheck(this, CreatorNode);

    _defineProperty$1(this, "web3Manager", void 0);

    _defineProperty$1(this, "creatorNodeEndpoint", void 0);

    _defineProperty$1(this, "isServer", void 0);

    _defineProperty$1(this, "userStateManager", void 0);

    _defineProperty$1(this, "schemas", void 0);

    _defineProperty$1(this, "passList", void 0);

    _defineProperty$1(this, "blockList", void 0);

    _defineProperty$1(this, "monitoringCallbacks", void 0);

    _defineProperty$1(this, "maxBlockNumber", void 0);

    _defineProperty$1(this, "storageNodeSelector", void 0);

    this.web3Manager = web3Manager; // This is just 1 endpoint (primary), unlike the creator_node_endpoint field in user metadata

    this.creatorNodeEndpoint = creatorNodeEndpoint;
    this.isServer = isServer;
    this.userStateManager = userStateManager;
    this.schemas = schemas;
    this.maxBlockNumber = 0;
    this.passList = passList;
    this.blockList = blockList;
    this.monitoringCallbacks = monitoringCallbacks;
    this.storageNodeSelector = storageNodeSelector;
  }

  _createClass(CreatorNode, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.web3Manager) {
                  _context.next = 2;
                  break;
                }

                throw new Error('Failed to initialize CreatorNode');

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }() // Throws an error upon validation failure

  }, {
    key: "validatePlaylistSchema",
    value: function validatePlaylistSchema(metadata) {
      var _this$schemas, _this$schemas$playlis, _this$schemas$playlis2;

      (_this$schemas = this.schemas) === null || _this$schemas === void 0 ? void 0 : (_this$schemas$playlis = (_this$schemas$playlis2 = _this$schemas[playlistSchemaType]).validate) === null || _this$schemas$playlis === void 0 ? void 0 : _this$schemas$playlis.call(_this$schemas$playlis2, metadata);
    } // Throws an error upon validation failure

  }, {
    key: "validateUserSchema",
    value: function validateUserSchema(metadata) {
      var _this$schemas2, _this$schemas2$userSc, _this$schemas2$userSc2;

      (_this$schemas2 = this.schemas) === null || _this$schemas2 === void 0 ? void 0 : (_this$schemas2$userSc = (_this$schemas2$userSc2 = _this$schemas2[userSchemaType]).validate) === null || _this$schemas2$userSc === void 0 ? void 0 : _this$schemas2$userSc.call(_this$schemas2$userSc2, metadata);
    } // Throws an error upon validation failure

  }, {
    key: "validateTrackSchema",
    value: function validateTrackSchema(metadata) {
      var _this$schemas3, _this$schemas3$trackS, _this$schemas3$trackS2;

      (_this$schemas3 = this.schemas) === null || _this$schemas3 === void 0 ? void 0 : (_this$schemas3$trackS = (_this$schemas3$trackS2 = _this$schemas3[trackSchemaType]).validate) === null || _this$schemas3$trackS === void 0 ? void 0 : _this$schemas3$trackS.call(_this$schemas3$trackS2, metadata);
    }
  }, {
    key: "getEndpoint",
    value: function getEndpoint() {
      return this.creatorNodeEndpoint;
    }
    /**
     * Switch from one creatorNodeEndpoint to another
     */

  }, {
    key: "setEndpoint",
    value: function () {
      var _setEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(creatorNodeEndpoint) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.creatorNodeEndpoint = creatorNodeEndpoint;

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setEndpoint(_x) {
        return _setEndpoint.apply(this, arguments);
      }

      return setEndpoint;
    }()
  }, {
    key: "transcodeTrackPreview",
    value: function () {
      var _transcodeTrackPreview = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(metadata) {
        var _this = this;

        var updatedMetadata, data, resp, previewKey;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (metadata.preview_start_seconds) {
                  _context4.next = 2;
                  break;
                }

                throw new Error('No track preview start time specified');

              case 2:
                if (metadata.audio_upload_id) {
                  _context4.next = 4;
                  break;
                }

                throw new Error('Missing required audio_upload_id');

              case 4:
                updatedMetadata = _objectSpread2({}, metadata);
                data = {
                  previewStartSeconds: metadata.preview_start_seconds.toString()
                };
                _context4.next = 8;
                return this._retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                  return regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 2;
                          return _this.editFileV2(metadata.audio_upload_id, data);

                        case 2:
                          return _context3.abrupt("return", _context3.sent);

                        case 3:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                })), function (e) {
                  console.log('Retrying editFileV2', e);
                });

              case 8:
                resp = _context4.sent;
                // Update metadata with new track preview cid
                previewKey = "320_preview|".concat(updatedMetadata.preview_start_seconds);
                updatedMetadata.preview_cid = resp.results[previewKey];
                return _context4.abrupt("return", updatedMetadata);

              case 12:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function transcodeTrackPreview(_x2) {
        return _transcodeTrackPreview.apply(this, arguments);
      }

      return transcodeTrackPreview;
    }()
  }, {
    key: "uploadTrackAudioAndCoverArtV2",
    value: function () {
      var _uploadTrackAudioAndCoverArtV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(trackFile, coverArtFile, metadata) {
        var _this2 = this,
            _updatedMetadata$down;

        var onProgress,
            updatedMetadata,
            audioUploadOpts,
            promises,
            _yield$Promise$all,
            _yield$Promise$all2,
            audioResp,
            coverArtResp,
            previewKey,
            _args7 = arguments;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                onProgress = _args7.length > 3 && _args7[3] !== undefined ? _args7[3] : function () {};
                updatedMetadata = _objectSpread2({}, metadata);
                audioUploadOpts = {};

                if (updatedMetadata.preview_start_seconds) {
                  audioUploadOpts['previewStartSeconds'] = updatedMetadata.preview_start_seconds.toString();
                } // Upload audio and cover art


                promises = [this._retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
                  return regeneratorRuntime.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return _this2.uploadTrackAudioV2(trackFile, onProgress, audioUploadOpts);

                        case 2:
                          return _context5.abrupt("return", _context5.sent);

                        case 3:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                })), function (e) {
                  console.log('Retrying uploadTrackAudioV2', e);
                })];

                if (coverArtFile) {
                  promises.push(this._retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
                    return regeneratorRuntime.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.next = 2;
                            return _this2.uploadTrackCoverArtV2(coverArtFile, onProgress);

                          case 2:
                            return _context6.abrupt("return", _context6.sent);

                          case 3:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6);
                  })), function (e) {
                    console.log('Retrying uploadTrackCoverArtV2', e);
                  }));
                }

                _context7.next = 8;
                return Promise.all(promises);

              case 8:
                _yield$Promise$all = _context7.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                audioResp = _yield$Promise$all2[0];
                coverArtResp = _yield$Promise$all2[1];
                // Update metadata to include uploaded CIDs
                updatedMetadata.track_segments = [];
                updatedMetadata.duration = parseInt(audioResp.probe.format.duration, 10);
                updatedMetadata.track_cid = audioResp.results['320'];

                if (updatedMetadata.preview_start_seconds) {
                  previewKey = "320_preview|".concat(updatedMetadata.preview_start_seconds);
                  updatedMetadata.preview_cid = audioResp.results[previewKey];
                }

                updatedMetadata.audio_upload_id = audioResp.id;

                if ((_updatedMetadata$down = updatedMetadata.download) !== null && _updatedMetadata$down !== void 0 && _updatedMetadata$down.is_downloadable) {
                  updatedMetadata.download.cid = updatedMetadata.track_cid;
                }

                if (coverArtResp) updatedMetadata.cover_art_sizes = coverArtResp.id;
                return _context7.abrupt("return", updatedMetadata);

              case 20:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function uploadTrackAudioAndCoverArtV2(_x3, _x4, _x5) {
        return _uploadTrackAudioAndCoverArtV.apply(this, arguments);
      }

      return uploadTrackAudioAndCoverArtV2;
    }()
  }, {
    key: "uploadTrackAudioV2",
    value: function () {
      var _uploadTrackAudioV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(file) {
        var onProgress,
            options,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                onProgress = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : function () {};
                options = _args8.length > 2 ? _args8[2] : undefined;
                _context8.next = 4;
                return this.uploadFileV2(file, onProgress, 'audio', options);

              case 4:
                return _context8.abrupt("return", _context8.sent);

              case 5:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function uploadTrackAudioV2(_x6) {
        return _uploadTrackAudioV.apply(this, arguments);
      }

      return uploadTrackAudioV2;
    }()
  }, {
    key: "uploadTrackCoverArtV2",
    value: function () {
      var _uploadTrackCoverArtV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(file) {
        var onProgress,
            _args9 = arguments;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                onProgress = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : function () {};
                _context9.next = 3;
                return this.uploadFileV2(file, onProgress, 'img_square');

              case 3:
                return _context9.abrupt("return", _context9.sent);

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function uploadTrackCoverArtV2(_x7) {
        return _uploadTrackCoverArtV.apply(this, arguments);
      }

      return uploadTrackCoverArtV2;
    }()
  }, {
    key: "uploadProfilePictureV2",
    value: function () {
      var _uploadProfilePictureV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(file) {
        var onProgress,
            _args10 = arguments;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                onProgress = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : function () {};
                _context10.next = 3;
                return this.uploadFileV2(file, onProgress, 'img_square');

              case 3:
                return _context10.abrupt("return", _context10.sent);

              case 4:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function uploadProfilePictureV2(_x8) {
        return _uploadProfilePictureV.apply(this, arguments);
      }

      return uploadProfilePictureV2;
    }()
  }, {
    key: "uploadCoverPhotoV2",
    value: function () {
      var _uploadCoverPhotoV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(file) {
        var onProgress,
            _args11 = arguments;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                onProgress = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : function () {};
                _context11.next = 3;
                return this.uploadFileV2(file, onProgress, 'img_backdrop');

              case 3:
                return _context11.abrupt("return", _context11.sent);

              case 4:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function uploadCoverPhotoV2(_x9) {
        return _uploadCoverPhotoV.apply(this, arguments);
      }

      return uploadCoverPhotoV2;
    }()
  }, {
    key: "editFileV2",
    value: function () {
      var _editFileV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(uploadId, data) {
        var _this$web3Manager;

        var myPrivateKey, signatureData, signature, signatureEnvelope, headers, response;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                myPrivateKey = (_this$web3Manager = this.web3Manager) === null || _this$web3Manager === void 0 ? void 0 : _this$web3Manager.getOwnerWalletPrivateKey();

                if (myPrivateKey) {
                  _context12.next = 3;
                  break;
                }

                throw new Error('Missing user private key');

              case 3:
                // Generate signature
                signatureData = {
                  upload_id: uploadId,
                  timestamp: Date.now()
                };
                _context12.next = 6;
                return hashAndSign(JSON.stringify(sortObjectKeys$1(signatureData)), '0x' + myPrivateKey.toString('hex'));

              case 6:
                signature = _context12.sent;
                signatureEnvelope = {
                  data: JSON.stringify(signatureData),
                  signature: signature
                };
                headers = {
                  'X-Request-ID': uuid()
                };
                _context12.next = 11;
                return this._makeRequestV2({
                  method: 'post',
                  url: "/uploads/".concat(uploadId),
                  data: data,
                  params: {
                    signature: JSON.stringify(signatureEnvelope)
                  },
                  headers: headers
                });

              case 11:
                response = _context12.sent;
                _context12.next = 14;
                return this.pollProcessingStatusV2(uploadId, response.data.template === 'audio' ? MAX_TRACK_TRANSCODE_TIMEOUT : MAX_IMAGE_RESIZE_TIMEOUT_MS);

              case 14:
                return _context12.abrupt("return", _context12.sent);

              case 15:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function editFileV2(_x10, _x11) {
        return _editFileV.apply(this, arguments);
      }

      return editFileV2;
    }()
  }, {
    key: "uploadFileV2",
    value: function () {
      var _uploadFileV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(file, onProgress, template, options) {
        var _this$createFormDataA, headers, formData, response;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _this$createFormDataA = this.createFormDataAndUploadHeadersV2(file, _objectSpread2({
                  template: template
                }, options)), headers = _this$createFormDataA.headers, formData = _this$createFormDataA.formData;
                _context13.next = 3;
                return this._makeRequestV2({
                  method: 'post',
                  url: '/uploads',
                  data: formData,
                  headers: headers,
                  onUploadProgress: function onUploadProgress(progressEvent) {
                    return onProgress(progressEvent.loaded, progressEvent.total);
                  }
                });

              case 3:
                response = _context13.sent;
                _context13.next = 6;
                return this.pollProcessingStatusV2(response.data[0].id, template === 'audio' ? MAX_TRACK_TRANSCODE_TIMEOUT : MAX_IMAGE_RESIZE_TIMEOUT_MS);

              case 6:
                return _context13.abrupt("return", _context13.sent);

              case 7:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function uploadFileV2(_x12, _x13, _x14, _x15) {
        return _uploadFileV.apply(this, arguments);
      }

      return uploadFileV2;
    }()
    /**
     * Works for both track transcode and image resize jobs
     * @param id ID of the transcode/resize job
     * @param maxPollingMs millis to stop polling and error if job is not done
     * @returns successful job info, or throws error if job fails / times out
     */

  }, {
    key: "pollProcessingStatusV2",
    value: function () {
      var _pollProcessingStatusV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(id, maxPollingMs) {
        var start, resp, _e$message, _e$response;

        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                start = Date.now();

              case 1:
                if (!(Date.now() - start < maxPollingMs)) {
                  _context14.next = 21;
                  break;
                }

                _context14.prev = 2;
                _context14.next = 5;
                return this.getProcessingStatusV2(id);

              case 5:
                resp = _context14.sent;

                if (!((resp === null || resp === void 0 ? void 0 : resp.status) === 'done')) {
                  _context14.next = 8;
                  break;
                }

                return _context14.abrupt("return", resp);

              case 8:
                if (!((resp === null || resp === void 0 ? void 0 : resp.status) === 'error' || (resp === null || resp === void 0 ? void 0 : resp.status) === 'error_retranscode_preview')) {
                  _context14.next = 10;
                  break;
                }

                throw new Error("Upload failed: id=".concat(id, ", resp=").concat(JSON.stringify(resp)));

              case 10:
                _context14.next = 17;
                break;

              case 12:
                _context14.prev = 12;
                _context14.t0 = _context14["catch"](2);

                if (!((_e$message = _context14.t0.message) !== null && _e$message !== void 0 && _e$message.startsWith('Upload failed') || _context14.t0.response && ((_e$response = _context14.t0.response) === null || _e$response === void 0 ? void 0 : _e$response.status) === 422)) {
                  _context14.next = 16;
                  break;
                }

                throw _context14.t0;

              case 16:
                // Swallow errors caused by failure to establish connection to node so we can retry polling
                console.error("Failed to poll for processing status, ".concat(_context14.t0));

              case 17:
                _context14.next = 19;
                return wait(POLL_STATUS_INTERVAL);

              case 19:
                _context14.next = 1;
                break;

              case 21:
                throw new Error("Upload took over ".concat(maxPollingMs, "ms. id=").concat(id));

              case 22:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[2, 12]]);
      }));

      function pollProcessingStatusV2(_x16, _x17) {
        return _pollProcessingStatusV.apply(this, arguments);
      }

      return pollProcessingStatusV2;
    }()
    /**
     * Gets the task progress given the task type and id associated with the job
     * @param id the id of the transcoding or resizing job
     * @returns the status, and the success or failed response if the job is complete
     */

  }, {
    key: "getProcessingStatusV2",
    value: function () {
      var _getProcessingStatusV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(id) {
        var _yield$this$_makeRequ, data;

        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this._makeRequestV2({
                  method: 'get',
                  url: "/uploads/".concat(id)
                });

              case 2:
                _yield$this$_makeRequ = _context15.sent;
                data = _yield$this$_makeRequ.data;
                return _context15.abrupt("return", data);

              case 5:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getProcessingStatusV2(_x18) {
        return _getProcessingStatusV.apply(this, arguments);
      }

      return getProcessingStatusV2;
    }()
    /* ------- INTERNAL FUNCTIONS ------- */

    /**
     * Makes an axios request to this.creatorNodeEndpoint
     * @return response body
     */

  }, {
    key: "_makeRequestV2",
    value: function () {
      var _makeRequestV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(axiosRequestObj) {
        var _this$userStateManage, wallet, storageNodes, _iterator, _step, storageNode, requestId, msg;

        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                // TODO: This might want to have other error handling, request UUIDs, etc...
                //       But I didn't want to pull in all the chaos and incompatiblity of the old _makeRequest
                axiosRequestObj.baseURL = this.creatorNodeEndpoint;
                _context16.prev = 1;
                _context16.next = 4;
                return axios__default["default"](axiosRequestObj);

              case 4:
                return _context16.abrupt("return", _context16.sent);

              case 7:
                _context16.prev = 7;
                _context16.t0 = _context16["catch"](1);
                wallet = (_this$userStateManage = this.userStateManager.getCurrentUser()) === null || _this$userStateManage === void 0 ? void 0 : _this$userStateManage.wallet;
                storageNodes = this.storageNodeSelector.getNodes(wallet !== null && wallet !== void 0 ? wallet : '');
                _iterator = _createForOfIteratorHelper(storageNodes);
                _context16.prev = 12;

                _iterator.s();

              case 14:
                if ((_step = _iterator.n()).done) {
                  _context16.next = 27;
                  break;
                }

                storageNode = _step.value;
                _context16.prev = 16;
                axiosRequestObj.baseURL = storageNode;
                _context16.next = 20;
                return axios__default["default"](axiosRequestObj);

              case 20:
                return _context16.abrupt("return", _context16.sent);

              case 23:
                _context16.prev = 23;
                _context16.t1 = _context16["catch"](16);

              case 25:
                _context16.next = 14;
                break;

              case 27:
                _context16.next = 32;
                break;

              case 29:
                _context16.prev = 29;
                _context16.t2 = _context16["catch"](12);

                _iterator.e(_context16.t2);

              case 32:
                _context16.prev = 32;

                _iterator.f();

                return _context16.finish(32);

              case 35:
                requestId = axiosRequestObj.headers['X-Request-ID'];
                msg = "Error sending storagev2 request for X-Request-ID=".concat(requestId, ", tried all storage nodes: ").concat(_context16.t0);
                console.error(msg);
                throw new Error(msg);

              case 39:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this, [[1, 7], [12, 29, 32, 35], [16, 23]]);
      }));

      function _makeRequestV2(_x19) {
        return _makeRequestV.apply(this, arguments);
      }

      return _makeRequestV2;
    }()
    /**
     * Create headers and formData for file upload
     * @param file the file to upload
     * @returns headers and formData in an object
     */

  }, {
    key: "createFormDataAndUploadHeadersV2",
    value: function createFormDataAndUploadHeadersV2(file) {
      var extraFormDataOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // form data is from browser, not imported npm module
      var formData = new FormData__default["default"]();
      formData.append('files', file, file.name);
      Object.keys(extraFormDataOptions).forEach(function (key) {
        formData.append(key, "".concat(extraFormDataOptions[key]));
      });
      var headers = {};

      if (this.isServer) {
        headers = formData.getHeaders();
      }

      var requestId = uuid();
      headers['X-Request-ID'] = requestId;
      var user = this.userStateManager.getCurrentUser();

      if (user !== null && user !== void 0 && user.wallet && user.user_id) {
        headers['X-User-Wallet-Addr'] = user.wallet;
        headers['X-User-Id'] = user.user_id;
      }

      return {
        headers: headers,
        formData: formData
      };
    }
    /**
     * Calls fn and then retries once after 500ms, again after 1500ms, and again after 4000ms
     */

  }, {
    key: "_retry3",
    value: function () {
      var _retry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(fn) {
        var onRetry,
            _args17 = arguments;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                onRetry = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : function (_err) {};
                _context17.next = 3;
                return retry__default["default"](fn, {
                  minTimeout: 500,
                  maxTimeout: 4000,
                  factor: 3,
                  retries: 3,
                  onRetry: onRetry
                });

              case 3:
                return _context17.abrupt("return", _context17.sent);

              case 4:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17);
      }));

      function _retry3(_x20) {
        return _retry.apply(this, arguments);
      }

      return _retry3;
    }()
  }]);

  return CreatorNode;
}();

var DISCOVERY_PROVIDER_TIMESTAMP = '@audius/libs:discovery-node-timestamp';
var DISCOVERY_SERVICE_NAME = 'discovery-node';
var DEFAULT_UNHEALTHY_BLOCK_DIFF = 15;
var REGRESSED_MODE_TIMEOUT = 2 * 60 * 1000; // two minutes
// When to time out the cached discovery provider

var DISCOVERY_PROVIDER_RESELECT_TIMEOUT = 10
/* min */
* 60
/* seconds */
* 1000;
var REQUEST_TIMEOUT_MS = 30
/* seconds */
* 1000;
/* millisec */

/* eslint-disable @typescript-eslint/restrict-plus-operands */
var getUsers = function getUsers() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var idsArray = arguments.length > 2 ? arguments[2] : undefined;
  var walletAddress = arguments.length > 3 ? arguments[3] : undefined;
  var handle = arguments.length > 4 ? arguments[4] : undefined;
  var minBlockNumber = arguments.length > 5 ? arguments[5] : undefined;
  var includeIncomplete = arguments.length > 6 ? arguments[6] : undefined;
  var queryParams = {
    limit: limit,
    offset: offset
  };

  if (handle) {
    queryParams.handle = handle;
  }

  if (walletAddress) {
    queryParams.wallet = walletAddress;
  }

  if (minBlockNumber) {
    queryParams.min_block_number = minBlockNumber;
  }

  if (idsArray != null) {
    if (!Array.isArray(idsArray)) {
      throw new Error('Expected integer array of user ids');
    }

    queryParams.id = idsArray;
  }

  if (includeIncomplete != null) {
    queryParams.include_incomplete = includeIncomplete;
  }

  var req = {
    endpoint: 'users',
    queryParams: queryParams
  };
  return req;
};
var getTracks = function getTracks() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var idsArray = arguments.length > 2 ? arguments[2] : undefined;
  var targetUserId = arguments.length > 3 ? arguments[3] : undefined;
  var sort = arguments.length > 4 ? arguments[4] : undefined;
  var minBlockNumber = arguments.length > 5 ? arguments[5] : undefined;
  var filterDeleted = arguments.length > 6 ? arguments[6] : undefined;
  var withUsers = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var queryParams = {
    limit: limit,
    offset: offset
  };

  if (idsArray) {
    if (!Array.isArray(idsArray)) {
      throw new Error('Expected array of track ids');
    }

    queryParams.id = idsArray;
  }

  if (minBlockNumber) {
    queryParams.min_block_number = minBlockNumber;
  }

  if (targetUserId) {
    queryParams.user_id = targetUserId;
  }

  if (sort) {
    queryParams.sort = sort;
  }

  if (typeof filterDeleted === 'boolean') {
    queryParams.filter_deleted = filterDeleted;
  }

  if (withUsers) {
    queryParams.with_users = true;
  }

  var req = {
    endpoint: 'tracks',
    queryParams: queryParams
  };
  return req;
};
var getTracksByHandleAndSlug = function getTracksByHandleAndSlug(handle, slug) {
  return {
    endpoint: 'v1/tracks',
    method: 'get',
    queryParams: {
      handle: handle,
      slug: slug
    }
  };
};
var getTracksIncludingUnlisted = function getTracksIncludingUnlisted(identifiers) {
  var withUsers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var queryParams = {};

  if (withUsers) {
    queryParams.with_users = true;
  }

  var req = {
    endpoint: 'tracks_including_unlisted',
    method: 'post',
    data: {
      tracks: identifiers
    },
    queryParams: queryParams
  };
  return req;
};
var getRandomTracks = function getRandomTracks(genre, limit, exclusionList, time) {
  var req = {
    endpoint: 'tracks/random',
    queryParams: {
      genre: genre,
      limit: limit,
      exclusionList: exclusionList,
      time: time
    }
  };
  return req;
};
var getStemsForTrack = function getStemsForTrack(trackId) {
  var req = {
    endpoint: "stems/".concat(trackId),
    queryParams: {
      with_users: true
    }
  };
  return req;
};
var getRemixesOfTrack = function getRemixesOfTrack(trackId) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var req = {
    endpoint: "remixes/".concat(trackId, "/children"),
    queryParams: {
      with_users: true,
      limit: limit,
      offset: offset
    }
  };
  return req;
};
var getRemixTrackParents = function getRemixTrackParents(trackId) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var req = {
    endpoint: "remixes/".concat(trackId, "/parents"),
    queryParams: {
      with_users: true,
      limit: limit,
      offset: offset
    }
  };
  return req;
};
var getTrendingTracks = function getTrendingTracks() {
  var genre = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var timeFrame = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var idsArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var withUsers = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var endpoint = '/trending/';

  if (timeFrame != null) {
    switch (timeFrame) {
      case 'day':
      case 'week':
      case 'month':
      case 'year':
        break;

      default:
        throw new Error('Invalid timeFrame value provided');
    }

    endpoint += "".concat(endpoint).concat(timeFrame);
  }

  var req = {
    endpoint: endpoint,
    method: 'get',
    queryParams: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, idsArray !== null ? {
      id: idsArray
    } : {}), limit !== null ? {
      limit: limit
    } : {}), offset !== null ? {
      offset: offset
    } : {}), genre !== null ? {
      genre: genre
    } : {}), withUsers ? {
      with_users: withUsers
    } : {})
  };
  return req;
};
var getPlaylists = function getPlaylists() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var idsArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var targetUserId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var withUsers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  if (idsArray != null) {
    if (!Array.isArray(idsArray)) {
      throw new Error('Expected integer array of user ids');
    }
  }

  return {
    endpoint: 'playlists',
    queryParams: _objectSpread2(_objectSpread2(_objectSpread2({
      limit: limit,
      offset: offset
    }, idsArray != null ? {
      playlist_id: idsArray
    } : {}), targetUserId ? {
      user_id: targetUserId
    } : {}), withUsers ? {
      with_users: true
    } : {})
  };
};
var getFullPlaylist = function getFullPlaylist(encodedPlaylistId, encodedUserId) {
  return {
    endpoint: 'v1/full/playlists',
    urlParams: '/' + encodedPlaylistId,
    queryParams: {
      user_id: encodedUserId
    }
  };
};
var getSocialFeed = function getSocialFeed(filter) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var withUsers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var tracksOnly = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  return {
    endpoint: 'feed',
    queryParams: {
      filter: filter,
      limit: limit,
      offset: offset,
      with_users: withUsers,
      tracks_only: tracksOnly
    }
  };
};
var getUserRepostFeed = function getUserRepostFeed(userId) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var withUsers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return {
    endpoint: 'feed',
    urlParams: '/reposts/' + userId,
    queryParams: {
      limit: limit,
      offset: offset,
      with_users: withUsers
    }
  };
};
var getFollowIntersectionUsers = function getFollowIntersectionUsers() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var followeeUserId = arguments.length > 2 ? arguments[2] : undefined;
  var followerUserId = arguments.length > 3 ? arguments[3] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/intersection/follow/' + followeeUserId + '/' + followerUserId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getTrackRepostIntersectionUsers = function getTrackRepostIntersectionUsers() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var repostTrackId = arguments.length > 2 ? arguments[2] : undefined;
  var followerUserId = arguments.length > 3 ? arguments[3] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/intersection/repost/track/' + repostTrackId + '/' + followerUserId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getPlaylistRepostIntersectionUsers = function getPlaylistRepostIntersectionUsers() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var repostPlaylistId = arguments.length > 2 ? arguments[2] : undefined;
  var followerUserId = arguments.length > 3 ? arguments[3] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/intersection/repost/playlist/' + repostPlaylistId + '/' + followerUserId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getFollowersForUser = function getFollowersForUser() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var followeeUserId = arguments.length > 2 ? arguments[2] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/followers/' + followeeUserId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getFolloweesForUser = function getFolloweesForUser() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var followerUserId = arguments.length > 2 ? arguments[2] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/followees/' + followerUserId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getRepostersForTrack = function getRepostersForTrack() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var repostTrackId = arguments.length > 2 ? arguments[2] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/reposts/track/' + repostTrackId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getRepostersForPlaylist = function getRepostersForPlaylist() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var repostPlaylistId = arguments.length > 2 ? arguments[2] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/reposts/playlist/' + repostPlaylistId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getSaversForTrack = function getSaversForTrack() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var saveTrackId = arguments.length > 2 ? arguments[2] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/saves/track/' + saveTrackId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getSaversForPlaylist = function getSaversForPlaylist() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var savePlaylistId = arguments.length > 2 ? arguments[2] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/saves/playlist/' + savePlaylistId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var searchFull = function searchFull(text, kind) {
  var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  return {
    endpoint: 'search/full',
    queryParams: {
      query: text,
      kind: kind,
      limit: limit,
      offset: offset
    }
  };
};
var searchAutocomplete = function searchAutocomplete(text) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return {
    endpoint: 'search/autocomplete',
    queryParams: {
      query: text,
      limit: limit,
      offset: offset
    }
  };
};
var searchTags = function searchTags(text) {
  var userTagCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'all';
  var limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;
  var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  return {
    endpoint: 'search/tags',
    queryParams: {
      query: text,
      user_tag_count: userTagCount,
      kind: kind,
      limit: limit,
      offset: offset
    }
  };
};
var getSavedPlaylists = function getSavedPlaylists() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var withUsers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    endpoint: 'saves/playlists',
    queryParams: {
      limit: limit,
      offset: offset,
      with_users: withUsers
    }
  };
};
var getSavedAlbums = function getSavedAlbums() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var withUsers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    endpoint: 'saves/albums',
    queryParams: {
      limit: limit,
      offset: offset,
      with_users: withUsers
    }
  };
};
var getSavedTracks = function getSavedTracks() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var withUsers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    endpoint: 'saves/tracks',
    queryParams: {
      limit: limit,
      offset: offset,
      with_users: withUsers
    }
  };
};
/**
 * Return user collections (saved & uploaded) along w/ users for those collections
 */

var getUserAccount = function getUserAccount(wallet) {
  if (wallet === undefined) {
    throw new Error('Expected wallet to get user account');
  }

  return {
    endpoint: 'users/account',
    queryParams: {
      wallet: wallet
    }
  };
};
/**
 * @deprecated Migrate to using getTopFullPlaylists
 */

var getTopPlaylists = function getTopPlaylists(type, limit, mood, filter) {
  var withUsers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  return {
    endpoint: "/top/".concat(type),
    queryParams: {
      limit: limit,
      mood: mood,
      filter: filter,
      with_users: withUsers
    }
  };
};
var getTopFullPlaylists = function getTopFullPlaylists(_ref) {
  var type = _ref.type,
      limit = _ref.limit,
      mood = _ref.mood,
      filter = _ref.filter,
      encodedUserId = _ref.encodedUserId,
      _ref$withUsers = _ref.withUsers,
      withUsers = _ref$withUsers === void 0 ? false : _ref$withUsers;
  return {
    endpoint: "/v1/full/playlists/top",
    queryParams: {
      type: type,
      limit: limit,
      mood: mood,
      filter: filter,
      with_users: withUsers,
      user_id: encodedUserId
    }
  };
};
/**
 * @deprecated Migrate to using getBestNewReleases
 */

var getTopFolloweeWindowed = function getTopFolloweeWindowed(type, window, limit) {
  var withUsers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return {
    endpoint: "/top_followee_windowed/".concat(type, "/").concat(window),
    queryParams: {
      limit: limit,
      with_users: withUsers
    }
  };
};
var getBestNewReleases = function getBestNewReleases(window, limit, encodedUserId) {
  var withUsers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return {
    endpoint: "/v1/full/tracks/best_new_releases",
    queryParams: {
      window: window,
      limit: limit,
      user_id: encodedUserId,
      with_users: withUsers
    }
  };
};
var getMostLovedTracks = function getMostLovedTracks(encodedUserId, limit) {
  var withUsers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    endpoint: "/v1/full/tracks/most_loved",
    queryParams: {
      limit: limit,
      user_id: encodedUserId,
      with_users: withUsers
    }
  };
};
var getFeelingLuckyTracks = function getFeelingLuckyTracks(encodedUserId, limit) {
  var withUsers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    endpoint: "/v1/full/tracks/feeling_lucky",
    queryParams: {
      limit: limit,
      user_id: encodedUserId,
      with_users: withUsers
    }
  };
};
var getTopFolloweeSaves = function getTopFolloweeSaves(type, limit) {
  var withUsers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    endpoint: "/top_followee_saves/".concat(type),
    queryParams: {
      limit: limit,
      with_users: withUsers
    }
  };
};
var getLatest = function getLatest(type) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return {
    endpoint: "/latest/".concat(type),
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getTopCreatorsByGenres = function getTopCreatorsByGenres(genres) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var withUsers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return {
    endpoint: 'users/genre/top',
    queryParams: {
      genre: genres,
      limit: limit,
      offset: offset,
      with_users: withUsers
    }
  };
};
var getURSMContentNodes = function getURSMContentNodes(ownerWallet) {
  return {
    endpoint: 'ursm_content_nodes',
    queryParams: {
      owner_wallet: ownerWallet
    }
  };
};
var getNotifications = function getNotifications(minBlockNumber, trackIds, timeout) {
  return {
    endpoint: 'notifications',
    queryParams: {
      min_block_number: minBlockNumber,
      track_id: trackIds
    },
    timeout: timeout
  };
};
var getUserNotifications = function getUserNotifications(_ref2) {
  var encodedUserId = _ref2.encodedUserId,
      timestamp = _ref2.timestamp,
      groupId = _ref2.groupId,
      limit = _ref2.limit,
      validTypes = _ref2.validTypes;
  return {
    endpoint: "v1/full/notifications/".concat(encodedUserId),
    queryParams: {
      timestamp: timestamp,
      group_id: groupId,
      limit: limit,
      valid_types: validTypes
    }
  };
};
var getUserSubscribers = function getUserSubscribers(encodedUserId, timeout) {
  return {
    endpoint: "v1/full/users/".concat(encodedUserId, "/subscribers"),
    method: 'get',
    timeout: timeout
  };
};
var bulkGetUserSubscribers = function bulkGetUserSubscribers(encodedUserIds, timeout) {
  return {
    endpoint: 'v1/full/users/subscribers',
    method: 'post',
    headers: {
      'Content-Type': 'application/json'
    },
    data: {
      ids: encodedUserIds
    },
    timeout: timeout
  };
};
var getCIDData = function getCIDData(cid) {
  var responseType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'json';
  var timeout = arguments.length > 2 ? arguments[2] : undefined;
  return {
    endpoint: "v1/full/cid_data/".concat(cid),
    method: 'get',
    responseType: responseType,
    timeout: timeout
  };
};
var getSolanaNotifications = function getSolanaNotifications(minSlotNumber, timeout) {
  return {
    endpoint: 'solana_notifications',
    queryParams: {
      min_slot_number: minSlotNumber
    },
    timeout: timeout
  };
};
var getTrackListenMilestones = function getTrackListenMilestones(timeout) {
  return {
    endpoint: 'track_listen_milestones',
    timeout: timeout
  };
};
var getChallengeAttestation = function getChallengeAttestation(challengeId, encodedUserId, specifier, oracleAddress) {
  return {
    endpoint: "/v1/challenges/".concat(challengeId, "/attest"),
    queryParams: {
      user_id: encodedUserId,
      specifier: specifier,
      oracle: oracleAddress
    }
  };
};
var getCreateSenderAttestation = function getCreateSenderAttestation(senderEthAddress) {
  return {
    endpoint: '/v1/challenges/attest_sender',
    queryParams: {
      sender_eth_address: senderEthAddress
    }
  };
};
var getUndisbursedChallenges = function getUndisbursedChallenges(limit, offset, completedBlockNumber, encodedUserId) {
  return {
    endpoint: '/v1/challenges/undisbursed',
    queryParams: {
      limit: limit,
      offset: offset,
      completed_blocknumber: completedBlockNumber,
      user_id: encodedUserId
    }
  };
};
var verifyToken = function verifyToken(token) {
  return {
    endpoint: '/v1/users/verify_token',
    queryParams: {
      token: token
    }
  };
};
var getUserReplicaSet = function getUserReplicaSet(encodedUserId) {
  return {
    endpoint: "/v1/full/users/".concat(encodedUserId, "/replica_set"),
    timeout: 5000
  };
};
var getUnclaimedId = function getUnclaimedId(type) {
  return {
    endpoint: "/v1/".concat(type, "/unclaimed_id"),
    timeout: 5000,
    queryParams: {
      noCache: Math.floor(Math.random() * 1000).toString()
    }
  };
};
var getUserListenCountsMonthly = function getUserListenCountsMonthly(encodedUserId, startTime, endTime) {
  return {
    endpoint: "/v1/users/".concat(encodedUserId, "/listen_counts_monthly"),
    timeout: 10000,
    queryParams: {
      start_time: startTime,
      end_time: endTime
    }
  };
};

var PREVIOUS_VERSIONS_TO_CHECK = 5;
var DiscoveryProviderSelection = /*#__PURE__*/function (_ServiceSelection) {
  _inherits(DiscoveryProviderSelection, _ServiceSelection);

  var _super = _createSuper(DiscoveryProviderSelection);

  function DiscoveryProviderSelection(config, ethContracts) {
    var _config$monitoringCal, _config$unhealthySlot, _config$unhealthyBloc;

    var _this;

    _classCallCheck(this, DiscoveryProviderSelection);

    _this = _super.call(this, _objectSpread2({
      /**
       * Gets the "current" expected service version as well as
       * the list of registered providers from chain
       */
      getServices: function () {
        var _getServices = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var _ref,
              _ref$verbose,
              verbose,
              services,
              _args = arguments;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _ref = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, _ref$verbose = _ref.verbose, verbose = _ref$verbose === void 0 ? false : _ref$verbose;
                  _context.next = 3;
                  return ethContracts.getCurrentVersion(DISCOVERY_SERVICE_NAME);

                case 3:
                  _this.currentVersion = _context.sent;
                  _context.next = 6;
                  return _this.ethContracts.getServiceProviderList(DISCOVERY_SERVICE_NAME);

                case 6:
                  services = _context.sent;
                  return _context.abrupt("return", verbose ? services : services.map(function (e) {
                    return e.endpoint;
                  }));

                case 8:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function getServices() {
          return _getServices.apply(this, arguments);
        }

        return getServices;
      }()
    }, config));

    _defineProperty$1(_assertThisInitialized(_this), "currentVersion", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "ethContracts", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "reselectTimeout", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "selectionCallback", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "monitoringCallbacks", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "unhealthySlotDiffPlays", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "unhealthyBlockDiff", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "_regressedMode", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "validVersions", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "localStorage", void 0);

    _this.ethContracts = ethContracts;
    _this.currentVersion = '';
    _this.reselectTimeout = config.reselectTimeout;
    _this.selectionCallback = config.selectionCallback;
    _this.monitoringCallbacks = (_config$monitoringCal = config.monitoringCallbacks) !== null && _config$monitoringCal !== void 0 ? _config$monitoringCal : {};
    _this.unhealthySlotDiffPlays = (_config$unhealthySlot = config.unhealthySlotDiffPlays) !== null && _config$unhealthySlot !== void 0 ? _config$unhealthySlot : null;
    _this.unhealthyBlockDiff = (_config$unhealthyBloc = config.unhealthyBlockDiff) !== null && _config$unhealthyBloc !== void 0 ? _config$unhealthyBloc : DEFAULT_UNHEALTHY_BLOCK_DIFF;
    _this.localStorage = config.localStorage; // Whether or not we are running in `regressed` mode, meaning we were
    // unable to select a discovery provider that was up-to-date. Clients may
    // want to consider blocking writes.

    _this._regressedMode = false; // List of valid past discovery provider versions registered on chain

    _this.validVersions = null;
    return _this;
  }
  /** Retrieves a cached discovery provider from localstorage */


  _createClass(DiscoveryProviderSelection, [{
    key: "getCached",
    value: function () {
      var _getCached = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var discProvTimestamp, _JSON$parse, latestEndpoint, timestamp, inWhitelist, timeout, isExpired;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.localStorage) {
                  _context2.next = 20;
                  break;
                }

                _context2.prev = 1;
                _context2.next = 4;
                return this.localStorage.getItem(DISCOVERY_PROVIDER_TIMESTAMP);

              case 4:
                discProvTimestamp = _context2.sent;

                if (!discProvTimestamp) {
                  _context2.next = 15;
                  break;
                }

                _JSON$parse = JSON.parse(discProvTimestamp), latestEndpoint = _JSON$parse.endpoint, timestamp = _JSON$parse.timestamp;
                inWhitelist = !this.whitelist || this.whitelist.has(latestEndpoint);
                timeout = this.reselectTimeout ? this.reselectTimeout : DISCOVERY_PROVIDER_RESELECT_TIMEOUT;
                isExpired = Date.now() - timestamp > timeout;

                if (!(!inWhitelist || isExpired)) {
                  _context2.next = 14;
                  break;
                }

                this.clearCached();
                _context2.next = 15;
                break;

              case 14:
                return _context2.abrupt("return", latestEndpoint);

              case 15:
                _context2.next = 20;
                break;

              case 17:
                _context2.prev = 17;
                _context2.t0 = _context2["catch"](1);
                console.error('Could not retrieve cached discovery endpoint from localStorage', _context2.t0);

              case 20:
                return _context2.abrupt("return", null);

              case 21:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 17]]);
      }));

      function getCached() {
        return _getCached.apply(this, arguments);
      }

      return getCached;
    }()
    /** Clears any cached discovery provider from localstorage */

  }, {
    key: "clearCached",
    value: function () {
      var _clearCached = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.localStorage) {
                  _context3.next = 3;
                  break;
                }

                _context3.next = 3;
                return this.localStorage.removeItem(DISCOVERY_PROVIDER_TIMESTAMP);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function clearCached() {
        return _clearCached.apply(this, arguments);
      }

      return clearCached;
    }()
    /** Sets a cached discovery provider in localstorage */

  }, {
    key: "setCached",
    value: function () {
      var _setCached = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(endpoint) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this.localStorage) {
                  _context4.next = 3;
                  break;
                }

                _context4.next = 3;
                return this.localStorage.setItem(DISCOVERY_PROVIDER_TIMESTAMP, JSON.stringify({
                  endpoint: endpoint,
                  timestamp: Date.now()
                }));

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function setCached(_x) {
        return _setCached.apply(this, arguments);
      }

      return setCached;
    }()
    /** Allows the selection take a shortcut if there's a cached provider */

  }, {
    key: "shortcircuit",
    value: function () {
      var _shortcircuit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getCached();

              case 2:
                return _context5.abrupt("return", _context5.sent);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function shortcircuit() {
        return _shortcircuit.apply(this, arguments);
      }

      return shortcircuit;
    }()
  }, {
    key: "select",
    value: function () {
      var _select = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var endpoint;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return _get(_getPrototypeOf(DiscoveryProviderSelection.prototype), "select", this).call(this);

              case 2:
                endpoint = _context6.sent;

                if (endpoint) {
                  this.setCached(endpoint);
                }

                console.info("Selected discprov ".concat(endpoint), this.decisionTree);

                if (this.selectionCallback) {
                  this.selectionCallback(endpoint, this.decisionTree);
                }

                return _context6.abrupt("return", endpoint);

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function select() {
        return _select.apply(this, arguments);
      }

      return select;
    }()
    /**
     * Checks whether a given response is healthy:
     * - Not behind in blocks
     * - 200 response
     * - Current version
     *
     * Other responses are collected in `this.backups` if
     * - Behind by only a patch version
     *
     * @param response axios response
     * @param urlMap health check urls mapped to their cannonical url
     * e.g. https://discoveryprovider.audius.co/health_check => https://discoveryprovider.audius.co
     */

  }, {
    key: "isHealthy",
    value: function isHealthy(response, urlMap) {
      var status = response.status,
          data = response.data;
      var _data$data = data.data,
          blockDiff = _data$data.block_difference,
          service = _data$data.service,
          version = _data$data.version,
          plays = _data$data.plays;
      var slotDiffPlays = null;

      if (plays !== null && plays !== void 0 && plays.tx_info) {
        slotDiffPlays = plays.tx_info.slot_diff;
      }

      if ('healthCheck' in this.monitoringCallbacks) {
        var url = new URL(response.config.url);

        try {
          var _this$monitoringCallb, _this$monitoringCallb2;

          (_this$monitoringCallb = (_this$monitoringCallb2 = this.monitoringCallbacks).healthCheck) === null || _this$monitoringCallb === void 0 ? void 0 : _this$monitoringCallb.call(_this$monitoringCallb2, {
            endpoint: url.origin,
            pathname: url.pathname,
            queryString: url.search,
            version: version,
            git: data.data.git,
            blockDifference: blockDiff,
            slotDifferencePlays: slotDiffPlays,
            databaseBlockNumber: data.data.db.number,
            webBlockNumber: data.data.web.blocknumber,
            databaseSize: data.data.database_size,
            databaseConnections: data.data.database_connections,
            totalMemory: data.data.total_memory,
            usedMemory: data.data.used_memory,
            totalStorage: data.data.filesystem_size,
            usedStorage: data.data.filesystem_used,
            receivedBytesPerSec: data.received_bytes_per_sec,
            transferredBytesPerSec: data.transferred_bytes_per_sec,
            challengeLastEventAgeSec: data.challenge_last_event_age_sec
          });
        } catch (e) {
          // Swallow errors -- this method should not throw generally
          console.error(e);
        }
      }

      if (status !== 200) return false;
      if (service !== DISCOVERY_SERVICE_NAME) return false;
      if (!semver__default["default"].valid(version)) return false; // If this service is not at least the version on chain, reject

      if (!isVersionAtLeastSameMajorMinor(this.currentVersion, version)) {
        return false;
      } // If this service is behind, add it as a backup and reject


      if (semver__default["default"].lt(version, this.currentVersion)) {
        this.addBackup(urlMap[response.config.url], data.data);
        return false;
      } // If this service is an unhealthy block diff behind, add it as a backup and reject


      if (blockDiff > this.unhealthyBlockDiff) {
        this.addBackup(urlMap[response.config.url], data.data);
        return false;
      } // If this service is an unhealthy slot diff behind on the plays table, add it
      // as a backup and reject


      if (slotDiffPlays !== null && this.unhealthySlotDiffPlays !== null && slotDiffPlays > this.unhealthySlotDiffPlays) {
        this.addBackup(urlMap[response.config.url], data.data);
        return false;
      }

      return true;
    }
    /**
     * Estabilishes that connection to discovery providers has regressed
     */

  }, {
    key: "enterRegressedMode",
    value: function enterRegressedMode() {
      var _this2 = this;

      console.info('Entering regressed mode');
      this._regressedMode = true;
      setTimeout(function () {
        console.info('Leaving regressed mode');
        _this2._regressedMode = false;
      }, REGRESSED_MODE_TIMEOUT);
    }
  }, {
    key: "setUnhealthyBlockDiff",
    value: function setUnhealthyBlockDiff() {
      var updatedDiff = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_UNHEALTHY_BLOCK_DIFF;
      this.unhealthyBlockDiff = updatedDiff;
    }
  }, {
    key: "setUnhealthySlotDiffPlays",
    value: function setUnhealthySlotDiffPlays(updatedDiff) {
      this.unhealthySlotDiffPlays = updatedDiff;
    }
  }, {
    key: "isInRegressedMode",
    value: function isInRegressedMode() {
      return this._regressedMode;
    }
    /**
     * In the case of no "healthy" services, we resort to backups in the following order:
     * 1. Pick the most recent (patch) version that's not behind
     * 2. Pick the least behind provider that is a valid patch version and enter "regressed mode"
     * 3. Pick `null`
     */

  }, {
    key: "selectFromBackups",
    value: function () {
      var _selectFromBackups = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var _this3 = this,
            _blockDiffMap$bestBlo;

        var versions, blockDiffs, versionMap, blockDiffMap, numberOfVersions, i, pastServiceVersion, sortedVersions, selected, _iterator, _step, version, endpoints, _i2, _this$backups$endpoin, bestBlockDiff;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                versions = [];
                blockDiffs = [];
                versionMap = {};
                blockDiffMap = {}; // Go backwards in time on chain and get the registered versions up to PREVIOUS_VERSIONS_TO_CHECK.
                // Record those versions in a set and validate any backups against that set.
                // TODO: Clean up this logic when we can validate a specific version rather
                // than traversing backwards through all the versions

                if (this.validVersions) {
                  _context7.next = 18;
                  break;
                }

                this.validVersions = [this.currentVersion];
                _context7.next = 8;
                return this.ethContracts.getNumberOfVersions(DISCOVERY_SERVICE_NAME);

              case 8:
                numberOfVersions = _context7.sent;
                i = 0;

              case 10:
                if (!(i < Math.min(PREVIOUS_VERSIONS_TO_CHECK, numberOfVersions - 1))) {
                  _context7.next = 18;
                  break;
                }

                _context7.next = 13;
                return this.ethContracts.getVersion(DISCOVERY_SERVICE_NAME, // Exclude the latest version when querying older versions
                // Latest index is numberOfVersions - 1, so 2nd oldest version starts at numberOfVersions - 2
                numberOfVersions - 2 - i);

              case 13:
                pastServiceVersion = _context7.sent;
                this.validVersions.push(pastServiceVersion);

              case 15:
                ++i;
                _context7.next = 10;
                break;

              case 18:
                // Go through each backup and create two keyed maps:
                // { semver => [provider] }
                // { blockdiff => [provider] }
                Object.keys(this.backups).forEach(function (backup) {
                  var _this3$backups$backup = _this3.backups[backup],
                      blockDiff = _this3$backups$backup.block_difference,
                      version = _this3$backups$backup.version;
                  var isVersionOk = false;

                  for (var _i = 0; _i < _this3.validVersions.length; ++_i) {
                    var _this3$validVersions;

                    if (isVersionAtLeastSameMajorMinor((_this3$validVersions = _this3.validVersions) === null || _this3$validVersions === void 0 ? void 0 : _this3$validVersions[_i], version)) {
                      isVersionOk = true;
                      break;
                    }
                  } // Filter out any version that wasn't valid given what's registered on chain


                  if (!isVersionOk) return;
                  versions.push(version);
                  blockDiffs.push(blockDiff);

                  if (version in versionMap) {
                    var _versionMap$version;

                    (_versionMap$version = versionMap[version]) === null || _versionMap$version === void 0 ? void 0 : _versionMap$version.push(backup);
                  } else {
                    versionMap[version] = [backup];
                  }

                  if (blockDiff in blockDiffMap) {
                    var _blockDiffMap$blockDi;

                    (_blockDiffMap$blockDi = blockDiffMap[blockDiff]) === null || _blockDiffMap$blockDi === void 0 ? void 0 : _blockDiffMap$blockDi.push(backup);
                  } else {
                    blockDiffMap[blockDiff] = [backup];
                  }
                }); // Sort the versions by desc semver

                sortedVersions = versions.sort(semver__default["default"].rcompare); // Select the closest version that's a healthy # of blocks behind

                selected = '';
                _iterator = _createForOfIteratorHelper(sortedVersions);
                _context7.prev = 22;

                _iterator.s();

              case 24:
                if ((_step = _iterator.n()).done) {
                  _context7.next = 39;
                  break;
                }

                version = _step.value;
                endpoints = versionMap[version];
                _i2 = 0;

              case 28:
                if (!(_i2 < endpoints.length)) {
                  _context7.next = 35;
                  break;
                }

                if (!(((_this$backups$endpoin = this.backups[endpoints[_i2]]) === null || _this$backups$endpoin === void 0 ? void 0 : _this$backups$endpoin.block_difference) < this.unhealthyBlockDiff)) {
                  _context7.next = 32;
                  break;
                }

                selected = endpoints[_i2];
                return _context7.abrupt("break", 35);

              case 32:
                ++_i2;
                _context7.next = 28;
                break;

              case 35:
                if (!selected) {
                  _context7.next = 37;
                  break;
                }

                return _context7.abrupt("return", selected);

              case 37:
                _context7.next = 24;
                break;

              case 39:
                _context7.next = 44;
                break;

              case 41:
                _context7.prev = 41;
                _context7.t0 = _context7["catch"](22);

                _iterator.e(_context7.t0);

              case 44:
                _context7.prev = 44;

                _iterator.f();

                return _context7.finish(44);

              case 47:
                // Select the best block diff provider
                // eslint-disable-next-line @typescript-eslint/require-array-sort-compare
                bestBlockDiff = blockDiffs.sort()[0];
                selected = (_blockDiffMap$bestBlo = blockDiffMap[bestBlockDiff]) === null || _blockDiffMap$bestBlo === void 0 ? void 0 : _blockDiffMap$bestBlo[0];
                this.enterRegressedMode();
                return _context7.abrupt("return", selected);

              case 51:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[22, 41, 44, 47]]);
      }));

      function selectFromBackups() {
        return _selectFromBackups.apply(this, arguments);
      }

      return selectFromBackups;
    }()
  }]);

  return DiscoveryProviderSelection;
}(ServiceSelection);

var _excluded = ["data", "url"];
var MAX_MAKE_REQUEST_RETRY_COUNT = 5;
var MAX_MAKE_REQUEST_RETRIES_WITH_404 = 2;
/**
 * Constructs a service class for a discovery node
 * @param whitelist whether or not to only include specified nodes in selection
 * @param userStateManager singleton UserStateManager instance
 * @param ethContracts singleton EthContracts instance
 * @param web3Manager
 * @param reselectTimeout timeout to clear locally cached discovery providers
 * @param selectionCallback invoked when a discovery node is selected
 * @param monitoringCallbacks callbacks to be invoked with metrics from requests sent to a service
 *  @param monitoringCallbacks.request
 *  @param monitoringCallbacks.healthCheck
 * @param selectionRequestTimeout the amount of time (ms) an individual request should take before reselecting
 * @param selectionRequestRetries the number of retries to a given discovery node we make before reselecting
 * @param unhealthySlotDiffPlays the number of slots we would consider a discovery node unhealthy
 * @param unhealthyBlockDiff the number of missed blocks after which we would consider a discovery node unhealthy
 */

var DiscoveryProvider = /*#__PURE__*/function () {
  function DiscoveryProvider(_ref) {
    var whitelist = _ref.whitelist,
        blacklist = _ref.blacklist,
        userStateManager = _ref.userStateManager,
        ethContracts = _ref.ethContracts,
        web3Manager = _ref.web3Manager,
        reselectTimeout = _ref.reselectTimeout,
        selectionCallback = _ref.selectionCallback,
        monitoringCallbacks = _ref.monitoringCallbacks,
        _ref$selectionRequest = _ref.selectionRequestTimeout,
        selectionRequestTimeout = _ref$selectionRequest === void 0 ? REQUEST_TIMEOUT_MS : _ref$selectionRequest,
        _ref$selectionRequest2 = _ref.selectionRequestRetries,
        selectionRequestRetries = _ref$selectionRequest2 === void 0 ? MAX_MAKE_REQUEST_RETRY_COUNT : _ref$selectionRequest2,
        localStorage = _ref.localStorage,
        unhealthySlotDiffPlays = _ref.unhealthySlotDiffPlays,
        unhealthyBlockDiff = _ref.unhealthyBlockDiff,
        discoveryNodeSelector = _ref.discoveryNodeSelector;

    _classCallCheck(this, DiscoveryProvider);

    _defineProperty$1(this, "whitelist", void 0);

    _defineProperty$1(this, "blacklist", void 0);

    _defineProperty$1(this, "userStateManager", void 0);

    _defineProperty$1(this, "ethContracts", void 0);

    _defineProperty$1(this, "web3Manager", void 0);

    _defineProperty$1(this, "unhealthyBlockDiff", void 0);

    _defineProperty$1(this, "serviceSelector", void 0);

    _defineProperty$1(this, "selectionRequestTimeout", void 0);

    _defineProperty$1(this, "selectionRequestRetries", void 0);

    _defineProperty$1(this, "unhealthySlotDiffPlays", void 0);

    _defineProperty$1(this, "request404Count", void 0);

    _defineProperty$1(this, "maxRequestsForTrue404", void 0);

    _defineProperty$1(this, "monitoringCallbacks", void 0);

    _defineProperty$1(this, "discoveryProviderEndpoint", void 0);

    _defineProperty$1(this, "isInitialized", false);

    _defineProperty$1(this, "discoveryNodeSelector", void 0);

    _defineProperty$1(this, "discoveryNodeMiddleware", void 0);

    _defineProperty$1(this, "selectionCallback", void 0);

    this.whitelist = whitelist;
    this.blacklist = blacklist;
    this.userStateManager = userStateManager;
    this.ethContracts = ethContracts;
    this.web3Manager = web3Manager;
    this.selectionCallback = selectionCallback;
    this.unhealthyBlockDiff = unhealthyBlockDiff !== null && unhealthyBlockDiff !== void 0 ? unhealthyBlockDiff : DEFAULT_UNHEALTHY_BLOCK_DIFF;
    this.serviceSelector = new DiscoveryProviderSelection({
      whitelist: this.whitelist,
      blacklist: this.blacklist,
      reselectTimeout: reselectTimeout,
      selectionCallback: selectionCallback,
      monitoringCallbacks: monitoringCallbacks,
      requestTimeout: selectionRequestTimeout,
      unhealthySlotDiffPlays: unhealthySlotDiffPlays,
      localStorage: localStorage,
      unhealthyBlockDiff: this.unhealthyBlockDiff
    }, this.ethContracts);
    this.selectionRequestTimeout = selectionRequestTimeout;
    this.selectionRequestRetries = selectionRequestRetries;
    this.unhealthySlotDiffPlays = unhealthySlotDiffPlays; // Keep track of the number of times a request 404s so we know when a true 404 occurs
    // Due to incident where some discovery nodes may erroneously be missing content #flare-51,
    // we treat 404s differently than generic 4xx's or other 5xx errors.
    // In the case of a 404, try a few other nodes

    this.request404Count = 0;
    this.maxRequestsForTrue404 = MAX_MAKE_REQUEST_RETRIES_WITH_404;
    this.monitoringCallbacks = monitoringCallbacks;
    this.discoveryNodeSelector = discoveryNodeSelector;
    this.discoveryNodeMiddleware = discoveryNodeSelector === null || discoveryNodeSelector === void 0 ? void 0 : discoveryNodeSelector.createMiddleware();
  }

  _createClass(DiscoveryProvider, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this = this;

        var endpoint, _endpoint, userAccount;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.discoveryNodeSelector) {
                  _context.next = 8;
                  break;
                }

                this.discoveryNodeSelector.addEventListener('change', function (endpoint) {
                  var _this$selectionCallba;

                  _this.setEndpoint(endpoint);

                  (_this$selectionCallba = _this.selectionCallback) === null || _this$selectionCallba === void 0 ? void 0 : _this$selectionCallba.call(_this, endpoint, []);
                });
                _context.next = 4;
                return this.discoveryNodeSelector.getSelectedEndpoint();

              case 4:
                endpoint = _context.sent;

                if (endpoint) {
                  this.setEndpoint(endpoint);
                }

                _context.next = 12;
                break;

              case 8:
                _context.next = 10;
                return this.serviceSelector.select();

              case 10:
                _endpoint = _context.sent;
                this.setEndpoint(_endpoint);

              case 12:
                if (!(this.discoveryProviderEndpoint && this.web3Manager && this.web3Manager.web3)) {
                  _context.next = 19;
                  break;
                }

                _context.next = 15;
                return this.getUserAccount(this.web3Manager.getWalletAddress());

              case 15:
                userAccount = _context.sent;

                if (!userAccount) {
                  _context.next = 19;
                  break;
                }

                _context.next = 19;
                return this.userStateManager.setCurrentUser(userAccount);

              case 19:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "setEndpoint",
    value: function setEndpoint(endpoint) {
      this.discoveryProviderEndpoint = endpoint;
    }
  }, {
    key: "setUnhealthyBlockDiff",
    value: function setUnhealthyBlockDiff() {
      var updatedBlockDiff = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_UNHEALTHY_BLOCK_DIFF;
      this.unhealthyBlockDiff = updatedBlockDiff;
      this.serviceSelector.setUnhealthyBlockDiff(updatedBlockDiff);
    }
  }, {
    key: "setUnhealthySlotDiffPlays",
    value: function setUnhealthySlotDiffPlays(updatedDiff) {
      this.unhealthySlotDiffPlays = updatedDiff;
      this.serviceSelector.setUnhealthySlotDiffPlays(updatedDiff);
    }
    /**
     * Get users with all relevant user data
     * can be filtered by providing an integer array of ids
     * @returns Array of User metadata Objects
     * additional metadata fields on user objects:
     *  {Integer} track_count - track count for given user
     *  {Integer} playlist_count - playlist count for given user
     *  {Integer} album_count - album count for given user
     *  {Integer} follower_count - follower count for given user
     *  {Integer} followee_count - followee count for given user
     *  {Integer} repost_count - repost count for given user
     *  {Integer} track_blocknumber - blocknumber of latest track for user
     *  {Boolean} does_current_user_follow - does current user follow given user
     *  {Array} followee_follows - followees of current user that follow given user
     * @example
     * await getUsers()
     * await getUsers(100, 0, [3,2,6]) - Invalid user ids will not be accepted
     */

  }, {
    key: "getUsers",
    value: function () {
      var _getUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var limit,
            offset,
            idsArray,
            walletAddress,
            handle,
            minBlockNumber,
            includeIncomplete,
            req,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                limit = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 100;
                offset = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 0;
                idsArray = _args2.length > 2 ? _args2[2] : undefined;
                walletAddress = _args2.length > 3 ? _args2[3] : undefined;
                handle = _args2.length > 4 ? _args2[4] : undefined;
                minBlockNumber = _args2.length > 5 ? _args2[5] : undefined;
                includeIncomplete = _args2.length > 6 ? _args2[6] : undefined;
                req = getUsers(limit, offset, idsArray, walletAddress, handle, minBlockNumber, includeIncomplete);
                _context2.next = 10;
                return this._makeRequest(req);

              case 10:
                return _context2.abrupt("return", _context2.sent);

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getUsers$1() {
        return _getUsers.apply(this, arguments);
      }

      return getUsers$1;
    }()
    /**
     * get tracks with all relevant track data
     * can be filtered by providing an integer array of ids
     * @param limit
     * @param offset
     * @param idsArray
     * @param targetUserId the owner of the tracks being queried
     * @param sort a string of form eg. blocknumber:asc,timestamp:desc describing a sort path
     * @param minBlockNumber The min block number
     * @param filterDeleted If set to true, filters the deleted tracks
     * @returns Array of track metadata Objects
     * additional metadata fields on track objects:
     *  {Integer} repost_count - repost count for given track
     *  {Integer} save_count - save count for given track
     *  {Array} followee_reposts - followees of current user that have reposted given track
     *  {Boolean} has_current_user_reposted - has current user reposted given track
     *  {Boolean} has_current_user_saved - has current user saved given track
     * @example
     * await getTracks()
     * await getTracks(100, 0, [3,2,6]) - Invalid track ids will not be accepted
     */

  }, {
    key: "getTracks",
    value: function () {
      var _getTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var limit,
            offset,
            idsArray,
            targetUserId,
            sort,
            minBlockNumber,
            filterDeleted,
            withUsers,
            req,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                limit = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 100;
                offset = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 0;
                idsArray = _args3.length > 2 ? _args3[2] : undefined;
                targetUserId = _args3.length > 3 ? _args3[3] : undefined;
                sort = _args3.length > 4 ? _args3[4] : undefined;
                minBlockNumber = _args3.length > 5 ? _args3[5] : undefined;
                filterDeleted = _args3.length > 6 ? _args3[6] : undefined;
                withUsers = _args3.length > 7 ? _args3[7] : undefined;
                req = getTracks(limit, offset, idsArray, targetUserId, sort, minBlockNumber, filterDeleted, withUsers);
                _context3.next = 11;
                return this._makeRequest(req);

              case 11:
                return _context3.abrupt("return", _context3.sent);

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getTracks$1() {
        return _getTracks.apply(this, arguments);
      }

      return getTracks$1;
    }()
    /**
     * get tracks with all relevant track data
     * can be filtered by providing an integer array of ids
     * @param limit
     * @param offset
     * @param idsArray
     * @param targetUserId the owner of the tracks being queried
     * @param sort a string of form eg. blocknumber:asc,timestamp:desc describing a sort path
     * @param minBlockNumber The min block number
     * @param filterDeleted If set to true, filters the deleted tracks
     * @returns Array of track metadata Objects
     * additional metadata fields on track objects:
     *  {Integer} repost_count - repost count for given track
     *  {Integer} save_count - save count for given track
     *  {Array} followee_reposts - followees of current user that have reposted given track
     *  {Boolean} has_current_user_reposted - has current user reposted given track
     *  {Boolean} has_current_user_saved - has current user saved given track
     * @example
     * await getTracks()
     * await getTracks(100, 0, [3,2,6]) - Invalid track ids will not be accepted
     */

  }, {
    key: "getTracksVerbose",
    value: function () {
      var _getTracksVerbose = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var limit,
            offset,
            idsArray,
            targetUserId,
            sort,
            minBlockNumber,
            filterDeleted,
            withUsers,
            req,
            _args4 = arguments;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                limit = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : 100;
                offset = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : 0;
                idsArray = _args4.length > 2 ? _args4[2] : undefined;
                targetUserId = _args4.length > 3 ? _args4[3] : undefined;
                sort = _args4.length > 4 ? _args4[4] : undefined;
                minBlockNumber = _args4.length > 5 ? _args4[5] : undefined;
                filterDeleted = _args4.length > 6 ? _args4[6] : undefined;
                withUsers = _args4.length > 7 ? _args4[7] : undefined;
                req = getTracks(limit, offset, idsArray, targetUserId, sort, minBlockNumber, filterDeleted, withUsers);
                _context4.next = 11;
                return this._makeRequestInternal(req);

              case 11:
                return _context4.abrupt("return", _context4.sent);

              case 12:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getTracksVerbose() {
        return _getTracksVerbose.apply(this, arguments);
      }

      return getTracksVerbose;
    }()
    /**
     * Gets a particular track by its creator's handle and the track's URL slug
     * @param handle the handle of the owner of the track
     * @param slug the URL slug of the track, generally the title urlized
     * @returns the requested track's metadata
     */

  }, {
    key: "getTracksByHandleAndSlug",
    value: function () {
      var _getTracksByHandleAndSlug = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(handle, slug) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._makeRequest(getTracksByHandleAndSlug(handle, slug),
                /* retry */
                false);

              case 2:
                return _context5.abrupt("return", _context5.sent);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getTracksByHandleAndSlug$1(_x, _x2) {
        return _getTracksByHandleAndSlug.apply(this, arguments);
      }

      return getTracksByHandleAndSlug$1;
    }()
    /**
     * gets all tracks matching identifiers, including unlisted.
     *
     */

  }, {
    key: "getTracksIncludingUnlisted",
    value: function () {
      var _getTracksIncludingUnlisted = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(identifiers) {
        var withUsers,
            req,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                withUsers = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : false;
                req = getTracksIncludingUnlisted(identifiers, withUsers);
                _context6.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context6.abrupt("return", _context6.sent);

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getTracksIncludingUnlisted$1(_x3) {
        return _getTracksIncludingUnlisted.apply(this, arguments);
      }

      return getTracksIncludingUnlisted$1;
    }()
    /**
     * Gets random tracks from trending tracks for a given genre.
     * If genre not given, will return trending tracks across all genres.
     * Excludes specified track ids.
     */

  }, {
    key: "getRandomTracks",
    value: function () {
      var _getRandomTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(genre, limit, exclusionList, time) {
        var req;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                req = getRandomTracks(genre, limit, exclusionList, time);
                _context7.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context7.abrupt("return", _context7.sent);

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getRandomTracks$1(_x4, _x5, _x6, _x7) {
        return _getRandomTracks.apply(this, arguments);
      }

      return getRandomTracks$1;
    }()
    /**
     * Gets all stems for a given trackId as an array of tracks.
     */

  }, {
    key: "getStemsForTrack",
    value: function () {
      var _getStemsForTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(trackId) {
        var req;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                req = getStemsForTrack(trackId);
                _context8.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context8.abrupt("return", _context8.sent);

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getStemsForTrack$1(_x8) {
        return _getStemsForTrack.apply(this, arguments);
      }

      return getStemsForTrack$1;
    }()
    /**
     * Gets all the remixes of a given trackId as an array of tracks.
     */

  }, {
    key: "getRemixesOfTrack",
    value: function () {
      var _getRemixesOfTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(trackId, limit, offset) {
        var req;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                req = getRemixesOfTrack(trackId, limit, offset);
                _context9.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context9.abrupt("return", _context9.sent);

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getRemixesOfTrack$1(_x9, _x10, _x11) {
        return _getRemixesOfTrack.apply(this, arguments);
      }

      return getRemixesOfTrack$1;
    }()
    /**
     * Gets the remix parents of a given trackId as an array of tracks.
     */

  }, {
    key: "getRemixTrackParents",
    value: function () {
      var _getRemixTrackParents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(trackId, limit, offset) {
        var req;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                req = getRemixTrackParents(trackId, limit, offset);
                _context10.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context10.abrupt("return", _context10.sent);

              case 4:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getRemixTrackParents$1(_x12, _x13, _x14) {
        return _getRemixTrackParents.apply(this, arguments);
      }

      return getRemixTrackParents$1;
    }()
    /**
     * Gets tracks trending on Audius.
     * @param genre
     * @param timeFrame one of day, week, month, or year
     * @param idsArray track ids
     * @param limit
     * @param offset
     */

  }, {
    key: "getTrendingTracks",
    value: function () {
      var _getTrendingTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(genre, timeFrame, idsArray, limit, offset) {
        var withUsers,
            req,
            _args11 = arguments;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                withUsers = _args11.length > 5 && _args11[5] !== undefined ? _args11[5] : false;
                req = getTrendingTracks(genre, timeFrame, idsArray, limit, offset, withUsers);
                _context11.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context11.abrupt("return", _context11.sent);

              case 5:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getTrendingTracks$1(_x15, _x16, _x17, _x18, _x19) {
        return _getTrendingTracks.apply(this, arguments);
      }

      return getTrendingTracks$1;
    }()
    /**
     * get full playlist objects, including tracks, for passed in array of playlistId
     * @returns array of playlist objects
     * additional metadata fields on playlist objects:
     *  {Integer} repost_count - repost count for given playlist
     *  {Integer} save_count - save count for given playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given playlist
     *  {Array} followee_reposts - followees of current user that have reposted given playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given playlist
     *  {Boolean} has_current_user_saved - has current user saved given playlist
     */

  }, {
    key: "getPlaylists",
    value: function () {
      var _getPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var limit,
            offset,
            idsArray,
            targetUserId,
            withUsers,
            req,
            _args12 = arguments;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                limit = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : 100;
                offset = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : 0;
                idsArray = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : null;
                targetUserId = _args12.length > 3 && _args12[3] !== undefined ? _args12[3] : null;
                withUsers = _args12.length > 4 && _args12[4] !== undefined ? _args12[4] : false;
                req = getPlaylists(limit, offset, idsArray, targetUserId, withUsers);
                _context12.next = 8;
                return this._makeRequest(req);

              case 8:
                return _context12.abrupt("return", _context12.sent);

              case 9:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getPlaylists$1() {
        return _getPlaylists.apply(this, arguments);
      }

      return getPlaylists$1;
    }()
  }, {
    key: "getFullPlaylist",
    value: function () {
      var _getFullPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(encodedPlaylistId, encodedUserId) {
        var req;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                req = getFullPlaylist(encodedPlaylistId, encodedUserId);
                _context13.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context13.abrupt("return", _context13.sent);

              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getFullPlaylist$1(_x20, _x21) {
        return _getFullPlaylist.apply(this, arguments);
      }

      return getFullPlaylist$1;
    }()
    /**
     * Return social feed for current user
     * @param filter - filter by "all", "original", or "repost"
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     * @returns Array of track and playlist metadata objects
     * additional metadata fields on track and playlist objects:
     *  {String} activity_timestamp - timestamp of requested user's repost for given track or playlist,
     *    used for sorting feed
     *  {Integer} repost_count - repost count of given track/playlist
     *  {Integer} save_count - save count of given track/playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given track/playlist
     *  {Array} followee_reposts - followees of current user that have reposted given track/playlist
     */

  }, {
    key: "getSocialFeed",
    value: function () {
      var _getSocialFeed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(filter) {
        var limit,
            offset,
            withUsers,
            tracksOnly,
            req,
            _args14 = arguments;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                limit = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : 100;
                offset = _args14.length > 2 && _args14[2] !== undefined ? _args14[2] : 0;
                withUsers = _args14.length > 3 && _args14[3] !== undefined ? _args14[3] : false;
                tracksOnly = _args14.length > 4 && _args14[4] !== undefined ? _args14[4] : false;
                req = getSocialFeed(filter, limit, offset, withUsers, tracksOnly);
                _context14.next = 7;
                return this._makeRequest(req);

              case 7:
                return _context14.abrupt("return", _context14.sent);

              case 8:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getSocialFeed$1(_x22) {
        return _getSocialFeed.apply(this, arguments);
      }

      return getSocialFeed$1;
    }()
    /**
     * Return repost feed for requested user
     * @param userId - requested user id
     * @param limit - max # of items to return (for pagination)
     * @param offset - offset into list to return from (for pagination)
     * @returns Array of track and playlist metadata objects}
     * additional metadata fields on track and playlist objects:
     *  {String} activity_timestamp - timestamp of requested user's repost for given track or playlist,
     *    used for sorting feed
     *  {Integer} repost_count - repost count of given track/playlist
     *  {Integer} save_count - save count of given track/playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given track/playlist
     *  {Array} followee_reposts - followees of current user that have reposted given track/playlist
     */

  }, {
    key: "getUserRepostFeed",
    value: function () {
      var _getUserRepostFeed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(userId) {
        var limit,
            offset,
            withUsers,
            req,
            _args15 = arguments;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                limit = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : 100;
                offset = _args15.length > 2 && _args15[2] !== undefined ? _args15[2] : 0;
                withUsers = _args15.length > 3 && _args15[3] !== undefined ? _args15[3] : false;
                req = getUserRepostFeed(userId, limit, offset, withUsers);
                _context15.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context15.abrupt("return", _context15.sent);

              case 7:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getUserRepostFeed$1(_x23) {
        return _getUserRepostFeed.apply(this, arguments);
      }

      return getUserRepostFeed$1;
    }()
    /**
     * get intersection of users that follow followeeUserId and users that are followed by followerUserId
     * @param followeeUserId user that is followed
     * @param followerUserId user that follows
     * @example
     * getFollowIntersectionUsers(100, 0, 1, 1) - IDs must be valid
     */

  }, {
    key: "getFollowIntersectionUsers",
    value: function () {
      var _getFollowIntersectionUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
        var limit,
            offset,
            followeeUserId,
            followerUserId,
            req,
            _args16 = arguments;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                limit = _args16.length > 0 && _args16[0] !== undefined ? _args16[0] : 100;
                offset = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : 0;
                followeeUserId = _args16.length > 2 ? _args16[2] : undefined;
                followerUserId = _args16.length > 3 ? _args16[3] : undefined;
                req = getFollowIntersectionUsers(limit, offset, followeeUserId, followerUserId);
                _context16.next = 7;
                return this._makeRequest(req);

              case 7:
                return _context16.abrupt("return", _context16.sent);

              case 8:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getFollowIntersectionUsers$1() {
        return _getFollowIntersectionUsers.apply(this, arguments);
      }

      return getFollowIntersectionUsers$1;
    }()
    /**
     * get intersection of users that have reposted repostTrackId and users that are followed by followerUserId
     * followee = user that is followed; follower = user that follows
     * @param repostTrackId track that is reposted
     * @param followerUserId user that reposted track
     * @example
     * getTrackRepostIntersectionUsers(100, 0, 1, 1) - IDs must be valid
     */

  }, {
    key: "getTrackRepostIntersectionUsers",
    value: function () {
      var _getTrackRepostIntersectionUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
        var limit,
            offset,
            repostTrackId,
            followerUserId,
            req,
            _args17 = arguments;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                limit = _args17.length > 0 && _args17[0] !== undefined ? _args17[0] : 100;
                offset = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : 0;
                repostTrackId = _args17.length > 2 ? _args17[2] : undefined;
                followerUserId = _args17.length > 3 ? _args17[3] : undefined;
                req = getTrackRepostIntersectionUsers(limit, offset, repostTrackId, followerUserId);
                _context17.next = 7;
                return this._makeRequest(req);

              case 7:
                return _context17.abrupt("return", _context17.sent);

              case 8:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getTrackRepostIntersectionUsers$1() {
        return _getTrackRepostIntersectionUsers.apply(this, arguments);
      }

      return getTrackRepostIntersectionUsers$1;
    }()
    /**
     * get intersection of users that have reposted repostPlaylistId and users that are followed by followerUserId
     * followee = user that is followed; follower = user that follows
     * @param repostPlaylistId playlist that is reposted
     * @param followerUserId user that reposted track
     * @example
     * getPlaylistRepostIntersectionUsers(100, 0, 1, 1) - IDs must be valid
     */

  }, {
    key: "getPlaylistRepostIntersectionUsers",
    value: function () {
      var _getPlaylistRepostIntersectionUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
        var limit,
            offset,
            repostPlaylistId,
            followerUserId,
            req,
            _args18 = arguments;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                limit = _args18.length > 0 && _args18[0] !== undefined ? _args18[0] : 100;
                offset = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : 0;
                repostPlaylistId = _args18.length > 2 ? _args18[2] : undefined;
                followerUserId = _args18.length > 3 ? _args18[3] : undefined;
                req = getPlaylistRepostIntersectionUsers(limit, offset, repostPlaylistId, followerUserId);
                _context18.next = 7;
                return this._makeRequest(req);

              case 7:
                return _context18.abrupt("return", _context18.sent);

              case 8:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getPlaylistRepostIntersectionUsers$1() {
        return _getPlaylistRepostIntersectionUsers.apply(this, arguments);
      }

      return getPlaylistRepostIntersectionUsers$1;
    }()
    /**
     * get users that follow followeeUserId, sorted by follower count descending
     * @param followeeUserId user that is followed
     * @return {Array} array of user objects with standard user metadata
     */

  }, {
    key: "getFollowersForUser",
    value: function () {
      var _getFollowersForUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
        var limit,
            offset,
            followeeUserId,
            req,
            _args19 = arguments;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                limit = _args19.length > 0 && _args19[0] !== undefined ? _args19[0] : 100;
                offset = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : 0;
                followeeUserId = _args19.length > 2 ? _args19[2] : undefined;
                req = getFollowersForUser(limit, offset, followeeUserId);
                _context19.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context19.abrupt("return", _context19.sent);

              case 7:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getFollowersForUser$1() {
        return _getFollowersForUser.apply(this, arguments);
      }

      return getFollowersForUser$1;
    }()
    /**
     * get users that are followed by followerUserId, sorted by follower count descending
     * @param followerUserId user - i am the one who follows
     * @return array of user objects with standard user metadata
     */

  }, {
    key: "getFolloweesForUser",
    value: function () {
      var _getFolloweesForUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
        var limit,
            offset,
            followerUserId,
            req,
            _args20 = arguments;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                limit = _args20.length > 0 && _args20[0] !== undefined ? _args20[0] : 100;
                offset = _args20.length > 1 && _args20[1] !== undefined ? _args20[1] : 0;
                followerUserId = _args20.length > 2 ? _args20[2] : undefined;
                req = getFolloweesForUser(limit, offset, followerUserId);
                _context20.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context20.abrupt("return", _context20.sent);

              case 7:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getFolloweesForUser$1() {
        return _getFolloweesForUser.apply(this, arguments);
      }

      return getFolloweesForUser$1;
    }()
    /**
     * get users that reposted repostTrackId, sorted by follower count descending
     * @param repostTrackId
     * @return array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getRepostersForTrack(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getRepostersForTrack",
    value: function () {
      var _getRepostersForTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21() {
        var limit,
            offset,
            repostTrackId,
            req,
            _args21 = arguments;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                limit = _args21.length > 0 && _args21[0] !== undefined ? _args21[0] : 100;
                offset = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : 0;
                repostTrackId = _args21.length > 2 ? _args21[2] : undefined;
                req = getRepostersForTrack(limit, offset, repostTrackId);
                _context21.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context21.abrupt("return", _context21.sent);

              case 7:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getRepostersForTrack$1() {
        return _getRepostersForTrack.apply(this, arguments);
      }

      return getRepostersForTrack$1;
    }()
    /**
     * get users that reposted repostPlaylistId, sorted by follower count descending
     * @param repostPlaylistId
     * @return array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getRepostersForPlaylist(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getRepostersForPlaylist",
    value: function () {
      var _getRepostersForPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22() {
        var limit,
            offset,
            repostPlaylistId,
            req,
            _args22 = arguments;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                limit = _args22.length > 0 && _args22[0] !== undefined ? _args22[0] : 100;
                offset = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : 0;
                repostPlaylistId = _args22.length > 2 ? _args22[2] : undefined;
                req = getRepostersForPlaylist(limit, offset, repostPlaylistId);
                _context22.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context22.abrupt("return", _context22.sent);

              case 7:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getRepostersForPlaylist$1() {
        return _getRepostersForPlaylist.apply(this, arguments);
      }

      return getRepostersForPlaylist$1;
    }()
    /**
     * get users that saved saveTrackId, sorted by follower count descending
     * @param saveTrackId
     * @return array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getSaversForTrack(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getSaversForTrack",
    value: function () {
      var _getSaversForTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23() {
        var limit,
            offset,
            saveTrackId,
            req,
            _args23 = arguments;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                limit = _args23.length > 0 && _args23[0] !== undefined ? _args23[0] : 100;
                offset = _args23.length > 1 && _args23[1] !== undefined ? _args23[1] : 0;
                saveTrackId = _args23.length > 2 ? _args23[2] : undefined;
                req = getSaversForTrack(limit, offset, saveTrackId);
                _context23.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context23.abrupt("return", _context23.sent);

              case 7:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getSaversForTrack$1() {
        return _getSaversForTrack.apply(this, arguments);
      }

      return getSaversForTrack$1;
    }()
    /**
     * get users that saved savePlaylistId, sorted by follower count descending
     * @param savePlaylistId
     * @return array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getSaversForPlaylist(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getSaversForPlaylist",
    value: function () {
      var _getSaversForPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24() {
        var limit,
            offset,
            savePlaylistId,
            req,
            _args24 = arguments;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                limit = _args24.length > 0 && _args24[0] !== undefined ? _args24[0] : 100;
                offset = _args24.length > 1 && _args24[1] !== undefined ? _args24[1] : 0;
                savePlaylistId = _args24.length > 2 ? _args24[2] : undefined;
                req = getSaversForPlaylist(limit, offset, savePlaylistId);
                _context24.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context24.abrupt("return", _context24.sent);

              case 7:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getSaversForPlaylist$1() {
        return _getSaversForPlaylist.apply(this, arguments);
      }

      return getSaversForPlaylist$1;
    }()
    /**
     * get whether a JWT given by Audius Oauth popup is valid
     * @param token - JWT
     * @return profile info of user attached to JWT payload if the JWT is valid, else false
     */

  }, {
    key: "verifyToken",
    value: function () {
      var _verifyToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(token) {
        var req, res;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                req = verifyToken(token);
                _context25.next = 3;
                return this._makeRequest(req);

              case 3:
                res = _context25.sent;

                if (!(res == null)) {
                  _context25.next = 8;
                  break;
                }

                return _context25.abrupt("return", false);

              case 8:
                return _context25.abrupt("return", res);

              case 9:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function verifyToken$1(_x24) {
        return _verifyToken.apply(this, arguments);
      }

      return verifyToken$1;
    }()
    /**
     * Perform a full-text search. Returns tracks, users, playlists, albums
     *    with optional user-specific results for each
     *  - user, track, and playlist objects have all same data as returned from standalone endpoints
     * @param text search query
     * @param kind 'tracks', 'users', 'playlists', 'albums', 'all'
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */

  }, {
    key: "searchFull",
    value: function () {
      var _searchFull = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(text, kind) {
        var limit,
            offset,
            req,
            _args26 = arguments;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                limit = _args26.length > 2 && _args26[2] !== undefined ? _args26[2] : 100;
                offset = _args26.length > 3 && _args26[3] !== undefined ? _args26[3] : 0;
                req = searchFull(text, kind, limit, offset);
                _context26.next = 5;
                return this._makeRequest(req);

              case 5:
                return _context26.abrupt("return", _context26.sent);

              case 6:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function searchFull$1(_x25, _x26) {
        return _searchFull.apply(this, arguments);
      }

      return searchFull$1;
    }()
    /**
     * Perform a lighter-weight full-text search. Returns tracks, users, playlists, albums
     *    with optional user-specific results for each
     *  - user, track, and playlist objects have core data, and track & playlist objects
     *    also return user object
     * @param text search query
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */

  }, {
    key: "searchAutocomplete",
    value: function () {
      var _searchAutocomplete = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(text) {
        var limit,
            offset,
            req,
            _args27 = arguments;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                limit = _args27.length > 1 && _args27[1] !== undefined ? _args27[1] : 100;
                offset = _args27.length > 2 && _args27[2] !== undefined ? _args27[2] : 0;
                req = searchAutocomplete(text, limit, offset);
                _context27.next = 5;
                return this._makeRequest(req);

              case 5:
                return _context27.abrupt("return", _context27.sent);

              case 6:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function searchAutocomplete$1(_x27) {
        return _searchAutocomplete.apply(this, arguments);
      }

      return searchAutocomplete$1;
    }()
    /**
     * Perform a tags-only search. Returns tracks with required tag and users
     * that have used a tag greater than a specified number of times
     * @param text search query
     * @param userTagCount min # of times a user must have used a tag to be returned
     * @param kind 'tracks', 'users', 'playlists', 'albums', 'all'
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */

  }, {
    key: "searchTags",
    value: function () {
      var _searchTags = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(text) {
        var userTagCount,
            kind,
            limit,
            offset,
            req,
            _args28 = arguments;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                userTagCount = _args28.length > 1 && _args28[1] !== undefined ? _args28[1] : 2;
                kind = _args28.length > 2 && _args28[2] !== undefined ? _args28[2] : 'all';
                limit = _args28.length > 3 && _args28[3] !== undefined ? _args28[3] : 100;
                offset = _args28.length > 4 && _args28[4] !== undefined ? _args28[4] : 0;
                req = searchTags(text, userTagCount, kind, limit, offset);
                _context28.next = 7;
                return this._makeRequest(req);

              case 7:
                return _context28.abrupt("return", _context28.sent);

              case 8:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function searchTags$1(_x28) {
        return _searchTags.apply(this, arguments);
      }

      return searchTags$1;
    }()
    /**
     * Return saved playlists for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */

  }, {
    key: "getSavedPlaylists",
    value: function () {
      var _getSavedPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29() {
        var limit,
            offset,
            withUsers,
            req,
            _args29 = arguments;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                limit = _args29.length > 0 && _args29[0] !== undefined ? _args29[0] : 100;
                offset = _args29.length > 1 && _args29[1] !== undefined ? _args29[1] : 0;
                withUsers = _args29.length > 2 && _args29[2] !== undefined ? _args29[2] : false;
                req = getSavedPlaylists(limit, offset, withUsers);
                _context29.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context29.abrupt("return", _context29.sent);

              case 7:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getSavedPlaylists$1() {
        return _getSavedPlaylists.apply(this, arguments);
      }

      return getSavedPlaylists$1;
    }()
    /**
     * Return saved albums for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */

  }, {
    key: "getSavedAlbums",
    value: function () {
      var _getSavedAlbums = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30() {
        var limit,
            offset,
            withUsers,
            req,
            _args30 = arguments;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                limit = _args30.length > 0 && _args30[0] !== undefined ? _args30[0] : 100;
                offset = _args30.length > 1 && _args30[1] !== undefined ? _args30[1] : 0;
                withUsers = _args30.length > 2 && _args30[2] !== undefined ? _args30[2] : false;
                req = getSavedAlbums(limit, offset, withUsers);
                _context30.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context30.abrupt("return", _context30.sent);

              case 7:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getSavedAlbums$1() {
        return _getSavedAlbums.apply(this, arguments);
      }

      return getSavedAlbums$1;
    }()
    /**
     * Return saved tracks for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */

  }, {
    key: "getSavedTracks",
    value: function () {
      var _getSavedTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31() {
        var limit,
            offset,
            withUsers,
            req,
            _args31 = arguments;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                limit = _args31.length > 0 && _args31[0] !== undefined ? _args31[0] : 100;
                offset = _args31.length > 1 && _args31[1] !== undefined ? _args31[1] : 0;
                withUsers = _args31.length > 2 && _args31[2] !== undefined ? _args31[2] : false;
                req = getSavedTracks(limit, offset, withUsers);
                _context31.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context31.abrupt("return", _context31.sent);

              case 7:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getSavedTracks$1() {
        return _getSavedTracks.apply(this, arguments);
      }

      return getSavedTracks$1;
    }()
    /**
     * Return user collections (saved & uploaded) along w/ users for those collections
     */

  }, {
    key: "getUserAccount",
    value: function () {
      var _getUserAccount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(wallet) {
        var req;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                req = getUserAccount(wallet);
                _context32.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context32.abrupt("return", _context32.sent);

              case 4:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getUserAccount$1(_x29) {
        return _getUserAccount.apply(this, arguments);
      }

      return getUserAccount$1;
    }()
    /**
     * @deprecated Migrate to using getTrendingPlaylists
     */

  }, {
    key: "getTopPlaylists",
    value: function () {
      var _getTopPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(type, limit, mood, filter) {
        var withUsers,
            req,
            _args33 = arguments;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                withUsers = _args33.length > 4 && _args33[4] !== undefined ? _args33[4] : false;
                req = getTopPlaylists(type, limit, mood, filter, withUsers);
                _context33.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context33.abrupt("return", _context33.sent);

              case 5:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getTopPlaylists$1(_x30, _x31, _x32, _x33) {
        return _getTopPlaylists.apply(this, arguments);
      }

      return getTopPlaylists$1;
    }()
  }, {
    key: "getTopFullPlaylists",
    value: function () {
      var _getTopFullPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(_ref2) {
        var type, limit, mood, filter, encodedUserId, _ref2$withUsers, withUsers, req;

        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                type = _ref2.type, limit = _ref2.limit, mood = _ref2.mood, filter = _ref2.filter, encodedUserId = _ref2.encodedUserId, _ref2$withUsers = _ref2.withUsers, withUsers = _ref2$withUsers === void 0 ? false : _ref2$withUsers;
                req = getTopFullPlaylists({
                  type: type,
                  limit: limit,
                  mood: mood,
                  filter: filter,
                  encodedUserId: encodedUserId,
                  withUsers: withUsers
                });
                _context34.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context34.abrupt("return", _context34.sent);

              case 5:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function getTopFullPlaylists$1(_x34) {
        return _getTopFullPlaylists.apply(this, arguments);
      }

      return getTopFullPlaylists$1;
    }()
    /**
     * @deprecated Migrate to using getBestNewReleases
     */

  }, {
    key: "getTopFolloweeWindowed",
    value: function () {
      var _getTopFolloweeWindowed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(type, window, limit) {
        var withUsers,
            req,
            _args35 = arguments;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                withUsers = _args35.length > 3 && _args35[3] !== undefined ? _args35[3] : false;
                req = getTopFolloweeWindowed(type, window, limit, withUsers);
                _context35.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context35.abrupt("return", _context35.sent);

              case 5:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function getTopFolloweeWindowed$1(_x35, _x36, _x37) {
        return _getTopFolloweeWindowed.apply(this, arguments);
      }

      return getTopFolloweeWindowed$1;
    }()
  }, {
    key: "getBestNewReleases",
    value: function () {
      var _getBestNewReleases = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36(encodedUserId, window, limit) {
        var withUsers,
            req,
            _args36 = arguments;
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                withUsers = _args36.length > 3 && _args36[3] !== undefined ? _args36[3] : false;
                req = getBestNewReleases(window, limit, encodedUserId, withUsers);
                _context36.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context36.abrupt("return", _context36.sent);

              case 5:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function getBestNewReleases$1(_x38, _x39, _x40) {
        return _getBestNewReleases.apply(this, arguments);
      }

      return getBestNewReleases$1;
    }()
    /**
     * @deprecated Migrate to using getMostLovedTracks
     */

  }, {
    key: "getTopFolloweeSaves",
    value: function () {
      var _getTopFolloweeSaves = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(type, limit) {
        var withUsers,
            req,
            _args37 = arguments;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                withUsers = _args37.length > 2 && _args37[2] !== undefined ? _args37[2] : false;
                req = getTopFolloweeSaves(type, limit, withUsers);
                _context37.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context37.abrupt("return", _context37.sent);

              case 5:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function getTopFolloweeSaves$1(_x41, _x42) {
        return _getTopFolloweeSaves.apply(this, arguments);
      }

      return getTopFolloweeSaves$1;
    }()
  }, {
    key: "getMostLovedTracks",
    value: function () {
      var _getMostLovedTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(encodedUserId, limit) {
        var withUsers,
            req,
            _args38 = arguments;
        return regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                withUsers = _args38.length > 2 && _args38[2] !== undefined ? _args38[2] : false;
                req = getMostLovedTracks(encodedUserId, limit, withUsers);
                _context38.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context38.abrupt("return", _context38.sent);

              case 5:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function getMostLovedTracks$1(_x43, _x44) {
        return _getMostLovedTracks.apply(this, arguments);
      }

      return getMostLovedTracks$1;
    }()
  }, {
    key: "getFeelingLuckyTracks",
    value: function () {
      var _getFeelingLuckyTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(encodedUserId, limit) {
        var withUsers,
            req,
            _args39 = arguments;
        return regeneratorRuntime.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                withUsers = _args39.length > 2 && _args39[2] !== undefined ? _args39[2] : false;
                req = getFeelingLuckyTracks(encodedUserId, limit, withUsers);
                _context39.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context39.abrupt("return", _context39.sent);

              case 5:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));

      function getFeelingLuckyTracks$1(_x45, _x46) {
        return _getFeelingLuckyTracks.apply(this, arguments);
      }

      return getFeelingLuckyTracks$1;
    }()
  }, {
    key: "getLatest",
    value: function () {
      var _getLatest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee40(type) {
        var limit,
            offset,
            req,
            _args40 = arguments;
        return regeneratorRuntime.wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                limit = _args40.length > 1 && _args40[1] !== undefined ? _args40[1] : 1;
                offset = _args40.length > 2 && _args40[2] !== undefined ? _args40[2] : 0;
                req = getLatest(type, limit, offset);
                _context40.next = 5;
                return this._makeRequest(req);

              case 5:
                return _context40.abrupt("return", _context40.sent);

              case 6:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));

      function getLatest$1(_x47) {
        return _getLatest.apply(this, arguments);
      }

      return getLatest$1;
    }()
  }, {
    key: "getTopCreatorsByGenres",
    value: function () {
      var _getTopCreatorsByGenres = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee41(genres) {
        var limit,
            offset,
            withUsers,
            req,
            _args41 = arguments;
        return regeneratorRuntime.wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                limit = _args41.length > 1 && _args41[1] !== undefined ? _args41[1] : 30;
                offset = _args41.length > 2 && _args41[2] !== undefined ? _args41[2] : 0;
                withUsers = _args41.length > 3 && _args41[3] !== undefined ? _args41[3] : false;
                req = getTopCreatorsByGenres(genres, limit, offset, withUsers);
                _context41.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context41.abrupt("return", _context41.sent);

              case 7:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this);
      }));

      function getTopCreatorsByGenres$1(_x48) {
        return _getTopCreatorsByGenres.apply(this, arguments);
      }

      return getTopCreatorsByGenres$1;
    }()
  }, {
    key: "getUserNotifications",
    value: function () {
      var _getUserNotifications = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee42(params) {
        var req;
        return regeneratorRuntime.wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                req = getUserNotifications(params);
                _context42.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context42.abrupt("return", _context42.sent);

              case 4:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this);
      }));

      function getUserNotifications$1(_x49) {
        return _getUserNotifications.apply(this, arguments);
      }

      return getUserNotifications$1;
    }()
  }, {
    key: "getURSMContentNodes",
    value: function () {
      var _getURSMContentNodes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee43() {
        var ownerWallet,
            req,
            _args43 = arguments;
        return regeneratorRuntime.wrap(function _callee43$(_context43) {
          while (1) {
            switch (_context43.prev = _context43.next) {
              case 0:
                ownerWallet = _args43.length > 0 && _args43[0] !== undefined ? _args43[0] : null;
                req = getURSMContentNodes(ownerWallet);
                _context43.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context43.abrupt("return", _context43.sent);

              case 5:
              case "end":
                return _context43.stop();
            }
          }
        }, _callee43, this);
      }));

      function getURSMContentNodes$1() {
        return _getURSMContentNodes.apply(this, arguments);
      }

      return getURSMContentNodes$1;
    }()
  }, {
    key: "getNotifications",
    value: function () {
      var _getNotifications = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee44(minBlockNumber, trackIds, timeout) {
        var req;
        return regeneratorRuntime.wrap(function _callee44$(_context44) {
          while (1) {
            switch (_context44.prev = _context44.next) {
              case 0:
                req = getNotifications(minBlockNumber, trackIds, timeout);
                _context44.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context44.abrupt("return", _context44.sent);

              case 4:
              case "end":
                return _context44.stop();
            }
          }
        }, _callee44, this);
      }));

      function getNotifications$1(_x50, _x51, _x52) {
        return _getNotifications.apply(this, arguments);
      }

      return getNotifications$1;
    }()
    /**
     * Retrieves subscribers for a given user.
     * @param params.encodedUserId string of the encoded user id
     * @param params.timeout timeout in ms
     * @returns Array of User metadata objects for each subscriber
     */

  }, {
    key: "getUserSubscribers",
    value: function () {
      var _getUserSubscribers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee45(encodedUserId, timeout) {
        var req;
        return regeneratorRuntime.wrap(function _callee45$(_context45) {
          while (1) {
            switch (_context45.prev = _context45.next) {
              case 0:
                req = getUserSubscribers(encodedUserId, timeout);
                _context45.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context45.abrupt("return", _context45.sent);

              case 4:
              case "end":
                return _context45.stop();
            }
          }
        }, _callee45, this);
      }));

      function getUserSubscribers$1(_x53, _x54) {
        return _getUserSubscribers.apply(this, arguments);
      }

      return getUserSubscribers$1;
    }()
    /**
     * Retrieves subscribers for the given users.
     * @param params.encodedUserIds JSON stringified array of
     *   encoded user ids
     * @param params.timeout timeout in ms
     * @returns Array of {user_id: <encoded user id>,
     *   subscriber_ids: Array[<encoded subscriber ids>]} objects
     */

  }, {
    key: "bulkGetUserSubscribers",
    value: function () {
      var _bulkGetUserSubscribers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee46(encodedUserIds, timeout) {
        var req;
        return regeneratorRuntime.wrap(function _callee46$(_context46) {
          while (1) {
            switch (_context46.prev = _context46.next) {
              case 0:
                req = bulkGetUserSubscribers(encodedUserIds, timeout);
                _context46.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context46.abrupt("return", _context46.sent);

              case 4:
              case "end":
                return _context46.stop();
            }
          }
        }, _callee46, this);
      }));

      function bulkGetUserSubscribers$1(_x55, _x56) {
        return _bulkGetUserSubscribers.apply(this, arguments);
      }

      return bulkGetUserSubscribers$1;
    }()
  }, {
    key: "getCIDData",
    value: function () {
      var _getCIDData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee47(cid, responseType, timeout) {
        var req;
        return regeneratorRuntime.wrap(function _callee47$(_context47) {
          while (1) {
            switch (_context47.prev = _context47.next) {
              case 0:
                req = getCIDData(cid, responseType, timeout);
                _context47.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context47.abrupt("return", _context47.sent);

              case 4:
              case "end":
                return _context47.stop();
            }
          }
        }, _callee47, this);
      }));

      function getCIDData$1(_x57, _x58, _x59) {
        return _getCIDData.apply(this, arguments);
      }

      return getCIDData$1;
    }()
  }, {
    key: "getSolanaNotifications",
    value: function () {
      var _getSolanaNotifications = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee48(minSlotNumber, timeout) {
        var req;
        return regeneratorRuntime.wrap(function _callee48$(_context48) {
          while (1) {
            switch (_context48.prev = _context48.next) {
              case 0:
                req = getSolanaNotifications(minSlotNumber, timeout);
                _context48.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context48.abrupt("return", _context48.sent);

              case 4:
              case "end":
                return _context48.stop();
            }
          }
        }, _callee48, this);
      }));

      function getSolanaNotifications$1(_x60, _x61) {
        return _getSolanaNotifications.apply(this, arguments);
      }

      return getSolanaNotifications$1;
    }()
  }, {
    key: "getTrackListenMilestones",
    value: function () {
      var _getTrackListenMilestones = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee49(timeout) {
        var req;
        return regeneratorRuntime.wrap(function _callee49$(_context49) {
          while (1) {
            switch (_context49.prev = _context49.next) {
              case 0:
                req = getTrackListenMilestones(timeout);
                _context49.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context49.abrupt("return", _context49.sent);

              case 4:
              case "end":
                return _context49.stop();
            }
          }
        }, _callee49, this);
      }));

      function getTrackListenMilestones$1(_x62) {
        return _getTrackListenMilestones.apply(this, arguments);
      }

      return getTrackListenMilestones$1;
    }()
  }, {
    key: "getChallengeAttestation",
    value: function () {
      var _getChallengeAttestation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee50(challengeId, encodedUserId, specifier, oracleAddress, discoveryProviderEndpoint) {
        var req, _yield$this$_performR, data;

        return regeneratorRuntime.wrap(function _callee50$(_context50) {
          while (1) {
            switch (_context50.prev = _context50.next) {
              case 0:
                req = getChallengeAttestation(challengeId, encodedUserId, specifier, oracleAddress);
                _context50.next = 3;
                return this._performRequestWithMonitoring(req, discoveryProviderEndpoint);

              case 3:
                _yield$this$_performR = _context50.sent;
                data = _yield$this$_performR.data;
                return _context50.abrupt("return", data);

              case 6:
              case "end":
                return _context50.stop();
            }
          }
        }, _callee50, this);
      }));

      function getChallengeAttestation$1(_x63, _x64, _x65, _x66, _x67) {
        return _getChallengeAttestation.apply(this, arguments);
      }

      return getChallengeAttestation$1;
    }()
  }, {
    key: "getCreateSenderAttestation",
    value: function () {
      var _getCreateSenderAttestation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee51(senderEthAddress, discoveryProviderEndpoint) {
        var req, _yield$this$_performR2, data;

        return regeneratorRuntime.wrap(function _callee51$(_context51) {
          while (1) {
            switch (_context51.prev = _context51.next) {
              case 0:
                req = getCreateSenderAttestation(senderEthAddress);
                _context51.next = 3;
                return this._performRequestWithMonitoring(req, discoveryProviderEndpoint);

              case 3:
                _yield$this$_performR2 = _context51.sent;
                data = _yield$this$_performR2.data;
                return _context51.abrupt("return", data);

              case 6:
              case "end":
                return _context51.stop();
            }
          }
        }, _callee51, this);
      }));

      function getCreateSenderAttestation$1(_x68, _x69) {
        return _getCreateSenderAttestation.apply(this, arguments);
      }

      return getCreateSenderAttestation$1;
    }()
  }, {
    key: "getUndisbursedChallenges",
    value: function () {
      var _getUndisbursedChallenges = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee52() {
        var limit,
            offset,
            completedBlockNumber,
            encodedUserId,
            req,
            res,
            _args52 = arguments;
        return regeneratorRuntime.wrap(function _callee52$(_context52) {
          while (1) {
            switch (_context52.prev = _context52.next) {
              case 0:
                limit = _args52.length > 0 && _args52[0] !== undefined ? _args52[0] : null;
                offset = _args52.length > 1 && _args52[1] !== undefined ? _args52[1] : null;
                completedBlockNumber = _args52.length > 2 && _args52[2] !== undefined ? _args52[2] : null;
                encodedUserId = _args52.length > 3 && _args52[3] !== undefined ? _args52[3] : null;
                req = getUndisbursedChallenges(limit, offset, completedBlockNumber, encodedUserId);
                _context52.next = 7;
                return this._makeRequest(req);

              case 7:
                res = _context52.sent;

                if (res) {
                  _context52.next = 10;
                  break;
                }

                return _context52.abrupt("return", []);

              case 10:
                return _context52.abrupt("return", res.map(function (r) {
                  return _objectSpread2(_objectSpread2({}, r), {}, {
                    amount: parseInt(r.amount)
                  });
                }));

              case 11:
              case "end":
                return _context52.stop();
            }
          }
        }, _callee52, this);
      }));

      function getUndisbursedChallenges$1() {
        return _getUndisbursedChallenges.apply(this, arguments);
      }

      return getUndisbursedChallenges$1;
    }()
    /**
     * Retrieves listen counts for all tracks of a given artist grouped by month.
     * @param params.encodedUserId string of the encoded user id
     * @param params.startTime start time of query
     * @param params.endTime end time of query
     * @return object containing listen counts for an artist's tracks grouped by month
     */

  }, {
    key: "getUserListenCountsMonthly",
    value: function () {
      var _getUserListenCountsMonthly = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee53(encodedUserId, startTime, endTime) {
        var req;
        return regeneratorRuntime.wrap(function _callee53$(_context53) {
          while (1) {
            switch (_context53.prev = _context53.next) {
              case 0:
                req = getUserListenCountsMonthly(encodedUserId, startTime, endTime);
                _context53.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context53.abrupt("return", _context53.sent);

              case 4:
              case "end":
                return _context53.stop();
            }
          }
        }, _callee53, this);
      }));

      function getUserListenCountsMonthly$1(_x70, _x71, _x72) {
        return _getUserListenCountsMonthly.apply(this, arguments);
      }

      return getUserListenCountsMonthly$1;
    }()
    /**
     * Retrieves the user's replica set
     * @param params.encodedUserId string of the encoded user id
     * @param params.blockNumber optional integer pass to wait until the discovery node has indexed that block number
     * @return object containing the user replica set
     */

  }, {
    key: "getUserReplicaSet",
    value: function () {
      var _getUserReplicaSet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee54(_ref3) {
        var encodedUserId, blockNumber, req;
        return regeneratorRuntime.wrap(function _callee54$(_context54) {
          while (1) {
            switch (_context54.prev = _context54.next) {
              case 0:
                encodedUserId = _ref3.encodedUserId, blockNumber = _ref3.blockNumber;
                req = getUserReplicaSet(encodedUserId);
                _context54.next = 4;
                return this._makeRequest(req, true, 0, false, blockNumber);

              case 4:
                return _context54.abrupt("return", _context54.sent);

              case 5:
              case "end":
                return _context54.stop();
            }
          }
        }, _callee54, this);
      }));

      function getUserReplicaSet$1(_x73) {
        return _getUserReplicaSet.apply(this, arguments);
      }

      return getUserReplicaSet$1;
    }()
    /**
     * Retrieves an unclaimed ID
     * @return encoded ID
     */

  }, {
    key: "getUnclaimedId",
    value: function () {
      var _getUnclaimedId = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee55(type) {
        var req;
        return regeneratorRuntime.wrap(function _callee55$(_context55) {
          while (1) {
            switch (_context55.prev = _context55.next) {
              case 0:
                req = getUnclaimedId(type);
                _context55.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context55.abrupt("return", _context55.sent);

              case 4:
              case "end":
                return _context55.stop();
            }
          }
        }, _callee55, this);
      }));

      function getUnclaimedId$1(_x74) {
        return _getUnclaimedId.apply(this, arguments);
      }

      return getUnclaimedId$1;
    }()
    /* ------- INTERNAL FUNCTIONS ------- */

    /**
     * Performs a single request, defined in the request, via axios, calling any
     * monitoring callbacks as needed.
     *
     */

  }, {
    key: "_performRequestWithMonitoring",
    value: function () {
      var _performRequestWithMonitoring2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee56(requestObj, discoveryProviderEndpoint) {
        var _axiosRequest$url;

        var axiosRequest, response, parsedResponse, url, start, duration, _this$monitoringCallb, _this$monitoringCallb2, _error$response$data, _error$response, error, resp, _duration, errData, _this$monitoringCallb3, _this$monitoringCallb4;

        return regeneratorRuntime.wrap(function _callee56$(_context56) {
          while (1) {
            switch (_context56.prev = _context56.next) {
              case 0:
                axiosRequest = this._createDiscProvRequest(requestObj, discoveryProviderEndpoint);
                url = new URL((_axiosRequest$url = axiosRequest.url) !== null && _axiosRequest$url !== void 0 ? _axiosRequest$url : '');
                start = Date.now();
                _context56.prev = 3;
                _context56.next = 6;
                return axios__default["default"](axiosRequest);

              case 6:
                response = _context56.sent;
                duration = Date.now() - start;
                parsedResponse = Utils.parseDataFromResponse(response); // Fire monitoring callbacks for request success case

                if (this.monitoringCallbacks && 'request' in this.monitoringCallbacks) {
                  try {
                    (_this$monitoringCallb = (_this$monitoringCallb2 = this.monitoringCallbacks).request) === null || _this$monitoringCallb === void 0 ? void 0 : _this$monitoringCallb.call(_this$monitoringCallb2, {
                      endpoint: url.origin,
                      pathname: url.pathname,
                      queryString: url.search,
                      signer: response.data.signer,
                      signature: response.data.signature,
                      requestMethod: axiosRequest.method,
                      status: response.status,
                      responseTimeMillis: duration
                    });
                  } catch (e) {
                    // Swallow errors -- this method should not throw generally
                    console.error(e);
                  }
                }

                _context56.next = 22;
                break;

              case 12:
                _context56.prev = 12;
                _context56.t0 = _context56["catch"](3);
                error = _context56.t0;
                resp = error.response;
                _duration = Date.now() - start;
                errData = (_error$response$data = (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) !== null && _error$response$data !== void 0 ? _error$response$data : error; // Fire monitoring callbacks for request failure case

                if (this.monitoringCallbacks && 'request' in this.monitoringCallbacks) {
                  try {
                    (_this$monitoringCallb3 = (_this$monitoringCallb4 = this.monitoringCallbacks).request) === null || _this$monitoringCallb3 === void 0 ? void 0 : _this$monitoringCallb3.call(_this$monitoringCallb4, {
                      endpoint: url.origin,
                      pathname: url.pathname,
                      queryString: url.search,
                      requestMethod: axiosRequest.method,
                      status: resp === null || resp === void 0 ? void 0 : resp.status,
                      responseTimeMillis: _duration
                    });
                  } catch (e) {
                    // Swallow errors -- this method should not throw generally
                    console.error(e);
                  }
                }

                if (!(resp && resp.status === 404)) {
                  _context56.next = 21;
                  break;
                }

                throw _objectSpread2(_objectSpread2({}, errData), {}, {
                  status: '404'
                });

              case 21:
                throw errData;

              case 22:
                return _context56.abrupt("return", parsedResponse);

              case 23:
              case "end":
                return _context56.stop();
            }
          }
        }, _callee56, this, [[3, 12]]);
      }));

      function _performRequestWithMonitoring(_x75, _x76) {
        return _performRequestWithMonitoring2.apply(this, arguments);
      }

      return _performRequestWithMonitoring;
    }()
    /**
     * Gets how many blocks behind a discovery node is.
     * If this method throws (missing data in health check response),
     * return an unhealthy number of blocks
     * @param parsedResponse health check response object
     * @returns a number of blocks if behind or null if not behind
     */

  }, {
    key: "_getBlocksBehind",
    value: function () {
      var _getBlocksBehind2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee57(parsedResponse) {
        var indexedBlock, chainBlock, blockDiff;
        return regeneratorRuntime.wrap(function _callee57$(_context57) {
          while (1) {
            switch (_context57.prev = _context57.next) {
              case 0:
                _context57.prev = 0;
                indexedBlock = parsedResponse.latest_indexed_block, chainBlock = parsedResponse.latest_chain_block;
                blockDiff = chainBlock - indexedBlock;

                if (!(blockDiff > this.unhealthyBlockDiff)) {
                  _context57.next = 5;
                  break;
                }

                return _context57.abrupt("return", blockDiff);

              case 5:
                return _context57.abrupt("return", null);

              case 8:
                _context57.prev = 8;
                _context57.t0 = _context57["catch"](0);
                console.error(_context57.t0);
                return _context57.abrupt("return", this.unhealthyBlockDiff);

              case 12:
              case "end":
                return _context57.stop();
            }
          }
        }, _callee57, this, [[0, 8]]);
      }));

      function _getBlocksBehind(_x77) {
        return _getBlocksBehind2.apply(this, arguments);
      }

      return _getBlocksBehind;
    }()
    /**
     * Gets how many plays slots behind a discovery node is.
     * If this method throws (missing data in health check response),
     * return an unhealthy number of slots
     * @param parsedResponse health check response object
     * @returns a number of slots if behind or null if not behind
     */

  }, {
    key: "_getPlaysSlotsBehind",
    value: function () {
      var _getPlaysSlotsBehind2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee58(parsedResponse) {
        var indexedSlotPlays, chainSlotPlays, slotDiff;
        return regeneratorRuntime.wrap(function _callee58$(_context58) {
          while (1) {
            switch (_context58.prev = _context58.next) {
              case 0:
                if (this.unhealthySlotDiffPlays) {
                  _context58.next = 2;
                  break;
                }

                return _context58.abrupt("return", null);

              case 2:
                _context58.prev = 2;
                indexedSlotPlays = parsedResponse.latest_indexed_slot_plays, chainSlotPlays = parsedResponse.latest_chain_slot_plays;
                slotDiff = chainSlotPlays - indexedSlotPlays;

                if (!(slotDiff > this.unhealthySlotDiffPlays)) {
                  _context58.next = 7;
                  break;
                }

                return _context58.abrupt("return", slotDiff);

              case 7:
                return _context58.abrupt("return", null);

              case 10:
                _context58.prev = 10;
                _context58.t0 = _context58["catch"](2);
                console.error(_context58.t0);
                return _context58.abrupt("return", this.unhealthySlotDiffPlays);

              case 14:
              case "end":
                return _context58.stop();
            }
          }
        }, _callee58, this, [[2, 10]]);
      }));

      function _getPlaysSlotsBehind(_x78) {
        return _getPlaysSlotsBehind2.apply(this, arguments);
      }

      return _getPlaysSlotsBehind;
    }()
    /**
     * Makes a request to a discovery node, reselecting if necessary
     * @param {{
     *  endpoint: string
     *  urlParams: object
     *  queryParams: object
     *  method: string
     *  headers: object
     *  data: object
     * }} {
     *  endpoint: the base route
     *  urlParams: string of URL params to be concatenated after base route
     *  queryParams: URL query (search) params
     *  method: string HTTP method
     * }
     * @param retry whether to retry on failure
     * @param attemptedRetries number of attempted retries (stops retrying at max)
     * @param throwError whether to throw error on error performing request or null
     * @param blockNumber If provided, throws an error if the discovery node has not yet indexed this block
     */

  }, {
    key: "_makeRequest",
    value: function () {
      var _makeRequest2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee59(requestObj) {
        var _yield$this$_makeRequ;

        var retry,
            attemptedRetries,
            throwError,
            blockNumber,
            _args59 = arguments;
        return regeneratorRuntime.wrap(function _callee59$(_context59) {
          while (1) {
            switch (_context59.prev = _context59.next) {
              case 0:
                retry = _args59.length > 1 && _args59[1] !== undefined ? _args59[1] : true;
                attemptedRetries = _args59.length > 2 && _args59[2] !== undefined ? _args59[2] : 0;
                throwError = _args59.length > 3 && _args59[3] !== undefined ? _args59[3] : false;
                blockNumber = _args59.length > 4 ? _args59[4] : undefined;
                _context59.next = 6;
                return this._makeRequestInternal(requestObj, retry, attemptedRetries, throwError, blockNumber);

              case 6:
                _context59.t1 = _yield$this$_makeRequ = _context59.sent;
                _context59.t0 = _context59.t1 === null;

                if (_context59.t0) {
                  _context59.next = 10;
                  break;
                }

                _context59.t0 = _yield$this$_makeRequ === void 0;

              case 10:
                if (!_context59.t0) {
                  _context59.next = 14;
                  break;
                }

                _context59.t2 = void 0;
                _context59.next = 15;
                break;

              case 14:
                _context59.t2 = _yield$this$_makeRequ.data;

              case 15:
                return _context59.abrupt("return", _context59.t2);

              case 16:
              case "end":
                return _context59.stop();
            }
          }
        }, _callee59, this);
      }));

      function _makeRequest(_x79) {
        return _makeRequest2.apply(this, arguments);
      }

      return _makeRequest;
    }()
    /**
     * Makes a request to a discovery node, reselecting if necessary
     *  endpoint: the base route
     *  urlParams: string of URL params to be concatenated after base route
     *  queryParams: URL query (search) params
     *  method: string HTTP method
     * }
     * @param retry whether to retry on failure
     * @param attemptedRetries number of attempted retries (stops retrying at max)
     * @param throwError whether to throw error on error performing request or null
     * @param blockNumber If provided, throws an error if the discovery node has not yet indexed this block
     */

  }, {
    key: "_makeRequestInternal",
    value: function () {
      var _makeRequestInternal2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee60(requestObj) {
        var retry,
            attemptedRetries,
            throwError,
            blockNumber,
            _args60 = arguments;
        return regeneratorRuntime.wrap(function _callee60$(_context60) {
          while (1) {
            switch (_context60.prev = _context60.next) {
              case 0:
                retry = _args60.length > 1 && _args60[1] !== undefined ? _args60[1] : true;
                attemptedRetries = _args60.length > 2 && _args60[2] !== undefined ? _args60[2] : 0;
                throwError = _args60.length > 3 && _args60[3] !== undefined ? _args60[3] : false;
                blockNumber = _args60.length > 4 ? _args60[4] : undefined;

                if (!this.discoveryNodeSelector) {
                  _context60.next = 8;
                  break;
                }

                _context60.next = 7;
                return this._makeRequestInternalNext(requestObj, throwError, blockNumber);

              case 7:
                return _context60.abrupt("return", _context60.sent);

              case 8:
                _context60.next = 10;
                return this._makeRequestInternalLegacy(requestObj, retry, attemptedRetries, throwError, blockNumber);

              case 10:
                return _context60.abrupt("return", _context60.sent);

              case 11:
              case "end":
                return _context60.stop();
            }
          }
        }, _callee60, this);
      }));

      function _makeRequestInternal(_x80) {
        return _makeRequestInternal2.apply(this, arguments);
      }

      return _makeRequestInternal;
    }()
  }, {
    key: "_makeRequestInternalLegacy",
    value: function () {
      var _makeRequestInternalLegacy2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee61(requestObj) {
        var retry,
            attemptedRetries,
            throwError,
            blockNumber,
            returnOrThrow,
            newDiscProvEndpoint,
            updateDiscProvEndpointMsg,
            parsedResponse,
            error,
            failureStr,
            attemptStr,
            errorStr,
            requestStr,
            fullErrString,
            notInRegressedMode,
            blockDiff,
            errorMessage,
            playsSlotDiff,
            _errorMessage,
            _args61 = arguments;

        return regeneratorRuntime.wrap(function _callee61$(_context61) {
          while (1) {
            switch (_context61.prev = _context61.next) {
              case 0:
                retry = _args61.length > 1 && _args61[1] !== undefined ? _args61[1] : true;
                attemptedRetries = _args61.length > 2 && _args61[2] !== undefined ? _args61[2] : 0;
                throwError = _args61.length > 3 && _args61[3] !== undefined ? _args61[3] : false;
                blockNumber = _args61.length > 4 ? _args61[4] : undefined;

                returnOrThrow = function returnOrThrow(e) {
                  if (throwError) {
                    // eslint-disable-next-line @typescript-eslint/no-throw-literal
                    throw e;
                  }

                  return null;
                };

                _context61.prev = 5;
                _context61.next = 8;
                return this.getHealthyDiscoveryProviderEndpoint(attemptedRetries);

              case 8:
                newDiscProvEndpoint = _context61.sent;

                // If new DP endpoint is selected, update disc prov endpoint and reset attemptedRetries count
                if (this.discoveryProviderEndpoint !== newDiscProvEndpoint) {
                  updateDiscProvEndpointMsg = "Current Discovery Provider endpoint ".concat(this.discoveryProviderEndpoint, " is unhealthy. ");
                  updateDiscProvEndpointMsg += "Switching over to the new Discovery Provider endpoint ".concat(newDiscProvEndpoint, "!");
                  console.info(updateDiscProvEndpointMsg);
                  this.discoveryProviderEndpoint = newDiscProvEndpoint;
                  attemptedRetries = 0;
                }

                _context61.next = 16;
                break;

              case 12:
                _context61.prev = 12;
                _context61.t0 = _context61["catch"](5);
                console.error(_context61.t0);
                return _context61.abrupt("return");

              case 16:
                _context61.prev = 16;
                _context61.next = 19;
                return this._performRequestWithMonitoring(requestObj, this.discoveryProviderEndpoint);

              case 19:
                parsedResponse = _context61.sent;
                _context61.next = 46;
                break;

              case 22:
                _context61.prev = 22;
                _context61.t1 = _context61["catch"](16);
                error = _context61.t1;
                failureStr = 'Failed to make Discovery Provider request, ';
                attemptStr = "attempt #".concat(attemptedRetries, ", ");
                errorStr = "error ".concat(JSON.stringify(error.message), ", ");
                requestStr = "request: ".concat(JSON.stringify(requestObj));
                fullErrString = "".concat(failureStr).concat(attemptStr).concat(errorStr).concat(requestStr);
                console.warn(fullErrString);

                if (!retry) {
                  _context61.next = 45;
                  break;
                }

                if (!(error.status === '404')) {
                  _context61.next = 42;
                  break;
                }

                this.request404Count += 1;

                if (!(this.request404Count < this.maxRequestsForTrue404)) {
                  _context61.next = 40;
                  break;
                }

                _context61.next = 37;
                return this._makeRequestInternalLegacy(requestObj, retry, this.selectionRequestRetries + 1, throwError);

              case 37:
                return _context61.abrupt("return", _context61.sent);

              case 40:
                this.request404Count = 0;
                return _context61.abrupt("return", returnOrThrow(_context61.t1));

              case 42:
                _context61.next = 44;
                return this._makeRequestInternalLegacy(requestObj, retry, attemptedRetries + 1, throwError);

              case 44:
                return _context61.abrupt("return", _context61.sent);

              case 45:
                return _context61.abrupt("return", returnOrThrow(_context61.t1));

              case 46:
                // Validate health check response
                // Regressed mode signals we couldn't find a node that wasn't behind by some measure
                // so we should should pick something
                notInRegressedMode = this.ethContracts && !this.ethContracts.isInRegressedMode();
                _context61.next = 49;
                return this._getBlocksBehind(parsedResponse);

              case 49:
                blockDiff = _context61.sent;

                if (!(blockNumber && parsedResponse.latest_indexed_block < blockNumber)) {
                  _context61.next = 52;
                  break;
                }

                throw new Error("Requested blocknumber ".concat(blockNumber, ", but discovery is behind at ").concat(parsedResponse.latest_indexed_block));

              case 52:
                if (!(notInRegressedMode && blockDiff)) {
                  _context61.next = 60;
                  break;
                }

                errorMessage = "".concat(this.discoveryProviderEndpoint, " is too far behind [block diff: ").concat(blockDiff, "]");

                if (!retry) {
                  _context61.next = 59;
                  break;
                }

                console.info("".concat(errorMessage, ". Retrying request at attempt #").concat(attemptedRetries, "..."));
                _context61.next = 58;
                return this._makeRequestInternalLegacy(requestObj, retry, attemptedRetries + 1, throwError);

              case 58:
                return _context61.abrupt("return", _context61.sent);

              case 59:
                return _context61.abrupt("return", returnOrThrow(new Error(errorMessage)));

              case 60:
                _context61.next = 62;
                return this._getPlaysSlotsBehind(parsedResponse);

              case 62:
                playsSlotDiff = _context61.sent;

                if (!(notInRegressedMode && playsSlotDiff)) {
                  _context61.next = 71;
                  break;
                }

                _errorMessage = "".concat(this.discoveryProviderEndpoint, " is too far behind [slot diff: ").concat(playsSlotDiff, "]");

                if (!retry) {
                  _context61.next = 70;
                  break;
                }

                console.info("".concat(_errorMessage, ". Retrying request at attempt #").concat(attemptedRetries, "..."));
                _context61.next = 69;
                return this._makeRequestInternalLegacy(requestObj, retry, attemptedRetries + 1, throwError);

              case 69:
                return _context61.abrupt("return", _context61.sent);

              case 70:
                return _context61.abrupt("return", returnOrThrow(new Error(_errorMessage)));

              case 71:
                // Reset 404 counts
                this.request404Count = 0; // Everything looks good, return the data!

                return _context61.abrupt("return", parsedResponse);

              case 73:
              case "end":
                return _context61.stop();
            }
          }
        }, _callee61, this, [[5, 12], [16, 22]]);
      }));

      function _makeRequestInternalLegacy(_x81) {
        return _makeRequestInternalLegacy2.apply(this, arguments);
      }

      return _makeRequestInternalLegacy;
    }()
  }, {
    key: "_makeRequestInternalNext",
    value: function () {
      var _makeRequestInternalNext2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee62(requestObj) {
        var _yield$this$discovery, _this$discoveryNodeMi, _this$discoveryNodeMi2, _yield$this$discovery3, _this$discoveryNodeMi5, _this$discoveryNodeMi6;

        var throwError,
            blockNumber,
            axiosRequest,
            data,
            _axiosRequest$url2,
            url,
            restRequest,
            fetchRequestInit,
            fetchParams,
            response,
            _yield$this$discovery2,
            _this$discoveryNodeMi3,
            _this$discoveryNodeMi4,
            responseBody,
            _args62 = arguments;

        return regeneratorRuntime.wrap(function _callee62$(_context62) {
          while (1) {
            switch (_context62.prev = _context62.next) {
              case 0:
                throwError = _args62.length > 1 && _args62[1] !== undefined ? _args62[1] : false;
                blockNumber = _args62.length > 2 ? _args62[2] : undefined;

                if (!(!this.discoveryProviderEndpoint || !this.discoveryNodeMiddleware)) {
                  _context62.next = 4;
                  break;
                }

                return _context62.abrupt("return");

              case 4:
                axiosRequest = this._createDiscProvRequest(requestObj, this.discoveryProviderEndpoint);
                data = axiosRequest.data, _axiosRequest$url2 = axiosRequest.url, url = _axiosRequest$url2 === void 0 ? '' : _axiosRequest$url2, restRequest = _objectWithoutProperties(axiosRequest, _excluded);
                fetchRequestInit = _objectSpread2({
                  body: data ? JSON.stringify(data) : data
                }, restRequest);
                fetchParams = {
                  url: url,
                  init: fetchRequestInit
                };
                _context62.next = 10;
                return (_this$discoveryNodeMi = (_this$discoveryNodeMi2 = this.discoveryNodeMiddleware).pre) === null || _this$discoveryNodeMi === void 0 ? void 0 : _this$discoveryNodeMi.call(_this$discoveryNodeMi2, _objectSpread2({
                  fetch: fetch__default["default"]
                }, fetchParams));

              case 10:
                _context62.t1 = _yield$this$discovery = _context62.sent;
                _context62.t0 = _context62.t1 !== null;

                if (!_context62.t0) {
                  _context62.next = 14;
                  break;
                }

                _context62.t0 = _yield$this$discovery !== void 0;

              case 14:
                if (!_context62.t0) {
                  _context62.next = 18;
                  break;
                }

                _context62.t2 = _yield$this$discovery;
                _context62.next = 19;
                break;

              case 18:
                _context62.t2 = fetchParams;

              case 19:
                fetchParams = _context62.t2;
                _context62.prev = 20;
                _context62.next = 23;
                return fetch__default["default"](fetchParams.url, fetchParams.init);

              case 23:
                response = _context62.sent;
                _context62.next = 48;
                break;

              case 26:
                _context62.prev = 26;
                _context62.t3 = _context62["catch"](20);
                _context62.next = 30;
                return (_this$discoveryNodeMi3 = (_this$discoveryNodeMi4 = this.discoveryNodeMiddleware).onError) === null || _this$discoveryNodeMi3 === void 0 ? void 0 : _this$discoveryNodeMi3.call(_this$discoveryNodeMi4, _objectSpread2(_objectSpread2({
                  fetch: fetch__default["default"]
                }, fetchParams), {}, {
                  error: _context62.t3,
                  response: response ? response.clone() : undefined
                }));

              case 30:
                _context62.t5 = _yield$this$discovery2 = _context62.sent;
                _context62.t4 = _context62.t5 !== null;

                if (!_context62.t4) {
                  _context62.next = 34;
                  break;
                }

                _context62.t4 = _yield$this$discovery2 !== void 0;

              case 34:
                if (!_context62.t4) {
                  _context62.next = 38;
                  break;
                }

                _context62.t6 = _yield$this$discovery2;
                _context62.next = 39;
                break;

              case 38:
                _context62.t6 = response;

              case 39:
                response = _context62.t6;

                if (!(response === undefined)) {
                  _context62.next = 48;
                  break;
                }

                if (!throwError) {
                  _context62.next = 47;
                  break;
                }

                if (!(_context62.t3 instanceof Error)) {
                  _context62.next = 46;
                  break;
                }

                throw new FetchError$1(_context62.t3, 'The request failed and the interceptors did not return an alternative response');

              case 46:
                throw _context62.t3;

              case 47:
                return _context62.abrupt("return", null);

              case 48:
                _context62.next = 50;
                return (_this$discoveryNodeMi5 = (_this$discoveryNodeMi6 = this.discoveryNodeMiddleware).post) === null || _this$discoveryNodeMi5 === void 0 ? void 0 : _this$discoveryNodeMi5.call(_this$discoveryNodeMi6, _objectSpread2(_objectSpread2({
                  fetch: fetch__default["default"]
                }, fetchParams), {}, {
                  response: response
                }));

              case 50:
                _context62.t8 = _yield$this$discovery3 = _context62.sent;
                _context62.t7 = _context62.t8 !== null;

                if (!_context62.t7) {
                  _context62.next = 54;
                  break;
                }

                _context62.t7 = _yield$this$discovery3 !== void 0;

              case 54:
                if (!_context62.t7) {
                  _context62.next = 58;
                  break;
                }

                _context62.t9 = _yield$this$discovery3;
                _context62.next = 59;
                break;

              case 58:
                _context62.t9 = response;

              case 59:
                response = _context62.t9;
                _context62.next = 62;
                return response.json();

              case 62:
                responseBody = _context62.sent;

                if (!(blockNumber && responseBody.latest_indexed_block < blockNumber)) {
                  _context62.next = 65;
                  break;
                }

                throw new Error("Requested blocknumber ".concat(blockNumber, ", but discovery is behind at ").concat(responseBody.latest_indexed_block));

              case 65:
                return _context62.abrupt("return", responseBody);

              case 66:
              case "end":
                return _context62.stop();
            }
          }
        }, _callee62, this, [[20, 26]]);
      }));

      function _makeRequestInternalNext(_x82) {
        return _makeRequestInternalNext2.apply(this, arguments);
      }

      return _makeRequestInternalNext;
    }()
    /**
     * Gets the healthy discovery provider endpoint used in creating the axios request later.
     * If the number of retries is over the max count for retires, clear the cache and reselect
     * another healthy discovery provider. Else, return the current discovery provider endpoint
     * @param attemptedRetries the number of attempted requests made to the current disc prov endpoint
     */

  }, {
    key: "getHealthyDiscoveryProviderEndpoint",
    value: function () {
      var _getHealthyDiscoveryProviderEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee63(attemptedRetries) {
        var endpoint;
        return regeneratorRuntime.wrap(function _callee63$(_context63) {
          while (1) {
            switch (_context63.prev = _context63.next) {
              case 0:
                endpoint = this.discoveryProviderEndpoint;

                if (!(attemptedRetries > this.selectionRequestRetries || !endpoint)) {
                  _context63.next = 8;
                  break;
                }

                // Add to unhealthy list if current disc prov endpoint has reached max retry count
                console.info("Attempted max retries with endpoint ".concat(endpoint));
                this.serviceSelector.addUnhealthy(endpoint); // Clear the cached endpoint and select new endpoint from backups

                this.serviceSelector.clearCached();
                _context63.next = 7;
                return this.serviceSelector.select();

              case 7:
                endpoint = _context63.sent;

              case 8:
                if (endpoint) {
                  _context63.next = 10;
                  break;
                }

                throw new Error('All Discovery Providers are unhealthy and unavailable.');

              case 10:
                return _context63.abrupt("return", endpoint);

              case 11:
              case "end":
                return _context63.stop();
            }
          }
        }, _callee63, this);
      }));

      function getHealthyDiscoveryProviderEndpoint(_x83) {
        return _getHealthyDiscoveryProviderEndpoint.apply(this, arguments);
      }

      return getHealthyDiscoveryProviderEndpoint;
    }()
    /**
     * Creates the discovery provider axios request object with necessary configs
     * @param requestObj
     * @param discoveryProviderEndpoint
     */

  }, {
    key: "_createDiscProvRequest",
    value: function _createDiscProvRequest(requestObj, discoveryProviderEndpoint) {
      var _requestObj$timeout, _requestObj$method, _requestObj$responseT;

      // Sanitize URL params if needed
      if (requestObj.queryParams) {
        Object.entries(requestObj.queryParams).forEach(function (_ref4) {
          var _ref5 = _slicedToArray(_ref4, 2),
              k = _ref5[0],
              v = _ref5[1];

          if (v === undefined || v === null) {
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete requestObj.queryParams[k];
          }
        });
      }

      var requestUrl = urlJoin__default["default"](discoveryProviderEndpoint, requestObj.endpoint, requestObj.urlParams, {
        query: requestObj.queryParams
      });
      var headers = {};

      if (requestObj.headers) {
        headers = requestObj.headers;
      }

      var currentUserId = this.userStateManager.getCurrentUserId();

      if (currentUserId) {
        headers['X-User-ID'] = currentUserId;
      }

      var timeout = (_requestObj$timeout = requestObj.timeout) !== null && _requestObj$timeout !== void 0 ? _requestObj$timeout : this.selectionRequestTimeout;
      var axiosRequest = {
        url: requestUrl,
        headers: headers,
        method: (_requestObj$method = requestObj.method) !== null && _requestObj$method !== void 0 ? _requestObj$method : 'get',
        responseType: (_requestObj$responseT = requestObj.responseType) !== null && _requestObj$responseT !== void 0 ? _requestObj$responseT : 'json',
        timeout: timeout
      };

      if (requestObj.method === 'post' && requestObj.data) {
        axiosRequest = _objectSpread2(_objectSpread2({}, axiosRequest), {}, {
          data: requestObj.data
        });
      }

      return axiosRequest;
    }
  }]);

  return DiscoveryProvider;
}();

/** Singleton state-manager for audius wormhole interaction */

var Wormhole = /*#__PURE__*/function () {
  function Wormhole(hedgehog, ethWeb3Manager, ethContracts, identityService, solanaWeb3Manager, rpcHosts, solBridgeAddress, solTokenBridgeAddress, ethBridgeAddress, ethTokenBridgeAddress) {
    _classCallCheck(this, Wormhole);

    _defineProperty$1(this, "hedgehog", void 0);

    _defineProperty$1(this, "ethWeb3Manager", void 0);

    _defineProperty$1(this, "ethContracts", void 0);

    _defineProperty$1(this, "identityService", void 0);

    _defineProperty$1(this, "solanaWeb3Manager", void 0);

    _defineProperty$1(this, "rpcHosts", void 0);

    _defineProperty$1(this, "solBridgeAddress", void 0);

    _defineProperty$1(this, "solTokenBridgeAddress", void 0);

    _defineProperty$1(this, "ethBridgeAddress", void 0);

    _defineProperty$1(this, "ethTokenBridgeAddress", void 0);

    _defineProperty$1(this, "wormholeSDK", void 0);

    // Wormhole service dependecies
    this.hedgehog = hedgehog;
    this.ethWeb3Manager = ethWeb3Manager;
    this.ethContracts = ethContracts;
    this.identityService = identityService;
    this.solanaWeb3Manager = solanaWeb3Manager; // Wormhole config

    this.rpcHosts = rpcHosts;
    this.solBridgeAddress = solBridgeAddress;
    this.solTokenBridgeAddress = solTokenBridgeAddress;
    this.ethBridgeAddress = ethBridgeAddress;
    this.ethTokenBridgeAddress = ethTokenBridgeAddress;
    this.wormholeSDK = wormholeSDK__default["default"];
  }

  _createClass(Wormhole, [{
    key: "getSignedVAAWithRetry",
    value: function () {
      var _getSignedVAAWithRetry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(hosts, emitterChain, emitterAddress, sequence) {
        var extraGrpcOpts,
            retryTimeout,
            retryAttempts,
            currentWormholeRpcHost,
            getNextRpcHost,
            result,
            attempts,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                extraGrpcOpts = _args.length > 4 && _args[4] !== undefined ? _args[4] : {};
                retryTimeout = _args.length > 5 && _args[5] !== undefined ? _args[5] : 5000;
                retryAttempts = _args.length > 6 && _args[6] !== undefined ? _args[6] : 60;
                currentWormholeRpcHost = -1;

                getNextRpcHost = function getNextRpcHost() {
                  return ++currentWormholeRpcHost % hosts.length;
                };

                attempts = 0;

              case 6:
                if (result) {
                  _context.next = 22;
                  break;
                }

                attempts++;
                _context.next = 10;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, retryTimeout);
                });

              case 10:
                _context.prev = 10;
                _context.next = 13;
                return this.wormholeSDK.getSignedVAA(hosts[getNextRpcHost()], emitterChain, emitterAddress, sequence, extraGrpcOpts);

              case 13:
                result = _context.sent;
                _context.next = 20;
                break;

              case 16:
                _context.prev = 16;
                _context.t0 = _context["catch"](10);

                if (!(retryAttempts !== undefined && attempts > retryAttempts)) {
                  _context.next = 20;
                  break;
                }

                throw _context.t0;

              case 20:
                _context.next = 6;
                break;

              case 22:
                return _context.abrupt("return", result);

              case 23:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[10, 16]]);
      }));

      function getSignedVAAWithRetry(_x, _x2, _x3, _x4) {
        return _getSignedVAAWithRetry.apply(this, arguments);
      }

      return getSignedVAAWithRetry;
    }()
    /**
     * Sends `amount` tokens to `solanaAccount` by way of the wormhole
     */

  }, {
    key: "attestAndCompleteTransferEthToSol",
    value: function () {
      var _attestAndCompleteTransferEthToSol = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(ethTxReceipt, customSignTransaction) {
        var _this = this;

        var options,
            phases,
            phase,
            logs,
            receipt,
            sequence,
            emitterAddress,
            _yield$this$getSigned,
            vaaBytes,
            connection,
            signTransaction,
            transaction,
            finalTxSignature,
            signedTransaction,
            txid,
            _yield$connection$get2,
            blockhash,
            transactionData,
            _yield$this$identityS,
            transactionSignature,
            _args5 = arguments;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                options = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};
                phases = {
                  GET_RECEIPT: 'GET_RECEIPT',
                  GET_SIGNED_VAA: 'GET_SIGNED_VAA',
                  POST_VAA_SOLANA: 'POST_VAA_SOLANA',
                  REDEEM_ON_SOLANA: 'REDEEM_ON_SOLANA'
                };
                phase = phases.GET_RECEIPT;
                logs = ["Attest and complete transfer for eth to sol for reciept ".concat(ethTxReceipt)];
                _context5.prev = 4;
                _context5.next = 7;
                return this.ethWeb3Manager.web3.eth.getTransactionReceipt(ethTxReceipt);

              case 7:
                receipt = _context5.sent;
                sequence = this.wormholeSDK.parseSequenceFromLogEth(receipt, this.ethBridgeAddress);
                emitterAddress = this.wormholeSDK.getEmitterAddressEth(this.ethTokenBridgeAddress);
                phase = phases.GET_SIGNED_VAA;
                _context5.next = 13;
                return this.getSignedVAAWithRetry(this.rpcHosts, this.wormholeSDK.CHAIN_ID_ETH, emitterAddress, sequence, options);

              case 13:
                _yield$this$getSigned = _context5.sent;
                vaaBytes = _yield$this$getSigned.vaaBytes;
                connection = this.solanaWeb3Manager.connection;

                if (!customSignTransaction) {
                  _context5.next = 20;
                  break;
                }

                signTransaction = customSignTransaction;
                _context5.next = 25;
                break;

              case 20:
                if (this.identityService) {
                  _context5.next = 22;
                  break;
                }

                throw new Error('Identity service required to relay raw transaction');

              case 22:
                signTransaction = /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(transaction) {
                    var _yield$connection$get, blockhash, transactionData, _yield$_this$identity, transactionSignature, signedTransaction;

                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return connection.getLatestBlockhash();

                          case 2:
                            _yield$connection$get = _context2.sent;
                            blockhash = _yield$connection$get.blockhash;
                            // Must call serialize message to set the correct signatures on the transaction
                            transaction.serializeMessage();
                            transactionData = {
                              recentBlockhash: blockhash,
                              instructions: transaction.instructions.map(SolanaUtils.prepareInstructionForRelay),
                              signatures: transaction.signatures.map(function (sig) {
                                return {
                                  publicKey: sig.publicKey.toString(),
                                  signature: sig.signature
                                };
                              })
                            };
                            _context2.next = 8;
                            return _this.identityService.solanaRelayRaw(transactionData);

                          case 8:
                            _yield$_this$identity = _context2.sent;
                            transactionSignature = _yield$_this$identity.transactionSignature;
                            logs.push("Relay sol tx for postVAA with signature ".concat(transactionSignature));
                            signedTransaction = {
                              serialize: function serialize() {}
                            };
                            return _context2.abrupt("return", signedTransaction);

                          case 13:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function signTransaction(_x7) {
                    return _ref.apply(this, arguments);
                  };
                }();

                connection.sendRawTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                  return regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          return _context3.abrupt("return", '');

                        case 1:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                }));
                connection.confirmTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                  return regeneratorRuntime.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          return _context4.abrupt("return", '');

                        case 1:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                }));

              case 25:
                phase = phases.POST_VAA_SOLANA;
                _context5.next = 28;
                return this.wormholeSDK.postVaaSolana(connection, signTransaction, this.solBridgeAddress, this.solanaWeb3Manager.feePayerAddress.toString(), // payerAddress
                vaaBytes);

              case 28:
                // Finally, redeem on Solana
                phase = phases.REDEEM_ON_SOLANA;
                _context5.next = 31;
                return this.wormholeSDK.redeemOnSolana(connection, this.solBridgeAddress, this.solTokenBridgeAddress, this.solanaWeb3Manager.feePayerAddress.toString(), // payerAddress,
                vaaBytes);

              case 31:
                transaction = _context5.sent;

                if (!customSignTransaction) {
                  _context5.next = 44;
                  break;
                }

                _context5.next = 35;
                return signTransaction(transaction);

              case 35:
                signedTransaction = _context5.sent;
                _context5.next = 38;
                return connection.sendRawTransaction(signedTransaction.serialize());

              case 38:
                txid = _context5.sent;
                finalTxSignature = txid;
                _context5.next = 42;
                return connection.confirmTransaction(txid);

              case 42:
                _context5.next = 57;
                break;

              case 44:
                if (this.identityService) {
                  _context5.next = 46;
                  break;
                }

                throw new Error('Identity service required to relay raw transaction');

              case 46:
                transaction.serializeMessage();
                _context5.next = 49;
                return connection.getLatestBlockhash();

              case 49:
                _yield$connection$get2 = _context5.sent;
                blockhash = _yield$connection$get2.blockhash;
                transactionData = {
                  recentBlockhash: blockhash,
                  instructions: transaction.instructions.map(SolanaUtils.prepareInstructionForRelay),
                  signatures: transaction.signatures.map(function (sig) {
                    return {
                      publicKey: sig.publicKey.toString(),
                      signature: sig.signature
                    };
                  })
                };
                _context5.next = 54;
                return this.identityService.solanaRelayRaw(transactionData);

              case 54:
                _yield$this$identityS = _context5.sent;
                transactionSignature = _yield$this$identityS.transactionSignature;
                finalTxSignature = transactionSignature;

              case 57:
                logs.push("Complete redeem on sol with signature ".concat(finalTxSignature));
                return _context5.abrupt("return", {
                  transactionSignature: finalTxSignature,
                  error: null,
                  phase: phase,
                  logs: logs
                });

              case 61:
                _context5.prev = 61;
                _context5.t0 = _context5["catch"](4);
                return _context5.abrupt("return", {
                  error: _context5.t0.message,
                  phase: phase,
                  logs: logs
                });

              case 64:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[4, 61]]);
      }));

      function attestAndCompleteTransferEthToSol(_x5, _x6) {
        return _attestAndCompleteTransferEthToSol.apply(this, arguments);
      }

      return attestAndCompleteTransferEthToSol;
    }()
    /**
     * Sends `amount` tokens to `solanaAccount` by way of the wormhole
     */

  }, {
    key: "sendTokensFromSolToEthViaWormhole",
    value: function () {
      var _sendTokensFromSolToEthViaWormhole = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(amount, ethTargetAddress) {
        var options,
            phases,
            phase,
            logs,
            _this$hedgehog$wallet,
            wAudioAmount,
            rootSolanaAccount,
            solanaAddress,
            associatedTokenAccount,
            tokenAccountInfo,
            connection,
            tx,
            _yield$connection$get3,
            blockhash,
            transactionData,
            _yield$this$identityS2,
            transactionSignature,
            info,
            sequence,
            emitterAddress,
            _yield$this$getSigned2,
            vaaBytes,
            signer,
            _args6 = arguments;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                options = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : {};

                if (this.hedgehog) {
                  _context6.next = 3;
                  break;
                }

                throw new Error('Hedgehog required for sendTokensFromSolToEthViaWormhole');

              case 3:
                if (this.identityService) {
                  _context6.next = 5;
                  break;
                }

                throw new Error('Identity service required to relay raw transaction');

              case 5:
                phases = {
                  GENERATE_SOL_ROOT_ACCT: 'GENERATE_SOL_ROOT_ACCT',
                  TRANSFER_WAUDIO_TO_ROOT: 'TRANSFER_WAUDIO_TO_ROOT',
                  TRANFER_FROM_SOL: 'TRANFER_FROM_SOL',
                  GET_SIGNED_VAA: 'GET_SIGNED_VAA',
                  GET_EMITTER_ADDR: 'GET_EMITTER_ADDR',
                  REDEEM_ON_ETH: 'REDEEM_ON_ETH'
                };
                phase = phases.GENERATE_SOL_ROOT_ACCT;
                logs = ["Transferring ".concat(amount, " WAUDIO to ").concat(ethTargetAddress)];
                _context6.prev = 8;

                if (!(typeof window === 'undefined' || window == null || // @ts-expect-error
                window.ethereum == null)) {
                  _context6.next = 11;
                  break;
                }

                throw new Error('Expected a browser/client context with Metamask');

              case 11:
                wAudioAmount = wAudioFromWeiAudio(amount); // Generate a solana keypair derived from the hedgehog private key
                // NOTE: The into to fromSeed is a 32 bytes Uint8Array

                rootSolanaAccount = this.solanaWeb3Manager.solanaWeb3.Keypair.fromSeed((_this$hedgehog$wallet = this.hedgehog.wallet) === null || _this$hedgehog$wallet === void 0 ? void 0 : _this$hedgehog$wallet.getPrivateKey());
                solanaAddress = rootSolanaAccount.publicKey.toString();
                logs.push("Root Solana Account: ".concat(solanaAddress)); // Find the token account owned by the root solana account and get the token account's info

                _context6.next = 17;
                return this.solanaWeb3Manager.findAssociatedTokenAddress(solanaAddress);

              case 17:
                associatedTokenAccount = _context6.sent;
                _context6.next = 20;
                return this.solanaWeb3Manager.getTokenAccountInfo(associatedTokenAccount.toString());

              case 20:
                tokenAccountInfo = _context6.sent;

                if (tokenAccountInfo) {
                  _context6.next = 27;
                  break;
                }

                logs.push("Creating Associated Token Account: ".concat(associatedTokenAccount.toString()));
                _context6.next = 25;
                return this.solanaWeb3Manager.createAssociatedTokenAccount(solanaAddress);

              case 25:
                _context6.next = 28;
                break;

              case 27:
                logs.push("Associated Token Account Exits: ".concat(associatedTokenAccount.toString()));

              case 28:
                phase = phases.TRANSFER_WAUDIO_TO_ROOT; // Move wrapped audio from then user bank account to the user's token wallet

                _context6.next = 31;
                return this.solanaWeb3Manager.transferWAudio(tokenAccountInfo.address.toString(), amount);

              case 31:
                logs.push("Transferred waudio ".concat(wAudioAmount.toString(), " balance to associated token account"));
                phase = phases.TRANFER_FROM_SOL;
                connection = this.solanaWeb3Manager.connection; // Submit transaction - results in a Wormhole message being published

                _context6.next = 36;
                return this.wormholeSDK.transferFromSolana(connection, // solana web3 Connection
                this.solBridgeAddress, // bridge address
                this.solTokenBridgeAddress, // token bridge address
                this.solanaWeb3Manager.feePayerAddress, // payerAddress
                tokenAccountInfo.address.toString(), // fromAddress
                this.solanaWeb3Manager.mints.audio.toString(), // mintAddress
                wAudioAmount, // BigInt
                utils.zeroPad(ethereumjsUtil.toBuffer(ethTargetAddress), 32), // Uint8Array of length 32 targetAddress
                this.wormholeSDK.CHAIN_ID_ETH, // ChainId targetChain
                utils.zeroPad(ethereumjsUtil.toBuffer(this.ethContracts.AudiusTokenClient.contractAddress), 32), // Uint8Array of length 32 originAddress
                this.wormholeSDK.CHAIN_ID_ETH, //  ChainId originChain
                solanaAddress // from owner address
                );

              case 36:
                tx = _context6.sent;
                // Must call serialize message to set the correct signatures on the transaction
                tx.serializeMessage();
                tx.partialSign(rootSolanaAccount);
                _context6.next = 41;
                return connection.getLatestBlockhash();

              case 41:
                _yield$connection$get3 = _context6.sent;
                blockhash = _yield$connection$get3.blockhash;
                transactionData = {
                  recentBlockhash: blockhash,
                  instructions: tx.instructions.map(SolanaUtils.prepareInstructionForRelay),
                  signatures: tx.signatures.map(function (sig) {
                    return {
                      publicKey: sig.publicKey.toString(),
                      signature: sig.signature
                    };
                  })
                };
                _context6.next = 46;
                return this.identityService.solanaRelayRaw(transactionData);

              case 46:
                _yield$this$identityS2 = _context6.sent;
                transactionSignature = _yield$this$identityS2.transactionSignature;
                logs.push("Transferred to wormhole with signature: ".concat(transactionSignature));
                phase = phases.GET_EMITTER_ADDR; // Get the sequence number and emitter address required to fetch the signedVAA of our message

                _context6.next = 52;
                return connection.getTransaction(transactionSignature);

              case 52:
                info = _context6.sent;
                sequence = this.wormholeSDK.parseSequenceFromLogSolana(info);
                _context6.next = 56;
                return this.wormholeSDK.getEmitterAddressSolana(this.solTokenBridgeAddress);

              case 56:
                emitterAddress = _context6.sent;
                // Fetch the signedVAA from the Wormhole Network (this may require retries while you wait for confirmation)
                phase = phases.GET_SIGNED_VAA;
                _context6.next = 60;
                return this.getSignedVAAWithRetry(this.rpcHosts, this.wormholeSDK.CHAIN_ID_SOLANA, emitterAddress, sequence, options);

              case 60:
                _yield$this$getSigned2 = _context6.sent;
                vaaBytes = _yield$this$getSigned2.vaaBytes;
                // Redeem on Ethereum
                // NOTE: The signer should be the user's personal wallet
                phase = phases.REDEEM_ON_ETH; // @ts-expect-error

                signer = new index$1.providers.Web3Provider(window.ethereum).getSigner();
                _context6.next = 66;
                return this.wormholeSDK.redeemOnEth(this.ethTokenBridgeAddress, signer, vaaBytes);

              case 66:
                logs.push('Redeemed on eth');
                return _context6.abrupt("return", {
                  phase: phase,
                  logs: logs,
                  error: null
                });

              case 70:
                _context6.prev = 70;
                _context6.t0 = _context6["catch"](8);
                return _context6.abrupt("return", {
                  error: _context6.t0.message,
                  phase: phase,
                  logs: logs
                });

              case 73:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[8, 70]]);
      }));

      function sendTokensFromSolToEthViaWormhole(_x8, _x9) {
        return _sendTokensFromSolToEthViaWormhole.apply(this, arguments);
      }

      return sendTokensFromSolToEthViaWormhole;
    }()
    /**
     * Locks assets owned by `fromAccount` into the Solana wormhole with a target
     * solanaAccount destination via the provided relayer wallet.
     */

  }, {
    key: "_getTransferTokensToEthWormholeParams",
    value: function () {
      var _getTransferTokensToEthWormholeParams2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(fromAccount, amount, solanaAccount) {
        var _this$hedgehog$getWal;

        var web3, wormholeClientAddress, chainId, currentBlockNumber, currentBlock, deadline, solanaB58, recipient, nonce, arbiterFee, digest, privateKey, signedDigest;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this.hedgehog) {
                  _context7.next = 2;
                  break;
                }

                throw new Error('Hedgehog required for _getTransferTokensToEthWormholeParams');

              case 2:
                web3 = this.ethWeb3Manager.getWeb3();
                wormholeClientAddress = this.ethContracts.WormholeClient.contractAddress;
                _context7.next = 6;
                return web3.eth.getChainId();

              case 6:
                chainId = _context7.sent;
                _context7.next = 9;
                return web3.eth.getBlockNumber();

              case 9:
                currentBlockNumber = _context7.sent;
                _context7.next = 12;
                return web3.eth.getBlock(currentBlockNumber);

              case 12:
                currentBlock = _context7.sent;
                // 1 hour, sufficiently far in future
                deadline = currentBlock.timestamp + 60 * 60 * 1;
                solanaB58 = bs58__default["default"].decode(solanaAccount).toString('hex');
                recipient = ethereumjsUtil.toBuffer("0x".concat(solanaB58));
                _context7.next = 18;
                return this.ethContracts.WormholeClient.nonces(fromAccount);

              case 18:
                nonce = _context7.sent;
                arbiterFee = Utils.toBN('0');
                digest = getTransferTokensDigest(web3, 'AudiusWormholeClient', wormholeClientAddress, chainId, {
                  from: fromAccount,
                  amount: amount,
                  recipientChain: chainId,
                  recipient: recipient,
                  arbiterFee: arbiterFee
                }, nonce, deadline);
                privateKey = (_this$hedgehog$getWal = this.hedgehog.getWallet()) === null || _this$hedgehog$getWal === void 0 ? void 0 : _this$hedgehog$getWal.getPrivateKey();
                signedDigest = sign(digest, privateKey);
                return _context7.abrupt("return", {
                  chainId: chainId,
                  deadline: deadline,
                  recipient: recipient,
                  arbiterFee: arbiterFee,
                  signedDigest: signedDigest
                });

              case 24:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _getTransferTokensToEthWormholeParams(_x10, _x11, _x12) {
        return _getTransferTokensToEthWormholeParams2.apply(this, arguments);
      }

      return _getTransferTokensToEthWormholeParams;
    }()
    /**
     * Locks assets owned by `fromAccount` into the Solana wormhole with a target
     * solanaAccount destination via the provided relayer wallet.
     * @param fromAccount the account holding the ETH AUDIO to transfer
     * @param amount The amount of AUDIO to send in WEI (18 decimals)
     * @param solanaAccount The solana token account
     * @param relayer The eth relayer to permission to aprrove and transfer
     */

  }, {
    key: "transferTokensToEthWormhole",
    value: function () {
      var _transferTokensToEthWormhole = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(fromAccount, amount, solanaAccount, relayer) {
        var _yield$this$_getTrans, chainId, deadline, recipient, arbiterFee, signedDigest, tx;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._getTransferTokensToEthWormholeParams(fromAccount, amount, solanaAccount);

              case 2:
                _yield$this$_getTrans = _context8.sent;
                chainId = _yield$this$_getTrans.chainId;
                deadline = _yield$this$_getTrans.deadline;
                recipient = _yield$this$_getTrans.recipient;
                arbiterFee = _yield$this$_getTrans.arbiterFee;
                signedDigest = _yield$this$_getTrans.signedDigest;
                _context8.next = 10;
                return this.ethContracts.WormholeClient.transferTokens(fromAccount, amount, chainId, recipient, arbiterFee, deadline, signedDigest, relayer);

              case 10:
                tx = _context8.sent;
                return _context8.abrupt("return", tx);

              case 12:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function transferTokensToEthWormhole(_x13, _x14, _x15, _x16) {
        return _transferTokensToEthWormhole.apply(this, arguments);
      }

      return transferTokensToEthWormhole;
    }()
  }, {
    key: "getTransferTokensToEthWormholeMethod",
    value: function () {
      var _getTransferTokensToEthWormholeMethod = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(fromAccount, amount, solanaAccount) {
        var _yield$this$_getTrans2, chainId, deadline, recipient, arbiterFee, signedDigest, method;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._getTransferTokensToEthWormholeParams(fromAccount, amount, solanaAccount);

              case 2:
                _yield$this$_getTrans2 = _context9.sent;
                chainId = _yield$this$_getTrans2.chainId;
                deadline = _yield$this$_getTrans2.deadline;
                recipient = _yield$this$_getTrans2.recipient;
                arbiterFee = _yield$this$_getTrans2.arbiterFee;
                signedDigest = _yield$this$_getTrans2.signedDigest;
                _context9.next = 10;
                return this.ethContracts.WormholeClient.WormholeContract.methods.transferTokens(fromAccount, amount, chainId, recipient, arbiterFee, deadline, signedDigest.v, signedDigest.r, signedDigest.s);

              case 10:
                method = _context9.sent;
                return _context9.abrupt("return", method);

              case 12:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getTransferTokensToEthWormholeMethod(_x17, _x18, _x19) {
        return _getTransferTokensToEthWormholeMethod.apply(this, arguments);
      }

      return getTransferTokensToEthWormholeMethod;
    }()
  }]);

  return Wormhole;
}();

/**
 * Singleton class to store the current user if initialized.
 * Some instances of AudiusLibs and services require a current user to
 * return valid queries, e.g. requesting the a discprov to return a reposted track.
 */

var UserStateManager = /*#__PURE__*/function () {
  function UserStateManager(_ref) {
    var localStorage = _ref.localStorage;

    _classCallCheck(this, UserStateManager);

    _defineProperty$1(this, "currentUser", void 0);

    _defineProperty$1(this, "localStorage", void 0);

    // Should reflect the same fields as discovery node's /users?handle=<handle>
    this.currentUser = null;
    this.localStorage = localStorage;
  }
  /**
   * Sets this.currentUser with currentUser
   * @param {Object} currentUser fields to override this.currentUser with
   */


  _createClass(UserStateManager, [{
    key: "setCurrentUser",
    value: function () {
      var _setCurrentUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(currentUser) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.currentUser = currentUser;

                if (!this.localStorage) {
                  _context.next = 4;
                  break;
                }

                _context.next = 4;
                return this.localStorage.setItem(CURRENT_USER_EXISTS_LOCAL_STORAGE_KEY, 'true');

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setCurrentUser(_x) {
        return _setCurrentUser.apply(this, arguments);
      }

      return setCurrentUser;
    }()
  }, {
    key: "getCurrentUser",
    value: function getCurrentUser() {
      return this.currentUser;
    }
  }, {
    key: "getCurrentUserId",
    value: function getCurrentUserId() {
      return this.currentUser ? this.currentUser.user_id : null;
    }
  }, {
    key: "clearUser",
    value: function () {
      var _clearUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.currentUser = null;

                if (!this.localStorage) {
                  _context2.next = 4;
                  break;
                }

                _context2.next = 4;
                return this.localStorage.removeItem(CURRENT_USER_EXISTS_LOCAL_STORAGE_KEY);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function clearUser() {
        return _clearUser.apply(this, arguments);
      }

      return clearUser;
    }()
  }]);

  return UserStateManager;
}();

var CONTENT_NODE_SERVICE_NAME = 'content-node';
var DISCOVERY_NODE_SERVICE_NAME = 'discovery-node';
/**
 * API methods to interact with Audius service providers.
 * Types of services include:
 *    - Content Node (host creator content)
 *    - Discovery Node (index and make content queryable)
 * Retrieving lists of available services, etc. are found here.
 */

var ServiceProvider = /*#__PURE__*/function (_Base) {
  _inherits(ServiceProvider, _Base);

  var _super = _createSuper(ServiceProvider);

  function ServiceProvider() {
    var _this;

    _classCallCheck(this, ServiceProvider);

    for (var _len = arguments.length, services = new Array(_len), _key = 0; _key < _len; _key++) {
      services[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(services));

    _defineProperty$1(_assertThisInitialized(_this), "cachedStorageNodes", void 0);

    _this.cachedStorageNodes = [];
    return _this;
  }
  /* ------- Content Node  ------- */


  _createClass(ServiceProvider, [{
    key: "listCreatorNodes",
    value: function () {
      var _listCreatorNodes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.ethContracts.ServiceProviderFactoryClient.getServiceProviderList(CONTENT_NODE_SERVICE_NAME);

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function listCreatorNodes() {
        return _listCreatorNodes.apply(this, arguments);
      }

      return listCreatorNodes;
    }()
    /**
     * Selects numNodes storage nodes from the list of registered storage nodes on chain, optionally ordering them (descending) by rendezvous score.
     * TODO: This might want to handle blocklist/allowlist, latency checks, health checks, etc... but for now it just uses all nodes.
     *       CN selection without health checks might be a separate part of SDK anyway.
     */

  }, {
    key: "autoSelectStorageV2Nodes",
    value: function () {
      var _autoSelectStorageV2Nodes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var numNodes,
            userWallet,
            logger,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                numNodes = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 0;
                userWallet = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : '';
                logger = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : console;

                if (this.cachedStorageNodes.length) {
                  _context2.next = 7;
                  break;
                }

                _context2.next = 6;
                return this.listCreatorNodes();

              case 6:
                this.cachedStorageNodes = _context2.sent;

              case 7:
                _context2.next = 9;
                return getNStorageNodes(this.cachedStorageNodes, numNodes, userWallet, logger);

              case 9:
                return _context2.abrupt("return", _context2.sent);

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function autoSelectStorageV2Nodes() {
        return _autoSelectStorageV2Nodes.apply(this, arguments);
      }

      return autoSelectStorageV2Nodes;
    }()
    /* ------- Discovery Node ------ */

  }, {
    key: "listDiscoveryProviders",
    value: function () {
      var _listDiscoveryProviders = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.ethContracts.ServiceProviderFactoryClient.getServiceProviderList(DISCOVERY_NODE_SERVICE_NAME);

              case 2:
                return _context3.abrupt("return", _context3.sent);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function listDiscoveryProviders() {
        return _listDiscoveryProviders.apply(this, arguments);
      }

      return listDiscoveryProviders;
    }()
    /**
     * Returns a list of discovery nodes of size `quorumSize` that belong to
     * unique service operators.
     * Throws if unable to find a large enough list.
     */

  }, {
    key: "getUniquelyOwnedDiscoveryNodes",
    value: function () {
      var _getUniquelyOwnedDiscoveryNodes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref) {
        var quorumSize, _ref$discoveryNodes, discoveryNodes, _ref$filter, filter, _ref$useWhitelist, useWhitelist, grouped, owners;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                quorumSize = _ref.quorumSize, _ref$discoveryNodes = _ref.discoveryNodes, discoveryNodes = _ref$discoveryNodes === void 0 ? [] : _ref$discoveryNodes, _ref$filter = _ref.filter, filter = _ref$filter === void 0 ? /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_) {
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            return _context4.abrupt("return", true);

                          case 1:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function (_x2) {
                    return _ref2.apply(this, arguments);
                  };
                }() : _ref$filter, _ref$useWhitelist = _ref.useWhitelist, useWhitelist = _ref$useWhitelist === void 0 ? true : _ref$useWhitelist;

                if (!(!discoveryNodes || discoveryNodes.length === 0)) {
                  _context5.next = 5;
                  break;
                }

                _context5.next = 4;
                return this.discoveryProvider.serviceSelector.findAll({
                  verbose: true,
                  whitelist: useWhitelist ? undefined : null
                });

              case 4:
                discoveryNodes = _context5.sent;

              case 5:
                discoveryNodes.filter(filter); // Group nodes by owner

                grouped = discoveryNodes.reduce(function (acc, curr) {
                  if (curr.owner in acc) {
                    var _acc$curr$owner;

                    (_acc$curr$owner = acc[curr.owner]) === null || _acc$curr$owner === void 0 ? void 0 : _acc$curr$owner.push(curr);
                  } else {
                    acc[curr.owner] = [curr];
                  }

                  return acc;
                }, {});

                if (!(Object.keys(grouped).length < quorumSize)) {
                  _context5.next = 9;
                  break;
                }

                throw new Error('Not enough unique owners to choose from');

              case 9:
                // Select quorumSize owners from the groups
                owners = lodash.sampleSize(Object.keys(grouped), quorumSize); // Select 1 node from each owner selected

                return _context5.abrupt("return", owners.map(function (owner) {
                  return lodash.sampleSize(grouped[owner], 1)[0].endpoint;
                }));

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getUniquelyOwnedDiscoveryNodes(_x) {
        return _getUniquelyOwnedDiscoveryNodes.apply(this, arguments);
      }

      return getUniquelyOwnedDiscoveryNodes;
    }()
  }]);

  return ServiceProvider;
}(Base);

var Account = /*#__PURE__*/function (_Base) {
  _inherits(Account, _Base);

  var _super = _createSuper(Account);

  function Account(userApi, serviceProvider) {
    var _this;

    _classCallCheck(this, Account);

    for (var _len = arguments.length, services = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      services[_key - 2] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(services));

    _defineProperty$1(_assertThisInitialized(_this), "User", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "ServiceProvider", void 0);

    _this.User = userApi;
    _this.ServiceProvider = serviceProvider;
    _this.getCurrentUser = _this.getCurrentUser.bind(_assertThisInitialized(_this));
    _this.login = _this.login.bind(_assertThisInitialized(_this));
    _this.logout = _this.logout.bind(_assertThisInitialized(_this));
    _this.generateRecoveryLink = _this.generateRecoveryLink.bind(_assertThisInitialized(_this));
    _this.confirmCredentials = _this.confirmCredentials.bind(_assertThisInitialized(_this));
    _this.changePassword = _this.changePassword.bind(_assertThisInitialized(_this));
    _this.resetPassword = _this.resetPassword.bind(_assertThisInitialized(_this));
    _this.checkIfEmailRegistered = _this.checkIfEmailRegistered.bind(_assertThisInitialized(_this));
    _this.getUserEmail = _this.getUserEmail.bind(_assertThisInitialized(_this));
    _this.associateTwitterUser = _this.associateTwitterUser.bind(_assertThisInitialized(_this));
    _this.associateInstagramUser = _this.associateInstagramUser.bind(_assertThisInitialized(_this));
    _this.associateTikTokUser = _this.associateTikTokUser.bind(_assertThisInitialized(_this));
    _this.lookupTwitterHandle = _this.lookupTwitterHandle.bind(_assertThisInitialized(_this));
    _this.searchFull = _this.searchFull.bind(_assertThisInitialized(_this));
    _this.searchAutocomplete = _this.searchAutocomplete.bind(_assertThisInitialized(_this));
    _this.searchTags = _this.searchTags.bind(_assertThisInitialized(_this));
    _this.sendTokensFromEthToSol = _this.sendTokensFromEthToSol.bind(_assertThisInitialized(_this));
    _this.sendTokensFromSolToEth = _this.sendTokensFromSolToEth.bind(_assertThisInitialized(_this));
    _this.userHasClaimedSolAccount = _this.userHasClaimedSolAccount.bind(_assertThisInitialized(_this));
    _this.signUpV2 = _this.signUpV2.bind(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Fetches the user metadata for the current account
   * @return {Object} user metadata
   */


  _createClass(Account, [{
    key: "getCurrentUser",
    value: function getCurrentUser() {
      return this.userStateManager.getCurrentUser();
    }
    /**
     * Logs a user into Audius
     */

  }, {
    key: "login",
    value: function () {
      var _login = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(email, password) {
        var phases, phase, ownerWallet, userAccount, randomNodes;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                phases = {
                  FIND_WALLET: 'FIND_WALLET',
                  FIND_USER: 'FIND_USER'
                };
                phase = '';
                phase = phases.FIND_WALLET;

                if (this.web3Manager.web3IsExternal()) {
                  _context.next = 16;
                  break;
                }

                this.REQUIRES(Services.HEDGEHOG);
                _context.prev = 5;
                _context.next = 8;
                return this.hedgehog.login(email, password);

              case 8:
                ownerWallet = _context.sent;
                _context.next = 11;
                return this.web3Manager.setOwnerWallet(ownerWallet);

              case 11:
                _context.next = 16;
                break;

              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](5);
                return _context.abrupt("return", {
                  error: _context.t0.message,
                  phase: phase
                });

              case 16:
                phase = phases.FIND_USER;
                _context.next = 19;
                return this.discoveryProvider.getUserAccount(this.web3Manager.getWalletAddress());

              case 19:
                userAccount = _context.sent;

                if (!userAccount) {
                  _context.next = 28;
                  break;
                }

                this.userStateManager.setCurrentUser(userAccount);
                _context.next = 24;
                return this.ServiceProvider.autoSelectStorageV2Nodes(1, userAccount.wallet);

              case 24:
                randomNodes = _context.sent;
                _context.next = 27;
                return this.creatorNode.setEndpoint(randomNodes[0]);

              case 27:
                return _context.abrupt("return", {
                  user: userAccount,
                  error: false,
                  phase: phase
                });

              case 28:
                return _context.abrupt("return", {
                  error: 'No user found',
                  phase: phase
                });

              case 29:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[5, 13]]);
      }));

      function login(_x, _x2) {
        return _login.apply(this, arguments);
      }

      return login;
    }()
    /**
     * Logs a user out of Audius
     * Note: Actions will stop working at this point, but
     * clients may wish to call window.location.reload()
     * to show the user as logged out
     */

  }, {
    key: "logout",
    value: function () {
      var _logout = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.web3Manager.web3IsExternal()) {
                  _context2.next = 5;
                  break;
                }

                this.REQUIRES(Services.HEDGEHOG);
                _context2.next = 4;
                return this.hedgehog.logout();

              case 4:
                this.userStateManager.clearUser();

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function logout() {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
    /**
     * Signs a user up for Audius
     * @param email
     * @param password
     * @param metadata
     * @param profilePictureFile an optional file to upload as the profile picture
     * @param coverPhotoFile an optional file to upload as the cover phtoo
     * @param hasWallet
     * @param host The host url used for the recovery email
     * @param generateRecoveryLink an optional flag to skip generating recovery link for testing purposes
     */

  }, {
    key: "signUpV2",
    value: function () {
      var _signUpV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(email, password, metadata) {
        var profilePictureFile,
            coverPhotoFile,
            hasWallet,
            host,
            generateRecoveryLink,
            phases,
            phase,
            ownerWallet,
            randomNodes,
            _yield$this$User$crea,
            newMetadata,
            blockHash,
            blockNumber,
            _args3 = arguments;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                profilePictureFile = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : null;
                coverPhotoFile = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : null;
                hasWallet = _args3.length > 5 && _args3[5] !== undefined ? _args3[5] : false;
                host = _args3.length > 6 && _args3[6] !== undefined ? _args3[6] : typeof window !== 'undefined' && window.location.origin || null;
                generateRecoveryLink = _args3.length > 7 && _args3[7] !== undefined ? _args3[7] : true;
                phases = {
                  CREATE_USER_RECORD: 'CREATE_USER_RECORD',
                  HEDGEHOG_SIGNUP: 'HEDGEHOG_SIGNUP',
                  SELECT_STORAGE_NODE: 'SELECT_STORAGE_NODE',
                  ADD_USER: 'ADD_USER',
                  UPLOAD_PROFILE_IMAGES: 'UPLOAD_PROFILE_IMAGES'
                };
                phase = '';
                _context3.prev = 7;
                this.REQUIRES(Services.CREATOR_NODE, Services.IDENTITY_SERVICE);

                if (!this.web3Manager.web3IsExternal()) {
                  _context3.next = 15;
                  break;
                }

                phase = phases.CREATE_USER_RECORD;
                _context3.next = 13;
                return this.identityService.createUserRecord(email, this.web3Manager.getWalletAddress());

              case 13:
                _context3.next = 25;
                break;

              case 15:
                this.REQUIRES(Services.HEDGEHOG); // If an owner wallet already exists, don't try to recreate it

                if (hasWallet) {
                  _context3.next = 25;
                  break;
                }

                phase = phases.HEDGEHOG_SIGNUP;
                _context3.next = 20;
                return this.hedgehog.signUp(email, password);

              case 20:
                ownerWallet = _context3.sent;
                this.web3Manager.setOwnerWallet(ownerWallet);

                if (!generateRecoveryLink) {
                  _context3.next = 25;
                  break;
                }

                _context3.next = 25;
                return this.generateRecoveryLink({
                  handle: metadata.handle,
                  host: host
                });

              case 25:
                // Select a storage node to send future requests to
                phase = phases.SELECT_STORAGE_NODE;
                _context3.next = 28;
                return this.ServiceProvider.autoSelectStorageV2Nodes(1, this.web3Manager.getWalletAddress());

              case 28:
                randomNodes = _context3.sent;
                _context3.next = 31;
                return this.creatorNode.setEndpoint(randomNodes[0]);

              case 31:
                // Add user to chain
                phase = phases.ADD_USER;
                _context3.next = 34;
                return this.User.createEntityManagerUserV2({
                  metadata: metadata,
                  profilePictureFile: profilePictureFile,
                  coverPhotoFile: coverPhotoFile
                });

              case 34:
                _yield$this$User$crea = _context3.sent;
                newMetadata = _yield$this$User$crea.newMetadata;
                blockHash = _yield$this$User$crea.blockHash;
                blockNumber = _yield$this$User$crea.blockNumber;
                return _context3.abrupt("return", {
                  blockHash: blockHash,
                  blockNumber: blockNumber,
                  userId: newMetadata.user_id
                });

              case 41:
                _context3.prev = 41;
                _context3.t0 = _context3["catch"](7);
                return _context3.abrupt("return", {
                  error: _context3.t0.message,
                  phase: phase,
                  errorStatus: _context3.t0.response ? _context3.t0.response.status : null
                });

              case 44:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[7, 41]]);
      }));

      function signUpV2(_x3, _x4, _x5) {
        return _signUpV.apply(this, arguments);
      }

      return signUpV2;
    }()
    /**
     * Generates and sends a recovery email for a user
     */

  }, {
    key: "generateRecoveryLink",
    value: function () {
      var _generateRecoveryLink = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _ref,
            handle,
            host,
            _handle,
            recoveryInfo,
            unixTs,
            data,
            signature,
            recoveryData,
            _args4 = arguments;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _ref = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {}, handle = _ref.handle, host = _ref.host;
                this.REQUIRES(Services.IDENTITY_SERVICE);
                _context4.prev = 2;
                _context4.next = 5;
                return this.hedgehog.generateRecoveryInfo();

              case 5:
                recoveryInfo = _context4.sent;
                handle = (_handle = handle) !== null && _handle !== void 0 ? _handle : this.userStateManager.getCurrentUser().handle;
                unixTs = Math.round(new Date().getTime() / 1000); // current unix timestamp (sec)

                data = "Click sign to authenticate with identity service: ".concat(unixTs);
                _context4.next = 11;
                return this.web3Manager.sign(Buffer.from(data, 'utf-8'));

              case 11:
                signature = _context4.sent;
                recoveryData = {
                  login: recoveryInfo.login,
                  host: host !== null && host !== void 0 ? host : recoveryInfo.host,
                  data: data,
                  signature: signature,
                  handle: handle
                };
                _context4.next = 15;
                return this.identityService.sendRecoveryInfo(recoveryData);

              case 15:
                return _context4.abrupt("return", _context4.sent);

              case 18:
                _context4.prev = 18;
                _context4.t0 = _context4["catch"](2);
                console.error(_context4.t0);
                return _context4.abrupt("return", {
                  status: false
                });

              case 22:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[2, 18]]);
      }));

      function generateRecoveryLink() {
        return _generateRecoveryLink.apply(this, arguments);
      }

      return generateRecoveryLink;
    }()
  }, {
    key: "resetPassword",
    value: function () {
      var _resetPassword = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(email, newpassword) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.hedgehog.resetPassword(email, newpassword);

              case 2:
                return _context5.abrupt("return", _context5.sent);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function resetPassword(_x6, _x7) {
        return _resetPassword.apply(this, arguments);
      }

      return resetPassword;
    }()
  }, {
    key: "changePassword",
    value: function () {
      var _changePassword = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(email, newpassword, oldpassword) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.hedgehog.changePassword(email, newpassword, oldpassword);

              case 2:
                return _context6.abrupt("return", _context6.sent);

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function changePassword(_x8, _x9, _x10) {
        return _changePassword.apply(this, arguments);
      }

      return changePassword;
    }()
  }, {
    key: "confirmCredentials",
    value: function () {
      var _confirmCredentials = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(email, password) {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.hedgehog.confirmCredentials(email, password);

              case 2:
                return _context7.abrupt("return", _context7.sent);

              case 3:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function confirmCredentials(_x11, _x12) {
        return _confirmCredentials.apply(this, arguments);
      }

      return confirmCredentials;
    }()
    /**
     * Check if an email address has been previously registered.
     */

  }, {
    key: "checkIfEmailRegistered",
    value: function () {
      var _checkIfEmailRegistered = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(email) {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this.REQUIRES(Services.IDENTITY_SERVICE);
                _context8.next = 3;
                return this.identityService.checkIfEmailRegistered(email);

              case 3:
                return _context8.abrupt("return", _context8.sent);

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function checkIfEmailRegistered(_x13) {
        return _checkIfEmailRegistered.apply(this, arguments);
      }

      return checkIfEmailRegistered;
    }()
    /**
     * Get the current user's email address
     */

  }, {
    key: "getUserEmail",
    value: function () {
      var _getUserEmail = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                this.REQUIRES(Services.IDENTITY_SERVICE);
                _context9.next = 3;
                return this.identityService.getUserEmail();

              case 3:
                return _context9.abrupt("return", _context9.sent);

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getUserEmail() {
        return _getUserEmail.apply(this, arguments);
      }

      return getUserEmail;
    }()
    /**
     * Associates a user with a twitter uuid.
     * @param uuid from the Twitter API
     */

  }, {
    key: "associateTwitterUser",
    value: function () {
      var _associateTwitterUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(uuid, userId, handle) {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this.REQUIRES(Services.IDENTITY_SERVICE);
                _context10.next = 3;
                return this.identityService.associateTwitterUser(uuid, userId, handle);

              case 3:
                return _context10.abrupt("return", _context10.sent);

              case 4:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function associateTwitterUser(_x14, _x15, _x16) {
        return _associateTwitterUser.apply(this, arguments);
      }

      return associateTwitterUser;
    }()
    /**
     * Associates a user with an instagram uuid.
     * @param uuid from the Instagram API
     */

  }, {
    key: "associateInstagramUser",
    value: function () {
      var _associateInstagramUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(uuid, userId, handle) {
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                this.REQUIRES(Services.IDENTITY_SERVICE);
                _context11.next = 3;
                return this.identityService.associateInstagramUser(uuid, userId, handle);

              case 3:
                return _context11.abrupt("return", _context11.sent);

              case 4:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function associateInstagramUser(_x17, _x18, _x19) {
        return _associateInstagramUser.apply(this, arguments);
      }

      return associateInstagramUser;
    }()
    /**
     * Associates a user with an tiktok uuid
     * @param uuid from the TikTok API
     */

  }, {
    key: "associateTikTokUser",
    value: function () {
      var _associateTikTokUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(uuid, userId, handle) {
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                this.REQUIRES(Services.IDENTITY_SERVICE);
                _context12.next = 3;
                return this.identityService.associateTikTokUser(uuid, userId, handle);

              case 3:
                return _context12.abrupt("return", _context12.sent);

              case 4:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function associateTikTokUser(_x20, _x21, _x22) {
        return _associateTikTokUser.apply(this, arguments);
      }

      return associateTikTokUser;
    }()
    /**
     * Looks up a Twitter account by handle.
     */

  }, {
    key: "lookupTwitterHandle",
    value: function () {
      var _lookupTwitterHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(handle) {
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                this.REQUIRES(Services.IDENTITY_SERVICE);
                _context13.next = 3;
                return this.identityService.lookupTwitterHandle(handle);

              case 3:
                return _context13.abrupt("return", _context13.sent);

              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function lookupTwitterHandle(_x23) {
        return _lookupTwitterHandle.apply(this, arguments);
      }

      return lookupTwitterHandle;
    }()
    /**
     * Perform a full-text search. Returns tracks, users, playlists, albums
     *    with optional user-specific results for each
     *  - user, track, and playlist objects have all same data as returned from standalone endpoints
     * @param text search query
     * @param kind 'tracks', 'users', 'playlists', 'albums', 'all'
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */

  }, {
    key: "searchFull",
    value: function () {
      var _searchFull = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(text, kind) {
        var limit,
            offset,
            _args14 = arguments;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                limit = _args14.length > 2 && _args14[2] !== undefined ? _args14[2] : 100;
                offset = _args14.length > 3 && _args14[3] !== undefined ? _args14[3] : 0;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context14.next = 5;
                return this.discoveryProvider.searchFull(text, kind, limit, offset);

              case 5:
                return _context14.abrupt("return", _context14.sent);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function searchFull(_x24, _x25) {
        return _searchFull.apply(this, arguments);
      }

      return searchFull;
    }()
    /**
     * Perform a lighter-weight full-text search. Returns tracks, users, playlists, albums
     *    with optional user-specific results for each
     *  - user, track, and playlist objects have core data, and track & playlist objects
     *    also return user object
     * @param text search query
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */

  }, {
    key: "searchAutocomplete",
    value: function () {
      var _searchAutocomplete = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(text) {
        var limit,
            offset,
            _args15 = arguments;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                limit = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : 100;
                offset = _args15.length > 2 && _args15[2] !== undefined ? _args15[2] : 0;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context15.next = 5;
                return this.discoveryProvider.searchAutocomplete(text, limit, offset);

              case 5:
                return _context15.abrupt("return", _context15.sent);

              case 6:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function searchAutocomplete(_x26) {
        return _searchAutocomplete.apply(this, arguments);
      }

      return searchAutocomplete;
    }()
    /**
     * Perform a tags-only search. Returns tracks with required tag and users
     * that have used a tag greater than a specified number of times
     * @param text search query
     * @param userTagCount min # of times a user must have used a tag to be returned
     * @param kind 'tracks', 'users', 'playlists', 'albums', 'all'
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */

  }, {
    key: "searchTags",
    value: function () {
      var _searchTags = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(text) {
        var userTagCount,
            kind,
            limit,
            offset,
            _args16 = arguments;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                userTagCount = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : 2;
                kind = _args16.length > 2 ? _args16[2] : undefined;
                limit = _args16.length > 3 && _args16[3] !== undefined ? _args16[3] : 100;
                offset = _args16.length > 4 && _args16[4] !== undefined ? _args16[4] : 0;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context16.next = 7;
                return this.discoveryProvider.searchTags(text, userTagCount, kind, limit, offset);

              case 7:
                return _context16.abrupt("return", _context16.sent);

              case 8:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function searchTags(_x27) {
        return _searchTags.apply(this, arguments);
      }

      return searchTags;
    }()
    /**
     * Check if the user has a distribution claim
     * @param index The index of the claim to check (if known)
     */

  }, {
    key: "getHasClaimed",
    value: function () {
      var _getHasClaimed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(index) {
        var _this$ethContracts$Cl2;

        var _this$ethContracts$Cl, userWallet, web3, wallet, claim;

        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                this.REQUIRES(Services.COMSTOCK);

                if (!index) {
                  _context17.next = 5;
                  break;
                }

                _context17.next = 4;
                return (_this$ethContracts$Cl = this.ethContracts.ClaimDistributionClient) === null || _this$ethContracts$Cl === void 0 ? void 0 : _this$ethContracts$Cl.isClaimed(index);

              case 4:
                return _context17.abrupt("return", _context17.sent);

              case 5:
                userWallet = this.web3Manager.getWalletAddress();
                web3 = this.web3Manager.getWeb3();
                wallet = web3.utils.toChecksumAddress(userWallet);
                _context17.next = 10;
                return this.comstock.getComstock({
                  wallet: wallet
                });

              case 10:
                claim = _context17.sent;
                _context17.next = 13;
                return (_this$ethContracts$Cl2 = this.ethContracts.ClaimDistributionClient) === null || _this$ethContracts$Cl2 === void 0 ? void 0 : _this$ethContracts$Cl2.isClaimed(claim.index);

              case 13:
                return _context17.abrupt("return", _context17.sent);

              case 14:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getHasClaimed(_x28) {
        return _getHasClaimed.apply(this, arguments);
      }

      return getHasClaimed;
    }()
    /**
     * Get the distribution claim amount
     */

  }, {
    key: "getClaimDistributionAmount",
    value: function () {
      var _getClaimDistributionAmount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
        var userWallet, web3, wallet, claimDistribution, amount;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                this.REQUIRES(Services.COMSTOCK);
                userWallet = this.web3Manager.getWalletAddress();
                web3 = this.web3Manager.getWeb3();
                wallet = web3.utils.toChecksumAddress(userWallet);
                _context18.next = 6;
                return this.comstock.getComstock({
                  wallet: wallet
                });

              case 6:
                claimDistribution = _context18.sent;
                amount = Utils.toBN(claimDistribution.amount.replace('0x', ''), 16);
                return _context18.abrupt("return", amount);

              case 9:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getClaimDistributionAmount() {
        return _getClaimDistributionAmount.apply(this, arguments);
      }

      return getClaimDistributionAmount;
    }()
    /**
     * Make the claim
     * @param index The index of the claim to check
     * @param amount The amount to be claimed
     * @param merkleProof The merkle proof for the claim
     */

  }, {
    key: "makeDistributionClaim",
    value: function () {
      var _makeDistributionClaim = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(index, amount, merkleProof) {
        var _this$ethContracts$Cl4;

        var userWallet, web3, wallet, _this$ethContracts$Cl3, claim;

        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                this.REQUIRES(Services.COMSTOCK, Services.IDENTITY_SERVICE);
                userWallet = this.web3Manager.getWalletAddress();
                web3 = this.web3Manager.getWeb3();
                wallet = web3.utils.toChecksumAddress(userWallet);

                if (!(index && amount && merkleProof)) {
                  _context19.next = 8;
                  break;
                }

                _context19.next = 7;
                return (_this$ethContracts$Cl3 = this.ethContracts.ClaimDistributionClient) === null || _this$ethContracts$Cl3 === void 0 ? void 0 : _this$ethContracts$Cl3.claim(index, userWallet, amount, merkleProof);

              case 7:
                return _context19.abrupt("return", _context19.sent);

              case 8:
                _context19.next = 10;
                return this.comstock.getComstock({
                  wallet: wallet
                });

              case 10:
                claim = _context19.sent;
                _context19.next = 13;
                return (_this$ethContracts$Cl4 = this.ethContracts.ClaimDistributionClient) === null || _this$ethContracts$Cl4 === void 0 ? void 0 : _this$ethContracts$Cl4.claim(claim.index, userWallet, claim.amount, claim.proof);

              case 13:
                return _context19.abrupt("return", _context19.sent);

              case 14:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function makeDistributionClaim(_x29, _x30, _x31) {
        return _makeDistributionClaim.apply(this, arguments);
      }

      return makeDistributionClaim;
    }()
    /**
     * Sends `amount` tokens to `recipientAddress`
     */

  }, {
    key: "permitAndSendTokens",
    value: function () {
      var _permitAndSendTokens = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(recipientAddress, amount) {
        var myWalletAddress, _yield$this$identityS, selectedEthWallet;

        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                this.REQUIRES(Services.IDENTITY_SERVICE);
                myWalletAddress = this.web3Manager.getWalletAddress();
                _context20.next = 4;
                return this.identityService.getEthRelayer(myWalletAddress);

              case 4:
                _yield$this$identityS = _context20.sent;
                selectedEthWallet = _yield$this$identityS.selectedEthWallet;
                _context20.next = 8;
                return this.permitProxySendTokens(myWalletAddress, selectedEthWallet, amount);

              case 8:
                _context20.next = 10;
                return this.sendTokens(myWalletAddress, recipientAddress, selectedEthWallet, amount);

              case 10:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function permitAndSendTokens(_x32, _x33) {
        return _permitAndSendTokens.apply(this, arguments);
      }

      return permitAndSendTokens;
    }()
    /**
     * Sends Eth `amount` tokens to `solanaAccount` by way of the wormhole
     * 1.) Permits the eth relay to proxy send tokens on behalf of the user
     * 2.) Transfers the tokens on the eth side to the wormhole contract
     * 3.) Gathers attestations from wormhole oracles and relizes the tokens on sol
     */

  }, {
    key: "sendTokensFromEthToSol",
    value: function () {
      var _sendTokensFromEthToSol = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(amount, solanaAccount) {
        var phases, phase, logs, _response$error, myWalletAddress, wormholeAddress, _yield$this$identityS2, selectedEthWallet, transferTokensTx, transferTransactionHash, response;

        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                this.REQUIRES(Services.IDENTITY_SERVICE);
                phases = {
                  PERMIT_PROXY_SEND: 'PERMIT_PROXY_SEND',
                  TRANSFER_TOKENS: 'TRANSFER_TOKENS',
                  ATTEST_AND_COMPLETE_TRANSFER: 'ATTEST_AND_COMPLETE_TRANSFER'
                };
                phase = phases.PERMIT_PROXY_SEND;
                logs = ["Send tokens from eth to sol to ".concat(solanaAccount, " for ").concat(amount.toString())];
                _context21.prev = 4;
                myWalletAddress = this.web3Manager.getWalletAddress();
                wormholeAddress = this.ethContracts.WormholeClient.contractAddress;
                _context21.next = 9;
                return this.identityService.getEthRelayer(myWalletAddress);

              case 9:
                _yield$this$identityS2 = _context21.sent;
                selectedEthWallet = _yield$this$identityS2.selectedEthWallet;
                _context21.next = 13;
                return this.permitProxySendTokens(myWalletAddress, wormholeAddress, amount);

              case 13:
                logs.push('Completed permit proxy send tokens');
                phase = phases.TRANSFER_TOKENS;
                _context21.next = 17;
                return this.wormholeClient.transferTokensToEthWormhole(myWalletAddress, amount, solanaAccount, selectedEthWallet);

              case 17:
                transferTokensTx = _context21.sent;
                transferTransactionHash = transferTokensTx === null || transferTokensTx === void 0 ? void 0 : transferTokensTx.txHash;
                logs.push("Completed transfer tokens with tx ".concat(transferTransactionHash));
                phase = phases.ATTEST_AND_COMPLETE_TRANSFER;
                _context21.next = 23;
                return this.wormholeClient.attestAndCompleteTransferEthToSol(transferTransactionHash);

              case 23:
                response = _context21.sent;

                if (response.transactionSignature) {
                  logs.push("Receive sol wrapped tokens in tx ".concat(response.transactionSignature));
                }

                return _context21.abrupt("return", {
                  txSignature: response.transactionSignature,
                  phase: response.phase,
                  error: (_response$error = response.error) !== null && _response$error !== void 0 ? _response$error : null,
                  logs: logs.concat(response.logs)
                });

              case 28:
                _context21.prev = 28;
                _context21.t0 = _context21["catch"](4);
                return _context21.abrupt("return", {
                  error: _context21.t0.message,
                  phase: phase,
                  logs: logs
                });

              case 31:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this, [[4, 28]]);
      }));

      function sendTokensFromEthToSol(_x34, _x35) {
        return _sendTokensFromEthToSol.apply(this, arguments);
      }

      return sendTokensFromEthToSol;
    }()
    /**
     * Sends Eth `amount` tokens to `solanaAccount` on the identity service
     * by way of the wormhole.
     */

  }, {
    key: "proxySendTokensFromEthToSol",
    value: function () {
      var _proxySendTokensFromEthToSol = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(amount, solanaAccount) {
        var myWalletAddress, wormholeAddress, _yield$this$identityS3, selectedEthWallet, permitMethod, permit, transferTokensMethod, transferTokens;

        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                this.REQUIRES(Services.IDENTITY_SERVICE);
                myWalletAddress = this.web3Manager.getWalletAddress();
                wormholeAddress = this.ethContracts.WormholeClient.contractAddress;
                _context22.next = 5;
                return this.identityService.getEthRelayer(myWalletAddress);

              case 5:
                _yield$this$identityS3 = _context22.sent;
                selectedEthWallet = _yield$this$identityS3.selectedEthWallet;
                _context22.next = 9;
                return this.getPermitProxySendTokensMethod(myWalletAddress, wormholeAddress, amount);

              case 9:
                permitMethod = _context22.sent;
                _context22.next = 12;
                return this.ethWeb3Manager.getRelayMethodParams(this.ethContracts.AudiusTokenClient.contractAddress, permitMethod, selectedEthWallet);

              case 12:
                permit = _context22.sent;
                _context22.next = 15;
                return this.wormholeClient.getTransferTokensToEthWormholeMethod(myWalletAddress, amount, solanaAccount);

              case 15:
                transferTokensMethod = _context22.sent;
                _context22.next = 18;
                return this.ethWeb3Manager.getRelayMethodParams(this.ethContracts.WormholeClient.contractAddress, transferTokensMethod, selectedEthWallet);

              case 18:
                transferTokens = _context22.sent;
                _context22.next = 21;
                return this.identityService.wormholeRelay({
                  senderAddress: myWalletAddress,
                  permit: permit,
                  transferTokens: transferTokens
                });

              case 21:
                return _context22.abrupt("return", _context22.sent);

              case 22:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function proxySendTokensFromEthToSol(_x36, _x37) {
        return _proxySendTokensFromEthToSol.apply(this, arguments);
      }

      return proxySendTokensFromEthToSol;
    }()
    /**
     * Sends `amount` tokens to `ethAccount` by way of the wormhole
     * 1.) Creates a solana root wallet
     * 2.) Sends the tokens from the user bank account to the solana wallet
     * 3.) Permits the solana wallet to approve transfer to wormhole
     * 4.) Transfers to the wrapped audio to the sol wormhole contract
     * 5.) Gathers attestations from wormhole oracles and realizes the tokens on eth
     */

  }, {
    key: "sendTokensFromSolToEth",
    value: function () {
      var _sendTokensFromSolToEth = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(amount, ethAccount) {
        var _yield$this$wormholeC, error, logs, phase;

        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.wormholeClient.sendTokensFromSolToEthViaWormhole(amount, ethAccount);

              case 2:
                _yield$this$wormholeC = _context23.sent;
                error = _yield$this$wormholeC.error;
                logs = _yield$this$wormholeC.logs;
                phase = _yield$this$wormholeC.phase;
                return _context23.abrupt("return", {
                  error: error,
                  logs: logs,
                  phase: phase
                });

              case 7:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function sendTokensFromSolToEth(_x38, _x39) {
        return _sendTokensFromSolToEth.apply(this, arguments);
      }

      return sendTokensFromSolToEth;
    }()
  }, {
    key: "_getPermitProxySendTokensParams",
    value: function () {
      var _getPermitProxySendTokensParams2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(owner, relayerAddress, amount) {
        var web3, myPrivateKey, chainId, name, tokenAddress, nonce, currentBlockNumber, currentBlock, deadline, digest, result;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                web3 = this.ethWeb3Manager.getWeb3();
                myPrivateKey = this.web3Manager.getOwnerWalletPrivateKey();
                /* eslint-disable -- some funky promise logic ahead */

                _context25.next = 4;
                return new Promise( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(resolve) {
                    return regeneratorRuntime.wrap(function _callee24$(_context24) {
                      while (1) {
                        switch (_context24.prev = _context24.next) {
                          case 0:
                            _context24.next = 2;
                            return web3.eth.getChainId(function (_, chainId) {
                              return resolve(chainId);
                            });

                          case 2:
                            return _context24.abrupt("return", _context24.sent);

                          case 3:
                          case "end":
                            return _context24.stop();
                        }
                      }
                    }, _callee24);
                  }));

                  return function (_x43) {
                    return _ref2.apply(this, arguments);
                  };
                }());

              case 4:
                chainId = _context25.sent;
                _context25.next = 7;
                return this.ethContracts.AudiusTokenClient.name();

              case 7:
                name = _context25.sent;
                tokenAddress = this.ethContracts.AudiusTokenClient.contractAddress; // Submit permit request to give address approval, via relayer

                _context25.next = 11;
                return this.ethContracts.AudiusTokenClient.nonces(owner);

              case 11:
                nonce = _context25.sent;
                _context25.next = 14;
                return web3.eth.getBlockNumber();

              case 14:
                currentBlockNumber = _context25.sent;
                _context25.next = 17;
                return web3.eth.getBlock(currentBlockNumber);

              case 17:
                currentBlock = _context25.sent;
                // 1 hour, sufficiently far in future
                deadline = currentBlock.timestamp + 60 * 60 * 1;
                digest = getPermitDigest(web3, name, tokenAddress, chainId, {
                  owner: owner,
                  spender: relayerAddress,
                  value: amount
                }, nonce, deadline);
                result = sign(digest, myPrivateKey);
                return _context25.abrupt("return", {
                  result: result,
                  deadline: deadline
                });

              case 22:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function _getPermitProxySendTokensParams(_x40, _x41, _x42) {
        return _getPermitProxySendTokensParams2.apply(this, arguments);
      }

      return _getPermitProxySendTokensParams;
    }()
    /**
     * Permits `relayerAddress` to send `amount` on behalf of the current user, `owner`
     */

  }, {
    key: "permitProxySendTokens",
    value: function () {
      var _permitProxySendTokens = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(owner, relayerAddress, amount) {
        var _yield$this$_getPermi, result, deadline, tx;

        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this._getPermitProxySendTokensParams(owner, relayerAddress, amount);

              case 2:
                _yield$this$_getPermi = _context26.sent;
                result = _yield$this$_getPermi.result;
                deadline = _yield$this$_getPermi.deadline;
                _context26.next = 7;
                return this.ethContracts.AudiusTokenClient.permit(owner, relayerAddress, amount, deadline, result.v, result.r, result.s);

              case 7:
                tx = _context26.sent;
                return _context26.abrupt("return", tx);

              case 9:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function permitProxySendTokens(_x44, _x45, _x46) {
        return _permitProxySendTokens.apply(this, arguments);
      }

      return permitProxySendTokens;
    }()
    /**
     * Gets the permit method to proxy send tokens `relayerAddress` to send `amount` on behalf of the current user, `owner`
     */

  }, {
    key: "getPermitProxySendTokensMethod",
    value: function () {
      var _getPermitProxySendTokensMethod = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(owner, relayerAddress, amount) {
        var _yield$this$_getPermi2, result, deadline, contractMethod;

        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                _context27.next = 2;
                return this._getPermitProxySendTokensParams(owner, relayerAddress, amount);

              case 2:
                _yield$this$_getPermi2 = _context27.sent;
                result = _yield$this$_getPermi2.result;
                deadline = _yield$this$_getPermi2.deadline;
                contractMethod = this.ethContracts.AudiusTokenClient.AudiusTokenContract.methods.permit(owner, relayerAddress, amount, deadline, result.v, result.r, result.s);
                return _context27.abrupt("return", contractMethod);

              case 7:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getPermitProxySendTokensMethod(_x47, _x48, _x49) {
        return _getPermitProxySendTokensMethod.apply(this, arguments);
      }

      return getPermitProxySendTokensMethod;
    }()
    /**
     * Sends `amount` tokens to `address` from `owner`
     */

  }, {
    key: "sendTokens",
    value: function () {
      var _sendTokens = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(owner, address, relayer, amount) {
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                this.REQUIRES(Services.IDENTITY_SERVICE);
                _context28.next = 3;
                return this.ethContracts.AudiusTokenClient.transferFrom(owner, address, relayer, amount);

              case 3:
                return _context28.abrupt("return", _context28.sent);

              case 4:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function sendTokens(_x50, _x51, _x52, _x53) {
        return _sendTokens.apply(this, arguments);
      }

      return sendTokens;
    }()
    /**
     * Updates the minimum delegation amount for a user in identity
     * NOTE: Requests eth account signature
     */

  }, {
    key: "updateMinimumDelegationAmount",
    value: function () {
      var _updateMinimumDelegationAmount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(amount) {
        var _this$identityService;

        var unixTs, message, signature, wallet;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                this.REQUIRES(Services.IDENTITY_SERVICE);
                unixTs = Math.round(new Date().getTime() / 1000); // current unix timestamp (sec)

                message = "Click sign to authenticate with identity service: ".concat(unixTs);
                _context29.next = 5;
                return this.ethWeb3Manager.sign(Buffer.from(message, 'utf-8'));

              case 5:
                signature = _context29.sent;
                wallet = this.ethWeb3Manager.getWalletAddress();
                _context29.next = 9;
                return this.identityService.updateMinimumDelegationAmount(wallet, amount, (_this$identityService = {}, _defineProperty$1(_this$identityService, AuthHeaders.MESSAGE, message), _defineProperty$1(_this$identityService, AuthHeaders.SIGNATURE, signature), _this$identityService));

              case 9:
                return _context29.abrupt("return", _context29.sent);

              case 10:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function updateMinimumDelegationAmount(_x54) {
        return _updateMinimumDelegationAmount.apply(this, arguments);
      }

      return updateMinimumDelegationAmount;
    }()
    /**
     * Checks that the current user has claimed account PDA on SOL
     * @returns userHasClaimedAccount
     */

  }, {
    key: "userHasClaimedSolAccount",
    value: function () {
      var _userHasClaimedSolAccount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30() {
        var _ref3,
            _ref3$account,
            account,
            _ref3$wallet,
            wallet,
            _ref3$userId,
            userId,
            userHasClaimedAccount,
            _args30 = arguments;

        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _ref3 = _args30.length > 0 && _args30[0] !== undefined ? _args30[0] : {
                  account: null,
                  wallet: null,
                  userId: null
                }, _ref3$account = _ref3.account, account = _ref3$account === void 0 ? null : _ref3$account, _ref3$wallet = _ref3.wallet, wallet = _ref3$wallet === void 0 ? null : _ref3$wallet, _ref3$userId = _ref3.userId, userId = _ref3$userId === void 0 ? null : _ref3$userId;

                if (!(!account && !wallet && !userId)) {
                  _context30.next = 3;
                  break;
                }

                throw new Error('Must supply EITHER an `account` OR `wallet` and `userId` to look up whether userHasClaimedSolAccount');

              case 3:
                userHasClaimedAccount = solanaWeb3.PublicKey["default"].toString() !== (account === null || account === void 0 ? void 0 : account.authority.toString());
                return _context30.abrupt("return", userHasClaimedAccount);

              case 5:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30);
      }));

      function userHasClaimedSolAccount() {
        return _userHasClaimedSolAccount.apply(this, arguments);
      }

      return userHasClaimedSolAccount;
    }()
  }]);

  return Account;
}(Base);

// null or non-null values

var USER_PROPS = ['is_verified', 'is_deactivated', 'name', 'handle', 'profile_picture', 'profile_picture_sizes', 'cover_photo', 'cover_photo_sizes', 'bio', 'location', 'artist_pick_track_id', 'creator_node_endpoint', 'associated_wallets', 'associated_sol_wallets', 'collectibles', 'playlist_library', 'events', 'allow_ai_attribution']; // User metadata fields that are required on the metadata object and only can have
// non-null values

var USER_REQUIRED_PROPS = ['name', 'handle']; // Constants for user metadata fields

var decodeHashId$1 = Utils.decodeHashId;
var Users = /*#__PURE__*/function (_Base) {
  _inherits(Users, _Base);

  var _super = _createSuper(Users);

  function Users(serviceProvider, preferHigherPatchForPrimary, preferHigherPatchForSecondaries) {
    var _this;

    _classCallCheck(this, Users);

    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "ServiceProvider", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "preferHigherPatchForPrimary", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "preferHigherPatchForSecondaries", void 0);

    _this.ServiceProvider = serviceProvider;
    _this.preferHigherPatchForPrimary = preferHigherPatchForPrimary;
    _this.preferHigherPatchForSecondaries = preferHigherPatchForSecondaries;
    _this.getUsers = _this.getUsers.bind(_assertThisInitialized(_this));
    _this.getMutualFollowers = _this.getMutualFollowers.bind(_assertThisInitialized(_this));
    _this.getFollowersForUser = _this.getFollowersForUser.bind(_assertThisInitialized(_this));
    _this.getFolloweesForUser = _this.getFolloweesForUser.bind(_assertThisInitialized(_this));
    _this.getUserRepostFeed = _this.getUserRepostFeed.bind(_assertThisInitialized(_this));
    _this.getSocialFeed = _this.getSocialFeed.bind(_assertThisInitialized(_this));
    _this.getTopCreatorsByGenres = _this.getTopCreatorsByGenres.bind(_assertThisInitialized(_this));
    _this.updateIsVerified = _this.updateIsVerified.bind(_assertThisInitialized(_this));
    _this.getUserListenCountsMonthly = _this.getUserListenCountsMonthly.bind(_assertThisInitialized(_this));
    _this.getUserSubscribers = _this.getUserSubscribers.bind(_assertThisInitialized(_this));
    _this.bulkGetUserSubscribers = _this.bulkGetUserSubscribers.bind(_assertThisInitialized(_this));
    _this.updateMetadataV2 = _this.updateMetadataV2.bind(_assertThisInitialized(_this));
    _this.uploadProfileImagesV2 = _this.uploadProfileImagesV2.bind(_assertThisInitialized(_this));
    _this.createEntityManagerUserV2 = _this.createEntityManagerUserV2.bind(_assertThisInitialized(_this));
    _this._waitForDiscoveryToIndexUser = _this._waitForDiscoveryToIndexUser.bind(_assertThisInitialized(_this));
    _this._validateUserMetadata = _this._validateUserMetadata.bind(_assertThisInitialized(_this));
    _this.cleanUserMetadata = _this.cleanUserMetadata.bind(_assertThisInitialized(_this));
    return _this;
  }
  /* ----------- GETTERS ---------- */

  /**
   * get users with all relevant user data
   * can be filtered by providing an integer array of ids
   * @returns Array of User metadata Objects
   * additional metadata fields on user objects:
   *  {Integer} track_count - track count for given user
   *  {Integer} playlist_count - playlist count for given user
   *  {Integer} album_count - album count for given user
   *  {Integer} follower_count - follower count for given user
   *  {Integer} followee_count - followee count for given user
   *  {Integer} repost_count - repost count for given user
   *  {Integer} track_blocknumber - blocknumber of latest track for user
   *  {Boolean} does_current_user_follow - does current user follow given user
   *  {Array} followee_follows - followees of current user that follow given user
   * @example
   * await getUsers()
   * await getUsers(100, 0, [3,2,6]) - Invalid user ids will not be accepted
   */


  _createClass(Users, [{
    key: "getUsers",
    value: function () {
      var _getUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var limit,
            offset,
            idsArray,
            walletAddress,
            handle,
            minBlockNumber,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                limit = _args.length > 0 && _args[0] !== undefined ? _args[0] : 100;
                offset = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;
                idsArray = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;
                walletAddress = _args.length > 3 && _args[3] !== undefined ? _args[3] : null;
                handle = _args.length > 4 && _args[4] !== undefined ? _args[4] : null;
                minBlockNumber = _args.length > 5 && _args[5] !== undefined ? _args[5] : null;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context.next = 9;
                return this.discoveryProvider.getUsers(limit, offset, idsArray, walletAddress, handle, minBlockNumber);

              case 9:
                return _context.abrupt("return", _context.sent);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getUsers() {
        return _getUsers.apply(this, arguments);
      }

      return getUsers;
    }()
    /**
     * get intersection of users that follow followeeUserId and users that are followed by followerUserId
     * @param followeeUserId user that is followed
     * @example
     * getMutualFollowers(100, 0, 1, 1) - IDs must be valid
     */

  }, {
    key: "getMutualFollowers",
    value: function () {
      var _getMutualFollowers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var limit,
            offset,
            followeeUserId,
            followerUserId,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                limit = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 100;
                offset = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 0;
                followeeUserId = _args2.length > 2 ? _args2[2] : undefined;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                followerUserId = this.userStateManager.getCurrentUserId();

                if (!followerUserId) {
                  _context2.next = 9;
                  break;
                }

                _context2.next = 8;
                return this.discoveryProvider.getFollowIntersectionUsers(limit, offset, followeeUserId, followerUserId);

              case 8:
                return _context2.abrupt("return", _context2.sent);

              case 9:
                return _context2.abrupt("return", []);

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getMutualFollowers() {
        return _getMutualFollowers.apply(this, arguments);
      }

      return getMutualFollowers;
    }()
    /**
     * get users that follow followeeUserId, sorted by follower count descending
     */

  }, {
    key: "getFollowersForUser",
    value: function () {
      var _getFollowersForUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var limit,
            offset,
            followeeUserId,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                limit = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 100;
                offset = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 0;
                followeeUserId = _args3.length > 2 ? _args3[2] : undefined;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context3.next = 6;
                return this.discoveryProvider.getFollowersForUser(limit, offset, followeeUserId);

              case 6:
                return _context3.abrupt("return", _context3.sent);

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getFollowersForUser() {
        return _getFollowersForUser.apply(this, arguments);
      }

      return getFollowersForUser;
    }()
    /**
     * get users that are followed by followerUserId, sorted by follower count descending
     */

  }, {
    key: "getFolloweesForUser",
    value: function () {
      var _getFolloweesForUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var limit,
            offset,
            followerUserId,
            _args4 = arguments;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                limit = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : 100;
                offset = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : 0;
                followerUserId = _args4.length > 2 ? _args4[2] : undefined;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context4.next = 6;
                return this.discoveryProvider.getFolloweesForUser(limit, offset, followerUserId);

              case 6:
                return _context4.abrupt("return", _context4.sent);

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getFolloweesForUser() {
        return _getFolloweesForUser.apply(this, arguments);
      }

      return getFolloweesForUser;
    }()
    /**
     * Return repost feed for requested user
     * @param userId - requested user id
     * @param limit - max # of items to return (for pagination)
     * @param offset - offset into list to return from (for pagination)
     * @returns Array of track and playlist metadata objects
     * additional metadata fields on track and playlist objects:
     *  {String} activity_timestamp - timestamp of requested user's repost for given track or playlist,
     *    used for sorting feed
     *  {Integer} repost_count - repost count of given track/playlist
     *  {Integer} save_count - save count of given track/playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given track/playlist
     *  {Array} followee_reposts - followees of current user that have reposted given track/playlist
     */

  }, {
    key: "getUserRepostFeed",
    value: function () {
      var _getUserRepostFeed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(userId) {
        var limit,
            offset,
            withUsers,
            _args5 = arguments;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                limit = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : 100;
                offset = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : 0;
                withUsers = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : false;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context5.next = 6;
                return this.discoveryProvider.getUserRepostFeed(userId, limit, offset, withUsers);

              case 6:
                return _context5.abrupt("return", _context5.sent);

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getUserRepostFeed(_x) {
        return _getUserRepostFeed.apply(this, arguments);
      }

      return getUserRepostFeed;
    }()
    /**
     * Return social feed for current user
     * @param limit - max # of items to return
     * @param filter - filter by "all", "original", or "repost"
     * @param offset - offset into list to return from (for pagination)
     * @returns Array of track and playlist metadata objects
     * additional metadata fields on track and playlist objects:
     *  {String} activity_timestamp - timestamp of requested user's repost for given track or playlist,
     *    used for sorting feed
     *  {Integer} repost_count - repost count of given track/playlist
     *  {Integer} save_count - save count of given track/playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given track/playlist
     *  {Array} followee_reposts - followees of current user that have reposted given track/playlist
     */

  }, {
    key: "getSocialFeed",
    value: function () {
      var _getSocialFeed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(filter) {
        var limit,
            offset,
            withUsers,
            tracksOnly,
            owner,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                limit = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : 100;
                offset = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : 0;
                withUsers = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : false;
                tracksOnly = _args6.length > 4 && _args6[4] !== undefined ? _args6[4] : false;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                owner = this.userStateManager.getCurrentUser();

                if (!owner) {
                  _context6.next = 10;
                  break;
                }

                _context6.next = 9;
                return this.discoveryProvider.getSocialFeed(filter, limit, offset, withUsers, tracksOnly);

              case 9:
                return _context6.abrupt("return", _context6.sent);

              case 10:
                return _context6.abrupt("return", []);

              case 11:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getSocialFeed(_x2) {
        return _getSocialFeed.apply(this, arguments);
      }

      return getSocialFeed;
    }()
    /**
     * Returns the top users for the specified genres
     * @param genres - filter by genres ie. "Rock", "Alternative"
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     * @param withUsers - If the userIds should be returned or the full user metadata
     * @returns  Array of user objects if with_users set, else array of userId
     */

  }, {
    key: "getTopCreatorsByGenres",
    value: function () {
      var _getTopCreatorsByGenres = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(genres) {
        var limit,
            offset,
            withUsers,
            _args7 = arguments;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                limit = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : 30;
                offset = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : 0;
                withUsers = _args7.length > 3 && _args7[3] !== undefined ? _args7[3] : false;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context7.next = 6;
                return this.discoveryProvider.getTopCreatorsByGenres(genres, limit, offset, withUsers);

              case 6:
                return _context7.abrupt("return", _context7.sent);

              case 7:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getTopCreatorsByGenres(_x3) {
        return _getTopCreatorsByGenres.apply(this, arguments);
      }

      return getTopCreatorsByGenres;
    }()
    /**
     * Gets listen count data for a user's tracks grouped by month
     * @returns Dictionary of listen count data where keys are requested months
     */

  }, {
    key: "getUserListenCountsMonthly",
    value: function () {
      var _getUserListenCountsMonthly = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(encodedUserId, startTime, endTime) {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context8.next = 3;
                return this.discoveryProvider.getUserListenCountsMonthly(encodedUserId, startTime, endTime);

              case 3:
                return _context8.abrupt("return", _context8.sent);

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getUserListenCountsMonthly(_x4, _x5, _x6) {
        return _getUserListenCountsMonthly.apply(this, arguments);
      }

      return getUserListenCountsMonthly;
    }()
    /**
     * Gets a user's subscribers.
     * @param params.encodedUserId string of the encoded user id
     * @returns Array of User metadata objects for each subscriber
     */

  }, {
    key: "getUserSubscribers",
    value: function () {
      var _getUserSubscribers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(encodedUserId) {
        var timeoutMs;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                this.REQUIRES(Services.DISCOVERY_PROVIDER); // 1 min timeout

                timeoutMs = 60000;
                _context9.next = 4;
                return this.discoveryProvider.getUserSubscribers(encodedUserId, timeoutMs);

              case 4:
                return _context9.abrupt("return", _context9.sent);

              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getUserSubscribers(_x7) {
        return _getUserSubscribers.apply(this, arguments);
      }

      return getUserSubscribers;
    }()
    /**
     * Bulk gets users' subscribers.
     * @param params.encodedUserIds JSON stringified array of
     *   encoded user ids
     * @returns Array of {user_id: <encoded user id>,
     *   subscriber_ids: Array[<encoded subscriber ids>]} objects
     */

  }, {
    key: "bulkGetUserSubscribers",
    value: function () {
      var _bulkGetUserSubscribers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(encodedUserIds) {
        var timeoutMs;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this.REQUIRES(Services.DISCOVERY_PROVIDER); // 1 min timeout

                timeoutMs = 60000;
                _context10.next = 4;
                return this.discoveryProvider.bulkGetUserSubscribers(encodedUserIds, timeoutMs);

              case 4:
                return _context10.abrupt("return", _context10.sent);

              case 5:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function bulkGetUserSubscribers(_x8) {
        return _bulkGetUserSubscribers.apply(this, arguments);
      }

      return bulkGetUserSubscribers;
    }()
    /* ------- SETTERS ------- */

  }, {
    key: "uploadProfileImagesV2",
    value: function () {
      var _uploadProfileImagesV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(profilePictureFile, coverPhotoFile, metadata) {
        var didMetadataUpdate, resp, _resp;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                didMetadataUpdate = false;

                if (!profilePictureFile) {
                  _context11.next = 7;
                  break;
                }

                _context11.next = 4;
                return this.creatorNode.uploadProfilePictureV2(profilePictureFile);

              case 4:
                resp = _context11.sent;
                metadata.profile_picture_sizes = resp.id;
                didMetadataUpdate = true;

              case 7:
                if (!coverPhotoFile) {
                  _context11.next = 13;
                  break;
                }

                _context11.next = 10;
                return this.creatorNode.uploadCoverPhotoV2(coverPhotoFile);

              case 10:
                _resp = _context11.sent;
                metadata.cover_photo_sizes = _resp.id;
                didMetadataUpdate = true;

              case 13:
                if (!didMetadataUpdate) {
                  _context11.next = 16;
                  break;
                }

                _context11.next = 16;
                return this.updateMetadataV2({
                  newMetadata: metadata,
                  userId: metadata.user_id
                });

              case 16:
                return _context11.abrupt("return", metadata);

              case 17:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function uploadProfileImagesV2(_x9, _x10, _x11) {
        return _uploadProfileImagesV.apply(this, arguments);
      }

      return uploadProfileImagesV2;
    }()
  }, {
    key: "createEntityManagerUserV2",
    value: function () {
      var _createEntityManagerUserV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(_ref) {
        var metadata, profilePictureFile, coverPhotoFile, userId, newMetadata, resp, _resp2, cid, manageEntityResponse, errorMsg;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                metadata = _ref.metadata, profilePictureFile = _ref.profilePictureFile, coverPhotoFile = _ref.coverPhotoFile;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context12.prev = 2;
                _context12.next = 5;
                return this._generateUserId();

              case 5:
                userId = _context12.sent;
                // Ensure metadata has expected properties
                newMetadata = this.cleanUserMetadata(_objectSpread2({}, metadata));

                this._validateUserMetadata(newMetadata);

                newMetadata.is_storage_v2 = true;
                newMetadata.wallet = this.web3Manager.getWalletAddress();
                newMetadata.user_id = userId;
                this.userStateManager.setCurrentUser(_objectSpread2(_objectSpread2({}, newMetadata), {}, {
                  // Initialize counts to be 0. We don't want to write this data to backends ever really
                  // (hence the cleanUserMetadata above), but we do want to make sure clients
                  // can properly "do math" on these numbers.
                  followee_count: 0,
                  follower_count: 0,
                  repost_count: 0
                })); // Upload images

                if (!profilePictureFile) {
                  _context12.next = 17;
                  break;
                }

                _context12.next = 15;
                return this.creatorNode.uploadProfilePictureV2(profilePictureFile);

              case 15:
                resp = _context12.sent;
                newMetadata.profile_picture_sizes = resp.id;

              case 17:
                if (!coverPhotoFile) {
                  _context12.next = 22;
                  break;
                }

                _context12.next = 20;
                return this.creatorNode.uploadCoverPhotoV2(coverPhotoFile);

              case 20:
                _resp2 = _context12.sent;
                newMetadata.cover_photo_sizes = _resp2.id;

              case 22:
                _context12.next = 24;
                return Utils.fileHasher.generateMetadataCidV1(newMetadata);

              case 24:
                cid = _context12.sent;
                _context12.next = 27;
                return this.contracts.EntityManagerClient.manageEntity(userId, EntityManagerClient.EntityType.USER, userId, EntityManagerClient.Action.CREATE, JSON.stringify({
                  cid: cid.toString(),
                  data: newMetadata
                }));

              case 27:
                manageEntityResponse = _context12.sent;
                _context12.next = 30;
                return this._waitForDiscoveryToIndexUser(userId, manageEntityResponse.txReceipt.blockNumber);

              case 30:
                // Update libs instance with new user metadata object
                this.userStateManager.setCurrentUser(_objectSpread2({}, newMetadata));
                return _context12.abrupt("return", {
                  newMetadata: newMetadata,
                  blockHash: manageEntityResponse.txReceipt.blockHash,
                  blockNumber: manageEntityResponse.txReceipt.blockNumber
                });

              case 34:
                _context12.prev = 34;
                _context12.t0 = _context12["catch"](2);
                errorMsg = "createEntityManagerUserV2() error: ".concat(_context12.t0);

                if (!(_context12.t0 instanceof Error)) {
                  _context12.next = 40;
                  break;
                }

                _context12.t0.message = errorMsg;
                throw _context12.t0;

              case 40:
                throw new Error(errorMsg);

              case 41:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[2, 34]]);
      }));

      function createEntityManagerUserV2(_x12) {
        return _createEntityManagerUserV.apply(this, arguments);
      }

      return createEntityManagerUserV2;
    }()
    /**
     * Updates a user on whether they are verified on Audius
     */

  }, {
    key: "updateIsVerified",
    value: function () {
      var _updateIsVerified = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(userId, privateKey) {
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this.contracts.EntityManagerClient.getManageEntityParams(userId, EntityManagerClient.EntityType.USER, userId, EntityManagerClient.Action.VERIFY, '', privateKey);

              case 2:
                return _context13.abrupt("return", _context13.sent);

              case 3:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function updateIsVerified(_x13, _x14) {
        return _updateIsVerified.apply(this, arguments);
      }

      return updateIsVerified;
    }()
    /**
     * Adds a user subscription for a given subscriber and user
     */

  }, {
    key: "addUserSubscribe",
    value: function () {
      var _addUserSubscribe = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(userId) {
        var subscriberUserId, response;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.prev = 0;
                subscriberUserId = this.userStateManager.getCurrentUserId();
                _context14.next = 4;
                return this.contracts.EntityManagerClient.manageEntity(subscriberUserId, EntityManagerClient.EntityType.USER, userId, EntityManagerClient.Action.SUBSCRIBE, '');

              case 4:
                response = _context14.sent;
                return _context14.abrupt("return", {
                  blockHash: response.txReceipt.blockHash,
                  blockNumber: response.txReceipt.blockNumber
                });

              case 8:
                _context14.prev = 8;
                _context14.t0 = _context14["catch"](0);
                return _context14.abrupt("return", {
                  error: _context14.t0.message
                });

              case 11:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[0, 8]]);
      }));

      function addUserSubscribe(_x15) {
        return _addUserSubscribe.apply(this, arguments);
      }

      return addUserSubscribe;
    }()
    /**
     * Delete a user subscription for a given subscriber and user
     */

  }, {
    key: "deleteUserSubscribe",
    value: function () {
      var _deleteUserSubscribe = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(userId) {
        var subscriberUserId, response;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.prev = 0;
                subscriberUserId = this.userStateManager.getCurrentUserId();
                _context15.next = 4;
                return this.contracts.EntityManagerClient.manageEntity(subscriberUserId, EntityManagerClient.EntityType.USER, userId, EntityManagerClient.Action.UNSUBSCRIBE, '');

              case 4:
                response = _context15.sent;
                return _context15.abrupt("return", {
                  blockHash: response.txReceipt.blockHash,
                  blockNumber: response.txReceipt.blockNumber
                });

              case 8:
                _context15.prev = 8;
                _context15.t0 = _context15["catch"](0);
                return _context15.abrupt("return", {
                  error: _context15.t0.message
                });

              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this, [[0, 8]]);
      }));

      function deleteUserSubscribe(_x16) {
        return _deleteUserSubscribe.apply(this, arguments);
      }

      return deleteUserSubscribe;
    }()
    /* ------- PRIVATE  ------- */

    /**
     * Only posts metadata to chain and not to Content Node.
     */

  }, {
    key: "updateMetadataV2",
    value: function () {
      var _updateMetadataV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(_ref2) {
        var newMetadata, userId, oldMetadata, cid, _yield$this$contracts, txReceipt, blockNumber, errorMsg;

        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                newMetadata = _ref2.newMetadata, userId = _ref2.userId;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                this.IS_OBJECT(newMetadata);
                oldMetadata = this.userStateManager.getCurrentUser();

                if (oldMetadata) {
                  _context16.next = 6;
                  break;
                }

                throw new Error('No current user.');

              case 6:
                newMetadata = this.cleanUserMetadata(newMetadata);

                this._validateUserMetadata(newMetadata);

                _context16.prev = 8;
                _context16.next = 11;
                return Utils.fileHasher.generateMetadataCidV1(newMetadata);

              case 11:
                cid = _context16.sent;
                _context16.next = 14;
                return this.contracts.EntityManagerClient.manageEntity(userId, EntityManagerClient.EntityType.USER, userId, EntityManagerClient.Action.UPDATE, JSON.stringify({
                  cid: cid.toString(),
                  data: newMetadata
                }));

              case 14:
                _yield$this$contracts = _context16.sent;
                txReceipt = _yield$this$contracts.txReceipt;
                blockNumber = txReceipt.blockNumber; // Update libs instance with new user metadata object

                this.userStateManager.setCurrentUser(_objectSpread2(_objectSpread2({}, oldMetadata), newMetadata));
                return _context16.abrupt("return", {
                  blockHash: txReceipt.blockHash,
                  blockNumber: blockNumber
                });

              case 21:
                _context16.prev = 21;
                _context16.t0 = _context16["catch"](8);
                errorMsg = "updateMetadataV2() error: ".concat(_context16.t0);

                if (!(_context16.t0 instanceof Error)) {
                  _context16.next = 27;
                  break;
                }

                _context16.t0.message = errorMsg;
                throw _context16.t0;

              case 27:
                throw new Error(errorMsg);

              case 28:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this, [[8, 21]]);
      }));

      function updateMetadataV2(_x17) {
        return _updateMetadataV.apply(this, arguments);
      }

      return updateMetadataV2;
    }()
  }, {
    key: "_waitForDiscoveryToIndexUser",
    value: function () {
      var _waitForDiscoveryToIndexUser2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(userId, blockNumber) {
        var _this2 = this;

        var timeoutMs,
            asyncFn,
            _args18 = arguments;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                timeoutMs = _args18.length > 2 && _args18[2] !== undefined ? _args18[2] : 60000;

                asyncFn = /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
                    var _user, user, _yield$_this2$discove;

                    return regeneratorRuntime.wrap(function _callee17$(_context17) {
                      while (1) {
                        switch (_context17.prev = _context17.next) {
                          case 0:

                            // Try to get user. Catch+ignore error if the block number isn't yet indexed
                            user = void 0;
                            _context17.prev = 2;
                            _context17.next = 5;
                            return _this2.discoveryProvider.getUsers(1, // limit
                            0, // offset
                            [userId], // userIds
                            null, // walletAddress
                            null, // handle
                            blockNumber, // minBlockNumber
                            true // includeIncomplete
                            );

                          case 5:
                            _context17.t1 = _yield$_this2$discove = _context17.sent;
                            _context17.t0 = _context17.t1 === null;

                            if (_context17.t0) {
                              _context17.next = 9;
                              break;
                            }

                            _context17.t0 = _yield$_this2$discove === void 0;

                          case 9:
                            if (!_context17.t0) {
                              _context17.next = 13;
                              break;
                            }

                            _context17.t2 = void 0;
                            _context17.next = 14;
                            break;

                          case 13:
                            _context17.t2 = _yield$_this2$discove[0];

                          case 14:
                            user = _context17.t2;
                            _context17.next = 19;
                            break;

                          case 17:
                            _context17.prev = 17;
                            _context17.t3 = _context17["catch"](2);

                          case 19:
                            if (!(((_user = user) === null || _user === void 0 ? void 0 : _user.user_id) === userId)) {
                              _context17.next = 21;
                              break;
                            }

                            return _context17.abrupt("break", 25);

                          case 21:
                            _context17.next = 23;
                            return Utils.wait(500);

                          case 23:
                            _context17.next = 0;
                            break;

                          case 25:
                          case "end":
                            return _context17.stop();
                        }
                      }
                    }, _callee17, null, [[2, 17]]);
                  }));

                  return function asyncFn() {
                    return _ref3.apply(this, arguments);
                  };
                }();

                _context18.next = 4;
                return Utils.racePromiseWithTimeout(asyncFn(), timeoutMs, "[User:_waitForDiscoveryToIndexUser()] Timeout error after ".concat(timeoutMs, "ms"));

              case 4:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18);
      }));

      function _waitForDiscoveryToIndexUser(_x18, _x19) {
        return _waitForDiscoveryToIndexUser2.apply(this, arguments);
      }

      return _waitForDiscoveryToIndexUser;
    }() // Throws an error upon validation failure

  }, {
    key: "_validateUserMetadata",
    value: function _validateUserMetadata(metadata) {
      this.OBJECT_HAS_PROPS(metadata, USER_PROPS, USER_REQUIRED_PROPS);
      this.creatorNode.validateUserSchema(metadata);
    }
    /**
     * Metadata object may have extra fields.
     * - Add what user props might be missing to normalize
     * - Only keep core fields in USER_PROPS and 'user_id'.
     */

  }, {
    key: "cleanUserMetadata",
    value: function cleanUserMetadata(metadata) {
      USER_PROPS.forEach(function (prop) {
        if (!(prop in metadata)) {
          // @ts-expect-error
          metadata[prop] = null;
        }
      });
      return lodash.pick(metadata, USER_PROPS.concat('user_id'));
    }
  }, {
    key: "_generateUserId",
    value: function () {
      var _generateUserId2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
        var encodedId;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.discoveryProvider.getUnclaimedId('users');

              case 2:
                encodedId = _context19.sent;

                if (encodedId) {
                  _context19.next = 5;
                  break;
                }

                throw new Error('No unclaimed user IDs');

              case 5:
                return _context19.abrupt("return", decodeHashId$1(encodedId));

              case 6:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function _generateUserId() {
        return _generateUserId2.apply(this, arguments);
      }

      return _generateUserId;
    }()
  }]);

  return Users;
}(Base);

var TRACK_PROPS = ['owner_id', 'title', 'cover_art_sizes', 'tags', 'genre', 'mood', 'credits_splits', 'release_date', 'file_type', 'is_premium', 'premium_conditions', 'ai_attribution_user_id'];
var TRACK_REQUIRED_PROPS = ['owner_id', 'title'];
var decodeHashId = Utils.decodeHashId;
var Track = /*#__PURE__*/function (_Base) {
  _inherits(Track, _Base);

  var _super = _createSuper(Track);

  function Track() {
    var _this;

    _classCallCheck(this, Track);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.getTracks = _this.getTracks.bind(_assertThisInitialized(_this));
    _this.getTracksIncludingUnlisted = _this.getTracksIncludingUnlisted.bind(_assertThisInitialized(_this));
    _this.getRandomTracks = _this.getRandomTracks.bind(_assertThisInitialized(_this));
    _this.getStemsForTrack = _this.getStemsForTrack.bind(_assertThisInitialized(_this));
    _this.getRemixesOfTrack = _this.getRemixesOfTrack.bind(_assertThisInitialized(_this));
    _this.getRemixTrackParents = _this.getRemixTrackParents.bind(_assertThisInitialized(_this));
    _this.getSavedTracks = _this.getSavedTracks.bind(_assertThisInitialized(_this));
    _this.getTrendingTracks = _this.getTrendingTracks.bind(_assertThisInitialized(_this));
    _this.getTrackListens = _this.getTrackListens.bind(_assertThisInitialized(_this));
    _this.getSaversForTrack = _this.getSaversForTrack.bind(_assertThisInitialized(_this));
    _this.getSaversForPlaylist = _this.getSaversForPlaylist.bind(_assertThisInitialized(_this));
    _this.getRepostersForTrack = _this.getRepostersForTrack.bind(_assertThisInitialized(_this));
    _this.getRepostersForPlaylist = _this.getRepostersForPlaylist.bind(_assertThisInitialized(_this));
    _this.getListenHistoryTracks = _this.getListenHistoryTracks.bind(_assertThisInitialized(_this));
    _this.logTrackListen = _this.logTrackListen.bind(_assertThisInitialized(_this));
    _this.deleteTrack = _this.deleteTrack.bind(_assertThisInitialized(_this));
    return _this;
  }
  /* ------- GETTERS ------- */

  /**
   * get tracks with all relevant track data
   * can be filtered by providing an integer array of ids
   * @param limit
   * @param offset
   * @param idsArray
   * @param targetUserId the owner of the tracks being queried
   * @param sort a string of form eg. blocknumber:asc,timestamp:desc describing a sort path
   * @param minBlockNumber The min block number
   * @param filterDeleted If set to true filters out deleted tracks
   * @returns Array of track metadata Objects
   * additional metadata fields on track objects:
   *  {Integer} repost_count - repost count for given track
   *  {Integer} save_count - save count for given track
   *  {Array} followee_reposts - followees of current user that have reposted given track
   *  {Boolean} has_current_user_reposted - has current user reposted given track
   *  {Boolean} has_current_user_saved - has current user saved given track
   * @example
   * await getTracks()
   * await getTracks(100, 0, [3,2,6]) - Invalid track ids will not be accepted
   */


  _createClass(Track, [{
    key: "getTracks",
    value: function () {
      var _getTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var limit,
            offset,
            idsArray,
            targetUserId,
            sort,
            minBlockNumber,
            filterDeleted,
            withUsers,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                limit = _args.length > 0 && _args[0] !== undefined ? _args[0] : 100;
                offset = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;
                idsArray = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;
                targetUserId = _args.length > 3 && _args[3] !== undefined ? _args[3] : null;
                sort = _args.length > 4 && _args[4] !== undefined ? _args[4] : null;
                minBlockNumber = _args.length > 5 && _args[5] !== undefined ? _args[5] : null;
                filterDeleted = _args.length > 6 && _args[6] !== undefined ? _args[6] : null;
                withUsers = _args.length > 7 && _args[7] !== undefined ? _args[7] : false;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context.next = 11;
                return this.discoveryProvider.getTracks(limit, offset, idsArray, targetUserId, sort, minBlockNumber, filterDeleted, withUsers);

              case 11:
                return _context.abrupt("return", _context.sent);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getTracks() {
        return _getTracks.apply(this, arguments);
      }

      return getTracks;
    }()
    /**
     * get tracks with all relevant track data
     * can be filtered by providing an integer array of ids
     * @param limit
     * @param offset
     * @param idsArray
     * @param targetUserId the owner of the tracks being queried
     * @param sort a string of form eg. blocknumber:asc,timestamp:desc describing a sort path
     * @param minBlockNumber The min block number
     * @param filterDeleted If set to true filters out deleted tracks
     * @returns Array of track metadata Objects
     * additional metadata fields on track objects:
     *  {Integer} repost_count - repost count for given track
     *  {Integer} save_count - save count for given track
     *  {Array} followee_reposts - followees of current user that have reposted given track
     *  {Boolean} has_current_user_reposted - has current user reposted given track
     *  {Boolean} has_current_user_saved - has current user saved given track
     * @example
     * await getTracks()
     * await getTracks(100, 0, [3,2,6]) - Invalid track ids will not be accepted
     */

  }, {
    key: "getTracksVerbose",
    value: function () {
      var _getTracksVerbose = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var limit,
            offset,
            idsArray,
            targetUserId,
            sort,
            minBlockNumber,
            filterDeleted,
            withUsers,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                limit = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 100;
                offset = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 0;
                idsArray = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : null;
                targetUserId = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : null;
                sort = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : null;
                minBlockNumber = _args2.length > 5 && _args2[5] !== undefined ? _args2[5] : null;
                filterDeleted = _args2.length > 6 && _args2[6] !== undefined ? _args2[6] : null;
                withUsers = _args2.length > 7 && _args2[7] !== undefined ? _args2[7] : false;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context2.next = 11;
                return this.discoveryProvider.getTracksVerbose(limit, offset, idsArray, targetUserId, sort, minBlockNumber, filterDeleted, withUsers);

              case 11:
                return _context2.abrupt("return", _context2.sent);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getTracksVerbose() {
        return _getTracksVerbose.apply(this, arguments);
      }

      return getTracksVerbose;
    }()
    /**
     * Gets tracks by their slug and owner handle
     * @param handle the owner's handle
     * @param slug the track's slug, including collision identifiers
     */

  }, {
    key: "getTracksByHandleAndSlug",
    value: function () {
      var _getTracksByHandleAndSlug = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(handle, slug) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context3.next = 3;
                return this.discoveryProvider.getTracksByHandleAndSlug(handle, slug);

              case 3:
                return _context3.abrupt("return", _context3.sent);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getTracksByHandleAndSlug(_x, _x2) {
        return _getTracksByHandleAndSlug.apply(this, arguments);
      }

      return getTracksByHandleAndSlug;
    }()
    /**
     * gets all tracks matching identifiers, including unlisted.
     */

  }, {
    key: "getTracksIncludingUnlisted",
    value: function () {
      var _getTracksIncludingUnlisted = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(identifiers) {
        var withUsers,
            _args4 = arguments;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                withUsers = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : false;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context4.next = 4;
                return this.discoveryProvider.getTracksIncludingUnlisted(identifiers, withUsers);

              case 4:
                return _context4.abrupt("return", _context4.sent);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getTracksIncludingUnlisted(_x3) {
        return _getTracksIncludingUnlisted.apply(this, arguments);
      }

      return getTracksIncludingUnlisted;
    }()
    /**
     * Gets random tracks from trending tracks for a given genre.
     * If genre not given, will return trending tracks across all genres.
     * Excludes specified track ids.
     */

  }, {
    key: "getRandomTracks",
    value: function () {
      var _getRandomTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(genre, limit, exclusionList, time) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context5.next = 3;
                return this.discoveryProvider.getRandomTracks(genre, limit, exclusionList, time);

              case 3:
                return _context5.abrupt("return", _context5.sent);

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getRandomTracks(_x4, _x5, _x6, _x7) {
        return _getRandomTracks.apply(this, arguments);
      }

      return getRandomTracks;
    }()
    /**
     * Gets all stems for a given trackId as an array of tracks.
     */

  }, {
    key: "getStemsForTrack",
    value: function () {
      var _getStemsForTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(trackId) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context6.next = 3;
                return this.discoveryProvider.getStemsForTrack(trackId);

              case 3:
                return _context6.abrupt("return", _context6.sent);

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getStemsForTrack(_x8) {
        return _getStemsForTrack.apply(this, arguments);
      }

      return getStemsForTrack;
    }()
    /**
     * Gets all the remixes of a given trackId as an array of tracks.
     */

  }, {
    key: "getRemixesOfTrack",
    value: function () {
      var _getRemixesOfTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(trackId) {
        var limit,
            offset,
            _args7 = arguments;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                limit = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : null;
                offset = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : null;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context7.next = 5;
                return this.discoveryProvider.getRemixesOfTrack(trackId, limit, offset);

              case 5:
                return _context7.abrupt("return", _context7.sent);

              case 6:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getRemixesOfTrack(_x9) {
        return _getRemixesOfTrack.apply(this, arguments);
      }

      return getRemixesOfTrack;
    }()
    /**
     * Gets the remix parents of a given trackId as an array of tracks.
     */

  }, {
    key: "getRemixTrackParents",
    value: function () {
      var _getRemixTrackParents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(trackId) {
        var limit,
            offset,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                limit = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : null;
                offset = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : null;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context8.next = 5;
                return this.discoveryProvider.getRemixTrackParents(trackId, limit, offset);

              case 5:
                return _context8.abrupt("return", _context8.sent);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getRemixTrackParents(_x10) {
        return _getRemixTrackParents.apply(this, arguments);
      }

      return getRemixTrackParents;
    }()
    /**
     * Return saved tracks for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     */

  }, {
    key: "getSavedTracks",
    value: function () {
      var _getSavedTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var limit,
            offset,
            withUsers,
            _args9 = arguments;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                limit = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : 100;
                offset = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : 0;
                withUsers = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : false;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context9.next = 6;
                return this.discoveryProvider.getSavedTracks(limit, offset, withUsers);

              case 6:
                return _context9.abrupt("return", _context9.sent);

              case 7:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getSavedTracks() {
        return _getSavedTracks.apply(this, arguments);
      }

      return getSavedTracks;
    }()
    /**
     * Gets tracks trending on Audius.
     */

  }, {
    key: "getTrendingTracks",
    value: function () {
      var _getTrendingTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var genre,
            time,
            idsArray,
            limit,
            offset,
            _args10 = arguments;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                genre = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : null;
                time = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : null;
                idsArray = _args10.length > 2 && _args10[2] !== undefined ? _args10[2] : null;
                limit = _args10.length > 3 && _args10[3] !== undefined ? _args10[3] : null;
                offset = _args10.length > 4 && _args10[4] !== undefined ? _args10[4] : null;
                this.REQUIRES(Services.IDENTITY_SERVICE);
                _context10.next = 8;
                return this.discoveryProvider.getTrendingTracks(genre, time, idsArray, limit, offset);

              case 8:
                return _context10.abrupt("return", _context10.sent);

              case 9:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getTrendingTracks() {
        return _getTrendingTracks.apply(this, arguments);
      }

      return getTrendingTracks;
    }()
    /**
     * Gets listens for tracks bucketted by timeFrame.
     */

  }, {
    key: "getTrackListens",
    value: function () {
      var _getTrackListens = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var timeFrame,
            idsArray,
            startTime,
            endTime,
            limit,
            offset,
            _args11 = arguments;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                timeFrame = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : null;
                idsArray = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : null;
                startTime = _args11.length > 2 && _args11[2] !== undefined ? _args11[2] : null;
                endTime = _args11.length > 3 && _args11[3] !== undefined ? _args11[3] : null;
                limit = _args11.length > 4 && _args11[4] !== undefined ? _args11[4] : null;
                offset = _args11.length > 5 && _args11[5] !== undefined ? _args11[5] : null;
                this.REQUIRES(Services.IDENTITY_SERVICE);
                _context11.next = 9;
                return this.identityService.getTrackListens(timeFrame, idsArray, startTime, endTime, limit, offset);

              case 9:
                return _context11.abrupt("return", _context11.sent);

              case 10:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getTrackListens() {
        return _getTrackListens.apply(this, arguments);
      }

      return getTrackListens;
    }()
    /**
     * get users that saved saveTrackId, sorted by follower count descending
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getSaversForTrack(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getSaversForTrack",
    value: function () {
      var _getSaversForTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var limit,
            offset,
            saveTrackId,
            _args12 = arguments;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                limit = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : 100;
                offset = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : 0;
                saveTrackId = _args12.length > 2 ? _args12[2] : undefined;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context12.next = 6;
                return this.discoveryProvider.getSaversForTrack(limit, offset, saveTrackId);

              case 6:
                return _context12.abrupt("return", _context12.sent);

              case 7:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getSaversForTrack() {
        return _getSaversForTrack.apply(this, arguments);
      }

      return getSaversForTrack;
    }()
    /**
     * get users that saved savePlaylistId, sorted by follower count descending
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getSaversForPlaylist(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getSaversForPlaylist",
    value: function () {
      var _getSaversForPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
        var limit,
            offset,
            savePlaylistId,
            _args13 = arguments;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                limit = _args13.length > 0 && _args13[0] !== undefined ? _args13[0] : 100;
                offset = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : 0;
                savePlaylistId = _args13.length > 2 ? _args13[2] : undefined;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context13.next = 6;
                return this.discoveryProvider.getSaversForPlaylist(limit, offset, savePlaylistId);

              case 6:
                return _context13.abrupt("return", _context13.sent);

              case 7:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getSaversForPlaylist() {
        return _getSaversForPlaylist.apply(this, arguments);
      }

      return getSaversForPlaylist;
    }()
    /**
     * get users that reposted repostTrackId, sorted by follower count descending
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getRepostersForTrack(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getRepostersForTrack",
    value: function () {
      var _getRepostersForTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
        var limit,
            offset,
            repostTrackId,
            _args14 = arguments;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                limit = _args14.length > 0 && _args14[0] !== undefined ? _args14[0] : 100;
                offset = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : 0;
                repostTrackId = _args14.length > 2 ? _args14[2] : undefined;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context14.next = 6;
                return this.discoveryProvider.getRepostersForTrack(limit, offset, repostTrackId);

              case 6:
                return _context14.abrupt("return", _context14.sent);

              case 7:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getRepostersForTrack() {
        return _getRepostersForTrack.apply(this, arguments);
      }

      return getRepostersForTrack;
    }()
    /**
     * get users that reposted repostPlaylistId, sorted by follower count descending
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getRepostersForPlaylist(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getRepostersForPlaylist",
    value: function () {
      var _getRepostersForPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
        var limit,
            offset,
            repostPlaylistId,
            _args15 = arguments;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                limit = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : 100;
                offset = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : 0;
                repostPlaylistId = _args15.length > 2 ? _args15[2] : undefined;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context15.next = 6;
                return this.discoveryProvider.getRepostersForPlaylist(limit, offset, repostPlaylistId);

              case 6:
                return _context15.abrupt("return", _context15.sent);

              case 7:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getRepostersForPlaylist() {
        return _getRepostersForPlaylist.apply(this, arguments);
      }

      return getRepostersForPlaylist;
    }()
    /**
     * Return saved tracks for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     */

  }, {
    key: "getListenHistoryTracks",
    value: function () {
      var _getListenHistoryTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
        var limit,
            offset,
            userId,
            _args16 = arguments;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                limit = _args16.length > 0 && _args16[0] !== undefined ? _args16[0] : 100;
                offset = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : 0;
                this.REQUIRES(Services.IDENTITY_SERVICE);
                userId = this.userStateManager.getCurrentUserId();
                _context16.next = 6;
                return this.identityService.getListenHistoryTracks(userId, limit, offset);

              case 6:
                return _context16.abrupt("return", _context16.sent);

              case 7:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getListenHistoryTracks() {
        return _getListenHistoryTracks.apply(this, arguments);
      }

      return getListenHistoryTracks;
    }()
    /* ------- SETTERS ------- */

    /**
     * Takes in a readable stream if isServer is true, or a file reference if isServer is
     * false.
     * Uploads file, retrieves multihash, adds multihash to input metadata object,
     * uploads metadata, and finally returns metadata multihash
     * Wraps the stateless function in AudiusLib.
     *
     * @param trackFile ReadableStream from server, or File handle on client
     * @param coverArtFile ReadableStream from server, or File handle on client
     * @param metadata json of the track metadata with all fields, missing fields will error
     * @param onProgress callback fired with (loaded, total) on byte upload progress
     */

  }, {
    key: "uploadTrackV2AndWriteToChain",
    value: function () {
      var _uploadTrackV2AndWriteToChain = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(trackFile, coverArtFile, metadata, onProgress) {
        var updatedMetadata, _yield$this$writeTrac, trackId, metadataCid, txReceipt;

        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this.uploadTrackV2(trackFile, coverArtFile, metadata, onProgress);

              case 2:
                updatedMetadata = _context17.sent;
                _context17.next = 5;
                return this.writeTrackToChain(updatedMetadata, Action.CREATE);

              case 5:
                _yield$this$writeTrac = _context17.sent;
                trackId = _yield$this$writeTrac.trackId;
                metadataCid = _yield$this$writeTrac.metadataCid;
                txReceipt = _yield$this$writeTrac.txReceipt;
                return _context17.abrupt("return", {
                  trackId: trackId,
                  metadataCid: metadataCid,
                  updatedMetadata: updatedMetadata,
                  txReceipt: txReceipt
                });

              case 10:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function uploadTrackV2AndWriteToChain(_x11, _x12, _x13, _x14) {
        return _uploadTrackV2AndWriteToChain.apply(this, arguments);
      }

      return uploadTrackV2AndWriteToChain;
    }()
    /**
     * Only uploads track but does not write to chain. Do not call by itself.
     *
     * @dev To upload a single track, call uploadTrackV2AndWriteToChain() instead.
     * @dev To upload multiple uploads, call this function multiple times and then call addTracksToChainV2() once.
     *
     * @param trackFile ReadableStream from server, or File handle on client
     * @param coverArtFile ReadableStream from server, or File handle on client
     * @param metadata json of the track metadata with all fields, missing fields will error
     * @param onProgress callback fired with (loaded, total) on byte upload progress
     */

  }, {
    key: "uploadTrackV2",
    value: function () {
      var _uploadTrackV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(trackFile, coverArtFile, metadata, onProgress) {
        var ownerId, updatedMetadata;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                // Validate inputs
                this.REQUIRES(Services.CREATOR_NODE);
                this.FILE_IS_VALID(trackFile);
                if (coverArtFile) this.FILE_IS_VALID(coverArtFile);
                this.IS_OBJECT(metadata);
                ownerId = this.userStateManager.getCurrentUserId();

                if (ownerId) {
                  _context18.next = 7;
                  break;
                }

                throw new Error('No users loaded for this wallet');

              case 7:
                metadata.owner_id = ownerId;

                this._validateTrackMetadata(metadata); // Upload track audio and cover art to storage node


                _context18.next = 11;
                return this.creatorNode.uploadTrackAudioAndCoverArtV2(trackFile, coverArtFile, metadata, onProgress);

              case 11:
                updatedMetadata = _context18.sent;
                return _context18.abrupt("return", updatedMetadata);

              case 13:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function uploadTrackV2(_x15, _x16, _x17, _x18) {
        return _uploadTrackV.apply(this, arguments);
      }

      return uploadTrackV2;
    }()
    /**
     * Creates a trackId for each CID in metadataCids and adds each track to chain for this user.
     */

  }, {
    key: "addTracksToChainV2",
    value: function () {
      var _addTracksToChainV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(trackMetadatas) {
        var _this2 = this;

        var ownerId, requestFailed, trackIds, error;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                ownerId = this.userStateManager.getCurrentUserId();

                if (ownerId) {
                  _context20.next = 3;
                  break;
                }

                throw new Error('No users loaded for this wallet');

              case 3:
                // Any failures in adding track to the blockchain will prevent further progress.
                // The list of successful track uploads is returned for revert operations by caller
                requestFailed = false;
                _context20.next = 6;
                return Promise.all(trackMetadatas.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(trackMetadata) {
                    var _yield$_this2$writeTr, trackId;

                    return regeneratorRuntime.wrap(function _callee19$(_context19) {
                      while (1) {
                        switch (_context19.prev = _context19.next) {
                          case 0:
                            _context19.prev = 0;
                            _context19.next = 3;
                            return _this2.writeTrackToChain(trackMetadata, Action.CREATE);

                          case 3:
                            _yield$_this2$writeTr = _context19.sent;
                            trackId = _yield$_this2$writeTr.trackId;
                            return _context19.abrupt("return", trackId);

                          case 8:
                            _context19.prev = 8;
                            _context19.t0 = _context19["catch"](0);
                            requestFailed = true;
                            console.error("Failed to add track to chain: ".concat(_context19.t0));
                            return _context19.abrupt("return", null);

                          case 13:
                          case "end":
                            return _context19.stop();
                        }
                      }
                    }, _callee19, null, [[0, 8]]);
                  }));

                  return function (_x20) {
                    return _ref.apply(this, arguments);
                  };
                }()));

              case 6:
                trackIds = _context20.sent.filter(Boolean);
                error = requestFailed || trackIds.length !== trackMetadatas.length;
                return _context20.abrupt("return", {
                  error: error,
                  trackIds: trackIds
                });

              case 9:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function addTracksToChainV2(_x19) {
        return _addTracksToChainV.apply(this, arguments);
      }

      return addTracksToChainV2;
    }()
    /**
     * Adds the given track's metadata to chain for this user, optionally creating a trackId if one doesn't exist.
     */

  }, {
    key: "writeTrackToChain",
    value: function () {
      var _writeTrackToChain = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(trackMetadata, action, trackId) {
        var ownerId, metadataCid, _yield$this$contracts, txReceipt;

        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                ownerId = this.userStateManager.getCurrentUserId();

                if (ownerId) {
                  _context21.next = 3;
                  break;
                }

                throw new Error('No users loaded for this wallet');

              case 3:
                if (trackId) {
                  _context21.next = 7;
                  break;
                }

                _context21.next = 6;
                return this._generateTrackId();

              case 6:
                trackId = _context21.sent;

              case 7:
                _context21.next = 9;
                return Utils.fileHasher.generateMetadataCidV1(trackMetadata);

              case 9:
                metadataCid = _context21.sent;
                _context21.next = 12;
                return this.contracts.EntityManagerClient.manageEntity(ownerId, EntityManagerClient.EntityType.TRACK, trackId, action, JSON.stringify({
                  cid: metadataCid.toString(),
                  data: trackMetadata
                }));

              case 12:
                _yield$this$contracts = _context21.sent;
                txReceipt = _yield$this$contracts.txReceipt;
                return _context21.abrupt("return", {
                  trackId: trackId,
                  metadataCid: metadataCid,
                  txReceipt: txReceipt
                });

              case 15:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function writeTrackToChain(_x21, _x22, _x23) {
        return _writeTrackToChain.apply(this, arguments);
      }

      return writeTrackToChain;
    }()
    /**
     * Updates an existing track given metadata using only chain and not creator node.
     * @param metadata json of the track metadata with all fields, missing fields will error
     * @param transcodePreview bool: retranscode track preview and set preview_cid if true
     */

  }, {
    key: "updateTrackV2",
    value: function () {
      var _updateTrackV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(metadata) {
        var transcodePreview,
            ownerId,
            trackId,
            updatedMetadata,
            _yield$this$writeTrac2,
            txReceipt,
            _args22 = arguments;

        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                transcodePreview = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : false;
                this.IS_OBJECT(metadata);
                ownerId = this.userStateManager.getCurrentUserId();

                if (ownerId) {
                  _context22.next = 5;
                  break;
                }

                throw new Error('No users loaded for this wallet');

              case 5:
                metadata.owner_id = ownerId;

                this._validateTrackMetadata(metadata);

                trackId = metadata.track_id;
                updatedMetadata = _objectSpread2({}, metadata);

                if (!transcodePreview) {
                  _context22.next = 17;
                  break;
                }

                if (metadata.preview_start_seconds) {
                  _context22.next = 12;
                  break;
                }

                throw new Error('No track preview start time specified');

              case 12:
                if (metadata.audio_upload_id) {
                  _context22.next = 14;
                  break;
                }

                throw new Error('Missing required audio_upload_id');

              case 14:
                _context22.next = 16;
                return this.creatorNode.transcodeTrackPreview(metadata);

              case 16:
                updatedMetadata = _context22.sent;

              case 17:
                _context22.next = 19;
                return this.writeTrackToChain(updatedMetadata, Action.UPDATE, trackId);

              case 19:
                _yield$this$writeTrac2 = _context22.sent;
                txReceipt = _yield$this$writeTrac2.txReceipt;
                return _context22.abrupt("return", {
                  blockHash: txReceipt.blockHash,
                  blockNumber: txReceipt.blockNumber,
                  trackId: trackId,
                  updatedMetadata: updatedMetadata
                });

              case 22:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function updateTrackV2(_x24) {
        return _updateTrackV.apply(this, arguments);
      }

      return updateTrackV2;
    }()
    /**
     * Logs a track listen for a given user id.
     * @param unauthUuid account for those not logged in
     * @param trackId listened to
     */

  }, {
    key: "logTrackListen",
    value: function () {
      var _logTrackListen = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(trackId, unauthUuid) {
        var solanaListen,
            accountId,
            userId,
            _args23 = arguments;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                solanaListen = _args23.length > 2 && _args23[2] !== undefined ? _args23[2] : false;
                this.REQUIRES(Services.IDENTITY_SERVICE);
                accountId = this.userStateManager.getCurrentUserId();
                userId = accountId !== null && accountId !== void 0 ? accountId : unauthUuid;
                _context23.next = 6;
                return this.identityService.logTrackListen(trackId, userId, null, null, solanaListen);

              case 6:
                return _context23.abrupt("return", _context23.sent);

              case 7:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function logTrackListen(_x25, _x26) {
        return _logTrackListen.apply(this, arguments);
      }

      return logTrackListen;
    }()
    /**
     * Marks a tracks as deleted
     * @param trackId
     */

  }, {
    key: "deleteTrack",
    value: function () {
      var _deleteTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(trackId) {
        var ownerId;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                ownerId = this.userStateManager.getCurrentUserId();

                if (ownerId) {
                  _context24.next = 3;
                  break;
                }

                throw new Error('No users loaded for this wallet');

              case 3:
                _context24.next = 5;
                return this.contracts.EntityManagerClient.manageEntity(ownerId, EntityManagerClient.EntityType.TRACK, trackId, EntityManagerClient.Action.DELETE, '');

              case 5:
                return _context24.abrupt("return", _context24.sent);

              case 6:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function deleteTrack(_x27) {
        return _deleteTrack.apply(this, arguments);
      }

      return deleteTrack;
    }()
    /* ------- PRIVATE  ------- */
    // Throws an error upon validation failure

  }, {
    key: "_validateTrackMetadata",
    value: function _validateTrackMetadata(metadata) {
      this.OBJECT_HAS_PROPS(metadata, TRACK_PROPS, TRACK_REQUIRED_PROPS);
      this.creatorNode.validateTrackSchema(metadata);
    }
  }, {
    key: "_generateTrackId",
    value: function () {
      var _generateTrackId2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25() {
        var encodedId;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this.discoveryProvider.getUnclaimedId('tracks');

              case 2:
                encodedId = _context25.sent;

                if (encodedId) {
                  _context25.next = 5;
                  break;
                }

                throw new Error('No unclaimed track IDs');

              case 5:
                return _context25.abrupt("return", decodeHashId(encodedId));

              case 6:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function _generateTrackId() {
        return _generateTrackId2.apply(this, arguments);
      }

      return _generateTrackId;
    }()
  }]);

  return Track;
}(Base);

var Playlists = /*#__PURE__*/function (_Base) {
  _inherits(Playlists, _Base);

  var _super = _createSuper(Playlists);

  function Playlists() {
    var _this;

    _classCallCheck(this, Playlists);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.getPlaylists = _this.getPlaylists.bind(_assertThisInitialized(_this));
    _this.getSavedPlaylists = _this.getSavedPlaylists.bind(_assertThisInitialized(_this));
    _this.getSavedAlbums = _this.getSavedAlbums.bind(_assertThisInitialized(_this));
    return _this;
  }
  /* ------- GETTERS ------- */

  /**
   * get full playlist objects, including tracks, for passed in array of playlistId
   * @param limit max # of items to return
   * @param offset offset into list to return from (for pagination)
   * @param idsArray list of playlist ids
   * @param targetUserId the user whose playlists we're trying to get
   * @param withUsers whether to return users nested within the collection objects
   * @returns array of playlist objects
   * additional metadata fields on playlist objects:
   *  {Integer} repost_count - repost count for given playlist
   *  {Integer} save_count - save count for given playlist
   *  {Boolean} has_current_user_reposted - has current user reposted given playlist
   *  {Array} followee_reposts - followees of current user that have reposted given playlist
   *  {Boolean} has_current_user_reposted - has current user reposted given playlist
   *  {Boolean} has_current_user_saved - has current user saved given playlist
   */


  _createClass(Playlists, [{
    key: "getPlaylists",
    value: function () {
      var _getPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var limit,
            offset,
            idsArray,
            targetUserId,
            withUsers,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                limit = _args.length > 0 && _args[0] !== undefined ? _args[0] : 100;
                offset = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;
                idsArray = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;
                targetUserId = _args.length > 3 && _args[3] !== undefined ? _args[3] : null;
                withUsers = _args.length > 4 && _args[4] !== undefined ? _args[4] : false;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context.next = 8;
                return this.discoveryProvider.getPlaylists(limit, offset, idsArray, targetUserId, withUsers);

              case 8:
                return _context.abrupt("return", _context.sent);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getPlaylists() {
        return _getPlaylists.apply(this, arguments);
      }

      return getPlaylists;
    }()
    /**
     * Return saved playlists for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */

  }, {
    key: "getSavedPlaylists",
    value: function () {
      var _getSavedPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var limit,
            offset,
            withUsers,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                limit = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 100;
                offset = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 0;
                withUsers = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : false;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context2.next = 6;
                return this.discoveryProvider.getSavedPlaylists(limit, offset, withUsers);

              case 6:
                return _context2.abrupt("return", _context2.sent);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getSavedPlaylists() {
        return _getSavedPlaylists.apply(this, arguments);
      }

      return getSavedPlaylists;
    }()
    /**
     * Return saved albums for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */

  }, {
    key: "getSavedAlbums",
    value: function () {
      var _getSavedAlbums = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var limit,
            offset,
            withUsers,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                limit = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 100;
                offset = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 0;
                withUsers = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : false;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context3.next = 6;
                return this.discoveryProvider.getSavedAlbums(limit, offset, withUsers);

              case 6:
                return _context3.abrupt("return", _context3.sent);

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getSavedAlbums() {
        return _getSavedAlbums.apply(this, arguments);
      }

      return getSavedAlbums;
    }()
  }]);

  return Playlists;
}(Base);

/**
 * Downloads a file using an element in the DOM
 */

var downloadURL = function downloadURL(url, filename) {
  if (document) {
    var link = document.createElement('a');
    link.href = url;
    link.target = '_blank';
    link.download = filename;
    link.click();
    return;
  }

  throw new Error('No body document found');
};

var File = /*#__PURE__*/function (_Base) {
  _inherits(File, _Base);

  var _super = _createSuper(File);

  function File(user, serviceProvider) {
    var _this;

    _classCallCheck(this, File);

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "User", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "ServiceProvider", void 0);

    _this.User = user;
    _this.ServiceProvider = serviceProvider;
    return _this;
  }
  /**
   * Fetches a file from Discovery Provider with a given CID.
   * @param cid IPFS content identifier
   * @param responseType axios response type
   */


  _createClass(File, [{
    key: "fetchCIDFromDiscovery",
    value: function () {
      var _fetchCIDFromDiscovery = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(cid) {
        var responseType,
            timeoutMs,
            response,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                responseType = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'json';
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                timeoutMs = 4000;
                _context.next = 5;
                return this.discoveryProvider.getCIDData(cid, responseType, timeoutMs);

              case 5:
                response = _context.sent;

                if (response) {
                  _context.next = 8;
                  break;
                }

                throw new Error("Could not fetch ".concat(cid, " from discovery"));

              case 8:
                return _context.abrupt("return", response);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function fetchCIDFromDiscovery(_x) {
        return _fetchCIDFromDiscovery.apply(this, arguments);
      }

      return fetchCIDFromDiscovery;
    }()
    /**
     * Fetches a file from Content Node with a given CID.
     * @param cid IPFS content identifier
     * @param creatorNodeGateways Content Node gateways to fetch content from
     * @param callback callback called on each successful/failed fetch with
     *  [String, Bool](gateway, succeeded)
     *  Can be used for tracking metrics on which gateways were used.
     */

  }, {
    key: "fetchCID",
    value: function () {
      var _fetchCID = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(cid, creatorNodeGateways) {
        var callback,
            responseType,
            trackId,
            premiumContentHeaders,
            replicaSetAttempt,
            allCreatorNodes,
            allCreatorNodeEndpoints,
            allNodesAttempt,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                callback = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : null;
                responseType = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : 'blob';
                trackId = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : null;
                premiumContentHeaders = _args2.length > 5 && _args2[5] !== undefined ? _args2[5] : {};
                _context2.prev = 4;
                _context2.next = 7;
                return this.fetchCIDInternal(cid, creatorNodeGateways, callback, responseType, trackId, premiumContentHeaders);

              case 7:
                replicaSetAttempt = _context2.sent;
                return _context2.abrupt("return", replicaSetAttempt);

              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2["catch"](4);
                // In the case we can't find the CID from anywhere in the user's replica set,
                // retry the whole network
                console.error(_context2.t0);
                _context2.next = 16;
                return this.ServiceProvider.listCreatorNodes();

              case 16:
                allCreatorNodes = _context2.sent;
                allCreatorNodeEndpoints = allCreatorNodes.map(function (node) {
                  return urlJoin__default["default"](node.endpoint, 'ipfs');
                }); // Re-throw whatever error might happen here

                _context2.next = 20;
                return this.fetchCIDInternal(cid, allCreatorNodeEndpoints, callback, responseType, trackId, premiumContentHeaders, 0);

              case 20:
                allNodesAttempt = _context2.sent;
                return _context2.abrupt("return", allNodesAttempt);

              case 22:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[4, 11]]);
      }));

      function fetchCID(_x2, _x3) {
        return _fetchCID.apply(this, arguments);
      }

      return fetchCID;
    }()
  }, {
    key: "fetchCIDInternal",
    value: function () {
      var _fetchCIDInternal = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(cid, creatorNodeGateways) {
        var callback,
            responseType,
            trackId,
            premiumContentHeaders,
            retries,
            urls,
            _args4 = arguments;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                callback = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : null;
                responseType = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : 'blob';
                trackId = _args4.length > 4 && _args4[4] !== undefined ? _args4[4] : null;
                premiumContentHeaders = _args4.length > 5 && _args4[5] !== undefined ? _args4[5] : {};
                retries = _args4.length > 6 && _args4[6] !== undefined ? _args4[6] : 3;
                urls = [];
                creatorNodeGateways.forEach(function (gateway) {
                  var gatewayWithCid = urlJoin__default["default"](gateway, cid);
                  if (trackId) gatewayWithCid = urlJoin__default["default"](gatewayWithCid, {
                    query: {
                      trackId: trackId
                    }
                  });
                  urls.push(gatewayWithCid);
                });
                _context4.next = 9;
                return retry__default["default"]( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(bail) {
                    var _yield$raceRequests, response, errored, allForbidden, legacyUrls, _yield$raceRequests2, _response;

                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.prev = 0;
                            _context3.next = 3;
                            return raceRequests(urls, callback, _objectSpread2({
                              method: 'get',
                              responseType: responseType
                            }, premiumContentHeaders),
                            /* timeout */
                            null);

                          case 3:
                            _yield$raceRequests = _context3.sent;
                            response = _yield$raceRequests.response;
                            errored = _yield$raceRequests.errored;

                            if (response) {
                              _context3.next = 12;
                              break;
                            }

                            allForbidden = errored.length && errored.every( // @ts-expect-error not valid axios error
                            function (error) {
                              return error.response.status === 403;
                            });

                            if (!allForbidden) {
                              _context3.next = 11;
                              break;
                            }

                            // In the case for a 403, do not retry fetching
                            bail(new Error('Forbidden'));
                            return _context3.abrupt("return");

                          case 11:
                            throw new Error("Could not fetch ".concat(cid));

                          case 12:
                            return _context3.abrupt("return", response);

                          case 15:
                            _context3.prev = 15;
                            _context3.t0 = _context3["catch"](0);

                            if (!cid.includes('/')) {
                              _context3.next = 33;
                              break;
                            }

                            // dirCID -- an image
                            console.debug("Attempted to fetch image ".concat(cid, " via legacy method")); // Try legacy image format
                            // Lop off anything like /480x480.jpg in the CID

                            // Try legacy image format
                            // Lop off anything like /480x480.jpg in the CID
                            legacyUrls = creatorNodeGateways.map(function (gateway) {
                              return urlJoin__default["default"](gateway, cid.split('/')[0]);
                            });
                            _context3.prev = 20;
                            _context3.next = 23;
                            return raceRequests(legacyUrls, callback, _objectSpread2({
                              method: 'get',
                              responseType: responseType
                            }, premiumContentHeaders),
                            /* timeout */
                            null);

                          case 23:
                            _yield$raceRequests2 = _context3.sent;
                            _response = _yield$raceRequests2.response;

                            if (_response) {
                              _context3.next = 27;
                              break;
                            }

                            throw new Error("Could not fetch ".concat(cid, " via legacy method"));

                          case 27:
                            return _context3.abrupt("return", _response);

                          case 30:
                            _context3.prev = 30;
                            _context3.t1 = _context3["catch"](20);
                            throw new Error("Failed to retrieve ".concat(cid, " by legacy method"));

                          case 33:
                            throw new Error("Failed to retrieve ".concat(cid));

                          case 34:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3, null, [[0, 15], [20, 30]]);
                  }));

                  return function (_x6) {
                    return _ref.apply(this, arguments);
                  };
                }(), {
                  minTimeout: 500,
                  maxTimeout: 4000,
                  factor: 3,
                  retries: retries,
                  onRetry: function onRetry(err, i) {
                    // eslint-disable-next-line no-console
                    console.log("FetchCID attempt ".concat(i, " error: ").concat(err));
                  }
                });

              case 9:
                return _context4.abrupt("return", _context4.sent);

              case 10:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function fetchCIDInternal(_x4, _x5) {
        return _fetchCIDInternal.apply(this, arguments);
      }

      return fetchCIDInternal;
    }()
    /**
     * Fetches a file from Content Node with a given CID. Follows the same pattern
     * as fetchCID, but resolves with a download of the file rather than
     * returning the response content.
     * @param cid IPFS content identifier
     * @param creatorNodeGateways Content Node gateways to fetch content from
     * @param filename optional filename for the download
     */

  }, {
    key: "downloadCID",
    value: function () {
      var _downloadCID = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(cid, creatorNodeGateways, filename) {
        var urls, _yield$raceRequests3, response;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                urls = creatorNodeGateways.map(function (gateway) {
                  return urlJoin__default["default"](gateway, cid, {
                    query: {
                      filename: filename
                    }
                  });
                });
                _context5.prev = 1;
                _context5.next = 4;
                return raceRequests(urls, function (url) {
                  return downloadURL(url, filename);
                }, {
                  method: 'head'
                },
                /* timeout */
                10000);

              case 4:
                _yield$raceRequests3 = _context5.sent;
                response = _yield$raceRequests3.response;
                return _context5.abrupt("return", response);

              case 9:
                _context5.prev = 9;
                _context5.t0 = _context5["catch"](1);
                throw new Error("Failed to retrieve ".concat(cid));

              case 12:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[1, 9]]);
      }));

      function downloadCID(_x7, _x8, _x9) {
        return _downloadCID.apply(this, arguments);
      }

      return downloadCID;
    }()
    /**
     * Checks if a CID exists on a Content Node.
     * @param cid IPFS content identifier
     * @param creatorNodeGateways Content Node gateways to fetch content from
     * Eg. creatorNodeGateways = ["https://creatornode.audius.co/ipfs/", "https://creatornode2.audius.co/ipfs/"]
     */

  }, {
    key: "checkIfCidAvailable",
    value: function () {
      var _checkIfCidAvailable = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(cid, creatorNodeGateways) {
        var exists;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                exists = {};
                _context7.next = 3;
                return Promise.all(creatorNodeGateways.map( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(gateway) {
                    var _yield$axios, status;

                    return regeneratorRuntime.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.prev = 0;
                            _context6.next = 3;
                            return axios__default["default"]({
                              url: urlJoin__default["default"](gateway, cid),
                              method: 'head'
                            });

                          case 3:
                            _yield$axios = _context6.sent;
                            status = _yield$axios.status;
                            exists[gateway] = status === 200;
                            _context6.next = 11;
                            break;

                          case 8:
                            _context6.prev = 8;
                            _context6.t0 = _context6["catch"](0);
                            exists[gateway] = false;

                          case 11:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6, null, [[0, 8]]);
                  }));

                  return function (_x12) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 3:
                return _context7.abrupt("return", exists);

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function checkIfCidAvailable(_x10, _x11) {
        return _checkIfCidAvailable.apply(this, arguments);
      }

      return checkIfCidAvailable;
    }()
  }]);

  return File;
}(Base);

var Reactions = /*#__PURE__*/function (_Base) {
  _inherits(Reactions, _Base);

  var _super = _createSuper(Reactions);

  function Reactions() {
    var _this;

    _classCallCheck(this, Reactions);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.submitReaction = _this.submitReaction.bind(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Submit a user's reaction, represented by a numberic ID,
   * to an entity e.g. a notification for a received tip.
   */


  _createClass(Reactions, [{
    key: "submitReaction",
    value: function () {
      var _submitReaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
        var reactedTo, reactionValue, _ref$logger, logger, errorMessage;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                reactedTo = _ref.reactedTo, reactionValue = _ref.reactionValue, _ref$logger = _ref.logger, logger = _ref$logger === void 0 ? console : _ref$logger;
                _context.prev = 1;
                _context.next = 4;
                return this.identityService.submitReaction({
                  reactedTo: reactedTo,
                  reactionValue: reactionValue
                });

              case 4:
                logger.info("Successfully submitted reaction for entity ".concat(reactedTo, " and reaction value ").concat(reactionValue, "."));
                return _context.abrupt("return", {
                  success: true,
                  error: null
                });

              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](1);
                errorMessage = _context.t0.message;
                logger.error("Could not successfully submit reaction for entity ".concat(reactedTo, " and reaction value ").concat(reactionValue, ". Error: ").concat(errorMessage));
                return _context.abrupt("return", {
                  success: false,
                  error: errorMessage
                });

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 8]]);
      }));

      function submitReaction(_x) {
        return _submitReaction.apply(this, arguments);
      }

      return submitReaction;
    }()
  }]);

  return Reactions;
}(Base);

var Notifications = /*#__PURE__*/function (_Base) {
  _inherits(Notifications, _Base);

  var _super = _createSuper(Notifications);

  function Notifications() {
    var _this;

    _classCallCheck(this, Notifications);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.viewNotification = _this.viewNotification.bind(_assertThisInitialized(_this));
    _this.createNotification = _this.createNotification.bind(_assertThisInitialized(_this));
    _this.viewPlaylist = _this.viewPlaylist.bind(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Submit a user's view of notification event
   */


  _createClass(Notifications, [{
    key: "viewNotification",
    value: function () {
      var _viewNotification = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _ref,
            _ref$logger,
            logger,
            userId,
            _yield$this$contracts,
            txReceipt,
            errorMessage,
            _args = arguments;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _ref = _args.length > 0 && _args[0] !== undefined ? _args[0] : {
                  logger: console
                }, _ref$logger = _ref.logger, logger = _ref$logger === void 0 ? console : _ref$logger;
                _context.prev = 1;
                userId = this.userStateManager.getCurrentUserId();

                if (userId) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return", {
                  error: 'Missing current user ID'
                });

              case 5:
                _context.next = 7;
                return this.contracts.EntityManagerClient.manageEntity(userId, EntityType.NOTIFICATION, userId, Action.VIEW, '');

              case 7:
                _yield$this$contracts = _context.sent;
                txReceipt = _yield$this$contracts.txReceipt;
                return _context.abrupt("return", {
                  txReceipt: txReceipt
                });

              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](1);
                errorMessage = _context.t0.message;
                logger.error("Could not successfully submit view notification action to entity manager. Error: ".concat(errorMessage));
                return _context.abrupt("return", {
                  error: errorMessage
                });

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 12]]);
      }));

      function viewNotification() {
        return _viewNotification.apply(this, arguments);
      }

      return viewNotification;
    }()
    /**
     * Creates a new notification
     * NOTE: currently only used for announcements and permissioned to a single wallet signer
     */

  }, {
    key: "createNotification",
    value: function () {
      var _createNotification = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {
        var _ref2$logger, logger, data, _yield$this$contracts2, txReceipt, errorMessage;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref2$logger = _ref2.logger, logger = _ref2$logger === void 0 ? console : _ref2$logger, data = _ref2.data;
                _context2.prev = 1;
                _context2.next = 4;
                return this.contracts.EntityManagerClient.manageEntity(1, // NOTE: This field does not matter
                EntityType.NOTIFICATION, 1, // NOTE: This field does not matter
                Action.CREATE, JSON.stringify(data));

              case 4:
                _yield$this$contracts2 = _context2.sent;
                txReceipt = _yield$this$contracts2.txReceipt;
                return _context2.abrupt("return", {
                  txReceipt: txReceipt
                });

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2["catch"](1);
                errorMessage = _context2.t0.message;
                logger.error("Could not successfully submit create notification action to entity manager. Error: ".concat(errorMessage));
                return _context2.abrupt("return", {
                  error: errorMessage
                });

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 9]]);
      }));

      function createNotification(_x) {
        return _createNotification.apply(this, arguments);
      }

      return createNotification;
    }()
  }, {
    key: "viewPlaylist",
    value: function () {
      var _viewPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref3) {
        var _ref3$logger, logger, playlistId, userId, _yield$this$contracts3, txReceipt, errorMessage;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _ref3$logger = _ref3.logger, logger = _ref3$logger === void 0 ? console : _ref3$logger, playlistId = _ref3.playlistId;
                _context3.prev = 1;
                userId = this.userStateManager.getCurrentUserId();

                if (userId) {
                  _context3.next = 5;
                  break;
                }

                return _context3.abrupt("return", {
                  error: 'Missing current user ID'
                });

              case 5:
                if (playlistId) {
                  _context3.next = 7;
                  break;
                }

                return _context3.abrupt("return", {
                  error: 'Missing playlist ID'
                });

              case 7:
                _context3.next = 9;
                return this.contracts.EntityManagerClient.manageEntity(userId, EntityType.NOTIFICATION, playlistId, Action.VIEW_PLAYLIST, '');

              case 9:
                _yield$this$contracts3 = _context3.sent;
                txReceipt = _yield$this$contracts3.txReceipt;
                return _context3.abrupt("return", {
                  txReceipt: txReceipt
                });

              case 14:
                _context3.prev = 14;
                _context3.t0 = _context3["catch"](1);
                errorMessage = _context3.t0.message;
                logger.error("Could not successfully submit view playlist action to entity manager. Error: ".concat(errorMessage));
                return _context3.abrupt("return", {
                  error: errorMessage
                });

              case 19:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[1, 14]]);
      }));

      function viewPlaylist(_x2) {
        return _viewPlaylist.apply(this, arguments);
      }

      return viewPlaylist;
    }()
  }, {
    key: "getNotifications",
    value: function () {
      var _getNotifications = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context4.next = 3;
                return this.discoveryProvider.getUserNotifications(params);

              case 3:
                return _context4.abrupt("return", _context4.sent);

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getNotifications(_x3) {
        return _getNotifications.apply(this, arguments);
      }

      return getNotifications;
    }()
  }]);

  return Notifications;
}(Base);

/**
 * Local storage interface that supports async storage implementations
 */

/**
 * Fallback for localStorage that works in node and the browser
 * @returns localStorage
 */
var getPlatformLocalStorage = function getPlatformLocalStorage() {
  if (typeof window === 'undefined' || window === null) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    var LocalStorage = require('node-localstorage').LocalStorage;

    return new LocalStorage('./local-storage');
  } else {
    return window.localStorage;
  }
};

/*
  API surface for updated data contract interactions.
  Provides simplified entity management in a generic fashion
  Handles metadata + file upload etc. for entities such as Playlist/Track/User
*/

var EntityManager = /*#__PURE__*/function (_Base) {
  _inherits(EntityManager, _Base);

  var _super = _createSuper(EntityManager);

  function EntityManager() {
    var _this;

    _classCallCheck(this, EntityManager);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "createSocialMethod", function (entityType, action) {
      return /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(entityId) {
          var metadata,
              responseValues,
              error,
              _args = arguments;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  metadata = _args.length > 1 && _args[1] !== undefined ? _args[1] : '';
                  responseValues = _this.getDefaultEntityManagerResponseValues();
                  _context.prev = 2;
                  _context.next = 5;
                  return _this.manageEntity({
                    userId: _this.getCurrentUserId(),
                    entityType: entityType,
                    entityId: entityId,
                    action: action,
                    metadata: metadata
                  });

                case 5:
                  return _context.abrupt("return", _context.sent);

                case 8:
                  _context.prev = 8;
                  _context.t0 = _context["catch"](2);
                  error = _context.t0.message;
                  responseValues.error = error;
                  return _context.abrupt("return", responseValues);

                case 13:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[2, 8]]);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }();
    });

    _defineProperty$1(_assertThisInitialized(_this), "followUser", _this.createSocialMethod(EntityType.USER, Action.FOLLOW));

    _defineProperty$1(_assertThisInitialized(_this), "unfollowUser", _this.createSocialMethod(EntityType.USER, Action.UNFOLLOW));

    _defineProperty$1(_assertThisInitialized(_this), "saveTrack", _this.createSocialMethod(EntityType.TRACK, Action.SAVE));

    _defineProperty$1(_assertThisInitialized(_this), "unsaveTrack", _this.createSocialMethod(EntityType.TRACK, Action.UNSAVE));

    _defineProperty$1(_assertThisInitialized(_this), "savePlaylist", _this.createSocialMethod(EntityType.PLAYLIST, Action.SAVE));

    _defineProperty$1(_assertThisInitialized(_this), "unsavePlaylist", _this.createSocialMethod(EntityType.PLAYLIST, Action.UNSAVE));

    _defineProperty$1(_assertThisInitialized(_this), "repostTrack", _this.createSocialMethod(EntityType.TRACK, Action.REPOST));

    _defineProperty$1(_assertThisInitialized(_this), "unrepostTrack", _this.createSocialMethod(EntityType.TRACK, Action.UNREPOST));

    _defineProperty$1(_assertThisInitialized(_this), "repostPlaylist", _this.createSocialMethod(EntityType.PLAYLIST, Action.REPOST));

    _defineProperty$1(_assertThisInitialized(_this), "unrepostPlaylist", _this.createSocialMethod(EntityType.PLAYLIST, Action.UNREPOST));

    return _this;
  }

  _createClass(EntityManager, [{
    key: "mapTimestamps",
    value:
    /**
     * Generate random integer between two known values
     */
    function mapTimestamps(addedTimestamps) {
      var trackIds = addedTimestamps.map(function (trackObj) {
        var _trackObj$metadata_ti;

        return {
          track: trackObj.track,
          time: (_trackObj$metadata_ti = trackObj.metadata_time) !== null && _trackObj$metadata_ti !== void 0 ? _trackObj$metadata_ti : trackObj.time // default to time for legacy playlists

        };
      });
      return trackIds;
    }
  }, {
    key: "getCurrentUserId",
    value: function getCurrentUserId() {
      var userId = this.userStateManager.getCurrentUserId();

      if (!userId) {
        throw new Error('Missing current user ID');
      }

      return userId;
    }
  }, {
    key: "getDefaultEntityManagerResponseValues",
    value: function getDefaultEntityManagerResponseValues() {
      return {
        blockHash: null,
        blockNumber: null,
        error: ''
      };
    }
    /** Social Features */

  }, {
    key: "createPlaylist",
    value:
    /** Playlist */
    function () {
      var _createPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(playlist) {
        var responseValues, _playlist$artwork, _dirCID, userId, createAction, entityType, dirCID, updatedPlaylistImage, tracks, metadata, metadataCid, entityManagerMetadata, error;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                responseValues = this.getDefaultEntityManagerResponseValues();
                _context2.prev = 1;
                userId = this.userStateManager.getCurrentUserId();

                if (userId) {
                  _context2.next = 6;
                  break;
                }

                responseValues.error = 'Missing current user ID';
                return _context2.abrupt("return", responseValues);

              case 6:
                createAction = Action.CREATE;
                entityType = EntityType.PLAYLIST;
                this.REQUIRES(Services.CREATOR_NODE);

                if (!(playlist !== null && playlist !== void 0 && (_playlist$artwork = playlist.artwork) !== null && _playlist$artwork !== void 0 && _playlist$artwork.file)) {
                  _context2.next = 14;
                  break;
                }

                _context2.next = 12;
                return this.creatorNode.uploadTrackCoverArtV2(playlist.artwork.file);

              case 12:
                updatedPlaylistImage = _context2.sent;
                dirCID = updatedPlaylistImage.id;

              case 14:
                tracks = this.mapTimestamps(playlist.playlist_contents.track_ids);
                metadata = {
                  playlist_id: playlist.playlist_id,
                  playlist_contents: {
                    track_ids: tracks
                  },
                  playlist_name: playlist.playlist_name,
                  playlist_image_sizes_multihash: (_dirCID = dirCID) !== null && _dirCID !== void 0 ? _dirCID : playlist.cover_art_sizes,
                  description: playlist.description,
                  is_album: playlist.is_album,
                  is_private: playlist.is_private,
                  is_image_autogenerated: false
                };
                this.creatorNode.validatePlaylistSchema(metadata);
                _context2.next = 19;
                return Utils.fileHasher.generateMetadataCidV1(metadata);

              case 19:
                metadataCid = _context2.sent.toString();
                entityManagerMetadata = JSON.stringify({
                  cid: metadataCid,
                  data: metadata
                });
                _context2.next = 23;
                return this.manageEntity({
                  userId: userId,
                  entityType: entityType,
                  entityId: playlist.playlist_id,
                  action: createAction,
                  metadata: entityManagerMetadata
                });

              case 23:
                return _context2.abrupt("return", _context2.sent);

              case 26:
                _context2.prev = 26;
                _context2.t0 = _context2["catch"](1);
                error = _context2.t0.message;
                responseValues.error = error;
                return _context2.abrupt("return", responseValues);

              case 31:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 26]]);
      }));

      function createPlaylist(_x2) {
        return _createPlaylist.apply(this, arguments);
      }

      return createPlaylist;
    }()
  }, {
    key: "deletePlaylist",
    value: function () {
      var _deletePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(playlistId) {
        var responseValues, userId, error;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                responseValues = this.getDefaultEntityManagerResponseValues();
                userId = this.userStateManager.getCurrentUserId();

                if (userId) {
                  _context3.next = 5;
                  break;
                }

                responseValues.error = 'Missing current user ID';
                return _context3.abrupt("return", responseValues);

              case 5:
                _context3.prev = 5;
                _context3.next = 8;
                return this.manageEntity({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.DELETE,
                  metadata: ''
                });

              case 8:
                return _context3.abrupt("return", _context3.sent);

              case 11:
                _context3.prev = 11;
                _context3.t0 = _context3["catch"](5);
                error = _context3.t0.message;
                responseValues.error = error;
                return _context3.abrupt("return", responseValues);

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[5, 11]]);
      }));

      function deletePlaylist(_x3) {
        return _deletePlaylist.apply(this, arguments);
      }

      return deletePlaylist;
    }()
  }, {
    key: "updatePlaylist",
    value: function () {
      var _updatePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(playlist) {
        var responseValues, _playlist$artwork2, _dirCID2, userId, updateAction, entityType, dirCID, updatedPlaylistImage, trackIds, metadata, metadataCid, entityManagerMetadata, error;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                responseValues = this.getDefaultEntityManagerResponseValues();
                _context4.prev = 1;
                userId = this.userStateManager.getCurrentUserId();

                if (!(!playlist || playlist === undefined)) {
                  _context4.next = 6;
                  break;
                }

                responseValues.error = 'Missing current playlist';
                return _context4.abrupt("return", responseValues);

              case 6:
                if (userId) {
                  _context4.next = 9;
                  break;
                }

                responseValues.error = 'Missing current user ID';
                return _context4.abrupt("return", responseValues);

              case 9:
                updateAction = Action.UPDATE;
                entityType = EntityType.PLAYLIST;
                this.REQUIRES(Services.CREATOR_NODE);

                if (!(playlist !== null && playlist !== void 0 && (_playlist$artwork2 = playlist.artwork) !== null && _playlist$artwork2 !== void 0 && _playlist$artwork2.file)) {
                  _context4.next = 17;
                  break;
                }

                _context4.next = 15;
                return this.creatorNode.uploadTrackCoverArtV2(playlist.artwork.file);

              case 15:
                updatedPlaylistImage = _context4.sent;
                dirCID = updatedPlaylistImage.id;

              case 17:
                trackIds = this.mapTimestamps(playlist.playlist_contents.track_ids);
                metadata = {
                  playlist_id: playlist.playlist_id,
                  playlist_contents: {
                    track_ids: trackIds
                  },
                  playlist_name: playlist.playlist_name,
                  playlist_image_sizes_multihash: (_dirCID2 = dirCID) !== null && _dirCID2 !== void 0 ? _dirCID2 : playlist.cover_art_sizes,
                  description: playlist.description,
                  is_album: playlist.is_album,
                  is_private: playlist.is_private,
                  is_image_autogenerated: playlist.is_image_autogenerated
                };
                this.creatorNode.validatePlaylistSchema(metadata);
                _context4.next = 22;
                return Utils.fileHasher.generateMetadataCidV1(metadata);

              case 22:
                metadataCid = _context4.sent.toString();
                entityManagerMetadata = JSON.stringify({
                  cid: metadataCid,
                  data: metadata
                });
                _context4.next = 26;
                return this.manageEntity({
                  userId: userId,
                  entityType: entityType,
                  entityId: playlist.playlist_id,
                  action: updateAction,
                  metadata: entityManagerMetadata
                });

              case 26:
                return _context4.abrupt("return", _context4.sent);

              case 29:
                _context4.prev = 29;
                _context4.t0 = _context4["catch"](1);
                error = _context4.t0.message;
                responseValues.error = error;
                return _context4.abrupt("return", responseValues);

              case 34:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[1, 29]]);
      }));

      function updatePlaylist(_x4) {
        return _updatePlaylist.apply(this, arguments);
      }

      return updatePlaylist;
    }()
    /**
     * Manage an entity with the updated data contract flow
     * Leveraged to manipulate User/Track/Playlist/+ other entities
     */

  }, {
    key: "manageEntity",
    value: function () {
      var _manageEntity = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref2) {
        var userId, entityType, entityId, action, metadata, responseValues, resp, error;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                userId = _ref2.userId, entityType = _ref2.entityType, entityId = _ref2.entityId, action = _ref2.action, metadata = _ref2.metadata;
                responseValues = this.getDefaultEntityManagerResponseValues();
                _context5.prev = 2;

                if (!(this.contracts.EntityManagerClient === undefined)) {
                  _context5.next = 5;
                  break;
                }

                throw new Error('EntityManagerClient is undefined');

              case 5:
                _context5.next = 7;
                return this.contracts.EntityManagerClient.manageEntity(userId, entityType, entityId, action, metadata !== null && metadata !== void 0 ? metadata : '');

              case 7:
                resp = _context5.sent;
                responseValues.blockHash = resp.txReceipt.blockHash;
                responseValues.blockNumber = resp.txReceipt.blockNumber;
                return _context5.abrupt("return", responseValues);

              case 13:
                _context5.prev = 13;
                _context5.t0 = _context5["catch"](2);
                error = _context5.t0.message;
                responseValues.error = error;
                return _context5.abrupt("return", responseValues);

              case 18:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[2, 13]]);
      }));

      function manageEntity(_x5) {
        return _manageEntity.apply(this, arguments);
      }

      return manageEntity;
    }()
  }]);

  return EntityManager;
}(Base);

/**
 * Sanity check for whether a user needs a recovery email to be sent.
 * Users with accounts created before email recovery existed need
 * to be sent an email on their next log-in just in case they get logged
 * out of their account.
 */
var needsRecoveryEmail = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(libs) {
    var _libs$userStateManage, _libs$identityService;

    var user, events, _libs$Account;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            console.debug('Sanity Check - needsRecoveryEmail');
            user = (_libs$userStateManage = libs.userStateManager) === null || _libs$userStateManage === void 0 ? void 0 : _libs$userStateManage.getCurrentUser();

            if (!(!user || !user.wallet)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return");

          case 4:
            _context.next = 6;
            return (_libs$identityService = libs.identityService) === null || _libs$identityService === void 0 ? void 0 : _libs$identityService.getUserEvents(user.wallet);

          case 6:
            events = _context.sent;

            if (!(events !== null && events !== void 0 && events.needsRecoveryEmail)) {
              _context.next = 11;
              break;
            }

            console.debug('Sanity Check - needsRecoveryEmail - Sending Email'); // Send email

            _context.next = 11;
            return (_libs$Account = libs.Account) === null || _libs$Account === void 0 ? void 0 : _libs$Account.generateRecoveryLink();

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function needsRecoveryEmail(_x) {
    return _ref.apply(this, arguments);
  };
}();

var SanityChecks = /*#__PURE__*/function () {
  function SanityChecks(libsInstance) {
    _classCallCheck(this, SanityChecks);

    _defineProperty$1(this, "libs", void 0);

    this.libs = libsInstance;
  }
  /**
   * Runs sanity checks
   */


  _createClass(SanityChecks, [{
    key: "run",
    value: function () {
      var _run = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return needsRecoveryEmail(this.libs);

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function run() {
        return _run.apply(this, arguments);
      }

      return run;
    }()
  }]);

  return SanityChecks;
}();

var AudiusLibs = /*#__PURE__*/function () {
  /**
   * Constructs an Audius Libs instance with configs.
   * Unless default-valued, all configs are optional.
   * @example
   *  const audius = AudiusLibs({
   *    discoveryProviderConfig: {},
   *    creatorNodeConfig: configCreatorNode('https://my-creator.node')
   *  })
   *  await audius.init()
   */
  function AudiusLibs(_ref) {
    var web3Config = _ref.web3Config,
        ethWeb3Config = _ref.ethWeb3Config,
        solanaWeb3Config = _ref.solanaWeb3Config,
        identityServiceConfig = _ref.identityServiceConfig,
        discoveryProviderConfig = _ref.discoveryProviderConfig,
        creatorNodeConfig = _ref.creatorNodeConfig,
        comstockConfig = _ref.comstockConfig,
        wormholeConfig = _ref.wormholeConfig,
        hedgehogConfig = _ref.hedgehogConfig,
        isServer = _ref.isServer,
        _ref$logger = _ref.logger,
        logger = _ref$logger === void 0 ? console : _ref$logger,
        _ref$isDebug = _ref.isDebug,
        isDebug = _ref$isDebug === void 0 ? false : _ref$isDebug,
        _ref$preferHigherPatc = _ref.preferHigherPatchForPrimary,
        preferHigherPatchForPrimary = _ref$preferHigherPatc === void 0 ? true : _ref$preferHigherPatc,
        _ref$preferHigherPatc2 = _ref.preferHigherPatchForSecondaries,
        preferHigherPatchForSecondaries = _ref$preferHigherPatc2 === void 0 ? true : _ref$preferHigherPatc2,
        _ref$localStorage = _ref.localStorage,
        localStorage = _ref$localStorage === void 0 ? getPlatformLocalStorage() : _ref$localStorage;

    _classCallCheck(this, AudiusLibs);

    _defineProperty$1(this, "version", void 0);

    _defineProperty$1(this, "ethWeb3Config", void 0);

    _defineProperty$1(this, "web3Config", void 0);

    _defineProperty$1(this, "solanaWeb3Config", void 0);

    _defineProperty$1(this, "identityServiceConfig", void 0);

    _defineProperty$1(this, "creatorNodeConfig", void 0);

    _defineProperty$1(this, "discoveryProviderConfig", void 0);

    _defineProperty$1(this, "comstockConfig", void 0);

    _defineProperty$1(this, "wormholeConfig", void 0);

    _defineProperty$1(this, "hedgehogConfig", void 0);

    _defineProperty$1(this, "isServer", void 0);

    _defineProperty$1(this, "isDebug", void 0);

    _defineProperty$1(this, "logger", void 0);

    _defineProperty$1(this, "AudiusABIDecoder", void 0);

    _defineProperty$1(this, "Utils", void 0);

    _defineProperty$1(this, "userStateManager", void 0);

    _defineProperty$1(this, "identityService", void 0);

    _defineProperty$1(this, "hedgehog", void 0);

    _defineProperty$1(this, "discoveryProvider", void 0);

    _defineProperty$1(this, "ethWeb3Manager", void 0);

    _defineProperty$1(this, "ethContracts", void 0);

    _defineProperty$1(this, "web3Manager", void 0);

    _defineProperty$1(this, "solanaWeb3Manager", void 0);

    _defineProperty$1(this, "contracts", void 0);

    _defineProperty$1(this, "wormholeClient", void 0);

    _defineProperty$1(this, "creatorNode", void 0);

    _defineProperty$1(this, "schemas", void 0);

    _defineProperty$1(this, "comstock", void 0);

    _defineProperty$1(this, "ServiceProvider", void 0);

    _defineProperty$1(this, "Account", void 0);

    _defineProperty$1(this, "User", void 0);

    _defineProperty$1(this, "Track", void 0);

    _defineProperty$1(this, "Playlist", void 0);

    _defineProperty$1(this, "File", void 0);

    _defineProperty$1(this, "Rewards", void 0);

    _defineProperty$1(this, "Reactions", void 0);

    _defineProperty$1(this, "Notifications", void 0);

    _defineProperty$1(this, "EntityManager", void 0);

    _defineProperty$1(this, "preferHigherPatchForPrimary", void 0);

    _defineProperty$1(this, "preferHigherPatchForSecondaries", void 0);

    _defineProperty$1(this, "localStorage", void 0);

    // set version
    this.version = version_1;
    this.ethWeb3Config = ethWeb3Config;
    this.web3Config = web3Config;
    this.solanaWeb3Config = solanaWeb3Config;
    this.identityServiceConfig = identityServiceConfig;
    this.creatorNodeConfig = creatorNodeConfig;
    this.discoveryProviderConfig = discoveryProviderConfig;
    this.comstockConfig = comstockConfig;
    this.wormholeConfig = wormholeConfig;
    this.hedgehogConfig = hedgehogConfig;
    this.isServer = isServer;
    this.isDebug = isDebug;
    this.logger = logger;
    this.AudiusABIDecoder = AudiusABIDecoder;
    this.Utils = Utils; // Services to initialize. Initialized in .init().

    this.userStateManager = null;
    this.identityService = null;
    this.hedgehog = null;
    this.discoveryProvider = null;
    this.ethWeb3Manager = null;
    this.ethContracts = null;
    this.web3Manager = null;
    this.solanaWeb3Manager = null;
    this.wormholeClient = null;
    this.contracts = null;
    this.creatorNode = null;
    this.comstock = null; // API

    this.ServiceProvider = null;
    this.Account = null;
    this.User = null;
    this.Track = null;
    this.Playlist = null;
    this.File = null;
    this.Rewards = null;
    this.Reactions = null;
    this.Notifications = null;
    this.EntityManager = null;
    this.preferHigherPatchForPrimary = preferHigherPatchForPrimary;
    this.preferHigherPatchForSecondaries = preferHigherPatchForSecondaries;
    this.localStorage = localStorage; // Schemas

    var schemaValidator = new SchemaValidator();
    schemaValidator.init();
    this.schemas = schemaValidator.getSchemas();
  }
  /** Init services based on presence of a relevant config. */


  _createClass(AudiusLibs, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var hedgehogService, contractsToInit, _this$ethWeb3Config, _ref2, _ref2$tokenAddress, tokenAddress, _ref2$registryAddress, registryAddress, _ref2$claimDistributi, claimDistributionContractAddress, _ref2$wormholeContrac, wormholeContractAddress, currentUser, creatorNodeEndpoint, _this$creatorNodeConf, _this$creatorNodeConf2, storageNode, storageV2Nodes, randomNodes, services;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.userStateManager = new UserStateManager({
                  localStorage: this.localStorage
                }); // Config external web3 is an async function, so await it here in case it needs to be

                _context.next = 3;
                return this.web3Config;

              case 3:
                this.web3Config = _context.sent;

                if (!this.identityServiceConfig) {
                  _context.next = 12;
                  break;
                }

                this.identityService = new IdentityService({
                  identityServiceEndpoint: this.identityServiceConfig.url
                });
                hedgehogService = new Hedgehog(_objectSpread2({
                  identityService: this.identityService,
                  useLocalStorage: this.identityServiceConfig.useHedgehogLocalStorage,
                  localStorage: this.localStorage
                }, this.hedgehogConfig));
                this.hedgehog = hedgehogService.instance;
                _context.next = 10;
                return this.hedgehog.waitUntilReady();

              case 10:
                _context.next = 14;
                break;

              case 12:
                if (!(this.web3Config && !this.web3Config.useExternalWeb3)) {
                  _context.next = 14;
                  break;
                }

                throw new Error('Identity Service required for internal Web3');

              case 14:
                /** Web3 Managers */
                if (this.ethWeb3Config) {
                  this.ethWeb3Manager = new EthWeb3Manager({
                    web3Config: this.ethWeb3Config,
                    identityService: this.identityService,
                    hedgehog: this.hedgehog
                  });
                }

                if (!this.web3Config) {
                  _context.next = 20;
                  break;
                }

                this.web3Manager = new Web3Manager({
                  web3Config: this.web3Config,
                  identityService: this.identityService,
                  hedgehog: this.hedgehog,
                  isServer: this.isServer
                });
                _context.next = 19;
                return this.web3Manager.init();

              case 19:
                if (this.identityService) {
                  this.identityService.setWeb3Manager(this.web3Manager);
                }

              case 20:
                if (!this.solanaWeb3Config) {
                  _context.next = 24;
                  break;
                }

                this.solanaWeb3Manager = new SolanaWeb3Manager(this.solanaWeb3Config, this.identityService, this.web3Manager);
                _context.next = 24;
                return this.solanaWeb3Manager.init();

              case 24:
                /** Contracts - Eth and Data Contracts */
                contractsToInit = [];

                if (this.ethWeb3Manager) {
                  _ref2 = (_this$ethWeb3Config = this.ethWeb3Config) !== null && _this$ethWeb3Config !== void 0 ? _this$ethWeb3Config : {}, _ref2$tokenAddress = _ref2.tokenAddress, tokenAddress = _ref2$tokenAddress === void 0 ? null : _ref2$tokenAddress, _ref2$registryAddress = _ref2.registryAddress, registryAddress = _ref2$registryAddress === void 0 ? null : _ref2$registryAddress, _ref2$claimDistributi = _ref2.claimDistributionContractAddress, claimDistributionContractAddress = _ref2$claimDistributi === void 0 ? null : _ref2$claimDistributi, _ref2$wormholeContrac = _ref2.wormholeContractAddress, wormholeContractAddress = _ref2$wormholeContrac === void 0 ? null : _ref2$wormholeContrac;
                  this.ethContracts = new EthContracts({
                    ethWeb3Manager: this.ethWeb3Manager,
                    tokenContractAddress: tokenAddress,
                    registryAddress: registryAddress,
                    claimDistributionContractAddress: claimDistributionContractAddress,
                    wormholeContractAddress: wormholeContractAddress,
                    isServer: this.isServer,
                    logger: this.logger,
                    isDebug: this.isDebug
                  });
                  contractsToInit.push(this.ethContracts.init());
                }

                if (this.web3Manager) {
                  this.contracts = new AudiusContracts(this.web3Manager, this.web3Config ? this.web3Config.registryAddress : null, this.web3Config ? this.web3Config.entityManagerAddress : null, this.isServer, this.logger);
                  contractsToInit.push(this.contracts.init());
                }

                _context.next = 29;
                return Promise.all(contractsToInit);

              case 29:
                if (this.wormholeConfig && this.ethWeb3Manager && this.ethContracts && this.solanaWeb3Manager) {
                  this.wormholeClient = new Wormhole(this.hedgehog, this.ethWeb3Manager, this.ethContracts, this.identityService, this.solanaWeb3Manager, this.wormholeConfig.rpcHosts, this.wormholeConfig.solBridgeAddress, this.wormholeConfig.solTokenBridgeAddress, this.wormholeConfig.ethBridgeAddress, this.wormholeConfig.ethTokenBridgeAddress);
                }
                /** Discovery Provider */


                if (!this.discoveryProviderConfig) {
                  _context.next = 34;
                  break;
                }

                this.discoveryProvider = new DiscoveryProvider(_objectSpread2({
                  userStateManager: this.userStateManager,
                  ethContracts: this.ethContracts,
                  web3Manager: this.web3Manager,
                  localStorage: this.localStorage
                }, this.discoveryProviderConfig));
                _context.next = 34;
                return this.discoveryProvider.init();

              case 34:
                if (!this.creatorNodeConfig) {
                  _context.next = 54;
                  break;
                }

                currentUser = this.userStateManager.getCurrentUser(); // Use rendezvous to select creatorNodeEndpoint

                creatorNodeEndpoint = this.creatorNodeConfig.fallbackUrl;

                if (!(currentUser !== null && currentUser !== void 0 && currentUser.wallet)) {
                  _context.next = 51;
                  break;
                }

                if (!this.creatorNodeConfig.storageNodeSelector) {
                  _context.next = 43;
                  break;
                }

                _this$creatorNodeConf = this.creatorNodeConfig.storageNodeSelector.getNodes(currentUser.wallet), _this$creatorNodeConf2 = _slicedToArray(_this$creatorNodeConf, 1), storageNode = _this$creatorNodeConf2[0];

                if (storageNode) {
                  creatorNodeEndpoint = storageNode;
                }

                _context.next = 51;
                break;

              case 43:
                if (!this.ethContracts) {
                  _context.next = 51;
                  break;
                }

                _context.next = 46;
                return this.ethContracts.ServiceProviderFactoryClient.getServiceProviderList('content-node');

              case 46:
                storageV2Nodes = _context.sent;
                _context.next = 49;
                return getNStorageNodes(storageV2Nodes, 1, currentUser.wallet, this.logger);

              case 49:
                randomNodes = _context.sent;
                creatorNodeEndpoint = randomNodes[0];

              case 51:
                this.creatorNode = new CreatorNode(this.web3Manager, creatorNodeEndpoint, this.isServer, this.userStateManager, this.schemas, this.creatorNodeConfig.passList, this.creatorNodeConfig.blockList, this.creatorNodeConfig.monitoringCallbacks, this.creatorNodeConfig.storageNodeSelector);
                _context.next = 54;
                return this.creatorNode.init();

              case 54:
                /** Comstock */
                if (this.comstockConfig) {
                  this.comstock = new Comstock(this.comstockConfig.url);
                } // Initialize apis


                services = [this.userStateManager, this.identityService, this.hedgehog, this.discoveryProvider, this.web3Manager, this.contracts, this.ethWeb3Manager, this.ethContracts, this.solanaWeb3Manager, this.wormholeClient, this.creatorNode, this.comstock, this.isServer, this.logger];
                this.ServiceProvider = _construct(ServiceProvider, services);
                this.User = _construct(Users, [this.ServiceProvider, this.preferHigherPatchForPrimary, this.preferHigherPatchForSecondaries].concat(services));
                this.Account = _construct(Account, [this.User, this.ServiceProvider].concat(services));
                this.Track = _construct(Track, services);
                this.Playlist = _construct(Playlists, services);
                this.File = _construct(File, [this.User, this.ServiceProvider].concat(services));
                this.Rewards = _construct(Rewards, [this.ServiceProvider].concat(services));
                this.Reactions = _construct(Reactions, services);
                this.Notifications = _construct(Notifications, services);
                this.EntityManager = _construct(EntityManager, services);

              case 66:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }], [{
    key: "configIdentityService",
    value:
    /**
     * Configures an identity service wrapper
     */
    function configIdentityService(url) {
      var useHedgehogLocalStorage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return {
        url: url,
        useHedgehogLocalStorage: useHedgehogLocalStorage
      };
    }
    /**
     * Configures an identity service wrapper
     */

  }, {
    key: "configComstock",
    value: function configComstock(url) {
      return {
        url: url
      };
    }
  }, {
    key: "configCreatorNode",
    value: function configCreatorNode( // creator node endpoint to fall back to on requests
    fallbackUrl) {
      var passList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var blockList = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var monitoringCallbacks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      return {
        fallbackUrl: fallbackUrl,
        passList: passList,
        blockList: blockList,
        monitoringCallbacks: monitoringCallbacks
      };
    }
    /**
     * Configures an external web3 to use with Audius Libs (e.g. MetaMask)
     */

  }, {
    key: "configExternalWeb3",
    value: function () {
      var _configExternalWeb = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(registryAddress, // equal to web.currentProvider
      web3Provider, // network chain id
      networkId) {
        var walletOverride,
            entityManagerAddress,
            web3Instance,
            wallets,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                walletOverride = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : null;
                entityManagerAddress = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : null;
                _context2.next = 4;
                return Utils.configureWeb3(web3Provider, networkId);

              case 4:
                web3Instance = _context2.sent;

                if (web3Instance) {
                  _context2.next = 7;
                  break;
                }

                throw new Error('External web3 incorrectly configured');

              case 7:
                _context2.next = 9;
                return web3Instance.eth.getAccounts();

              case 9:
                wallets = _context2.sent;
                return _context2.abrupt("return", {
                  registryAddress: registryAddress,
                  entityManagerAddress: entityManagerAddress,
                  useExternalWeb3: true,
                  externalWeb3Config: {
                    web3: web3Instance,
                    ownerWallet: walletOverride !== null && walletOverride !== void 0 ? walletOverride : wallets[0]
                  }
                });

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function configExternalWeb3(_x, _x2, _x3) {
        return _configExternalWeb.apply(this, arguments);
      }

      return configExternalWeb3;
    }()
    /**
     * Configures an internal web3 to use (via Hedgehog)
     */

  }, {
    key: "configInternalWeb3",
    value: function configInternalWeb3(registryAddress, providers, privateKey, entityManagerAddress) {
      var providerList;

      if (typeof providers === 'string') {
        providerList = providers.split(',');
      } else if (providers instanceof LibsWeb3) {
        providerList = [providers];
      } else if (Array.isArray(providers)) {
        providerList = providers;
      } else {
        throw new Error('Providers must be of type string, Array, or Web3 instance');
      }

      return {
        registryAddress: registryAddress,
        entityManagerAddress: entityManagerAddress,
        useExternalWeb3: false,
        internalWeb3Config: {
          web3ProviderEndpoints: providerList,
          privateKey: privateKey
        }
      };
    }
    /**
     * Configures an eth web3
     */

  }, {
    key: "configEthWeb3",
    value: function configEthWeb3(tokenAddress, registryAddress, providers, ownerWallet, claimDistributionContractAddress, wormholeContractAddress) {
      var providerList;

      if (typeof providers === 'string') {
        providerList = providers.split(',');
      } else if (providers instanceof LibsWeb3) {
        providerList = [providers];
      } else if (Array.isArray(providers)) {
        providerList = providers;
      } else {
        throw new Error('Providers must be of type string, Array, or Web3 instance');
      }

      return {
        tokenAddress: tokenAddress,
        registryAddress: registryAddress,
        providers: providerList,
        ownerWallet: ownerWallet,
        claimDistributionContractAddress: claimDistributionContractAddress,
        wormholeContractAddress: wormholeContractAddress
      };
    }
    /**
     * Configures wormhole
     */

  }, {
    key: "configWormhole",
    value: function configWormhole(_ref3) {
      var rpcHosts = _ref3.rpcHosts,
          solBridgeAddress = _ref3.solBridgeAddress,
          solTokenBridgeAddress = _ref3.solTokenBridgeAddress,
          ethBridgeAddress = _ref3.ethBridgeAddress,
          ethTokenBridgeAddress = _ref3.ethTokenBridgeAddress;
      var rpcHostList;

      if (typeof rpcHosts === 'string') {
        rpcHostList = rpcHosts.split(',');
      } else if (Array.isArray(rpcHosts)) {
        rpcHostList = rpcHosts;
      } else {
        throw new Error('rpcHosts must be of type string or Array');
      }

      return {
        rpcHosts: rpcHostList,
        solBridgeAddress: solBridgeAddress,
        solTokenBridgeAddress: solTokenBridgeAddress,
        ethBridgeAddress: ethBridgeAddress,
        ethTokenBridgeAddress: ethTokenBridgeAddress
      };
    }
    /**
     * Configures a solana web3
     */

  }, {
    key: "configSolanaWeb3",
    value: function configSolanaWeb3(_ref4) {
      var solanaClusterEndpoint = _ref4.solanaClusterEndpoint,
          mintAddress = _ref4.mintAddress,
          usdcMintAddress = _ref4.usdcMintAddress,
          solanaTokenAddress = _ref4.solanaTokenAddress,
          feePayerAddress = _ref4.feePayerAddress,
          claimableTokenProgramAddress = _ref4.claimableTokenProgramAddress,
          rewardsManagerProgramId = _ref4.rewardsManagerProgramId,
          rewardsManagerProgramPDA = _ref4.rewardsManagerProgramPDA,
          rewardsManagerTokenPDA = _ref4.rewardsManagerTokenPDA,
          useRelay = _ref4.useRelay,
          feePayerSecretKeys = _ref4.feePayerSecretKeys,
          confirmationTimeout = _ref4.confirmationTimeout;
      return {
        solanaClusterEndpoint: solanaClusterEndpoint,
        mintAddress: mintAddress,
        usdcMintAddress: usdcMintAddress,
        solanaTokenAddress: solanaTokenAddress,
        feePayerAddress: feePayerAddress,
        claimableTokenProgramAddress: claimableTokenProgramAddress,
        rewardsManagerProgramId: rewardsManagerProgramId,
        rewardsManagerProgramPDA: rewardsManagerProgramPDA,
        rewardsManagerTokenPDA: rewardsManagerTokenPDA,
        useRelay: useRelay,
        feePayerKeypairs: feePayerSecretKeys === null || feePayerSecretKeys === void 0 ? void 0 : feePayerSecretKeys.map(function (key) {
          return solanaWeb3.Keypair.fromSecretKey(key);
        }),
        confirmationTimeout: confirmationTimeout
      };
    }
  }]);

  return AudiusLibs;
}();

var AudiusLibsLegacyShim = AudiusLibs;
AudiusLibsLegacyShim.AudiusABIDecoder = AudiusABIDecoder;
AudiusLibsLegacyShim.Utils = Utils;
AudiusLibsLegacyShim.SolanaUtils = SolanaUtils;
AudiusLibsLegacyShim.CreatorNode = CreatorNode;
AudiusLibsLegacyShim.SanityChecks = SanityChecks;
AudiusLibsLegacyShim.RewardsAttester = RewardsAttester;

exports.ALLOWED_AUDIO_MIME_TYPES = ALLOWED_AUDIO_MIME_TYPES;
exports.ALLOWED_IMAGE_MIME_TYPES = ALLOWED_IMAGE_MIME_TYPES;
exports.ActivityFromJSON = ActivityFromJSON;
exports.ActivityFromJSONTyped = ActivityFromJSONTyped;
exports.ActivityToJSON = ActivityToJSON;
exports.AddTrackToPlaylistSchema = AddTrackToPlaylistSchema;
exports.AlbumsApi = AlbumsApi;
exports.AppAuth = AppAuth;
exports.AudioFile = AudioFile;
exports.AudiusABIDecoder = AudiusABIDecoder;
exports.AudiusLibs = AudiusLibs;
exports.Auth = Auth;
exports.AuthorizedAppFromJSON = AuthorizedAppFromJSON;
exports.AuthorizedAppFromJSONTyped = AuthorizedAppFromJSONTyped;
exports.AuthorizedAppToJSON = AuthorizedAppToJSON;
exports.AuthorizedAppsFromJSON = AuthorizedAppsFromJSON;
exports.AuthorizedAppsFromJSONTyped = AuthorizedAppsFromJSONTyped;
exports.AuthorizedAppsToJSON = AuthorizedAppsToJSON;
exports.BASE_PATH = BASE_PATH$1;
exports.BaseAPI = BaseAPI$1;
exports.BlobApiResponse = BlobApiResponse$1;
exports.COLLECTION_FORMATS = COLLECTION_FORMATS$1;
exports.ChatBlockRequestSchema = ChatBlockRequestSchema;
exports.ChatCreateRequestSchema = ChatCreateRequestSchema;
exports.ChatDeleteRequestSchema = ChatDeleteRequestSchema;
exports.ChatGetAllRequestSchema = ChatGetAllRequestSchema;
exports.ChatGetBlockersRequestSchema = ChatGetBlockersRequestSchema;
exports.ChatGetMessagesRequestSchema = ChatGetMessagesRequestSchema;
exports.ChatGetPermissionRequestSchema = ChatGetPermissionRequestSchema;
exports.ChatGetRequestSchema = ChatGetRequestSchema;
exports.ChatGetUnreadCountRequestSchema = ChatGetUnreadCountRequestSchema;
exports.ChatInviteRequestSchema = ChatInviteRequestSchema;
exports.ChatListenRequestSchema = ChatListenRequestSchema;
exports.ChatMessageRequestSchema = ChatMessageRequestSchema;
exports.ChatPermitRequestSchema = ChatPermitRequestSchema;
exports.ChatReactRequestSchema = ChatReactRequestSchema;
exports.ChatReadRequestSchema = ChatReadRequestSchema;
exports.ChatUnfurlRequestSchema = ChatUnfurlRequestSchema;
exports.ChatValidateCanCreateRequestSchema = ChatValidateCanCreateRequestSchema;
exports.Configuration = Configuration$1;
exports.ConnectedWalletsFromJSON = ConnectedWalletsFromJSON;
exports.ConnectedWalletsFromJSONTyped = ConnectedWalletsFromJSONTyped;
exports.ConnectedWalletsResponseFromJSON = ConnectedWalletsResponseFromJSON;
exports.ConnectedWalletsResponseFromJSONTyped = ConnectedWalletsResponseFromJSONTyped;
exports.ConnectedWalletsResponseToJSON = ConnectedWalletsResponseToJSON;
exports.ConnectedWalletsToJSON = ConnectedWalletsToJSON;
exports.CoverPhotoFromJSON = CoverPhotoFromJSON$1;
exports.CoverPhotoFromJSONTyped = CoverPhotoFromJSONTyped$1;
exports.CoverPhotoToJSON = CoverPhotoToJSON$1;
exports.CreateDeveloperAppSchema = CreateDeveloperAppSchema;
exports.CreateGrantSchema = CreateGrantSchema;
exports.CreatePlaylistSchema = CreatePlaylistSchema;
exports.CreatorNode = CreatorNode;
exports.CrossPlatformFileSchema = CrossPlatformFileSchema;
exports.DecodedUserTokenFromJSON = DecodedUserTokenFromJSON;
exports.DecodedUserTokenFromJSONTyped = DecodedUserTokenFromJSONTyped;
exports.DecodedUserTokenToJSON = DecodedUserTokenToJSON;
exports.DefaultConfig = DefaultConfig$1;
exports.DeleteAlbumSchema = DeleteAlbumSchema;
exports.DeleteDeveloperAppSchema = DeleteDeveloperAppSchema;
exports.DeletePlaylistSchema = DeletePlaylistSchema;
exports.DeleteTrackSchema = DeleteTrackSchema;
exports.DeveloperAppFromJSON = DeveloperAppFromJSON;
exports.DeveloperAppFromJSONTyped = DeveloperAppFromJSONTyped;
exports.DeveloperAppResponseFromJSON = DeveloperAppResponseFromJSON;
exports.DeveloperAppResponseFromJSONTyped = DeveloperAppResponseFromJSONTyped;
exports.DeveloperAppResponseToJSON = DeveloperAppResponseToJSON;
exports.DeveloperAppToJSON = DeveloperAppToJSON;
exports.DeveloperAppsApi = DeveloperAppsApi;
exports.DeveloperAppsFromJSON = DeveloperAppsFromJSON;
exports.DeveloperAppsFromJSONTyped = DeveloperAppsFromJSONTyped;
exports.DeveloperAppsToJSON = DeveloperAppsToJSON;
exports.DiscoveryNodeSelector = DiscoveryNodeSelector;
exports.EncodedUserIdFromJSON = EncodedUserIdFromJSON;
exports.EncodedUserIdFromJSONTyped = EncodedUserIdFromJSONTyped;
exports.EncodedUserIdToJSON = EncodedUserIdToJSON;
exports.EntityManager = EntityManager$1;
exports.FavoriteAlbumSchema = FavoriteAlbumSchema;
exports.FavoriteFromJSON = FavoriteFromJSON$1;
exports.FavoriteFromJSONTyped = FavoriteFromJSONTyped$1;
exports.FavoritePlaylistSchema = FavoritePlaylistSchema;
exports.FavoriteToJSON = FavoriteToJSON$1;
exports.FavoriteTrackSchema = FavoriteTrackSchema;
exports.FavoritesResponseFromJSON = FavoritesResponseFromJSON;
exports.FavoritesResponseFromJSONTyped = FavoritesResponseFromJSONTyped;
exports.FavoritesResponseToJSON = FavoritesResponseToJSON;
exports.FetchError = FetchError$1;
exports.FollowUserSchema = FollowUserSchema;
exports.FollowersResponseFromJSON = FollowersResponseFromJSON;
exports.FollowersResponseFromJSONTyped = FollowersResponseFromJSONTyped;
exports.FollowersResponseToJSON = FollowersResponseToJSON;
exports.FollowingResponseFromJSON = FollowingResponseFromJSON$1;
exports.FollowingResponseFromJSONTyped = FollowingResponseFromJSONTyped$1;
exports.FollowingResponseToJSON = FollowingResponseToJSON$1;
exports.GetAIAttributedTracksByUserHandleFilterTracksEnum = GetAIAttributedTracksByUserHandleFilterTracksEnum$1;
exports.GetAIAttributedTracksByUserHandleSortDirectionEnum = GetAIAttributedTracksByUserHandleSortDirectionEnum$1;
exports.GetAIAttributedTracksByUserHandleSortEnum = GetAIAttributedTracksByUserHandleSortEnum$1;
exports.GetAIAttributedTracksByUserHandleSortMethodEnum = GetAIAttributedTracksByUserHandleSortMethodEnum$1;
exports.GetAudioTransactionHistorySortDirectionEnum = GetAudioTransactionHistorySortDirectionEnum;
exports.GetAudioTransactionHistorySortMethodEnum = GetAudioTransactionHistorySortMethodEnum;
exports.GetSupportersFromJSON = GetSupportersFromJSON;
exports.GetSupportersFromJSONTyped = GetSupportersFromJSONTyped;
exports.GetSupportersToJSON = GetSupportersToJSON;
exports.GetSupportingFromJSON = GetSupportingFromJSON;
exports.GetSupportingFromJSONTyped = GetSupportingFromJSONTyped;
exports.GetSupportingToJSON = GetSupportingToJSON;
exports.GetTipsCurrentUserFollowsEnum = GetTipsCurrentUserFollowsEnum$1;
exports.GetTipsResponseFromJSON = GetTipsResponseFromJSON$1;
exports.GetTipsResponseFromJSONTyped = GetTipsResponseFromJSONTyped$1;
exports.GetTipsResponseToJSON = GetTipsResponseToJSON$1;
exports.GetTipsUniqueByEnum = GetTipsUniqueByEnum$1;
exports.GetTracksByUserFilterTracksEnum = GetTracksByUserFilterTracksEnum$1;
exports.GetTracksByUserSortDirectionEnum = GetTracksByUserSortDirectionEnum$1;
exports.GetTracksByUserSortEnum = GetTracksByUserSortEnum$1;
exports.GetTracksByUserSortMethodEnum = GetTracksByUserSortMethodEnum$1;
exports.GetTrendingPlaylistsTimeEnum = GetTrendingPlaylistsTimeEnum$1;
exports.GetTrendingTracksTimeEnum = GetTrendingTracksTimeEnum$1;
exports.GrantsApi = GrantsApi;
exports.HashId = HashId;
exports.ImageFile = ImageFile;
exports.JSONApiResponse = JSONApiResponse$1;
exports.Logger = Logger;
exports.ParseRequestError = ParseRequestError;
exports.PlaylistAddedTimestampFromJSON = PlaylistAddedTimestampFromJSON$1;
exports.PlaylistAddedTimestampFromJSONTyped = PlaylistAddedTimestampFromJSONTyped$1;
exports.PlaylistAddedTimestampToJSON = PlaylistAddedTimestampToJSON$1;
exports.PlaylistArtworkFromJSON = PlaylistArtworkFromJSON$1;
exports.PlaylistArtworkFromJSONTyped = PlaylistArtworkFromJSONTyped$1;
exports.PlaylistArtworkToJSON = PlaylistArtworkToJSON$1;
exports.PlaylistFromJSON = PlaylistFromJSON;
exports.PlaylistFromJSONTyped = PlaylistFromJSONTyped;
exports.PlaylistResponseFromJSON = PlaylistResponseFromJSON;
exports.PlaylistResponseFromJSONTyped = PlaylistResponseFromJSONTyped;
exports.PlaylistResponseToJSON = PlaylistResponseToJSON;
exports.PlaylistSearchResultFromJSON = PlaylistSearchResultFromJSON;
exports.PlaylistSearchResultFromJSONTyped = PlaylistSearchResultFromJSONTyped;
exports.PlaylistSearchResultToJSON = PlaylistSearchResultToJSON;
exports.PlaylistToJSON = PlaylistToJSON;
exports.PlaylistTracksResponseFromJSON = PlaylistTracksResponseFromJSON;
exports.PlaylistTracksResponseFromJSONTyped = PlaylistTracksResponseFromJSONTyped;
exports.PlaylistTracksResponseToJSON = PlaylistTracksResponseToJSON;
exports.PlaylistsApi = PlaylistsApi$1;
exports.PremiumConditionsEthNFTCollection = PremiumConditionsEthNFTCollection;
exports.PremiumConditionsFollowUserId = PremiumConditionsFollowUserId;
exports.PremiumConditionsNFTCollection = PremiumConditionsNFTCollection;
exports.PremiumConditionsSolNFTCollection = PremiumConditionsSolNFTCollection;
exports.PremiumConditionsTipUserId = PremiumConditionsTipUserId;
exports.ProfilePictureFromJSON = ProfilePictureFromJSON$1;
exports.ProfilePictureFromJSONTyped = ProfilePictureFromJSONTyped$1;
exports.ProfilePictureToJSON = ProfilePictureToJSON$1;
exports.PublishPlaylistSchema = PublishPlaylistSchema;
exports.RelatedArtistResponseFromJSON = RelatedArtistResponseFromJSON;
exports.RelatedArtistResponseFromJSONTyped = RelatedArtistResponseFromJSONTyped;
exports.RelatedArtistResponseToJSON = RelatedArtistResponseToJSON;
exports.RemixParentFromJSON = RemixParentFromJSON;
exports.RemixParentFromJSONTyped = RemixParentFromJSONTyped;
exports.RemixParentToJSON = RemixParentToJSON;
exports.RemoveTrackFromPlaylistSchema = RemoveTrackFromPlaylistSchema;
exports.RendezvousHash = RendezvousHash;
exports.RepostAlbumSchema = RepostAlbumSchema;
exports.RepostPlaylistSchema = RepostPlaylistSchema;
exports.RepostTrackSchema = RepostTrackSchema;
exports.RepostsFromJSON = RepostsFromJSON;
exports.RepostsFromJSONTyped = RepostsFromJSONTyped;
exports.RepostsToJSON = RepostsToJSON;
exports.RequiredError = RequiredError$1;
exports.ResolveApi = ResolveApi;
exports.ResponseError = ResponseError$1;
exports.RevokeGrantSchema = RevokeGrantSchema;
exports.RewardsAttester = RewardsAttester;
exports.SanityChecks = SanityChecks;
exports.SolanaUtils = SolanaUtils;
exports.Storage = Storage;
exports.StorageNodeSelector = StorageNodeSelector;
exports.SubscribeToUserSchema = SubscribeToUserSchema;
exports.SubscribersResponseFromJSON = SubscribersResponseFromJSON;
exports.SubscribersResponseFromJSONTyped = SubscribersResponseFromJSONTyped;
exports.SubscribersResponseToJSON = SubscribersResponseToJSON;
exports.SupporterFromJSON = SupporterFromJSON;
exports.SupporterFromJSONTyped = SupporterFromJSONTyped;
exports.SupporterToJSON = SupporterToJSON;
exports.SupportingFromJSON = SupportingFromJSON;
exports.SupportingFromJSONTyped = SupportingFromJSONTyped;
exports.SupportingToJSON = SupportingToJSON;
exports.TagsResponseFromJSON = TagsResponseFromJSON;
exports.TagsResponseFromJSONTyped = TagsResponseFromJSONTyped;
exports.TagsResponseToJSON = TagsResponseToJSON;
exports.TextApiResponse = TextApiResponse$1;
exports.TipFromJSON = TipFromJSON;
exports.TipFromJSONTyped = TipFromJSONTyped;
exports.TipToJSON = TipToJSON;
exports.TipsApi = TipsApi$1;
exports.TrackArtworkFromJSON = TrackArtworkFromJSON$1;
exports.TrackArtworkFromJSONTyped = TrackArtworkFromJSONTyped$1;
exports.TrackArtworkToJSON = TrackArtworkToJSON$1;
exports.TrackElementFromJSON = TrackElementFromJSON;
exports.TrackElementFromJSONTyped = TrackElementFromJSONTyped;
exports.TrackElementToJSON = TrackElementToJSON;
exports.TrackFromJSON = TrackFromJSON;
exports.TrackFromJSONTyped = TrackFromJSONTyped;
exports.TrackResponseFromJSON = TrackResponseFromJSON;
exports.TrackResponseFromJSONTyped = TrackResponseFromJSONTyped;
exports.TrackResponseToJSON = TrackResponseToJSON;
exports.TrackSearchFromJSON = TrackSearchFromJSON;
exports.TrackSearchFromJSONTyped = TrackSearchFromJSONTyped;
exports.TrackSearchToJSON = TrackSearchToJSON;
exports.TrackToJSON = TrackToJSON;
exports.TracksApi = TracksApi$1;
exports.TracksResponseFromJSON = TracksResponseFromJSON;
exports.TracksResponseFromJSONTyped = TracksResponseFromJSONTyped;
exports.TracksResponseToJSON = TracksResponseToJSON;
exports.TrendingPlaylistsResponseFromJSON = TrendingPlaylistsResponseFromJSON;
exports.TrendingPlaylistsResponseFromJSONTyped = TrendingPlaylistsResponseFromJSONTyped;
exports.TrendingPlaylistsResponseToJSON = TrendingPlaylistsResponseToJSON;
exports.UnfavoriteAlbumSchema = UnfavoriteAlbumSchema;
exports.UnfavoritePlaylistSchema = UnfavoritePlaylistSchema;
exports.UnfavoriteTrackSchema = UnfavoriteTrackSchema;
exports.UnfollowUserSchema = UnfollowUserSchema;
exports.UnrepostAlbumSchema = UnrepostAlbumSchema;
exports.UnrepostPlaylistSchema = UnrepostPlaylistSchema;
exports.UnrepostTrackSchema = UnrepostTrackSchema;
exports.UnsubscribeFromUserSchema = UnsubscribeFromUserSchema;
exports.UpdateProfileSchema = UpdateProfileSchema;
exports.UserAssociatedWalletResponseFromJSON = UserAssociatedWalletResponseFromJSON;
exports.UserAssociatedWalletResponseFromJSONTyped = UserAssociatedWalletResponseFromJSONTyped;
exports.UserAssociatedWalletResponseToJSON = UserAssociatedWalletResponseToJSON;
exports.UserFromJSON = UserFromJSON;
exports.UserFromJSONTyped = UserFromJSONTyped;
exports.UserResponseFromJSON = UserResponseFromJSON;
exports.UserResponseFromJSONTyped = UserResponseFromJSONTyped;
exports.UserResponseToJSON = UserResponseToJSON;
exports.UserSearchFromJSON = UserSearchFromJSON;
exports.UserSearchFromJSONTyped = UserSearchFromJSONTyped;
exports.UserSearchToJSON = UserSearchToJSON;
exports.UserToJSON = UserToJSON;
exports.UsersApi = UsersApi$1;
exports.Utils = Utils;
exports.VerifyTokenFromJSON = VerifyTokenFromJSON;
exports.VerifyTokenFromJSONTyped = VerifyTokenFromJSONTyped;
exports.VerifyTokenToJSON = VerifyTokenToJSON;
exports.VoidApiResponse = VoidApiResponse$1;
exports.canConsumeForm = canConsumeForm$1;
exports.createUpdateAlbumSchema = createUpdateAlbumSchema;
exports.createUpdatePlaylistMetadataSchema = createUpdatePlaylistMetadataSchema;
exports.createUpdatePlaylistSchema = createUpdatePlaylistSchema;
exports.createUpdateTrackSchema = createUpdateTrackSchema;
exports.createUploadAlbumMetadataSchema = createUploadAlbumMetadataSchema;
exports.createUploadAlbumSchema = createUploadAlbumSchema;
exports.createUploadPlaylistSchema = createUploadPlaylistSchema;
exports.createUploadTrackMetadataSchema = createUploadTrackMetadataSchema;
exports.createUploadTrackSchema = createUploadTrackSchema;
exports.developmentConfig = servicesConfig$2;
exports.exists = exists$1;
exports.full = index;
exports.getAlbumSchema = getAlbumSchema;
exports.getAlbumTracksSchema = getAlbumTracksSchema;
exports.instanceOfActivity = instanceOfActivity;
exports.instanceOfAuthorizedApp = instanceOfAuthorizedApp;
exports.instanceOfAuthorizedApps = instanceOfAuthorizedApps;
exports.instanceOfConnectedWallets = instanceOfConnectedWallets;
exports.instanceOfConnectedWalletsResponse = instanceOfConnectedWalletsResponse;
exports.instanceOfCoverPhoto = instanceOfCoverPhoto$1;
exports.instanceOfDecodedUserToken = instanceOfDecodedUserToken;
exports.instanceOfDeveloperApp = instanceOfDeveloperApp;
exports.instanceOfDeveloperAppResponse = instanceOfDeveloperAppResponse;
exports.instanceOfDeveloperApps = instanceOfDeveloperApps;
exports.instanceOfEncodedUserId = instanceOfEncodedUserId;
exports.instanceOfFavorite = instanceOfFavorite$1;
exports.instanceOfFavoritesResponse = instanceOfFavoritesResponse;
exports.instanceOfFollowersResponse = instanceOfFollowersResponse;
exports.instanceOfFollowingResponse = instanceOfFollowingResponse$1;
exports.instanceOfGetSupporters = instanceOfGetSupporters;
exports.instanceOfGetSupporting = instanceOfGetSupporting;
exports.instanceOfGetTipsResponse = instanceOfGetTipsResponse$1;
exports.instanceOfPlaylist = instanceOfPlaylist;
exports.instanceOfPlaylistAddedTimestamp = instanceOfPlaylistAddedTimestamp$1;
exports.instanceOfPlaylistArtwork = instanceOfPlaylistArtwork$1;
exports.instanceOfPlaylistResponse = instanceOfPlaylistResponse;
exports.instanceOfPlaylistSearchResult = instanceOfPlaylistSearchResult;
exports.instanceOfPlaylistTracksResponse = instanceOfPlaylistTracksResponse;
exports.instanceOfProfilePicture = instanceOfProfilePicture$1;
exports.instanceOfRelatedArtistResponse = instanceOfRelatedArtistResponse;
exports.instanceOfRemixParent = instanceOfRemixParent;
exports.instanceOfReposts = instanceOfReposts;
exports.instanceOfSubscribersResponse = instanceOfSubscribersResponse;
exports.instanceOfSupporter = instanceOfSupporter;
exports.instanceOfSupporting = instanceOfSupporting;
exports.instanceOfTagsResponse = instanceOfTagsResponse;
exports.instanceOfTip = instanceOfTip;
exports.instanceOfTrack = instanceOfTrack;
exports.instanceOfTrackArtwork = instanceOfTrackArtwork$1;
exports.instanceOfTrackElement = instanceOfTrackElement;
exports.instanceOfTrackResponse = instanceOfTrackResponse;
exports.instanceOfTrackSearch = instanceOfTrackSearch;
exports.instanceOfTracksResponse = instanceOfTracksResponse;
exports.instanceOfTrendingPlaylistsResponse = instanceOfTrendingPlaylistsResponse;
exports.instanceOfUser = instanceOfUser;
exports.instanceOfUserAssociatedWalletResponse = instanceOfUserAssociatedWalletResponse;
exports.instanceOfUserResponse = instanceOfUserResponse;
exports.instanceOfUserSearch = instanceOfUserSearch;
exports.instanceOfVerifyToken = instanceOfVerifyToken;
exports.isNodeFile = isNodeFile;
exports.libs = AudiusLibsLegacyShim;
exports.mapValues = mapValues$1;
exports.productionConfig = servicesConfig;
exports.querystring = querystring$1;
exports.sdk = sdk;
exports.stagingConfig = servicesConfig$1;
//# sourceMappingURL=legacy.js.map
