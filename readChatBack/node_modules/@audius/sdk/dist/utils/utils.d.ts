/// <reference types="bn.js" />
/// <reference types="node" />
import { AxiosResponse } from 'axios';
import type { ImageHasher, NonImageHasher, HashedImage } from './fileHasher';
import type { AbiItem } from 'web3-utils';
export type { ImageHasher, NonImageHasher, HashedImage };
export declare type ContractABI = {
    abi: AbiItem[];
    contractName: string;
};
export declare class Utils {
    static utf8ToHex(utf8Str: string): string;
    static padRight(hexStr: string, size: number): string;
    static hexToUtf8(hexStr: string): string;
    static keccak256(utf8Str: string): string;
    static isBN(number: number | string): boolean;
    static toBN(number: number | string, base?: number): import("bn.js");
    static BN(): typeof import("bn.js");
    static checkStrLen(str: string, maxLen: number, minLen?: number): void;
    static wait(milliseconds: number): Promise<void>;
    static isFQDN(url: string): boolean;
    static isHttps(url: string): boolean;
    static isHealthy(url: string): Promise<boolean>;
    static formatOptionalMultihash(multihash: string): string;
    static decodeMultihash(multihash: string): {
        digest: string;
        hashFn: number;
        size: number;
    };
    /**
     * Given a digest value (written on chain, obtained through AudiusABIDecoder.decodeMethod),
     * convert back to a IFPS CIDv0
     * @param multihashDigest digest value from decodeMultihash
     * @returns String CID value
     */
    static encodeMultihash(multihashDigest: string): string;
    static parseDataFromResponse(response: AxiosResponse): any;
    static configureWeb3(web3Provider: string, chainNetworkId: string, requiresAccount?: boolean): Promise<false | import("web3").default>;
    static get zeroAddress(): string;
    static isZeroAddress(address: string): boolean;
    static makeUuid(): string;
    /**
     * Decodes a string id into an int. Returns null if an invalid ID.
     */
    static decodeHashId(id: string): number | null;
    /**
     * Encodes an int to a string based hashid
     */
    static encodeHashId(id: number | null): string | null;
    /**
     * If `promise` responds before `timeoutMs`,
     * this function returns its response; else rejects with `timeoutMessage`
     */
    static racePromiseWithTimeout(promise: Promise<void>, timeoutMs: number, timeoutMessage: string): Promise<unknown>;
    static getRandomInt(min: number, max: number): number;
    static fileHasher: {
        convertNanosToMillis(nanoSeconds: bigint): bigint;
        initImageHasher(content: import("ipfs-unixfs-importer/types/src/types").ImportCandidate, options: import("ipfs-unixfs-importer/types/src/types").UserImporterOptions): ImageHasher;
        initNonImageHasher(content: Uint8Array, options: import("ipfs-unixfs-importer/types/src/types").UserImporterOptions): NonImageHasher;
        convertToBuffer(content: import("./fileHasher").Content, logger: any): Promise<Buffer>;
        hashNonImages(content: Uint8Array, options?: import("ipfs-unixfs-importer/types/src/types").UserImporterOptions): Promise<string>;
        hashImages(content: import("ipfs-unixfs-importer/types/src/types").ImportCandidate, options?: import("ipfs-unixfs-importer/types/src/types").UserImporterOptions): Promise<HashedImage[]>;
        generateNonImageCid(content: import("./fileHasher").Content, logger?: any): Promise<string>;
        generateMetadataCidV1(metadata: {}): Promise<import("multiformats/cid").CID>;
        generateImageCids(content: import("ipfs-unixfs-importer/types/src/types").ImportCandidate, _?: any): Promise<HashedImage[]>;
    };
}
