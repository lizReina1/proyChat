/// <reference types="node" />
import { ImportCandidate, UserImporterOptions } from 'ipfs-unixfs-importer';
import { CID } from 'multiformats/cid';
export declare type Content = ReadableStream | Buffer | string;
export interface ImageHasher {
    options: UserImporterOptions;
    content: ImportCandidate;
}
export interface NonImageHasher {
    options: UserImporterOptions;
    content: Uint8Array;
}
export interface HashedImage {
    path: string | undefined;
    cid: string;
    size: number;
}
export declare const fileHasher: {
    convertNanosToMillis(nanoSeconds: bigint): bigint;
    /**
     * Used to initalize the only hash fns. See Alan Shaw's reference code for more context.
     */
    initImageHasher(content: ImportCandidate, options: UserImporterOptions): ImageHasher;
    /**
     * Used to iniitalize the only hash fns. See Alan Shaw's reference code for more context.
     */
    initNonImageHasher(content: Uint8Array, options: UserImporterOptions): NonImageHasher;
    /**
     * Convert content to a buffer; used in `generateNonImageCid()`.
     * @param {ReadStream|Buffer|string} content if string, should be file path
     * @param {Object} logger
     * @returns buffer version of content
     */
    convertToBuffer(content: Content, logger: any): Promise<Buffer>;
    /**
     * Custom fn to generate the content-hashing logic
     * @param content a buffer of the content
     * @param options options for importer
     * @returns the V0 CID from content addressing logic
     */
    hashNonImages(content: Uint8Array, options?: UserImporterOptions): Promise<string>;
    /**
     * Custom fn to generate the content-hashing logic
     * @param content an Object[] with the structure [{ path: string, content: buffer }, ...]
     * @param options options for importer
     * @returns an Object[] with the structure [{path: <string>, cid: <string>, size: <number>}]
     *
     * Example with adding a profile picture:
     * [
        {
          "cid": "QmSRyKvnXwoxPZ9UxqxXPR8NXjcPYBEf1qbNrXyo5USqLL",
          "path": "blob/150x150.jpg",
          "size": 3091
        },
        {
          "cid": "QmQQMV9TXxRmDKafZiRvMVkqUNtUu9WGAfukUBS1yCk2ht",
          "path": "blob/480x480.jpg",
          "size": 20743
        },
        {
          "cid": "Qmd8cDdDGcWVaLEoJPVFtkKhYMqvHXZTvXcisYjubFxv1F",
          "path": "blob/1000x1000.jpg",
          "size": 72621
        },
        {
          "cid": "QmaYCPUH8G14yxetsMgW5J5tpTqPaTp3HMd3EAyffZKSvm",
          "path": "blob/original.jpg",
          "size": 185844
        },
        {
          "cid": "QmW8FUFhvaxv1MZmVcUcmR7Tg9WZhGf8xDNBesT9XepwrK",
          "path": "blob",
          "size": 282525
        }
      ]
    */
    hashImages(content: ImportCandidate, options?: UserImporterOptions): Promise<HashedImage[]>;
    /**
     * Generates CID V0 (46-char string starting with "Qm") for a non-image file (track segment, track transcode, metadata)
     * @param {Buffer|ReadStream|string} content a single Buffer, a ReadStream, or path to an existing file
     * @param {Object?} logger
     * @returns {string} only hash response cid
     */
    generateNonImageCid(content: Content, logger?: any): Promise<string>;
    /**
     * Generates CID V1 for a JSON metadata object (NOT the string of the metadata - must be an object).
     * CID<T, 512, SHA_256, 1> represents CID with json codec (512) and sha256 hash using CID V1.
     * Call toString() on the result to get the CID V1 string.
     */
    generateMetadataCidV1(metadata: {}): Promise<CID>;
    /**
     * Wrapper that generates multihashes for image files
     * @param {Object[]} content an Object[] with the structure [{ path: string, content: buffer }, ...]
     * @param {Object?} logger
     * @returns {HashedImage[]} only hash responses with the structure [{path: <string>, cid: <string>, size: <number>}]
     */
    generateImageCids(content: ImportCandidate, _?: any): Promise<HashedImage[]>;
};
