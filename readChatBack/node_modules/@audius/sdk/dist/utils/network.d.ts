import { AxiosRequestConfig, AxiosResponse } from 'axios';
import type { Nullable } from './types';
export declare type ServiceName = string;
export interface ServiceWithEndpoint {
    endpoint: string;
    spID?: string;
    owner: string;
    delegateOwnerWallet: string;
}
export declare type Service = ServiceName | ServiceWithEndpoint;
interface Request {
    id?: string;
    url: string;
}
export interface Timing {
    request: Request;
    response: AxiosResponse | null;
    millis: number | null;
}
/**
 * Fetches a url and times how long it took the request to complete.
 */
declare function timeRequest(request: Request, timeout?: number | null, headers?: object | null): Promise<Timing>;
interface SortServiceTimingsConfig {
    serviceTimings: Timing[];
    sortByVersion: boolean;
    currentVersion?: string | null;
    equivalencyDelta?: number | null;
}
/**
 * Custom sort for `serviceTimings`, the response from `timeRequest()` function above
 */
declare function sortServiceTimings({ serviceTimings, sortByVersion, currentVersion, // only required if `sortByVersion` = false
equivalencyDelta }: SortServiceTimingsConfig): Timing[];
interface TimeRequestsConfig {
    requests: Request[];
    sortByVersion?: boolean;
    filterNonResponsive?: boolean;
    currentVersion?: string | null;
    timeout?: number | null;
    equivalencyDelta?: number | null;
    headers?: object | null;
}
/**
 * Fetches multiple urls and times each request and returns the results sorted
 * first by version and then by lowest-latency.
 */
declare function timeRequests({ requests, sortByVersion, currentVersion, // only required if `sortByVersion` = false
filterNonResponsive, timeout, equivalencyDelta, headers }: TimeRequestsConfig): Promise<Timing[]>;
/**
 * Races multiple requests
 * @param urls
 * @param callback invoked with the first successful url
 * @param axiosConfig extra axios config for each request
 * @param timeout timeout for any requests to be considered bad
 * @param timeBetweenRequests time between requests being dispatched to free up client network interface
 */
declare function raceRequests(urls: string[], callback: (url: string) => void, axiosConfig: AxiosRequestConfig, timeout?: Nullable<number>, timeBetweenRequests?: number, validationCheck?: (_: AxiosResponse) => boolean): Promise<{
    response: AxiosResponse<any>;
    errored: AxiosResponse<any>[];
} | {
    response: null;
    errored: AxiosResponse<any>[];
}>;
interface AllRequestsConfig {
    urlMap: Record<string, Service>;
    timeout: number;
    validationCheck: (_: AxiosResponse) => boolean;
}
/**
 * Gets the response for many requests with a timeout to each
 */
declare function allRequests({ urlMap, timeout, validationCheck }: AllRequestsConfig): Promise<(Service | null)[]>;
export { timeRequest, timeRequests, raceRequests, allRequests, sortServiceTimings };
