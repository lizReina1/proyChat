import type { BaseConstructorArgs } from './base';
import { Base } from './base';
import { Nullable, TrackMetadata } from '../utils';
import { Action } from '../services/dataContracts/EntityManagerClient';
export declare class Track extends Base {
    constructor(...args: BaseConstructorArgs);
    /**
     * get tracks with all relevant track data
     * can be filtered by providing an integer array of ids
     * @param limit
     * @param offset
     * @param idsArray
     * @param targetUserId the owner of the tracks being queried
     * @param sort a string of form eg. blocknumber:asc,timestamp:desc describing a sort path
     * @param minBlockNumber The min block number
     * @param filterDeleted If set to true filters out deleted tracks
     * @returns Array of track metadata Objects
     * additional metadata fields on track objects:
     *  {Integer} repost_count - repost count for given track
     *  {Integer} save_count - save count for given track
     *  {Array} followee_reposts - followees of current user that have reposted given track
     *  {Boolean} has_current_user_reposted - has current user reposted given track
     *  {Boolean} has_current_user_saved - has current user saved given track
     * @example
     * await getTracks()
     * await getTracks(100, 0, [3,2,6]) - Invalid track ids will not be accepted
     */
    getTracks(limit?: number, offset?: number, idsArray?: Nullable<string[]>, targetUserId?: Nullable<string>, sort?: Nullable<boolean>, minBlockNumber?: Nullable<number>, filterDeleted?: Nullable<boolean>, withUsers?: boolean): Promise<unknown>;
    /**
     * get tracks with all relevant track data
     * can be filtered by providing an integer array of ids
     * @param limit
     * @param offset
     * @param idsArray
     * @param targetUserId the owner of the tracks being queried
     * @param sort a string of form eg. blocknumber:asc,timestamp:desc describing a sort path
     * @param minBlockNumber The min block number
     * @param filterDeleted If set to true filters out deleted tracks
     * @returns Array of track metadata Objects
     * additional metadata fields on track objects:
     *  {Integer} repost_count - repost count for given track
     *  {Integer} save_count - save count for given track
     *  {Array} followee_reposts - followees of current user that have reposted given track
     *  {Boolean} has_current_user_reposted - has current user reposted given track
     *  {Boolean} has_current_user_saved - has current user saved given track
     * @example
     * await getTracks()
     * await getTracks(100, 0, [3,2,6]) - Invalid track ids will not be accepted
     */
    getTracksVerbose(limit?: number, offset?: number, idsArray?: Nullable<string[]>, targetUserId?: Nullable<string>, sort?: Nullable<boolean>, minBlockNumber?: Nullable<number>, filterDeleted?: Nullable<boolean>, withUsers?: boolean): Promise<{
        latest_indexed_block: number;
        latest_chain_block: number;
        latest_indexed_slot_plays: number;
        latest_chain_slot_plays: number;
        data: unknown;
    } | null | undefined>;
    /**
     * Gets tracks by their slug and owner handle
     * @param handle the owner's handle
     * @param slug the track's slug, including collision identifiers
     */
    getTracksByHandleAndSlug(handle: string, slug: string): Promise<unknown>;
    /**
     * gets all tracks matching identifiers, including unlisted.
     */
    getTracksIncludingUnlisted(identifiers: string[], withUsers?: boolean): Promise<unknown>;
    /**
     * Gets random tracks from trending tracks for a given genre.
     * If genre not given, will return trending tracks across all genres.
     * Excludes specified track ids.
     */
    getRandomTracks(genre: string, limit: number, exclusionList: number[], time: string): Promise<unknown>;
    /**
     * Gets all stems for a given trackId as an array of tracks.
     */
    getStemsForTrack(trackId: number): Promise<unknown>;
    /**
     * Gets all the remixes of a given trackId as an array of tracks.
     */
    getRemixesOfTrack(trackId: number, limit?: Nullable<number>, offset?: Nullable<number>): Promise<unknown>;
    /**
     * Gets the remix parents of a given trackId as an array of tracks.
     */
    getRemixTrackParents(trackId: number, limit?: Nullable<number>, offset?: Nullable<number>): Promise<unknown>;
    /**
     * Return saved tracks for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     */
    getSavedTracks(limit?: number, offset?: number, withUsers?: boolean): Promise<unknown>;
    /**
     * Gets tracks trending on Audius.
     */
    getTrendingTracks(genre?: Nullable<string>, time?: Nullable<string>, idsArray?: Nullable<number[]>, limit?: Nullable<number>, offset?: Nullable<number>): Promise<{
        listenCounts: {
            trackId: number;
            listens: number;
        }[];
    } | null | undefined>;
    /**
     * Gets listens for tracks bucketted by timeFrame.
     */
    getTrackListens(timeFrame?: null, idsArray?: null, startTime?: null, endTime?: null, limit?: null, offset?: null): Promise<{
        bucket: {
            trackId: number;
            date: string;
            listens: number;
        }[];
    }>;
    /**
     * get users that saved saveTrackId, sorted by follower count descending
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getSaversForTrack(100, 0, 1) - ID must be valid
     */
    getSaversForTrack(limit: number | undefined, offset: number | undefined, saveTrackId: number): Promise<unknown>;
    /**
     * get users that saved savePlaylistId, sorted by follower count descending
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getSaversForPlaylist(100, 0, 1) - ID must be valid
     */
    getSaversForPlaylist(limit: number | undefined, offset: number | undefined, savePlaylistId: number): Promise<unknown>;
    /**
     * get users that reposted repostTrackId, sorted by follower count descending
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getRepostersForTrack(100, 0, 1) - ID must be valid
     */
    getRepostersForTrack(limit: number | undefined, offset: number | undefined, repostTrackId: number): Promise<unknown>;
    /**
     * get users that reposted repostPlaylistId, sorted by follower count descending
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getRepostersForPlaylist(100, 0, 1) - ID must be valid
     */
    getRepostersForPlaylist(limit: number | undefined, offset: number | undefined, repostPlaylistId: number): Promise<unknown>;
    /**
     * Return saved tracks for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     */
    getListenHistoryTracks(limit?: number, offset?: number): Promise<unknown>;
    /**
     * Takes in a readable stream if isServer is true, or a file reference if isServer is
     * false.
     * Uploads file, retrieves multihash, adds multihash to input metadata object,
     * uploads metadata, and finally returns metadata multihash
     * Wraps the stateless function in AudiusLib.
     *
     * @param trackFile ReadableStream from server, or File handle on client
     * @param coverArtFile ReadableStream from server, or File handle on client
     * @param metadata json of the track metadata with all fields, missing fields will error
     * @param onProgress callback fired with (loaded, total) on byte upload progress
     */
    uploadTrackV2AndWriteToChain(trackFile: File, coverArtFile: File, metadata: TrackMetadata, onProgress: () => void): Promise<{
        trackId: number;
        metadataCid: import("multiformats/cid").CID;
        updatedMetadata: TrackMetadata;
        txReceipt: import("web3-core").TransactionReceipt;
    }>;
    /**
     * Only uploads track but does not write to chain. Do not call by itself.
     *
     * @dev To upload a single track, call uploadTrackV2AndWriteToChain() instead.
     * @dev To upload multiple uploads, call this function multiple times and then call addTracksToChainV2() once.
     *
     * @param trackFile ReadableStream from server, or File handle on client
     * @param coverArtFile ReadableStream from server, or File handle on client
     * @param metadata json of the track metadata with all fields, missing fields will error
     * @param onProgress callback fired with (loaded, total) on byte upload progress
     */
    uploadTrackV2(trackFile: File, coverArtFile: File, metadata: TrackMetadata, onProgress: () => void): Promise<TrackMetadata>;
    /**
     * Creates a trackId for each CID in metadataCids and adds each track to chain for this user.
     */
    addTracksToChainV2(trackMetadatas: TrackMetadata[]): Promise<{
        error: boolean;
        trackIds: (number | null)[];
    }>;
    /**
     * Adds the given track's metadata to chain for this user, optionally creating a trackId if one doesn't exist.
     */
    writeTrackToChain(trackMetadata: TrackMetadata, action: Action, trackId?: number): Promise<{
        trackId: number;
        metadataCid: import("multiformats/cid").CID;
        txReceipt: import("web3-core").TransactionReceipt;
    }>;
    /**
     * Updates an existing track given metadata using only chain and not creator node.
     * @param metadata json of the track metadata with all fields, missing fields will error
     * @param transcodePreview bool: retranscode track preview and set preview_cid if true
     */
    updateTrackV2(metadata: TrackMetadata, transcodePreview?: boolean): Promise<{
        blockHash: string;
        blockNumber: number;
        trackId: number;
        updatedMetadata: {
            blocknumber: number;
            activity_timestamp?: string | undefined;
            is_delete: boolean;
            track_id: number;
            track_cid: string;
            preview_cid: Nullable<string>;
            created_at: string;
            isrc: Nullable<string>;
            iswc: Nullable<string>;
            credits_splits: Nullable<string>;
            description: Nullable<string>;
            download: Nullable<import("../utils").Download>;
            genre: string;
            has_current_user_reposted: boolean;
            has_current_user_saved: boolean;
            license: Nullable<string>;
            mood: Nullable<string>;
            play_count: number;
            owner_id: number;
            release_date: Nullable<string>;
            repost_count: number;
            save_count: number;
            tags: Nullable<string>;
            title: string;
            track_segments: import("../utils").TrackSegment[];
            cover_art: Nullable<string>;
            cover_art_sizes: Nullable<string>;
            is_unlisted: boolean;
            is_available: boolean;
            is_premium: boolean;
            premium_conditions: Nullable<import("../utils").PremiumConditions>;
            premium_content_signature: Nullable<import("../utils").PremiumContentSignature>;
            listenCount?: number | undefined;
            permalink: string;
            audio_upload_id: Nullable<string>;
            preview_start_seconds: Nullable<number>;
            is_invalid?: boolean | undefined;
            stem_of?: {
                parent_track_id: number;
            } | undefined;
            dateListened?: string | undefined;
            duration: number;
            is_playlist_upload?: boolean | undefined;
            ai_attribution_user_id?: number | undefined;
        };
    }>;
    /**
     * Logs a track listen for a given user id.
     * @param unauthUuid account for those not logged in
     * @param trackId listened to
     */
    logTrackListen(trackId: number, unauthUuid: number, solanaListen?: boolean): Promise<unknown>;
    /**
     * Marks a tracks as deleted
     * @param trackId
     */
    deleteTrack(trackId: number): Promise<{
        txReceipt: import("web3-core").TransactionReceipt;
    }>;
    _validateTrackMetadata(metadata: TrackMetadata): void;
    _generateTrackId(): Promise<number>;
}
