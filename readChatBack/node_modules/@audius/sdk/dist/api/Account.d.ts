/// <reference types="bn.js" />
import { Base, BaseConstructorArgs } from './base';
import { Nullable, UserMetadata } from '../utils';
import type { Users } from './Users';
import type { ServiceProvider } from './ServiceProvider';
import type { BN } from 'ethereumjs-util';
export declare class Account extends Base {
    User: Users;
    ServiceProvider: ServiceProvider;
    constructor(userApi: Users, serviceProvider: ServiceProvider, ...services: BaseConstructorArgs);
    /**
     * Fetches the user metadata for the current account
     * @return {Object} user metadata
     */
    getCurrentUser(): import("../userStateManager").CurrentUser | null;
    /**
     * Logs a user into Audius
     */
    login(email: string, password: string): Promise<{
        error: string;
        phase: string;
        user?: undefined;
    } | {
        user: import("../userStateManager").CurrentUser;
        error: boolean;
        phase: string;
    }>;
    /**
     * Logs a user out of Audius
     * Note: Actions will stop working at this point, but
     * clients may wish to call window.location.reload()
     * to show the user as logged out
     */
    logout(): Promise<void>;
    /**
     * Signs a user up for Audius
     * @param email
     * @param password
     * @param metadata
     * @param profilePictureFile an optional file to upload as the profile picture
     * @param coverPhotoFile an optional file to upload as the cover phtoo
     * @param hasWallet
     * @param host The host url used for the recovery email
     * @param generateRecoveryLink an optional flag to skip generating recovery link for testing purposes
     */
    signUpV2(email: string, password: string, metadata: UserMetadata, profilePictureFile?: Nullable<File>, coverPhotoFile?: Nullable<File>, hasWallet?: boolean, host?: string | null, generateRecoveryLink?: boolean): Promise<{
        blockHash: string;
        blockNumber: number;
        userId: number;
        error?: undefined;
        phase?: undefined;
        errorStatus?: undefined;
    } | {
        error: any;
        phase: string;
        errorStatus: any;
        blockHash?: undefined;
        blockNumber?: undefined;
        userId?: undefined;
    }>;
    /**
     * Generates and sends a recovery email for a user
     */
    generateRecoveryLink({ handle, host }?: {
        handle?: string;
        host?: Nullable<string>;
    }): Promise<{
        status: boolean;
    }>;
    resetPassword(email: string, newpassword: string): Promise<void>;
    changePassword(email: string, newpassword: string, oldpassword: string): Promise<void>;
    confirmCredentials(email: string, password: string): Promise<boolean>;
    /**
     * Check if an email address has been previously registered.
     */
    checkIfEmailRegistered(email: string): Promise<{
        exists: boolean;
    }>;
    /**
     * Get the current user's email address
     */
    getUserEmail(): Promise<{
        email: string | null | undefined;
    }>;
    /**
     * Associates a user with a twitter uuid.
     * @param uuid from the Twitter API
     */
    associateTwitterUser(uuid: string, userId: number, handle: string): Promise<unknown>;
    /**
     * Associates a user with an instagram uuid.
     * @param uuid from the Instagram API
     */
    associateInstagramUser(uuid: string, userId: number, handle: string): Promise<unknown>;
    /**
     * Associates a user with an tiktok uuid
     * @param uuid from the TikTok API
     */
    associateTikTokUser(uuid: string, userId: number, handle: string): Promise<unknown>;
    /**
     * Looks up a Twitter account by handle.
     */
    lookupTwitterHandle(handle: string): Promise<unknown>;
    /**
     * Perform a full-text search. Returns tracks, users, playlists, albums
     *    with optional user-specific results for each
     *  - user, track, and playlist objects have all same data as returned from standalone endpoints
     * @param text search query
     * @param kind 'tracks', 'users', 'playlists', 'albums', 'all'
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */
    searchFull(text: string, kind: string, limit?: number, offset?: number): Promise<unknown>;
    /**
     * Perform a lighter-weight full-text search. Returns tracks, users, playlists, albums
     *    with optional user-specific results for each
     *  - user, track, and playlist objects have core data, and track & playlist objects
     *    also return user object
     * @param text search query
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */
    searchAutocomplete(text: string, limit?: number, offset?: number): Promise<unknown>;
    /**
     * Perform a tags-only search. Returns tracks with required tag and users
     * that have used a tag greater than a specified number of times
     * @param text search query
     * @param userTagCount min # of times a user must have used a tag to be returned
     * @param kind 'tracks', 'users', 'playlists', 'albums', 'all'
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */
    searchTags(text: string, userTagCount: number | undefined, kind: string, limit?: number, offset?: number): Promise<unknown>;
    /**
     * Check if the user has a distribution claim
     * @param index The index of the claim to check (if known)
     */
    getHasClaimed(index?: number): Promise<any>;
    /**
     * Get the distribution claim amount
     */
    getClaimDistributionAmount(): Promise<BN>;
    /**
     * Make the claim
     * @param index The index of the claim to check
     * @param amount The amount to be claimed
     * @param merkleProof The merkle proof for the claim
     */
    makeDistributionClaim(index: number, amount: BN, merkleProof: string[]): Promise<import("../utils").Maybe<{
        txHash: string;
        txParams: {
            data: string;
            gasLimit: string;
            gasPrice: number;
            nonce: string;
            to: string;
            value: string;
        };
    }>>;
    /**
     * Sends `amount` tokens to `recipientAddress`
     */
    permitAndSendTokens(recipientAddress: string, amount: BN): Promise<void>;
    /**
     * Sends Eth `amount` tokens to `solanaAccount` by way of the wormhole
     * 1.) Permits the eth relay to proxy send tokens on behalf of the user
     * 2.) Transfers the tokens on the eth side to the wormhole contract
     * 3.) Gathers attestations from wormhole oracles and relizes the tokens on sol
     */
    sendTokensFromEthToSol(amount: BN, solanaAccount: string): Promise<{
        txSignature: string | undefined;
        phase: string;
        error: string | null;
        logs: string[];
    } | {
        error: any;
        phase: string;
        logs: string[];
        txSignature?: undefined;
    }>;
    /**
     * Sends Eth `amount` tokens to `solanaAccount` on the identity service
     * by way of the wormhole.
     */
    proxySendTokensFromEthToSol(amount: BN, solanaAccount: string): Promise<unknown>;
    /**
     * Sends `amount` tokens to `ethAccount` by way of the wormhole
     * 1.) Creates a solana root wallet
     * 2.) Sends the tokens from the user bank account to the solana wallet
     * 3.) Permits the solana wallet to approve transfer to wormhole
     * 4.) Transfers to the wrapped audio to the sol wormhole contract
     * 5.) Gathers attestations from wormhole oracles and realizes the tokens on eth
     */
    sendTokensFromSolToEth(amount: BN, ethAccount: string): Promise<{
        error: string | null;
        logs: string[];
        phase: string;
    }>;
    _getPermitProxySendTokensParams(owner: string, relayerAddress: string, amount: BN): Promise<{
        result: import("ethereumjs-util").ECDSASignature;
        deadline: number;
    }>;
    /**
     * Permits `relayerAddress` to send `amount` on behalf of the current user, `owner`
     */
    permitProxySendTokens(owner: string, relayerAddress: string, amount: BN): Promise<import("../utils").Maybe<{
        txHash: string;
        txParams: {
            data: string;
            gasLimit: string;
            gasPrice: number;
            nonce: string;
            to: string;
            value: string;
        };
    }>>;
    /**
     * Gets the permit method to proxy send tokens `relayerAddress` to send `amount` on behalf of the current user, `owner`
     */
    getPermitProxySendTokensMethod(owner: string, relayerAddress: string, amount: BN): Promise<any>;
    /**
     * Sends `amount` tokens to `address` from `owner`
     */
    sendTokens(owner: string, address: string, relayer: string, amount: BN): Promise<{
        txReceipt: import("../utils").Maybe<{
            txHash: string;
            txParams: {
                data: string;
                gasLimit: string;
                gasPrice: number;
                nonce: string;
                to: string;
                value: string;
            };
        }>;
    }>;
    /**
     * Updates the minimum delegation amount for a user in identity
     * NOTE: Requests eth account signature
     */
    updateMinimumDelegationAmount(amount: BN): Promise<unknown>;
    /**
     * Checks that the current user has claimed account PDA on SOL
     * @returns userHasClaimedAccount
     */
    userHasClaimedSolAccount({ account, wallet, userId }?: {
        account: any;
        wallet: Nullable<string>;
        userId: Nullable<number>;
    }): Promise<boolean>;
}
