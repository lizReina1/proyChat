import { Base, BaseConstructorArgs } from './base';
import type { ServiceProvider } from './ServiceProvider';
import type { Logger, Nullable } from '../utils';
import type { AttestationMeta } from '../services/solana/rewards';
import type { DiscoveryProvider } from '../services/discoveryProvider';
/**
 * Combined error type for `SubmitAndEvaluate`
 */
export declare const SubmitAndEvaluateError: Readonly<{
    INCORRECT_OWNER: string;
    SIGN_COLLISION: string;
    WRONG_SIGNER: string;
    NOT_ENOUGH_SIGNERS: string;
    SECP256_INSTRUCTION_MISSING: string;
    INSTRUCTION_LOAD_ERROR: string;
    REPEATED_SENDERS: string;
    SIGNATURE_VERIFICATION_FAILED: string;
    OPERATOR_COLLISION: string;
    ALREADY_SENT: string;
    INCORRECT_MESSAGES: string;
    MESSAGE_OVERFLOW: string;
    MATH_OVERFLOW: string;
    INVALID_RECIPIENT: string;
    UNKNOWN: string;
    fromErrorCode: (code: number) => string;
    INSUFFICIENT_DISCOVERY_NODE_COUNT: string;
    UNKNOWN_ERROR: string;
    CHALLENGE_INCOMPLETE: string;
    ALREADY_DISBURSED: string;
    INVALID_ORACLE: string;
    MISSING_CHALLENGES: string;
    INVALID_INPUT: string;
    USER_NOT_FOUND: string;
    HCAPTCHA: string;
    COGNITO_FLOW: string;
    DISCOVERY_NODE_ATTESTATION_ERROR: string;
    DISCOVERY_NODE_UNKNOWN_RESPONSE: string;
    AAO_ATTESTATION_ERROR: string;
    AAO_ATTESTATION_REJECTION: string;
    AAO_ATTESTATION_UNKNOWN_RESPONSE: string;
}>;
export declare const AttestationPhases: Readonly<{
    SANITY_CHECKS: string;
    AGGREGATE_ATTESTATIONS: string;
    SUBMIT_ATTESTATIONS: string;
    EVALUATE_ATTESTATIONS: string;
}>;
declare type SubmitAndEvaluateConfig = {
    challengeId: string;
    encodedUserId: string;
    handle: string;
    recipientEthAddress: string;
    specifier: string;
    oracleEthAddress: string;
    amount: number;
    quorumSize: number;
    AAOEndpoint: string;
    endpoints: Nullable<string[]>;
    instructionsPerTransaction?: number;
    maxAggregationAttempts?: number;
    logger: Logger;
    feePayerOverride: string | null;
};
declare type AggregateAttestationsConfig = {
    challengeId: string;
    encodedUserId: string;
    handle: string;
    specifier: string;
    oracleEthAddress: string;
    amount: number;
    quorumSize: number;
    AAOEndpoint: string;
    maxAttempts: number;
    endpoints: Nullable<string[]>;
    logger: Logger;
};
declare type GetChallengeAttestationConfig = {
    challengeId: string;
    encodedUserId: string;
    specifier: string;
    oracleEthAddress: string;
    discoveryProviderEndpoint: string;
    logger: Logger;
};
declare type GetAAOAttestationConfig = {
    challengeId: string;
    specifier: string;
    handle: string;
    amount: number;
    AAOEndpoint: string;
    oracleEthAddress: string;
    logger?: Logger;
};
declare type SendAttestationResultConfig = {
    status: string;
    userId: string;
    challengeId: string;
    amount: number;
    source: string;
    specifier: string;
    error?: string;
    phase?: string;
    reason?: string;
};
declare type CreateSenderPublicConfig = {
    senderEthAddress: string;
    operatorEthAddress: string;
    endpoints?: string[];
    numAttestations?: number;
    feePayerOverride?: string;
};
export declare class Rewards extends Base {
    ServiceProvider: ServiceProvider;
    constructor(ServiceProvider: ServiceProvider, ...args: BaseConstructorArgs);
    /**
     * Top level method to aggregate attestations, submit them to RewardsManager, and evalute the result.
     */
    submitAndEvaluate({ challengeId, encodedUserId, handle, recipientEthAddress, specifier, oracleEthAddress, amount, quorumSize, AAOEndpoint, instructionsPerTransaction, maxAggregationAttempts, endpoints, logger, feePayerOverride }: SubmitAndEvaluateConfig): Promise<{
        success: boolean;
        error: null;
        aaoErrorCode: null;
        phase: null;
        nodesToReselect: null;
    } | {
        success: boolean;
        error: string;
        aaoErrorCode: number | null | undefined;
        phase: string | undefined;
        nodesToReselect: string[] | null;
    }>;
    /**
     * Aggregates attestations from Discovery Nodes and AAO.
     */
    aggregateAttestations({ challengeId, encodedUserId, handle, specifier, oracleEthAddress, amount, quorumSize, AAOEndpoint, maxAttempts, endpoints, logger }: AggregateAttestationsConfig): Promise<{
        discoveryNodeAttestations: null;
        aaoAttestation: null;
        error: string;
        aaoErrorCode: number | null | undefined;
        erroringNodes: null;
    } | {
        discoveryNodeAttestations: null;
        aaoAttestation: null;
        error: string;
        erroringNodes: string[];
        aaoErrorCode?: undefined;
    } | {
        discoveryNodeAttestations: Nullable<{
            ethAddress: string;
            signature: string;
        }>[];
        aaoAttestation: Nullable<AttestationMeta>;
        error: null;
        aaoErrorCode: null;
        erroringNodes: null;
    }>;
    /**
     * Retrieves a Discovery Node attestation for a given userId.
     */
    getChallengeAttestation({ challengeId, encodedUserId, specifier, oracleEthAddress, discoveryProviderEndpoint, logger }: GetChallengeAttestationConfig): Promise<{
        success: {
            ethAddress: string;
            signature: string;
        };
        error: null;
    } | {
        success: null;
        error: string;
    }>;
    getUndisbursedChallenges({ limit, offset, completedBlockNumber, encodedUserId, logger }?: {
        limit?: number;
        offset?: number;
        completedBlockNumber?: string;
        encodedUserId?: number;
        logger?: Logger;
    }): Promise<{
        success: Awaited<ReturnType<DiscoveryProvider['getUndisbursedChallenges']>>;
    } | {
        error: string;
    }>;
    /**
     * Retrieves an AAO attestation for a given user handle.
     */
    getAAOAttestation({ challengeId, specifier, handle, amount, AAOEndpoint, oracleEthAddress, logger }: GetAAOAttestationConfig): Promise<{
        success: null;
        aaoErrorCode: number | undefined;
        error: string;
    } | {
        success: {
            signature: string;
            ethAddress: string;
        };
        aaoErrorCode: null;
        error: null;
    } | {
        success: null;
        aaoErrorCode: null;
        error: string;
    }>;
    _getDiscoveryAttestationsWithRetries({ endpoints, challengeId, encodedUserId, specifier, oracleEthAddress, logger, maxAttempts }: {
        endpoints: string[];
        challengeId: string;
        encodedUserId: string;
        specifier: string;
        oracleEthAddress: string;
        logger: Logger;
        maxAttempts: number;
    }): Promise<{
        success: Nullable<{
            ethAddress: string;
            signature: string;
        }>;
        error: Nullable<string>;
        endpoint: string;
    }[]>;
    /**
     * Creates a new discovery node sender for rewards. A sender may
     * attest in user challenge completion to issue rewards.
     *
     * This method queries other discovery nodes asking for attestation of
     * a given new senderEthAddress (delegate wallet) and operatorEthAddress (owner wallet).
     * Those attestations are bundled
     */
    createSenderPublic({ senderEthAddress, operatorEthAddress, endpoints, numAttestations, feePayerOverride }: CreateSenderPublicConfig): Promise<{
        res: string | null;
        errorCode: string | number | null;
        error: string | null;
    } | {
        success: null;
        error: string;
    }>;
    /**
     * Logs results of an attestation to identity.
     */
    sendAttestationResult({ status, userId, challengeId, amount, error, phase, source, specifier, reason }: SendAttestationResultConfig): Promise<void>;
}
export {};
