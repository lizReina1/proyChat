import { Base, BaseConstructorArgs } from './base';
import { Nullable, UserMetadata } from '../utils';
import type { ServiceProvider } from './ServiceProvider';
export declare class Users extends Base {
    ServiceProvider: ServiceProvider;
    preferHigherPatchForPrimary: boolean;
    preferHigherPatchForSecondaries: boolean;
    constructor(serviceProvider: ServiceProvider, preferHigherPatchForPrimary: boolean, preferHigherPatchForSecondaries: boolean, ...args: BaseConstructorArgs);
    /**
     * get users with all relevant user data
     * can be filtered by providing an integer array of ids
     * @returns Array of User metadata Objects
     * additional metadata fields on user objects:
     *  {Integer} track_count - track count for given user
     *  {Integer} playlist_count - playlist count for given user
     *  {Integer} album_count - album count for given user
     *  {Integer} follower_count - follower count for given user
     *  {Integer} followee_count - followee count for given user
     *  {Integer} repost_count - repost count for given user
     *  {Integer} track_blocknumber - blocknumber of latest track for user
     *  {Boolean} does_current_user_follow - does current user follow given user
     *  {Array} followee_follows - followees of current user that follow given user
     * @example
     * await getUsers()
     * await getUsers(100, 0, [3,2,6]) - Invalid user ids will not be accepted
     */
    getUsers(limit?: number, offset?: number, idsArray?: Nullable<number[]>, walletAddress?: Nullable<string>, handle?: Nullable<string>, minBlockNumber?: Nullable<number>): Promise<Nullable<UserMetadata[]> | undefined>;
    /**
     * get intersection of users that follow followeeUserId and users that are followed by followerUserId
     * @param followeeUserId user that is followed
     * @example
     * getMutualFollowers(100, 0, 1, 1) - IDs must be valid
     */
    getMutualFollowers(limit: number | undefined, offset: number | undefined, followeeUserId: number): Promise<unknown>;
    /**
     * get users that follow followeeUserId, sorted by follower count descending
     */
    getFollowersForUser(limit: number | undefined, offset: number | undefined, followeeUserId: string): Promise<unknown>;
    /**
     * get users that are followed by followerUserId, sorted by follower count descending
     */
    getFolloweesForUser(limit: number | undefined, offset: number | undefined, followerUserId: string): Promise<unknown>;
    /**
     * Return repost feed for requested user
     * @param userId - requested user id
     * @param limit - max # of items to return (for pagination)
     * @param offset - offset into list to return from (for pagination)
     * @returns Array of track and playlist metadata objects
     * additional metadata fields on track and playlist objects:
     *  {String} activity_timestamp - timestamp of requested user's repost for given track or playlist,
     *    used for sorting feed
     *  {Integer} repost_count - repost count of given track/playlist
     *  {Integer} save_count - save count of given track/playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given track/playlist
     *  {Array} followee_reposts - followees of current user that have reposted given track/playlist
     */
    getUserRepostFeed(userId: number, limit?: number, offset?: number, withUsers?: boolean): Promise<unknown>;
    /**
     * Return social feed for current user
     * @param limit - max # of items to return
     * @param filter - filter by "all", "original", or "repost"
     * @param offset - offset into list to return from (for pagination)
     * @returns Array of track and playlist metadata objects
     * additional metadata fields on track and playlist objects:
     *  {String} activity_timestamp - timestamp of requested user's repost for given track or playlist,
     *    used for sorting feed
     *  {Integer} repost_count - repost count of given track/playlist
     *  {Integer} save_count - save count of given track/playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given track/playlist
     *  {Array} followee_reposts - followees of current user that have reposted given track/playlist
     */
    getSocialFeed(filter: string, limit?: number, offset?: number, withUsers?: boolean, tracksOnly?: boolean): Promise<unknown>;
    /**
     * Returns the top users for the specified genres
     * @param genres - filter by genres ie. "Rock", "Alternative"
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     * @param withUsers - If the userIds should be returned or the full user metadata
     * @returns  Array of user objects if with_users set, else array of userId
     */
    getTopCreatorsByGenres(genres: string[], limit?: number, offset?: number, withUsers?: boolean): Promise<unknown>;
    /**
     * Gets listen count data for a user's tracks grouped by month
     * @returns Dictionary of listen count data where keys are requested months
     */
    getUserListenCountsMonthly(encodedUserId: string, startTime: string, endTime: string): Promise<Object | null | undefined>;
    /**
     * Gets a user's subscribers.
     * @param params.encodedUserId string of the encoded user id
     * @returns Array of User metadata objects for each subscriber
     */
    getUserSubscribers(encodedUserId: string): Promise<unknown>;
    /**
     * Bulk gets users' subscribers.
     * @param params.encodedUserIds JSON stringified array of
     *   encoded user ids
     * @returns Array of {user_id: <encoded user id>,
     *   subscriber_ids: Array[<encoded subscriber ids>]} objects
     */
    bulkGetUserSubscribers(encodedUserIds: string): Promise<unknown>;
    uploadProfileImagesV2(profilePictureFile: File, coverPhotoFile: File, metadata: UserMetadata): Promise<UserMetadata>;
    createEntityManagerUserV2({ metadata, profilePictureFile, coverPhotoFile }: {
        metadata: UserMetadata;
        profilePictureFile: Nullable<File>;
        coverPhotoFile: Nullable<File>;
    }): Promise<{
        newMetadata: Pick<UserMetadata, keyof UserMetadata>;
        blockHash: string;
        blockNumber: number;
    }>;
    /**
     * Updates a user on whether they are verified on Audius
     */
    updateIsVerified(userId: number, privateKey: string): Promise<[string, string]>;
    /**
     * Adds a user subscription for a given subscriber and user
     */
    addUserSubscribe(userId: number): Promise<{
        blockHash: string;
        blockNumber: number;
        error?: undefined;
    } | {
        error: string;
        blockHash?: undefined;
        blockNumber?: undefined;
    }>;
    /**
     * Delete a user subscription for a given subscriber and user
     */
    deleteUserSubscribe(userId: number): Promise<{
        blockHash: string;
        blockNumber: number;
        error?: undefined;
    } | {
        error: string;
        blockHash?: undefined;
        blockNumber?: undefined;
    }>;
    /**
     * Only posts metadata to chain and not to Content Node.
     */
    updateMetadataV2({ newMetadata, userId }: {
        newMetadata: UserMetadata;
        userId: number;
    }): Promise<{
        blockHash: string;
        blockNumber: number;
    }>;
    _waitForDiscoveryToIndexUser(userId: number, blockNumber: number, timeoutMs?: number): Promise<void>;
    _validateUserMetadata(metadata: UserMetadata): void;
    /**
     * Metadata object may have extra fields.
     * - Add what user props might be missing to normalize
     * - Only keep core fields in USER_PROPS and 'user_id'.
     */
    cleanUserMetadata(metadata: UserMetadata): Pick<UserMetadata, keyof UserMetadata>;
    _generateUserId(): Promise<number>;
}
