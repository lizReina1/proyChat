import { BaseAPI, Configuration } from '../generated/default';
import type { UserChat, ChatMessage, RPCPayloadRequest, ValidatedChatPermissions } from './serverTypes';
import { ChatBlockRequest, ChatCreateRequest, ChatDeleteRequest, ChatEvents, ChatGetAllRequest, ChatGetBlockersRequest, ChatGetMessagesRequest, ChatGetPermissionRequest, ChatGetRequest, ChatGetUnreadCountRequest, ChatInviteRequest, ChatListenRequest, ChatMessageRequest, ChatPermitRequest, ChatReactRequest, ChatReadRequest, ChatUnfurlRequest, TypedCommsResponse, UnfurlResponse } from './clientTypes';
import type TypedEmitter from 'typed-emitter';
import type { DiscoveryNodeSelectorService } from '../../services/DiscoveryNodeSelector/types';
import type { AuthService } from '../../services/Auth';
import type { EventEmitterTarget } from '../../utils/EventEmitterTarget';
import type { LoggerService } from '../../services/Logger';
export declare class ChatsApi extends BaseAPI implements EventEmitterTarget<ChatEvents> {
    private readonly auth;
    private readonly discoveryNodeSelectorService;
    private readonly logger;
    /**
     * A map of chatId => chatSecret so we don't have to repeatedly fetch it
     */
    private chatSecrets;
    /**
     * An event emitter that's used for consumers to listen for chat events
     */
    private readonly eventEmitter;
    /**
     * The websocket currently in use
     */
    private websocket;
    /**
     * The current user ID to use when connecting/reconnecting the websocket
     */
    private listenUserId?;
    /**
     * Proxy to the event emitter addListener
     */
    addEventListener: <E extends keyof ChatEvents>(event: E, listener: ChatEvents[E]) => TypedEmitter<ChatEvents>;
    /**
     * Proxy to the event emitter removeListener
     */
    removeEventListener: <E extends keyof ChatEvents>(event: E, listener: ChatEvents[E]) => TypedEmitter<ChatEvents>;
    constructor(config: Configuration, auth: AuthService, discoveryNodeSelectorService: DiscoveryNodeSelectorService, logger: LoggerService);
    /**
     * Establishes a websocket connection for listening to chat events.
     * @param params.currentUserId the user to listen for chat events for
     */
    listen(params?: ChatListenRequest): Promise<void>;
    /**
     * Gets a single chat
     * @param params.chatId the chat to get
     * @param params.currentUserId the user to act on behalf of
     * @returns the chat response
     */
    get(params: ChatGetRequest): Promise<{
        data: UserChat;
        summary?: {
            prev_cursor: string;
            prev_count: number;
            next_cursor: string;
            next_count: number;
            total_count: number;
        } | undefined;
        health: {
            is_healthy: boolean;
        };
    }>;
    /**
     * Gets a list of chats
     * @param params.limit the max number of chats to get
     * @param params.before a timestamp cursor for pagination
     * @param params.after a timestamp cursor for pagination
     * @param params.currentUserId the user to act on behalf of
     * @returns the chat list response
     */
    getAll(params?: ChatGetAllRequest): Promise<{
        data: UserChat[];
        summary?: {
            prev_cursor: string;
            prev_count: number;
            next_cursor: string;
            next_count: number;
            total_count: number;
        } | undefined;
        health: {
            is_healthy: boolean;
        };
    }>;
    /**
     * Gets a list of messages
     * @param params.chatId the chat to get messages for
     * @param params.before a timestamp cursor for pagination
     * @param params.after a timestamp cursor for pagination
     * @param params.currentUserId the user to act on behalf of
     * @returns the messages list response
     */
    getMessages(params: ChatGetMessagesRequest): Promise<TypedCommsResponse<ChatMessage[]>>;
    /**
     * Gets the total unread message count for a user
     * @param params.currentUserId the user to act on behalf of
     * @returns the unread count response
     */
    getUnreadCount(params?: ChatGetUnreadCountRequest): Promise<TypedCommsResponse<number>>;
    /**
     * Gets the permission settings of the given users
     * @param params.userIds the users to fetch permissions of
     * @param params.currentUserId the user to act on behalf of
     * @returns the permissions response
     */
    getPermissions(params: ChatGetPermissionRequest): Promise<TypedCommsResponse<ValidatedChatPermissions[]>>;
    /**
     * Gets the user ids that have blocked the current user
     * @param params.currentUserId the user to act on behalf of
     * @returns the blockers response
     */
    getBlockers(params?: ChatGetBlockersRequest): Promise<TypedCommsResponse<string[]>>;
    /**
     * Gets the user ids the current user has blocked
     * @param params.currentUserId the user to act on behalf of
     * @returns
     */
    getBlockees(params?: ChatGetBlockersRequest): Promise<TypedCommsResponse<string[]>>;
    /**
     * Gets URL metadata useful for link previews
     * @param params.content the urls to get metadata for
     * @returns the unfurl response
     */
    unfurl(params: ChatUnfurlRequest): Promise<UnfurlResponse[]>;
    /**
     * Creates a chat between users
     * @param params.userId the user id who is creating the chat
     * @param params.invitedUserIds the user ids to add to the chat
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    create(params: ChatCreateRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Invites other users to an existing chat
     * @param params.chatId the chat id of the chat to invite to
     * @param params.userId the user id who is creating the chat
     * @param params.invitedUserIds the user ids to add to the chat
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    invite(params: ChatInviteRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Sends a message to a user in a chat
     * @param params.message the message
     * @param params.chatId the chat to send a message in
     * @param params.messageId the id of the message
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    message(params: ChatMessageRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Reacts to a message
     * @param params.reaction the reaction
     * @param params.chatId the chat to send a reaction in
     * @param params.messageId the id of the message to react to
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    react(params: ChatReactRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Marks a chat as read
     * @param params.chatId the chat to mark as read
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    read(params: ChatReadRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Blocks a user from sending messages to the current user
     * @param params.userId the user to block
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    block(params: ChatBlockRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Unblocks a user from sending messages to the current user
     * @param params.userId the user to unblock
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    unblock(params: ChatBlockRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Clears a chat's history for the current user
     * @param params.chatId the chat to clear
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    delete(params: ChatDeleteRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Sets the inbox settings permissions of the current user
     * @param params.permit the permission to set
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    permit(params: ChatPermitRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    private createInvites;
    private createInviteCode;
    private readInviteCode;
    private encrypt;
    private encryptString;
    private decrypt;
    private decryptString;
    private decryptLastChatMessage;
    private getRaw;
    private getChatSecret;
    private getPublicKey;
    private getSignatureHeader;
    private signAndSendRequest;
    private sendRpc;
    private createWebsocket;
}
