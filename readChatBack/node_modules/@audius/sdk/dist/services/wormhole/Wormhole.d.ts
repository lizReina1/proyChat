/// <reference types="bn.js" />
/// <reference types="node" />
import type { Hedgehog } from '@audius/hedgehog';
import type { EthContracts } from '../ethContracts';
import type { EthWeb3Manager } from '../ethWeb3Manager';
import type { IdentityService } from '../identity';
import type { SolanaWeb3Manager } from '../solana';
import { BN } from 'ethereumjs-util';
import wormholeSDK, { ChainId } from '@certusone/wormhole-sdk';
import { Nullable } from '../../utils';
import type { Transaction } from '@solana/web3.js';
import type { GetSignedVAAResponse } from '@certusone/wormhole-sdk/lib/cjs/proto/publicrpc/v1/publicrpc';
export declare type WormholeConfig = {
    rpcHosts: string[];
    solBridgeAddress: string;
    solTokenBridgeAddress: string;
    ethBridgeAddress: string;
    ethTokenBridgeAddress: string;
};
/** Singleton state-manager for audius wormhole interaction */
export declare class Wormhole {
    hedgehog: Nullable<Hedgehog>;
    ethWeb3Manager: EthWeb3Manager;
    ethContracts: EthContracts;
    identityService: Nullable<IdentityService>;
    solanaWeb3Manager: SolanaWeb3Manager;
    rpcHosts: string[];
    solBridgeAddress: string;
    solTokenBridgeAddress: string;
    ethBridgeAddress: string;
    ethTokenBridgeAddress: string;
    wormholeSDK: typeof wormholeSDK;
    constructor(hedgehog: Hedgehog | null, ethWeb3Manager: EthWeb3Manager, ethContracts: EthContracts, identityService: IdentityService | null, solanaWeb3Manager: SolanaWeb3Manager, rpcHosts: string[], solBridgeAddress: string, solTokenBridgeAddress: string, ethBridgeAddress: string, ethTokenBridgeAddress: string);
    getSignedVAAWithRetry(hosts: string[], emitterChain: ChainId, emitterAddress: string, sequence: string, extraGrpcOpts?: {}, retryTimeout?: number, retryAttempts?: number): Promise<GetSignedVAAResponse>;
    /**
     * Sends `amount` tokens to `solanaAccount` by way of the wormhole
     */
    attestAndCompleteTransferEthToSol(ethTxReceipt: string, customSignTransaction?: (transaction: Transaction) => Promise<Transaction>, options?: {}): Promise<{
        transactionSignature: string;
        error: null;
        phase: string;
        logs: string[];
    } | {
        error: string;
        phase: string;
        logs: string[];
        transactionSignature?: undefined;
    }>;
    /**
     * Sends `amount` tokens to `solanaAccount` by way of the wormhole
     */
    sendTokensFromSolToEthViaWormhole(amount: BN, ethTargetAddress: string, options?: {}): Promise<{
        phase: string;
        logs: string[];
        error: null;
    } | {
        error: string;
        phase: string;
        logs: string[];
    }>;
    /**
     * Locks assets owned by `fromAccount` into the Solana wormhole with a target
     * solanaAccount destination via the provided relayer wallet.
     */
    _getTransferTokensToEthWormholeParams(fromAccount: string, amount: BN, solanaAccount: string): Promise<{
        chainId: number;
        deadline: number;
        recipient: Buffer;
        arbiterFee: BN;
        signedDigest: import("ethereumjs-util").ECDSASignature;
    }>;
    /**
     * Locks assets owned by `fromAccount` into the Solana wormhole with a target
     * solanaAccount destination via the provided relayer wallet.
     * @param fromAccount the account holding the ETH AUDIO to transfer
     * @param amount The amount of AUDIO to send in WEI (18 decimals)
     * @param solanaAccount The solana token account
     * @param relayer The eth relayer to permission to aprrove and transfer
     */
    transferTokensToEthWormhole(fromAccount: string, amount: BN, solanaAccount: string, relayer: string): Promise<import("../../utils").Maybe<{
        txHash: string;
        txParams: {
            data: string;
            gasLimit: string;
            gasPrice: number;
            nonce: string;
            to: string;
            value: string;
        };
    }>>;
    getTransferTokensToEthWormholeMethod(fromAccount: string, amount: BN, solanaAccount: string): Promise<any>;
}
