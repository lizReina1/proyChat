/// <reference types="bn.js" />
import { AudiusTokenClient } from './AudiusTokenClient';
import { RegistryClient } from './RegistryClient';
import { GovernanceClient } from './GovernanceClient';
import { ServiceTypeManagerClient } from './ServiceTypeManagerClient';
import { ServiceProviderFactoryClient } from './ServiceProviderFactoryClient';
import { StakingProxyClient } from './StakingProxyClient';
import { DelegateManagerClient } from './DelegateManagerClient';
import { ClaimsManagerClient } from './ClaimsManagerClient';
import { ClaimDistributionClient } from './ClaimDistributionClient';
import { WormholeClient } from './WormholeClient';
import { EthRewardsManagerClient } from './EthRewardsManagerClient';
import { TrustedNotifierManagerClient } from './TrustedNotifierManagerClient';
import type { Logger } from '../../utils';
import type { EthWeb3Manager } from '../ethWeb3Manager';
import type { ContractClient } from '../contracts/ContractClient';
export declare const serviceType: Readonly<{
    DISCOVERY_PROVIDER: string;
    CREATOR_NODE: string;
}>;
export declare type EthContractsConfig = {
    ethWeb3Manager: EthWeb3Manager;
    tokenContractAddress: string;
    registryAddress: string;
    claimDistributionContractAddress: string;
    wormholeContractAddress: string;
    isServer?: boolean;
    logger?: Logger;
    isDebug?: boolean;
};
export declare class EthContracts {
    ethWeb3Manager: EthWeb3Manager;
    tokenContractAddress: string;
    claimDistributionContractAddress: string;
    wormholeContractAddress: string;
    registryAddress: string;
    isServer: boolean;
    logger: Logger;
    isDebug: boolean;
    expectedServiceVersions: null | string[];
    AudiusTokenClient: AudiusTokenClient;
    RegistryClient: RegistryClient;
    StakingProxyClient: StakingProxyClient;
    GovernanceClient: GovernanceClient;
    ClaimsManagerClient: ClaimsManagerClient;
    EthRewardsManagerClient: EthRewardsManagerClient;
    ServiceTypeManagerClient: ServiceTypeManagerClient;
    ServiceProviderFactoryClient: ServiceProviderFactoryClient;
    DelegateManagerClient: DelegateManagerClient;
    ClaimDistributionClient: ClaimDistributionClient | undefined;
    WormholeClient: WormholeClient;
    TrustedNotifierManagerClient: TrustedNotifierManagerClient;
    contractClients: ContractClient[];
    _regressedMode: boolean;
    contracts: Record<string, string> | undefined;
    contractAddresses: Record<string, string> | undefined;
    constructor({ ethWeb3Manager, tokenContractAddress, registryAddress, claimDistributionContractAddress, wormholeContractAddress, isServer, logger, isDebug }: EthContractsConfig);
    init(): Promise<void>;
    /**
     * Estabilishes that connection to discovery providers has regressed
     */
    enterRegressedMode(): void;
    isInRegressedMode(): boolean;
    getRegistryAddressForContract(contractName: string): Promise<string>;
    getCurrentVersion(serviceType: string): Promise<string>;
    getExpectedServiceVersions(): Promise<Record<string, string | null | undefined>>;
    /**
     * Determine whether major and minor versions match for two version strings
     * Version string 2 must have equivalent major/minor versions and a patch >= version1
     * @param version1 string 1
     * @param version2 string 2
     */
    isValidSPVersion(version1: string, version2: string): boolean;
    getServiceProviderList(spType: string): Promise<{
        owner: any;
        endpoint: any;
        spID: number;
        type: string;
        blockNumber: number;
        delegateOwnerWallet: any;
    }[]>;
    getNumberOfVersions(spType: string): Promise<number>;
    getVersion(spType: string, queryIndex: number): Promise<string>;
    getServiceTypeInfo(spType: string): Promise<{
        isValid: any;
        minStake: import("bn.js");
        maxStake: import("bn.js");
    }>;
}
/**
 * Determines whether version2's major/minor versions are greater than or
 * equal to version1's major/minor.
 * @param version1 string 1
 * @param version2 string 2
 */
export declare const isVersionAtLeastSameMajorMinor: (version1: string, version2: string) => boolean;
