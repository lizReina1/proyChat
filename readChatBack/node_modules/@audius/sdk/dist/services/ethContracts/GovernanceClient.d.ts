/// <reference types="bn.js" />
import { ContractClient, GetRegistryAddress } from '../contracts/ContractClient';
import { ContractABI, ContractMethod, Logger } from '../../utils';
import type { EthWeb3Manager } from '../ethWeb3Manager';
import type { AudiusTokenClient } from './AudiusTokenClient';
import type { StakingProxyClient } from './StakingProxyClient';
import type { EventLog } from 'web3-core';
declare type ProposalTxn = {
    proposalId: string;
    proposer: string;
    submissionBlockNumber: string;
    targetContractRegistryKey: string;
    targetContractAddress: string;
    callValue: string;
    functionSignature: string;
    callData: string;
    outcome: string;
    numVotes: string;
    voteMagnitudeYes: string;
    voteMagnitudeNo: string;
};
/**
 * Represent an instance of a proposal vote.
 */
export declare const Vote: Readonly<{
    no: number;
    yes: number;
}>;
export declare class GovernanceClient extends ContractClient {
    audiusTokenClient: AudiusTokenClient;
    stakingProxyClient: StakingProxyClient;
    isDebug: boolean;
    constructor(ethWeb3Manager: EthWeb3Manager, contractABI: ContractABI['abi'], contractRegistryKey: string, getRegistryAddress: GetRegistryAddress, audiusTokenClient: AudiusTokenClient, stakingProxyClient: StakingProxyClient, logger?: Logger, isDebug?: boolean);
    /**
     * Gets the function signature and call data for a contract method.
     * The signature and call data are passed to other contracts (like governance)
     * as arguments.
     * @param methodName
     * @param contractMethod
     */
    getSignatureAndCallData(methodName: string, contractMethod: ContractMethod): {
        signature: string;
        callData: string;
    };
    guardianExecuteTransaction(contractRegistryKey: string, functionSignature: string, callData: string): Promise<ContractMethod>;
    getVotingPeriod(): Promise<number>;
    setVotingPeriod(period: string): Promise<import("web3-core").TransactionReceipt>;
    getVotingQuorumPercent(): Promise<number>;
    getExecutionDelay(): Promise<number>;
    setExecutionDelay(delay: number): Promise<import("web3-core").TransactionReceipt>;
    getProposalById(id: number): Promise<{
        proposalId: number;
        proposer: string;
        submissionBlockNumber: number;
        targetContractRegistryKey: string;
        targetContractAddress: string;
        callValue: number;
        functionSignature: string;
        callData: string;
        outcome: number;
        numVotes: number;
        voteMagnitudeYes: import("bn.js");
        voteMagnitudeNo: import("bn.js");
    }>;
    getProposalTargetContractHash(id: string): Promise<any>;
    getProposals(queryStartBlock?: number): Promise<{
        proposalId: number;
        proposer: any;
        description: any;
        name: any;
        blockNumber: number;
    }[]>;
    getProposalsForAddresses(addresses: string[], queryStartBlock?: number): Promise<{
        proposalId: number;
        proposer: any;
        description: any;
        name: any;
        blockNumber: number;
    }[]>;
    getProposalSubmission(proposalId: number, queryStartBlock?: number): Promise<{
        proposalId: number;
        proposer: any;
        description: any;
        name: any;
        blockNumber: number;
    }>;
    getInProgressProposals(): Promise<any>;
    submitProposal({ targetContractRegistryKey, callValue, functionSignature, callData, // array of args, e.g. [slashAmount, targetAddress]
    name, description }: {
        targetContractRegistryKey: string;
        callValue: string;
        functionSignature: string;
        callData: string[];
        name: string;
        description: string;
    }): Promise<any>;
    submitVote({ proposalId, vote }: {
        proposalId: number;
        vote: string;
    }): Promise<void>;
    updateVote({ proposalId, vote }: {
        proposalId: number;
        vote: string;
    }): Promise<void>;
    evaluateProposalOutcome(proposalId: number): Promise<import("web3-core").TransactionReceipt>;
    getProposalEvaluation(proposalId: number, queryStartBlock?: number): Promise<import("web3-eth-contract").EventData[]>;
    getVotes({ proposalId, queryStartBlock }: {
        proposalId: number;
        queryStartBlock: number;
    }): Promise<{
        proposalId: number;
        voter: any;
        vote: number;
        voterStake: import("bn.js");
        blockNumber: number;
    }[]>;
    getVoteUpdates({ proposalId, queryStartBlock }: {
        proposalId: number;
        queryStartBlock: number;
    }): Promise<{
        proposalId: number;
        voter: any;
        vote: number;
        voterStake: import("bn.js");
        blockNumber: number;
    }[]>;
    getVoteSubmissionsByAddress({ addresses, queryStartBlock }: {
        addresses: string[];
        queryStartBlock: number;
    }): Promise<{
        proposalId: number;
        voter: any;
        vote: number;
        voterStake: import("bn.js");
        blockNumber: number;
    }[]>;
    getVoteUpdatesByAddress({ addresses, queryStartBlock }: {
        addresses: string[];
        queryStartBlock: number;
    }): Promise<{
        proposalId: number;
        voter: any;
        vote: number;
        voterStake: import("bn.js");
        blockNumber: number;
    }[]>;
    getVoteByProposalAndVoter({ proposalId, voterAddress }: {
        proposalId: number[];
        voterAddress: number;
    }): Promise<number>;
    /**
     * ABI encodes argument types and values together into one encoded string
     */
    abiEncode(types: string[], values: string[]): string;
    toBN(val: string): import("bn.js");
    /**
     * Prune off extraneous fields from proposal returned by txn
     */
    formatProposal(proposal: ProposalTxn): {
        proposalId: number;
        proposer: string;
        submissionBlockNumber: number;
        targetContractRegistryKey: string;
        targetContractAddress: string;
        callValue: number;
        functionSignature: string;
        callData: string;
        outcome: number;
        numVotes: number;
        voteMagnitudeYes: import("bn.js");
        voteMagnitudeNo: import("bn.js");
    };
    /**
     * Formats a proposal event
     */
    formatProposalEvent(proposalEvent: EventLog): {
        proposalId: number;
        proposer: any;
        description: any;
        name: any;
        blockNumber: number;
    };
    /**
     * Prune off extraneous fields from vote event
     */
    formatVote(voteEvent: EventLog): {
        proposalId: number;
        voter: any;
        vote: number;
        voterStake: import("bn.js");
        blockNumber: number;
    };
    /**
     *
     * @param {Number} proposalId id of the governance proposal
     * @returns {BN} amount of tokens in wei required to reach quorum
     */
    calculateQuorum(proposalId: number): Promise<any>;
}
export {};
