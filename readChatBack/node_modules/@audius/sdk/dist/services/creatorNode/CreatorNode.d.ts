import { AxiosRequestConfig } from 'axios';
import FormData from 'form-data';
import { Nullable, TrackMetadata, UserMetadata } from '../../utils';
import { Schemas } from '../schemaValidator/SchemaValidator';
import type { Web3Manager } from '../web3Manager';
import type { UserStateManager } from '../../userStateManager';
import type { MonitoringCallbacks } from '../types';
import type { StorageNodeSelectorService } from '../../sdk';
declare type PlaylistTrackId = {
    time: number;
    track: number;
};
declare type PlaylistContents = {
    track_ids: PlaylistTrackId[];
};
export declare type PlaylistMetadata = {
    playlist_contents: PlaylistContents;
    playlist_id: number;
    playlist_name: string;
    playlist_image_sizes_multihash: string;
    description: string;
    is_album: boolean;
    is_private: boolean;
    is_image_autogenerated: boolean;
};
declare type ProgressCB = (loaded: number, total: number) => void;
export declare type CreatorNodeConfig = {
    web3Manager: Web3Manager;
    creatorNodeEndpoint: string;
    isServer: boolean;
    userStateManager: UserStateManager;
    schemas: Schemas;
    passList: Set<string> | null;
    blockList: Set<string> | null;
    monitoringCallbacks: MonitoringCallbacks;
    fallbackUrl: string;
    storageNodeSelector: StorageNodeSelectorService;
};
export declare class CreatorNode {
    web3Manager: Nullable<Web3Manager>;
    creatorNodeEndpoint: string;
    isServer: boolean;
    userStateManager: UserStateManager;
    schemas: Schemas | undefined;
    passList: Set<string> | null;
    blockList: Set<string> | null;
    monitoringCallbacks: MonitoringCallbacks;
    maxBlockNumber: number;
    storageNodeSelector: StorageNodeSelectorService;
    /**
     * Constructs a service class for a creator node
     */
    constructor(web3Manager: Nullable<Web3Manager>, creatorNodeEndpoint: string, isServer: boolean, userStateManager: UserStateManager, schemas: Schemas | undefined, passList: Set<string> | null | undefined, blockList: Set<string> | null | undefined, monitoringCallbacks: MonitoringCallbacks | undefined, storageNodeSelector: StorageNodeSelectorService);
    init(): Promise<void>;
    validatePlaylistSchema(metadata: PlaylistMetadata): void;
    validateUserSchema(metadata: UserMetadata): void;
    validateTrackSchema(metadata: TrackMetadata): void;
    getEndpoint(): string;
    /**
     * Switch from one creatorNodeEndpoint to another
     */
    setEndpoint(creatorNodeEndpoint: string): Promise<void>;
    transcodeTrackPreview(metadata: TrackMetadata): Promise<TrackMetadata>;
    uploadTrackAudioAndCoverArtV2(trackFile: File, coverArtFile: File, metadata: TrackMetadata, onProgress?: ProgressCB): Promise<TrackMetadata>;
    uploadTrackAudioV2(file: File, onProgress?: ProgressCB, options?: {
        [key: string]: string;
    }): Promise<any>;
    uploadTrackCoverArtV2(file: File, onProgress?: ProgressCB): Promise<any>;
    uploadProfilePictureV2(file: File, onProgress?: ProgressCB): Promise<any>;
    uploadCoverPhotoV2(file: File, onProgress?: ProgressCB): Promise<any>;
    editFileV2(uploadId: string, data: {
        [key: string]: string;
    }): Promise<any>;
    uploadFileV2(file: File, onProgress: ProgressCB, template: 'audio' | 'img_square' | 'img_backdrop', options?: {
        [key: string]: string;
    }): Promise<any>;
    /**
     * Works for both track transcode and image resize jobs
     * @param id ID of the transcode/resize job
     * @param maxPollingMs millis to stop polling and error if job is not done
     * @returns successful job info, or throws error if job fails / times out
     */
    pollProcessingStatusV2(id: string, maxPollingMs: number): Promise<any>;
    /**
     * Gets the task progress given the task type and id associated with the job
     * @param id the id of the transcoding or resizing job
     * @returns the status, and the success or failed response if the job is complete
     */
    getProcessingStatusV2(id: string): Promise<any>;
    /**
     * Makes an axios request to this.creatorNodeEndpoint
     * @return response body
     */
    _makeRequestV2(axiosRequestObj: AxiosRequestConfig): Promise<import("axios").AxiosResponse<any>>;
    /**
     * Create headers and formData for file upload
     * @param file the file to upload
     * @returns headers and formData in an object
     */
    createFormDataAndUploadHeadersV2(file: File, extraFormDataOptions?: Record<string, unknown>): {
        headers: Record<string, string | null>;
        formData: FormData;
    };
    /**
     * Calls fn and then retries once after 500ms, again after 1500ms, and again after 4000ms
     */
    _retry3(fn: () => Promise<any>, onRetry?: (_err: any) => void): Promise<any>;
}
export {};
