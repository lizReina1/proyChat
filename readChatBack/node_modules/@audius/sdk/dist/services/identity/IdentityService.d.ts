/// <reference types="node" />
import { AxiosRequestConfig } from 'axios';
import type { Nullable } from '../../utils';
import { TimeFrame } from './requests';
import type { Web3Manager } from '../web3Manager';
import type { TransactionReceipt } from 'web3-core';
import type Wallet from 'ethereumjs-wallet';
import type BN from 'bn.js';
declare type Data = Record<string, unknown>;
declare type RelayTransactionInstruction = {
    programId: string;
    data: Buffer;
    keys: Array<{
        pubkey: string;
        isSigner: boolean;
        isWritable: boolean;
    }>;
};
export declare type RelayTransaction = {
    resp: {
        txHash: string;
        txParams: {
            data: string;
            gasLimit: string;
            gasPrice: number;
            nonce: string;
            to: string;
            value: string;
        };
    };
};
export declare type RelayTransactionData = {
    instructions: RelayTransactionInstruction[];
    skipPreflight?: boolean;
    feePayerOverride?: string | null;
    signatures?: Array<{
        publicKey: string;
        signature: Buffer;
    }> | null;
    retry?: boolean;
    recentBlockhash?: string;
};
declare type AttestationResult = {
    status: string;
    userId: string;
    challengeId: string;
    amount: number;
    source: string;
    specifier: string;
    error?: string;
    phase?: string;
    reason?: string;
};
declare type Reaction = {
    reactedTo: string;
    reactionValue: number;
};
declare enum TransactionMetadataType {
    PURCHASE_SOL_AUDIO_SWAP = "PURCHASE_SOL_AUDIO_SWAP"
}
declare type InAppAudioPurchaseMetadata = {
    discriminator: TransactionMetadataType.PURCHASE_SOL_AUDIO_SWAP;
    usd: string;
    sol: string;
    audio: string;
    purchaseTransactionId: string;
    setupTransactionId?: string;
    swapTransactionId: string;
    cleanupTransactionId?: string;
};
declare type CreateStripeSessionRequest = {
    destinationWallet: string;
    amount: string;
    destinationCurrency: 'sol' | 'usdc';
};
declare type CreateStripeSessionResponse = {
    id: string;
    client_secret: string;
    status: string;
};
export declare type IdentityServiceConfig = {
    identityServiceEndpoint: string;
};
export declare class IdentityService {
    identityServiceEndpoint: string;
    web3Manager: Web3Manager | null;
    constructor({ identityServiceEndpoint }: IdentityServiceConfig);
    setWeb3Manager(web3Manager: Web3Manager): void;
    getFn(params: {
        lookupKey: string;
        username: string;
    }): Promise<{
        iv: string;
        cipherText: string;
    }>;
    setAuthFn(obj: Data): Promise<unknown>;
    setUserFn(obj: Data & {
        token?: string;
    }): Promise<unknown>;
    getUserEvents(walletAddress: string): Promise<{
        needsRecoveryEmail: boolean;
    }>;
    sendRecoveryInfo(obj: Record<string, unknown>): Promise<{
        status: true;
    }>;
    /**
     * Check if an email address has been previously registered.
     */
    checkIfEmailRegistered(email: string): Promise<{
        exists: boolean;
    }>;
    getUserEmail(): Promise<{
        email: string | undefined | null;
    }>;
    /**
     * Associates a user with a twitter uuid.
     * @param uuid from the Twitter API
     * @param userId
     * @param handle User handle
     */
    associateTwitterUser(uuid: string, userId: number, handle: string): Promise<unknown>;
    /**
     * Associates a user with an instagram uuid.
     * @param uuid from the Instagram API
     * @param userId
     * @param handle
     */
    associateInstagramUser(uuid: string, userId: number, handle: string): Promise<unknown>;
    /**
     * Associates a user with an TikTok uuid.
     * @param uuid from the TikTok API
     * @param userId
     * @param handle
     */
    associateTikTokUser(uuid: string, userId: number, handle: string): Promise<unknown>;
    /**
     * Logs a track listen for a given user id.
     * @param trackId
     * @param userId
     * @param listenerAddress if logging this listen on behalf of another IP address, pass through here
     * @param signatureData if logging this listen via a 3p service, a signed piece of data proving authenticity
     */
    logTrackListen(trackId: number, userId: number, listenerAddress: Nullable<string>, signatureData: Nullable<{
        signature: string;
        timestamp: string;
    }>, solanaListen?: boolean): Promise<unknown>;
    /**
     * Return listen history tracks for a given user id.
     * @param userId - User ID
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */
    getListenHistoryTracks(userId: number, limit?: number, offset?: number): Promise<unknown>;
    /**
     * Looks up a Twitter account by handle.
     * @returns twitter API response.
     */
    lookupTwitterHandle(handle: string): Promise<unknown>;
    /**
     * Gets tracks trending on Audius.
     * @param timeFrame one of day, week, month, or year
     * @param idsArray track ids
     * @param limit
     * @param offset
     */
    getTrendingTracks(timeFrame?: string | null, idsArray?: number[] | null, limit?: number | null, offset?: number | null): Promise<{
        listenCounts: Array<{
            trackId: number;
            listens: number;
        }>;
    }>;
    /**
     * Gets listens for tracks bucketted by timeFrame.
     * @param timeFrame one of day, week, month, or year
     * @param idsArray track ids
     * @param startTime parseable by Date.parse
     * @param endTime parseable by Date.parse
     * @param limit
     * @param offset
     */
    getTrackListens(timeFrame?: TimeFrame | null, idsArray?: number[] | null, startTime?: string | null, endTime?: string | null, limit?: number | null, offset?: number | null): Promise<{
        bucket: Array<{
            trackId: number;
            date: string;
            listens: number;
        }>;
    }>;
    createUserRecord(email: string, walletAddress: string): Promise<unknown>;
    relay(contractRegistryKey: string | null | undefined, contractAddress: string | null | undefined, senderAddress: string, encodedABI: string, gasLimit: number, handle: string | null | undefined, nethermindContractAddress: string | null | undefined, nethermindEncodedAbi: string | undefined): Promise<{
        receipt: TransactionReceipt;
    }>;
    ethRelay(contractAddress: string, senderAddress: Wallet | string, encodedABI: string, gasLimit: string): Promise<RelayTransaction>;
    wormholeRelay({ senderAddress, permit, transferTokens }: {
        senderAddress: string;
        permit: {
            contractAddress: string;
            encodedABI: string;
            gasLimit: number;
        };
        transferTokens: {
            contractAddress: string;
            encodedABI: string;
            gasLimit: number;
        };
    }): Promise<unknown>;
    /**
     * Gets the correct wallet that will relay a txn for `senderAddress`
     * @param senderAddress wallet
     */
    getEthRelayer(senderAddress: string): Promise<{
        selectedEthWallet: string;
    }>;
    getRandomFeePayer(): Promise<unknown>;
    solanaRelay(transactionData: RelayTransactionData): Promise<{
        transactionSignature: string;
    }>;
    solanaRelayRaw(transactionData: RelayTransactionData): Promise<{
        transactionSignature: string;
    }>;
    getMinimumDelegationAmount(wallet: string): Promise<unknown>;
    updateMinimumDelegationAmount(wallet: string, minimumDelegationAmount: BN, signedData: AxiosRequestConfig['headers']): Promise<unknown>;
    /**
     * Sends an attestation result to identity.
     *
     */
    sendAttestationResult(data: AttestationResult): Promise<unknown>;
    /**
     * Post a reaction to identity.
     */
    submitReaction(data: Reaction): Promise<unknown>;
    /**
     * Gets $AUDIO purchase metadata
     */
    getUserBankTransactionMetadata(transactionId: string): Promise<InAppAudioPurchaseMetadata | null>;
    /**
     * Saves $AUDIO purchase metadata
     */
    saveUserBankTransactionMetadata(data: {
        transactionSignature: string;
        metadata: InAppAudioPurchaseMetadata;
    }): Promise<unknown>;
    createStripeSession(data: CreateStripeSessionRequest): Promise<CreateStripeSessionResponse>;
    _makeRequest<T = unknown>(axiosRequestObj: AxiosRequestConfig): Promise<T>;
    _signData(): Promise<{
        "Encoded-Data-Message": string;
        "Encoded-Data-Signature": string | undefined;
    } | {
        "Encoded-Data-Message"?: undefined;
        "Encoded-Data-Signature"?: undefined;
    }>;
}
export {};
