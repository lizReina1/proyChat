import { AxiosRequestConfig, Method, ResponseType } from 'axios';
import { CollectionMetadata, Nullable } from '../../utils';
import * as Requests from './requests';
import { PathArg } from 'proper-url-join';
import { DiscoveryProviderSelection, DiscoveryProviderSelectionConfig } from './DiscoveryProviderSelection';
import type { CurrentUser, UserStateManager } from '../../userStateManager';
import type { EthContracts } from '../ethContracts';
import type { Web3Manager } from '../web3Manager';
import { DiscoveryNodeSelector, Middleware } from '../../sdk';
declare type RequestParams = {
    queryParams: Record<string, string>;
    endpoint: string;
    timeout?: number;
    method?: Method;
    urlParams?: PathArg;
    headers?: Record<string, string>;
    data?: Record<string, unknown>;
    responseType?: ResponseType;
};
declare type UserReplicaSet = {
    primarySpID: number;
    secondary1SpID: number;
    secondary2SpID: number;
};
declare type DiscoveryResponse<Response> = {
    latest_indexed_block: number;
    latest_chain_block: number;
    latest_indexed_slot_plays: number;
    latest_chain_slot_plays: number;
    version: {
        service: string;
        version: string;
    };
    data: Response;
};
export declare type DiscoveryProviderConfig = {
    whitelist?: Set<string>;
    blacklist?: Set<string>;
    userStateManager: UserStateManager;
    ethContracts: Nullable<EthContracts>;
    web3Manager?: Nullable<Web3Manager>;
    reselectTimeout?: number;
    selectionRequestTimeout?: number;
    selectionRequestRetries?: number;
    unhealthySlotDiffPlays?: number;
    unhealthyBlockDiff?: number;
    discoveryNodeSelector?: DiscoveryNodeSelector;
} & Pick<DiscoveryProviderSelectionConfig, 'selectionCallback' | 'monitoringCallbacks' | 'localStorage'>;
export declare type UserProfile = {
    userId: string;
    email: string;
    name: string;
    handle: string;
    verified: boolean;
    profilePicture: {
        '150x150': string;
        '480x480': string;
        '1000x1000': string;
    } | null | undefined;
    sub: number;
    iat: string;
};
/**
 * Constructs a service class for a discovery node
 * @param whitelist whether or not to only include specified nodes in selection
 * @param userStateManager singleton UserStateManager instance
 * @param ethContracts singleton EthContracts instance
 * @param web3Manager
 * @param reselectTimeout timeout to clear locally cached discovery providers
 * @param selectionCallback invoked when a discovery node is selected
 * @param monitoringCallbacks callbacks to be invoked with metrics from requests sent to a service
 *  @param monitoringCallbacks.request
 *  @param monitoringCallbacks.healthCheck
 * @param selectionRequestTimeout the amount of time (ms) an individual request should take before reselecting
 * @param selectionRequestRetries the number of retries to a given discovery node we make before reselecting
 * @param unhealthySlotDiffPlays the number of slots we would consider a discovery node unhealthy
 * @param unhealthyBlockDiff the number of missed blocks after which we would consider a discovery node unhealthy
 */
export declare class DiscoveryProvider {
    whitelist: Set<string> | undefined;
    blacklist: Set<string> | undefined;
    userStateManager: UserStateManager;
    ethContracts: Nullable<EthContracts>;
    web3Manager?: Nullable<Web3Manager>;
    unhealthyBlockDiff: number;
    serviceSelector: DiscoveryProviderSelection;
    selectionRequestTimeout: number;
    selectionRequestRetries: number;
    unhealthySlotDiffPlays: number | undefined;
    request404Count: number;
    maxRequestsForTrue404: number;
    monitoringCallbacks: DiscoveryProviderSelection['monitoringCallbacks'] | undefined;
    discoveryProviderEndpoint: string | undefined;
    isInitialized: boolean;
    discoveryNodeSelector?: DiscoveryNodeSelector;
    discoveryNodeMiddleware?: Middleware;
    selectionCallback?: DiscoveryProviderSelectionConfig['selectionCallback'];
    constructor({ whitelist, blacklist, userStateManager, ethContracts, web3Manager, reselectTimeout, selectionCallback, monitoringCallbacks, selectionRequestTimeout, selectionRequestRetries, localStorage, unhealthySlotDiffPlays, unhealthyBlockDiff, discoveryNodeSelector }: DiscoveryProviderConfig);
    init(): Promise<void>;
    setEndpoint(endpoint: string): void;
    setUnhealthyBlockDiff(updatedBlockDiff?: number): void;
    setUnhealthySlotDiffPlays(updatedDiff: number): void;
    /**
     * Get users with all relevant user data
     * can be filtered by providing an integer array of ids
     * @returns Array of User metadata Objects
     * additional metadata fields on user objects:
     *  {Integer} track_count - track count for given user
     *  {Integer} playlist_count - playlist count for given user
     *  {Integer} album_count - album count for given user
     *  {Integer} follower_count - follower count for given user
     *  {Integer} followee_count - followee count for given user
     *  {Integer} repost_count - repost count for given user
     *  {Integer} track_blocknumber - blocknumber of latest track for user
     *  {Boolean} does_current_user_follow - does current user follow given user
     *  {Array} followee_follows - followees of current user that follow given user
     * @example
     * await getUsers()
     * await getUsers(100, 0, [3,2,6]) - Invalid user ids will not be accepted
     */
    getUsers(limit: number | undefined, offset: number | undefined, idsArray: Nullable<number[]>, walletAddress?: Nullable<string>, handle?: Nullable<string>, minBlockNumber?: Nullable<number>, includeIncomplete?: Nullable<boolean>): Promise<Nullable<import("../../utils").UserMetadata[]> | undefined>;
    /**
     * get tracks with all relevant track data
     * can be filtered by providing an integer array of ids
     * @param limit
     * @param offset
     * @param idsArray
     * @param targetUserId the owner of the tracks being queried
     * @param sort a string of form eg. blocknumber:asc,timestamp:desc describing a sort path
     * @param minBlockNumber The min block number
     * @param filterDeleted If set to true, filters the deleted tracks
     * @returns Array of track metadata Objects
     * additional metadata fields on track objects:
     *  {Integer} repost_count - repost count for given track
     *  {Integer} save_count - save count for given track
     *  {Array} followee_reposts - followees of current user that have reposted given track
     *  {Boolean} has_current_user_reposted - has current user reposted given track
     *  {Boolean} has_current_user_saved - has current user saved given track
     * @example
     * await getTracks()
     * await getTracks(100, 0, [3,2,6]) - Invalid track ids will not be accepted
     */
    getTracks(limit: number | undefined, offset: number | undefined, idsArray: Nullable<string[]>, targetUserId: Nullable<string>, sort: Nullable<boolean>, minBlockNumber: Nullable<number>, filterDeleted: Nullable<boolean>, withUsers?: boolean): Promise<unknown>;
    /**
     * get tracks with all relevant track data
     * can be filtered by providing an integer array of ids
     * @param limit
     * @param offset
     * @param idsArray
     * @param targetUserId the owner of the tracks being queried
     * @param sort a string of form eg. blocknumber:asc,timestamp:desc describing a sort path
     * @param minBlockNumber The min block number
     * @param filterDeleted If set to true, filters the deleted tracks
     * @returns Array of track metadata Objects
     * additional metadata fields on track objects:
     *  {Integer} repost_count - repost count for given track
     *  {Integer} save_count - save count for given track
     *  {Array} followee_reposts - followees of current user that have reposted given track
     *  {Boolean} has_current_user_reposted - has current user reposted given track
     *  {Boolean} has_current_user_saved - has current user saved given track
     * @example
     * await getTracks()
     * await getTracks(100, 0, [3,2,6]) - Invalid track ids will not be accepted
     */
    getTracksVerbose(limit: number | undefined, offset: number | undefined, idsArray: Nullable<string[]>, targetUserId: Nullable<string>, sort: Nullable<boolean>, minBlockNumber: Nullable<number>, filterDeleted: Nullable<boolean>, withUsers?: boolean): Promise<{
        latest_indexed_block: number;
        latest_chain_block: number;
        latest_indexed_slot_plays: number;
        latest_chain_slot_plays: number;
        data: unknown;
    } | null | undefined>;
    /**
     * Gets a particular track by its creator's handle and the track's URL slug
     * @param handle the handle of the owner of the track
     * @param slug the URL slug of the track, generally the title urlized
     * @returns the requested track's metadata
     */
    getTracksByHandleAndSlug(handle: string, slug: string): Promise<unknown>;
    /**
     * gets all tracks matching identifiers, including unlisted.
     *
     */
    getTracksIncludingUnlisted(identifiers: string[], withUsers?: boolean): Promise<unknown>;
    /**
     * Gets random tracks from trending tracks for a given genre.
     * If genre not given, will return trending tracks across all genres.
     * Excludes specified track ids.
     */
    getRandomTracks(genre: string, limit: number, exclusionList: number[], time: string): Promise<unknown>;
    /**
     * Gets all stems for a given trackId as an array of tracks.
     */
    getStemsForTrack(trackId: number): Promise<unknown>;
    /**
     * Gets all the remixes of a given trackId as an array of tracks.
     */
    getRemixesOfTrack(trackId: number, limit: Nullable<number>, offset: Nullable<number>): Promise<unknown>;
    /**
     * Gets the remix parents of a given trackId as an array of tracks.
     */
    getRemixTrackParents(trackId: number, limit: Nullable<number>, offset: Nullable<number>): Promise<unknown>;
    /**
     * Gets tracks trending on Audius.
     * @param genre
     * @param timeFrame one of day, week, month, or year
     * @param idsArray track ids
     * @param limit
     * @param offset
     */
    getTrendingTracks(genre: Nullable<string>, timeFrame: Nullable<string>, idsArray: Nullable<number[]>, limit: Nullable<number>, offset: Nullable<number>, withUsers?: boolean): Promise<{
        listenCounts: Array<{
            trackId: number;
            listens: number;
        }>;
    } | null | undefined>;
    /**
     * get full playlist objects, including tracks, for passed in array of playlistId
     * @returns array of playlist objects
     * additional metadata fields on playlist objects:
     *  {Integer} repost_count - repost count for given playlist
     *  {Integer} save_count - save count for given playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given playlist
     *  {Array} followee_reposts - followees of current user that have reposted given playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given playlist
     *  {Boolean} has_current_user_saved - has current user saved given playlist
     */
    getPlaylists(limit?: number, offset?: number, idsArray?: Nullable<number[]>, targetUserId?: Nullable<number>, withUsers?: boolean): Promise<CollectionMetadata[] | null | undefined>;
    getFullPlaylist(encodedPlaylistId: string, encodedUserId: string): Promise<unknown>;
    /**
     * Return social feed for current user
     * @param filter - filter by "all", "original", or "repost"
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     * @returns Array of track and playlist metadata objects
     * additional metadata fields on track and playlist objects:
     *  {String} activity_timestamp - timestamp of requested user's repost for given track or playlist,
     *    used for sorting feed
     *  {Integer} repost_count - repost count of given track/playlist
     *  {Integer} save_count - save count of given track/playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given track/playlist
     *  {Array} followee_reposts - followees of current user that have reposted given track/playlist
     */
    getSocialFeed(filter: string, limit?: number, offset?: number, withUsers?: boolean, tracksOnly?: boolean): Promise<unknown>;
    /**
     * Return repost feed for requested user
     * @param userId - requested user id
     * @param limit - max # of items to return (for pagination)
     * @param offset - offset into list to return from (for pagination)
     * @returns Array of track and playlist metadata objects}
     * additional metadata fields on track and playlist objects:
     *  {String} activity_timestamp - timestamp of requested user's repost for given track or playlist,
     *    used for sorting feed
     *  {Integer} repost_count - repost count of given track/playlist
     *  {Integer} save_count - save count of given track/playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given track/playlist
     *  {Array} followee_reposts - followees of current user that have reposted given track/playlist
     */
    getUserRepostFeed(userId: number, limit?: number, offset?: number, withUsers?: boolean): Promise<unknown>;
    /**
     * get intersection of users that follow followeeUserId and users that are followed by followerUserId
     * @param followeeUserId user that is followed
     * @param followerUserId user that follows
     * @example
     * getFollowIntersectionUsers(100, 0, 1, 1) - IDs must be valid
     */
    getFollowIntersectionUsers(limit: number | undefined, offset: number | undefined, followeeUserId: number, followerUserId: number): Promise<unknown>;
    /**
     * get intersection of users that have reposted repostTrackId and users that are followed by followerUserId
     * followee = user that is followed; follower = user that follows
     * @param repostTrackId track that is reposted
     * @param followerUserId user that reposted track
     * @example
     * getTrackRepostIntersectionUsers(100, 0, 1, 1) - IDs must be valid
     */
    getTrackRepostIntersectionUsers(limit: number | undefined, offset: number | undefined, repostTrackId: number, followerUserId: number): Promise<unknown>;
    /**
     * get intersection of users that have reposted repostPlaylistId and users that are followed by followerUserId
     * followee = user that is followed; follower = user that follows
     * @param repostPlaylistId playlist that is reposted
     * @param followerUserId user that reposted track
     * @example
     * getPlaylistRepostIntersectionUsers(100, 0, 1, 1) - IDs must be valid
     */
    getPlaylistRepostIntersectionUsers(limit: number | undefined, offset: number | undefined, repostPlaylistId: number, followerUserId: number): Promise<unknown>;
    /**
     * get users that follow followeeUserId, sorted by follower count descending
     * @param followeeUserId user that is followed
     * @return {Array} array of user objects with standard user metadata
     */
    getFollowersForUser(limit: number | undefined, offset: number | undefined, followeeUserId: string): Promise<unknown>;
    /**
     * get users that are followed by followerUserId, sorted by follower count descending
     * @param followerUserId user - i am the one who follows
     * @return array of user objects with standard user metadata
     */
    getFolloweesForUser(limit: number | undefined, offset: number | undefined, followerUserId: string): Promise<unknown>;
    /**
     * get users that reposted repostTrackId, sorted by follower count descending
     * @param repostTrackId
     * @return array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getRepostersForTrack(100, 0, 1) - ID must be valid
     */
    getRepostersForTrack(limit: number | undefined, offset: number | undefined, repostTrackId: number): Promise<unknown>;
    /**
     * get users that reposted repostPlaylistId, sorted by follower count descending
     * @param repostPlaylistId
     * @return array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getRepostersForPlaylist(100, 0, 1) - ID must be valid
     */
    getRepostersForPlaylist(limit: number | undefined, offset: number | undefined, repostPlaylistId: number): Promise<unknown>;
    /**
     * get users that saved saveTrackId, sorted by follower count descending
     * @param saveTrackId
     * @return array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getSaversForTrack(100, 0, 1) - ID must be valid
     */
    getSaversForTrack(limit: number | undefined, offset: number | undefined, saveTrackId: number): Promise<unknown>;
    /**
     * get users that saved savePlaylistId, sorted by follower count descending
     * @param savePlaylistId
     * @return array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getSaversForPlaylist(100, 0, 1) - ID must be valid
     */
    getSaversForPlaylist(limit: number | undefined, offset: number | undefined, savePlaylistId: number): Promise<unknown>;
    /**
     * get whether a JWT given by Audius Oauth popup is valid
     * @param token - JWT
     * @return profile info of user attached to JWT payload if the JWT is valid, else false
     */
    verifyToken(token: string): Promise<UserProfile | false>;
    /**
     * Perform a full-text search. Returns tracks, users, playlists, albums
     *    with optional user-specific results for each
     *  - user, track, and playlist objects have all same data as returned from standalone endpoints
     * @param text search query
     * @param kind 'tracks', 'users', 'playlists', 'albums', 'all'
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */
    searchFull(text: string, kind: string, limit?: number, offset?: number): Promise<unknown>;
    /**
     * Perform a lighter-weight full-text search. Returns tracks, users, playlists, albums
     *    with optional user-specific results for each
     *  - user, track, and playlist objects have core data, and track & playlist objects
     *    also return user object
     * @param text search query
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */
    searchAutocomplete(text: string, limit?: number, offset?: number): Promise<unknown>;
    /**
     * Perform a tags-only search. Returns tracks with required tag and users
     * that have used a tag greater than a specified number of times
     * @param text search query
     * @param userTagCount min # of times a user must have used a tag to be returned
     * @param kind 'tracks', 'users', 'playlists', 'albums', 'all'
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */
    searchTags(text: string, userTagCount?: number, kind?: string, limit?: number, offset?: number): Promise<unknown>;
    /**
     * Return saved playlists for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */
    getSavedPlaylists(limit?: number, offset?: number, withUsers?: boolean): Promise<unknown>;
    /**
     * Return saved albums for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */
    getSavedAlbums(limit?: number, offset?: number, withUsers?: boolean): Promise<unknown>;
    /**
     * Return saved tracks for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */
    getSavedTracks(limit?: number, offset?: number, withUsers?: boolean): Promise<unknown>;
    /**
     * Return user collections (saved & uploaded) along w/ users for those collections
     */
    getUserAccount(wallet: string): Promise<CurrentUser | null | undefined>;
    /**
     * @deprecated Migrate to using getTrendingPlaylists
     */
    getTopPlaylists(type: 'playlist' | 'album', limit: number, mood: string, filter: string, withUsers?: boolean): Promise<unknown>;
    getTopFullPlaylists({ type, limit, mood, filter, encodedUserId, withUsers }: Requests.GetTopFullPlaylistsParams): Promise<unknown>;
    /**
     * @deprecated Migrate to using getBestNewReleases
     */
    getTopFolloweeWindowed(type: string, window: string, limit: string, withUsers?: boolean): Promise<unknown>;
    getBestNewReleases(encodedUserId: string, window: string, limit: string, withUsers?: boolean): Promise<unknown>;
    /**
     * @deprecated Migrate to using getMostLovedTracks
     */
    getTopFolloweeSaves(type: string, limit: string, withUsers?: boolean): Promise<unknown>;
    getMostLovedTracks(encodedUserId: string, limit: string, withUsers?: boolean): Promise<unknown>;
    getFeelingLuckyTracks(encodedUserId: string, limit: string, withUsers?: boolean): Promise<unknown>;
    getLatest(type: string, limit?: number, offset?: number): Promise<unknown>;
    getTopCreatorsByGenres(genres: string[], limit?: number, offset?: number, withUsers?: boolean): Promise<unknown>;
    getUserNotifications(params: Requests.GetUserNotificationsParams): Promise<unknown>;
    getURSMContentNodes(ownerWallet?: string | null): Promise<unknown>;
    getNotifications(minBlockNumber: string, trackIds: string[], timeout: number): Promise<unknown>;
    /**
     * Retrieves subscribers for a given user.
     * @param params.encodedUserId string of the encoded user id
     * @param params.timeout timeout in ms
     * @returns Array of User metadata objects for each subscriber
     */
    getUserSubscribers(encodedUserId: string, timeout: number): Promise<unknown>;
    /**
     * Retrieves subscribers for the given users.
     * @param params.encodedUserIds JSON stringified array of
     *   encoded user ids
     * @param params.timeout timeout in ms
     * @returns Array of {user_id: <encoded user id>,
     *   subscriber_ids: Array[<encoded subscriber ids>]} objects
     */
    bulkGetUserSubscribers(encodedUserIds: string, timeout: number): Promise<unknown>;
    getCIDData(cid: string, responseType: ResponseType, timeout: number): Promise<unknown>;
    getSolanaNotifications(minSlotNumber: number, timeout: number): Promise<unknown>;
    getTrackListenMilestones(timeout: number): Promise<unknown>;
    getChallengeAttestation(challengeId: string, encodedUserId: string, specifier: string, oracleAddress: string, discoveryProviderEndpoint: string): Promise<{
        owner_wallet: string;
        attestation: string;
    }>;
    getCreateSenderAttestation(senderEthAddress: string, discoveryProviderEndpoint: string): Promise<{
        owner_wallet: string;
        attestation: string;
    }>;
    getUndisbursedChallenges(limit?: number | null, offset?: number | null, completedBlockNumber?: string | null, encodedUserId?: number | null): Promise<{
        amount: number;
        challenge_id: string;
        user_id: string;
        specifier: string;
        handle: string;
        wallet: string;
        completed_blocknumber: number;
    }[]>;
    /**
     * Retrieves listen counts for all tracks of a given artist grouped by month.
     * @param params.encodedUserId string of the encoded user id
     * @param params.startTime start time of query
     * @param params.endTime end time of query
     * @return object containing listen counts for an artist's tracks grouped by month
     */
    getUserListenCountsMonthly(encodedUserId: string, startTime: string, endTime: string): Promise<Object | null | undefined>;
    /**
     * Retrieves the user's replica set
     * @param params.encodedUserId string of the encoded user id
     * @param params.blockNumber optional integer pass to wait until the discovery node has indexed that block number
     * @return object containing the user replica set
     */
    getUserReplicaSet({ encodedUserId, blockNumber }: {
        encodedUserId: string;
        blockNumber?: number;
    }): Promise<Nullable<UserReplicaSet> | undefined>;
    /**
     * Retrieves an unclaimed ID
     * @return encoded ID
     */
    getUnclaimedId(type: 'users' | 'playlists' | 'tracks'): Promise<null | undefined | string>;
    /**
     * Performs a single request, defined in the request, via axios, calling any
     * monitoring callbacks as needed.
     *
     */
    _performRequestWithMonitoring<Response>(requestObj: RequestParams, discoveryProviderEndpoint: string): Promise<Response>;
    /**
     * Gets how many blocks behind a discovery node is.
     * If this method throws (missing data in health check response),
     * return an unhealthy number of blocks
     * @param parsedResponse health check response object
     * @returns a number of blocks if behind or null if not behind
     */
    _getBlocksBehind(parsedResponse: {
        latest_indexed_block: number;
        latest_chain_block: number;
    }): Promise<number | null>;
    /**
     * Gets how many plays slots behind a discovery node is.
     * If this method throws (missing data in health check response),
     * return an unhealthy number of slots
     * @param parsedResponse health check response object
     * @returns a number of slots if behind or null if not behind
     */
    _getPlaysSlotsBehind(parsedResponse: {
        latest_indexed_slot_plays: number;
        latest_chain_slot_plays: number;
    }): Promise<number | null>;
    /**
     * Makes a request to a discovery node, reselecting if necessary
     * @param {{
     *  endpoint: string
     *  urlParams: object
     *  queryParams: object
     *  method: string
     *  headers: object
     *  data: object
     * }} {
     *  endpoint: the base route
     *  urlParams: string of URL params to be concatenated after base route
     *  queryParams: URL query (search) params
     *  method: string HTTP method
     * }
     * @param retry whether to retry on failure
     * @param attemptedRetries number of attempted retries (stops retrying at max)
     * @param throwError whether to throw error on error performing request or null
     * @param blockNumber If provided, throws an error if the discovery node has not yet indexed this block
     */
    _makeRequest<Response>(requestObj: Record<string, unknown>, retry?: boolean, attemptedRetries?: number, throwError?: boolean, blockNumber?: number): Promise<Response | undefined | null>;
    /**
     * Makes a request to a discovery node, reselecting if necessary
     *  endpoint: the base route
     *  urlParams: string of URL params to be concatenated after base route
     *  queryParams: URL query (search) params
     *  method: string HTTP method
     * }
     * @param retry whether to retry on failure
     * @param attemptedRetries number of attempted retries (stops retrying at max)
     * @param throwError whether to throw error on error performing request or null
     * @param blockNumber If provided, throws an error if the discovery node has not yet indexed this block
     */
    _makeRequestInternal<Response>(requestObj: Record<string, unknown>, retry?: boolean, attemptedRetries?: number, throwError?: boolean, blockNumber?: number): Promise<{
        latest_indexed_block: number;
        latest_chain_block: number;
        latest_indexed_slot_plays: number;
        latest_chain_slot_plays: number;
        data: Response;
    } | null | undefined>;
    _makeRequestInternalLegacy<Response>(requestObj: Record<string, unknown>, retry?: boolean, attemptedRetries?: number, throwError?: boolean, blockNumber?: number): Promise<{
        latest_indexed_block: number;
        latest_chain_block: number;
        latest_indexed_slot_plays: number;
        latest_chain_slot_plays: number;
        data: Response;
    } | undefined | null>;
    _makeRequestInternalNext<Response>(requestObj: Record<string, unknown>, throwError?: boolean, blockNumber?: number): Promise<DiscoveryResponse<Response> | null | undefined>;
    /**
     * Gets the healthy discovery provider endpoint used in creating the axios request later.
     * If the number of retries is over the max count for retires, clear the cache and reselect
     * another healthy discovery provider. Else, return the current discovery provider endpoint
     * @param attemptedRetries the number of attempted requests made to the current disc prov endpoint
     */
    getHealthyDiscoveryProviderEndpoint(attemptedRetries: number): Promise<string>;
    /**
     * Creates the discovery provider axios request object with necessary configs
     * @param requestObj
     * @param discoveryProviderEndpoint
     */
    _createDiscProvRequest(requestObj: RequestParams, discoveryProviderEndpoint: string): AxiosRequestConfig;
}
export {};
