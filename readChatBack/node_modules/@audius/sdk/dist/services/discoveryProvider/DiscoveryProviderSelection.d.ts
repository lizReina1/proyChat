import { Decision, ServiceSelection, ServiceSelectionConfig } from '../../service-selection';
import { EthContracts } from '../ethContracts';
import type { AxiosResponse } from 'axios';
import type { Maybe, Nullable } from '../../utils';
import type { LocalStorage } from '../../utils/localStorage';
import type { MonitoringCallbacks } from '../types';
export declare type DiscoveryProviderSelectionConfig = Omit<ServiceSelectionConfig, 'getServices'> & {
    reselectTimeout?: number;
    selectionCallback?: (endpoint: string, decisionTree: Decision[]) => void;
    monitoringCallbacks?: MonitoringCallbacks;
    unhealthySlotDiffPlays?: number;
    unhealthyBlockDiff?: number;
    localStorage?: LocalStorage;
};
export declare class DiscoveryProviderSelection extends ServiceSelection {
    currentVersion: string;
    ethContracts: EthContracts;
    reselectTimeout: Maybe<number>;
    selectionCallback: Maybe<DiscoveryProviderSelectionConfig['selectionCallback']>;
    monitoringCallbacks: NonNullable<DiscoveryProviderSelectionConfig['monitoringCallbacks']> | {};
    unhealthySlotDiffPlays: Nullable<number>;
    unhealthyBlockDiff: number;
    _regressedMode: boolean;
    validVersions: Nullable<string[]>;
    localStorage?: LocalStorage;
    constructor(config: DiscoveryProviderSelectionConfig, ethContracts: Nullable<EthContracts>);
    /** Retrieves a cached discovery provider from localstorage */
    getCached(): Promise<any>;
    /** Clears any cached discovery provider from localstorage */
    clearCached(): Promise<void>;
    /** Sets a cached discovery provider in localstorage */
    setCached(endpoint: string): Promise<void>;
    /** Allows the selection take a shortcut if there's a cached provider */
    shortcircuit(): Promise<any>;
    select(): Promise<any>;
    /**
     * Checks whether a given response is healthy:
     * - Not behind in blocks
     * - 200 response
     * - Current version
     *
     * Other responses are collected in `this.backups` if
     * - Behind by only a patch version
     *
     * @param response axios response
     * @param urlMap health check urls mapped to their cannonical url
     * e.g. https://discoveryprovider.audius.co/health_check => https://discoveryprovider.audius.co
     */
    isHealthy(response: AxiosResponse, urlMap: Record<string, string>): boolean;
    /**
     * Estabilishes that connection to discovery providers has regressed
     */
    enterRegressedMode(): void;
    setUnhealthyBlockDiff(updatedDiff?: number): void;
    setUnhealthySlotDiffPlays(updatedDiff: number): void;
    isInRegressedMode(): boolean;
    /**
     * In the case of no "healthy" services, we resort to backups in the following order:
     * 1. Pick the most recent (patch) version that's not behind
     * 2. Pick the least behind provider that is a valid patch version and enter "regressed mode"
     * 3. Pick `null`
     */
    selectFromBackups(): Promise<string>;
}
