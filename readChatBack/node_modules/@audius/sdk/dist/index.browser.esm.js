import { isBrowser } from 'browser-or-node';
import { z } from 'zod';
import Hashids from 'hashids';
import snakecaseKeys from 'snakecase-keys';
import require$$0$3, { Stream as Stream$2 } from 'stream-browserify';
import require$$0$4 from 'safe-buffer';
import * as fileType$1 from 'file-type';
import retry from 'async-retry';
import { pick, shuffle } from 'lodash';
import * as aes from 'micro-aes-gcm';
import { base64 } from '@scure/base';
import { ulid } from 'ulid';
import * as secp from '@noble/secp256k1';
import WebSocket from 'isomorphic-ws';
import fetch$1, { Headers } from 'cross-fetch';
import semver from 'semver';
import { AbortController } from 'node-abort-controller';
import bs58 from 'bs58';
import axios from 'axios';
import { importer } from 'ipfs-unixfs-importer';
import require$$0$5 from 'bn.js';
import require$$0$6 from 'secp256k1';
import '@ethersproject/solidity';
import { Keypair } from '@solana/web3.js';
import FormData$1 from 'form-data';
import require$$1 from 'elliptic';

function _asyncIterator(iterable) {
  var method,
      async,
      sync,
      retry = 2;

  for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {
    if (async && null != (method = iterable[async])) return method.call(iterable);
    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
    async = "@@asyncIterator", sync = "@@iterator";
  }

  throw new TypeError("Object is not async iterable");
}

function AsyncFromSyncIterator(s) {
  function AsyncFromSyncIteratorContinuation(r) {
    if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
    var done = r.done;
    return Promise.resolve(r.value).then(function (value) {
      return {
        value: value,
        done: done
      };
    });
  }

  return AsyncFromSyncIterator = function (s) {
    this.s = s, this.n = s.next;
  }, AsyncFromSyncIterator.prototype = {
    s: null,
    n: null,
    next: function () {
      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
    },
    return: function (value) {
      var ret = this.s.return;
      return void 0 === ret ? Promise.resolve({
        value: value,
        done: !0
      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
    },
    throw: function (value) {
      var thr = this.s.return;
      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
    }
  }, new AsyncFromSyncIterator(s);
}

function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator$1(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var isOAuthScopeValid = function isOAuthScopeValid(scope) {
  var validScopes = new Set(OAUTH_SCOPE_OPTIONS);
  return scope.findIndex(function (s) {
    return !validScopes.has(s);
  }) === -1;
};

var ParseRequestError = /*#__PURE__*/function (_Error) {
  _inherits(ParseRequestError, _Error);

  var _super = _createSuper(ParseRequestError);

  function ParseRequestError(method, innerError) {
    var _this;

    _classCallCheck$1(this, ParseRequestError);

    _this = _super.call(this, "'".concat(method, "' => ").concat(innerError.message));

    _defineProperty$4(_assertThisInitialized(_this), "method", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "innerError", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "name", 'ParseRequestError');

    _this.method = method;
    _this.innerError = innerError;
    return _this;
  }

  return _createClass$1(ParseRequestError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * @param name Name of the method for which the parameters are being parsed
 * @param schema Zod schema that defines the shape of the request parameters
 * @returns The parsed data or throws an error
 */

var parseParams = function parseParams(name, schema) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
      var result;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return schema.safeParseAsync(params);

            case 2:
              result = _context.sent;

              if (result.success) {
                _context.next = 5;
                break;
              }

              throw new ParseRequestError(name, result.error);

            case 5:
              return _context.abrupt("return", result.data);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

var isApiKeyValid = function isApiKeyValid(apiKey) {
  try {
    if (apiKey.length !== 40) {
      return false;
    }

    var hexadecimalRegex = /^[0-9a-fA-F]+$/;
    return hexadecimalRegex.test(apiKey);
  } catch (_e) {
    return false;
  }
};

var IsWriteAccessGrantedSchema = z.object({
  userId: z.string(),
  apiKey: z.optional(z.custom(function (data) {
    return isApiKeyValid(data);
  }))
});
var OAUTH_SCOPE_OPTIONS = ['read', 'write'];

var CSS = "\n.audiusLoginButton {\n  cursor: pointer;\n  font-family: Helvetica, Arial, sans-serif;\n  text-align: center;\n  color: #FFFFFF;\n  font-weight: 700;\n  font-size: 14px;\n  line-height: 100%;\n  align-items: center;\n  display: flex;\n  border: 0;\n  height: 28px;\n  justify-content: center;\n  padding: 0px 16px;\n  background: #CC0FE0;\n  border-radius: 4px;\n  transition: all 0.07s ease-in-out;\n}\n\n.audiusLoginButton:hover {\n  background: #D127E3;\n  transform: perspective(1px) scale3d(1.04, 1.04, 1.04);\n}\n\n.audiusLoginButton.disableHoverGrow:hover {\n  transform: none;\n}\n\n.audiusLoginButton:active {\n  background: #A30CB3;\n}\n\n.audiusLoginButton.pill {\n  border-radius: 99px;\n}\n\n.audiusLoginButton.fullWidth {\n  width: 100%;\n}\n\n.audiusLoginButton.small {\n  height: 20px;\n  font-size: 11px;\n  padding: 0px 32px;\n}\n\n.audiusLoginButton.large {\n  height: 40px;\n  font-size: 18px;\n  padding: 0px 18px;\n}\n"; // From https://stackoverflow.com/a/27747377

var generateId = function generateId() {
  var arr = new Uint8Array(40 / 2) // Result of function will be 40 chars long
  ;
  (window.crypto || window.msCrypto).getRandomValues(arr);
  return Array.from(arr, function dec2hex(dec) {
    return dec.toString(16).padStart(2, '0');
  }).join('');
};

var generateAudiusLogoSvg = function generateAudiusLogoSvg(size) {
  var height;
  var paddingRight;

  if (size === 'small') {
    height = 16;
    paddingRight = 5;
  } else if (size === 'medium') {
    height = 18;
    paddingRight = 5;
  } else {
    height = 24;
    paddingRight = 10;
  }

  return "<svg width=\"".concat(height, "px\" height=\"").concat(height, "px\" viewBox=\"0 0 56 48\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"padding-right: ").concat(paddingRight, "px;\">\n<g id=\"Assets\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n    <g id=\"assets\" transform=\"translate(-1555.000000, -2588.000000)\">\n        <g id=\"audiusLogoGlyph\" transform=\"translate(1555.000000, 2588.000000)\">\n            <path d=\"M55.8191698,46.0362519 L42.4551012,23.3458831 L36.1870263,12.7036635 L29.0910326,0.65551431 C28.5766233,-0.217848954 27.2890668,-0.218676884 26.7734944,0.654065432 L13.3787621,23.3270477 L7.90582764,32.5909699 C7.39025522,33.4637122 8.03324043,34.5553386 9.06332791,34.5560631 L19.4031138,34.56279 C19.881044,34.5631005 20.3230236,34.3136864 20.5623059,33.9087249 L25.9362708,24.8122516 L26.7580568,23.4212248 C26.790518,23.3662709 26.8260456,23.3149392 26.8641108,23.2669192 C27.4325516,22.5520012 28.5935412,22.6041608 29.0755951,23.4226737 L34.6514114,32.8894388 L35.682239,34.6396841 C35.7412402,34.7399672 35.7843808,34.8430445 35.813987,34.9470533 C36.0430129,35.7492145 35.4339691,36.6039494 34.5220954,36.6034319 L22.3586676,36.5954631 C21.8806317,36.5951526 21.4387578,36.8445667 21.1994756,37.2496317 L16.0236614,46.0105861 C15.5080889,46.8833284 16.1510741,47.9749548 17.1810559,47.9756793 L27.9002253,47.9827167 L41.2664086,47.9913065 L54.6590261,47.9999997 C55.6892193,48.0006207 56.3335791,46.9096152 55.8191698,46.0362519\" id=\"Audius-Logo\" fill=\"#ffffff\" fill-rule=\"evenodd\"></path>\n            <rect id=\"bound\" x=\"0\" y=\"0\" width=\"56\" height=\"48\"></rect>\n        </g>\n    </g>\n</g>\n</svg>");
};

var CSRF_TOKEN_KEY = 'audiusOauthState';
var OAUTH_URL = {
  production: 'https://audius.co/oauth/auth',
  staging: 'https://staging.audius.co/oauth/auth'
};
var OAuth = /*#__PURE__*/function () {
  function OAuth(config) {
    var _config$apiKey;

    _classCallCheck$1(this, OAuth);

    _defineProperty$4(this, "config", void 0);

    _defineProperty$4(this, "activePopupWindow", void 0);

    _defineProperty$4(this, "popupCheckInterval", void 0);

    _defineProperty$4(this, "loginSuccessCallback", void 0);

    _defineProperty$4(this, "loginErrorCallback", void 0);

    _defineProperty$4(this, "apiKey", void 0);

    _defineProperty$4(this, "env", 'production');

    _defineProperty$4(this, "logger", void 0);

    this.config = config;

    if (typeof window === 'undefined') {
      throw new Error('Audius OAuth SDK functions are only available in browser. Refer to our documentation to learn how to implement Audius OAuth manually: https://docs.audius.org/developers/log-in-with-audius#manual-implementation.');
    }

    this.apiKey = (_config$apiKey = config.apiKey) !== null && _config$apiKey !== void 0 ? _config$apiKey : null;
    this.activePopupWindow = null;
    this.loginSuccessCallback = null;
    this.loginErrorCallback = null;
    this.popupCheckInterval = null;
    this.logger = config.logger.createPrefixedLogger('[oauth]');
  }

  _createClass$1(OAuth, [{
    key: "init",
    value: function init(_ref) {
      var _this = this;

      var successCallback = _ref.successCallback,
          errorCallback = _ref.errorCallback,
          _ref$env = _ref.env,
          env = _ref$env === void 0 ? 'production' : _ref$env;
      this.loginSuccessCallback = successCallback;
      this.loginErrorCallback = errorCallback !== null && errorCallback !== void 0 ? errorCallback : null;
      this.env = env;
      window.addEventListener('message', function (e) {
        _this._receiveMessage(e);
      }, false);
    }
  }, {
    key: "isWriteAccessGranted",
    value: function () {
      var _isWriteAccessGranted = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var _authorizedApps$data,
            _this2 = this;

        var _yield$parseParams, userId, apiKey, authorizedApps, foundIndex;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return parseParams('isWriteAccessGranted', IsWriteAccessGrantedSchema)(params);

              case 2:
                _yield$parseParams = _context.sent;
                userId = _yield$parseParams.userId;
                apiKey = _yield$parseParams.apiKey;

                if (!this.apiKey && !apiKey) {
                  this._surfaceError('Need to init Audius SDK with API key or pass in API Key directly to oauth.isWriteAccessGranted.');
                }

                _context.next = 8;
                return this.config.usersApi.getAuthorizedApps({
                  id: userId
                });

              case 8:
                authorizedApps = _context.sent;
                foundIndex = (_authorizedApps$data = authorizedApps.data) === null || _authorizedApps$data === void 0 ? void 0 : _authorizedApps$data.findIndex(function (a) {
                  return a.address.toLowerCase() === "0x".concat((apiKey || _this2.apiKey).toLowerCase());
                });
                return _context.abrupt("return", foundIndex !== undefined && foundIndex > -1);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function isWriteAccessGranted(_x) {
        return _isWriteAccessGranted.apply(this, arguments);
      }

      return isWriteAccessGranted;
    }()
  }, {
    key: "login",
    value: function login(_ref2) {
      var _this3 = this;

      var _ref2$scope = _ref2.scope,
          scope = _ref2$scope === void 0 ? 'read' : _ref2$scope;
      var scopeFormatted = typeof scope === 'string' ? [scope] : scope;

      if (!this.config.appName && !this.apiKey) {
        this._surfaceError('App name not set (set with `init` method).');

        return;
      }

      if (scope.includes('write') && !this.apiKey) {
        this._surfaceError("The 'write' scope requires Audius SDK to be initialized with an API key");
      }

      if (!this.loginSuccessCallback) {
        this._surfaceError('Login success callback not set (set with `init` method).');

        return;
      }

      if (!isOAuthScopeValid(scopeFormatted)) {
        this._surfaceError('Scope must be `read` or `write`.');

        return;
      }

      var csrfToken = generateId();
      window.localStorage.setItem(CSRF_TOKEN_KEY, csrfToken);
      var windowOptions = 'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=375, height=720, top=100, left=100';
      var originURISafe = encodeURIComponent(window.location.origin);
      var appIdURISafe = encodeURIComponent(this.apiKey || this.config.appName);
      var appIdURIParam = "".concat(this.apiKey ? 'api_key' : 'app_name', "=").concat(appIdURISafe);
      var scopeUriParam = scope.includes('write') ? 'write' : 'read';
      var fullOauthUrl = "".concat(OAUTH_URL[this.env], "?scope=").concat(scopeUriParam, "&state=").concat(csrfToken, "&redirect_uri=postMessage&origin=").concat(originURISafe, "&").concat(appIdURIParam);
      this.activePopupWindow = window.open(fullOauthUrl, '', windowOptions);

      this._clearPopupCheckInterval();

      this.popupCheckInterval = setInterval(function () {
        var _this3$activePopupWin;

        if ((_this3$activePopupWin = _this3.activePopupWindow) !== null && _this3$activePopupWin !== void 0 && _this3$activePopupWin.closed) {
          _this3._surfaceError('The login popup was closed prematurely.');

          if (_this3.popupCheckInterval) {
            clearInterval(_this3.popupCheckInterval);
          }
        }
      }, 500);
    }
  }, {
    key: "renderButton",
    value: function renderButton(_ref3) {
      var _buttonOptions$size,
          _buttonOptions$custom,
          _this4 = this;

      var element = _ref3.element,
          _ref3$scope = _ref3.scope,
          scope = _ref3$scope === void 0 ? 'read' : _ref3$scope,
          buttonOptions = _ref3.buttonOptions;

      if (!element) {
        this.logger.error('Target element for Audius OAuth button is empty.');
      }

      var style = document.createElement('style');
      style.textContent = CSS;
      document.head.appendChild(style);
      var button = document.createElement('button');
      button.id = 'audius-login-button';
      button.classList.add('audiusLoginButton');

      if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.corners) === 'pill') {
        button.classList.add('pill');
      }

      if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) === 'small') {
        button.classList.add('small');
      }

      if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) === 'large') {
        button.classList.add('large');
      }

      if (buttonOptions !== null && buttonOptions !== void 0 && buttonOptions.fullWidth) {
        button.classList.add('fullWidth');
      }

      if (buttonOptions !== null && buttonOptions !== void 0 && buttonOptions.disableHoverGrow) {
        button.classList.add('disableHoverGrow');
      }

      button.innerHTML = "".concat(generateAudiusLogoSvg((_buttonOptions$size = buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) !== null && _buttonOptions$size !== void 0 ? _buttonOptions$size : 'medium'), " ").concat((_buttonOptions$custom = buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.customText) !== null && _buttonOptions$custom !== void 0 ? _buttonOptions$custom : 'Continue With Audius');

      button.onclick = function () {
        _this4.login({
          scope: scope
        });
      };

      element.replaceWith(button);
    }
    /**
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     * @deprecated see `UsersApi.verifyIDToken`
     * @param token the token to verify
     * @returns
     */

  }, {
    key: "verifyToken",
    value: function () {
      var _verifyToken = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(token) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.config.usersApi.verifyIDToken({
                  token: token
                });

              case 2:
                return _context2.abrupt("return", _context2.sent);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function verifyToken(_x2) {
        return _verifyToken.apply(this, arguments);
      }

      return verifyToken;
    }()
    /* ------- INTERNAL FUNCTIONS ------- */

  }, {
    key: "_surfaceError",
    value: function _surfaceError(errorMessage) {
      if (this.loginErrorCallback) {
        this.loginErrorCallback(errorMessage);
      } else {
        this.logger.error(errorMessage);
      }
    }
  }, {
    key: "_clearPopupCheckInterval",
    value: function _clearPopupCheckInterval() {
      if (this.popupCheckInterval) {
        clearInterval(this.popupCheckInterval);
      }
    }
  }, {
    key: "_receiveMessage",
    value: function () {
      var _receiveMessage2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(event) {
        var oauthOrigin, decodedJwt;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                oauthOrigin = new URL(OAUTH_URL[this.env]).origin;

                if (!(event.origin !== oauthOrigin || event.source !== this.activePopupWindow || !event.data.state || !event.data.token)) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt("return");

              case 3:
                this._clearPopupCheckInterval();

                if (this.activePopupWindow) {
                  if (!this.activePopupWindow.closed) {
                    this.activePopupWindow.close();
                  }

                  this.activePopupWindow = null;
                }

                if (window.localStorage.getItem(CSRF_TOKEN_KEY) !== event.data.state) {
                  this._surfaceError('State mismatch.');
                } // Verify token and decode


                _context3.next = 8;
                return this.verifyToken(event.data.token);

              case 8:
                decodedJwt = _context3.sent;

                if (decodedJwt !== null && decodedJwt !== void 0 && decodedJwt.data) {
                  if (this.loginSuccessCallback) {
                    this.loginSuccessCallback(decodedJwt.data);
                  }
                } else {
                  this._surfaceError('The token was invalid.');
                }

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _receiveMessage(_x3) {
        return _receiveMessage2.apply(this, arguments);
      }

      return _receiveMessage;
    }()
  }]);

  return OAuth;
}();

var Action;

(function (Action) {
  Action["CREATE"] = "Create";
  Action["UPDATE"] = "Update";
  Action["DELETE"] = "Delete";
  Action["VERIFY"] = "Verify";
  Action["FOLLOW"] = "Follow";
  Action["UNFOLLOW"] = "Unfollow";
  Action["SAVE"] = "Save";
  Action["UNSAVE"] = "Unsave";
  Action["REPOST"] = "Repost";
  Action["UNREPOST"] = "Unrepost";
  Action["SUBSCRIBE"] = "Subscribe";
  Action["UNSUBSCRIBE"] = "Unsubscribe";
  Action["VIEW"] = "View";
  Action["VIEW_PLAYLIST"] = "ViewPlaylist";
})(Action || (Action = {}));

var EntityType;

(function (EntityType) {
  EntityType["PLAYLIST"] = "Playlist";
  EntityType["TRACK"] = "Track";
  EntityType["USER"] = "User";
  EntityType["USER_REPLICA_SET"] = "UserReplicaSet";
  EntityType["NOTIFICATION"] = "Notification";
  EntityType["DEVELOPER_APP"] = "DeveloperApp";
  EntityType["GRANT"] = "Grant";
})(EntityType || (EntityType = {}));

var BlockConfirmation;

(function (BlockConfirmation) {
  BlockConfirmation["CONFIRMED"] = "CONFIRMED";
  BlockConfirmation["DENIED"] = "DENIED";
  BlockConfirmation["UNKNOWN"] = "UNKNOWN";
})(BlockConfirmation || (BlockConfirmation = {}));

var HASH_SALT$1 = 'azowernasdfoia';
var MIN_LENGTH$1 = 5;
var hashids$1 = new Hashids(HASH_SALT$1, MIN_LENGTH$1);
/**
 * Decodes a string id into an int. Returns null if an invalid ID.
 */

var decodeHashId = function decodeHashId(id) {
  try {
    var ids = hashids$1.decode(id);
    if (!ids.length) return null;
    var num = Number(ids[0]);
    if (isNaN(num)) return null;
    return num;
  } catch (e) {
    return null;
  }
};
/**
 * Encodes an int to a string based hashid
 */

var encodeHashId = function encodeHashId(id) {
  try {
    if (id === null) return null;
    var encodedId = hashids$1.encode(id);
    return encodedId;
  } catch (e) {
    return null;
  }
};

var HashId = z.string().transform(function (data, context) {
  var id = decodeHashId(data);

  if (id === null) {
    context.addIssue({
      code: z.ZodIssueCode.custom,
      message: 'Hash id is invalid'
    });
    return z.NEVER;
  }

  return id;
});

var CreateGrantSchema = z.object({
  userId: HashId,
  appApiKey: z.custom(function (data) {
    return isApiKeyValid(data);
  })
});
var RevokeGrantSchema = z.object({
  userId: HashId,
  appApiKey: z.custom(function (data) {
    return isApiKeyValid(data);
  })
});

var GrantsApi = /*#__PURE__*/function () {
  function GrantsApi(_config, entityManager, auth) {
    _classCallCheck$1(this, GrantsApi);

    _defineProperty$4(this, "entityManager", void 0);

    _defineProperty$4(this, "auth", void 0);

    this.entityManager = entityManager;
    this.auth = auth;
  }
  /**
   * When user authorizes app to perform actions on their behalf
   */


  _createClass$1(GrantsApi, [{
    key: "createGrant",
    value: function () {
      var _createGrant = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var _yield$parseParams, userId, appApiKey;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return parseParams('createGrant', CreateGrantSchema)(params);

              case 2:
                _yield$parseParams = _context.sent;
                userId = _yield$parseParams.userId;
                appApiKey = _yield$parseParams.appApiKey;
                _context.next = 7;
                return this.entityManager.manageEntity({
                  userId: userId,
                  entityType: EntityType.GRANT,
                  entityId: 0,
                  action: Action.CREATE,
                  metadata: JSON.stringify({
                    grantee_address: "0x".concat(appApiKey)
                  }),
                  auth: this.auth
                });

              case 7:
                return _context.abrupt("return", _context.sent);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function createGrant(_x) {
        return _createGrant.apply(this, arguments);
      }

      return createGrant;
    }()
    /**
     * When user revokes an app's authorization to perform actions on their behalf
     */

  }, {
    key: "revokeGrant",
    value: function () {
      var _revokeGrant = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        var _yield$parseParams2, userId, appApiKey;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return parseParams('revokeGrant', RevokeGrantSchema)(params);

              case 2:
                _yield$parseParams2 = _context2.sent;
                userId = _yield$parseParams2.userId;
                appApiKey = _yield$parseParams2.appApiKey;
                _context2.next = 7;
                return this.entityManager.manageEntity({
                  userId: userId,
                  entityType: EntityType.GRANT,
                  entityId: 0,
                  action: Action.DELETE,
                  metadata: JSON.stringify({
                    grantee_address: "0x".concat(appApiKey)
                  }),
                  auth: this.auth
                });

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function revokeGrant(_x2) {
        return _revokeGrant.apply(this, arguments);
      }

      return revokeGrant;
    }()
  }]);

  return GrantsApi;
}();

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function commonjsRequire (path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var _rollup_plugin_ignore_empty_module_placeholder = {};

var _rollup_plugin_ignore_empty_module_placeholder$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': _rollup_plugin_ignore_empty_module_placeholder
});

var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(_rollup_plugin_ignore_empty_module_placeholder$1);

var web3;

if (typeof window !== 'undefined' && window && window.Web3) {
  web3 = window.Web3;
} else {
  web3 = require$$0$2;
}

var Web3$1 = web3;

/* tslint:disable */

/* eslint-disable */

/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var BASE_PATH$1 = "/v1".replace(/\/+$/, "");
var Configuration$1 = /*#__PURE__*/function () {
  function Configuration() {
    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck$1(this, Configuration);

    _defineProperty$4(this, "configuration", void 0);

    this.configuration = configuration;
  }

  _createClass$1(Configuration, [{
    key: "config",
    set: function set(configuration) {
      this.configuration = configuration;
    }
  }, {
    key: "basePath",
    get: function get() {
      return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH$1;
    }
  }, {
    key: "fetchApi",
    get: function get() {
      return this.configuration.fetchApi;
    }
  }, {
    key: "middleware",
    get: function get() {
      return this.configuration.middleware || [];
    }
  }, {
    key: "queryParamsStringify",
    get: function get() {
      return this.configuration.queryParamsStringify || querystring$1;
    }
  }, {
    key: "username",
    get: function get() {
      return this.configuration.username;
    }
  }, {
    key: "password",
    get: function get() {
      return this.configuration.password;
    }
  }, {
    key: "apiKey",
    get: function get() {
      var apiKey = this.configuration.apiKey;

      if (apiKey) {
        return typeof apiKey === 'function' ? apiKey : function () {
          return apiKey;
        };
      }

      return undefined;
    }
  }, {
    key: "accessToken",
    get: function get() {
      var accessToken = this.configuration.accessToken;

      if (accessToken) {
        return typeof accessToken === 'function' ? accessToken : /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", accessToken);

                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
      }

      return undefined;
    }
  }, {
    key: "headers",
    get: function get() {
      return this.configuration.headers;
    }
  }, {
    key: "credentials",
    get: function get() {
      return this.configuration.credentials;
    }
  }]);

  return Configuration;
}();
var DefaultConfig$1 = new Configuration$1();
/**
 * This is the base class for all generated API classes.
 */

var BaseAPI$1 = /*#__PURE__*/function () {
  function BaseAPI() {
    var _this = this;

    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultConfig$1;

    _classCallCheck$1(this, BaseAPI);

    _defineProperty$4(this, "configuration", void 0);

    _defineProperty$4(this, "middleware", void 0);

    _defineProperty$4(this, "fetchApi", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url, init) {
        var fetchParams, _iterator, _step, _middleware, response, _iterator2, _step2, middleware, _iterator3, _step3, _middleware2;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                fetchParams = {
                  url: url,
                  init: init
                };
                _iterator = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 2;

                _iterator.s();

              case 4:
                if ((_step = _iterator.n()).done) {
                  _context2.next = 15;
                  break;
                }

                _middleware = _step.value;

                if (!_middleware.pre) {
                  _context2.next = 13;
                  break;
                }

                _context2.next = 9;
                return _middleware.pre(_objectSpread2({
                  fetch: _this.fetchApi
                }, fetchParams));

              case 9:
                _context2.t0 = _context2.sent;

                if (_context2.t0) {
                  _context2.next = 12;
                  break;
                }

                _context2.t0 = fetchParams;

              case 12:
                fetchParams = _context2.t0;

              case 13:
                _context2.next = 4;
                break;

              case 15:
                _context2.next = 20;
                break;

              case 17:
                _context2.prev = 17;
                _context2.t1 = _context2["catch"](2);

                _iterator.e(_context2.t1);

              case 20:
                _context2.prev = 20;

                _iterator.f();

                return _context2.finish(20);

              case 23:
                response = undefined;
                _context2.prev = 24;
                _context2.next = 27;
                return (_this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);

              case 27:
                response = _context2.sent;
                _context2.next = 60;
                break;

              case 30:
                _context2.prev = 30;
                _context2.t2 = _context2["catch"](24);
                _iterator2 = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 33;

                _iterator2.s();

              case 35:
                if ((_step2 = _iterator2.n()).done) {
                  _context2.next = 46;
                  break;
                }

                middleware = _step2.value;

                if (!middleware.onError) {
                  _context2.next = 44;
                  break;
                }

                _context2.next = 40;
                return middleware.onError({
                  fetch: _this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  error: _context2.t2,
                  response: response ? response.clone() : undefined
                });

              case 40:
                _context2.t3 = _context2.sent;

                if (_context2.t3) {
                  _context2.next = 43;
                  break;
                }

                _context2.t3 = response;

              case 43:
                response = _context2.t3;

              case 44:
                _context2.next = 35;
                break;

              case 46:
                _context2.next = 51;
                break;

              case 48:
                _context2.prev = 48;
                _context2.t4 = _context2["catch"](33);

                _iterator2.e(_context2.t4);

              case 51:
                _context2.prev = 51;

                _iterator2.f();

                return _context2.finish(51);

              case 54:
                if (!(response === undefined)) {
                  _context2.next = 60;
                  break;
                }

                if (!(_context2.t2 instanceof Error)) {
                  _context2.next = 59;
                  break;
                }

                throw new FetchError$1(_context2.t2, 'The request failed and the interceptors did not return an alternative response');

              case 59:
                throw _context2.t2;

              case 60:
                _iterator3 = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 61;

                _iterator3.s();

              case 63:
                if ((_step3 = _iterator3.n()).done) {
                  _context2.next = 74;
                  break;
                }

                _middleware2 = _step3.value;

                if (!_middleware2.post) {
                  _context2.next = 72;
                  break;
                }

                _context2.next = 68;
                return _middleware2.post({
                  fetch: _this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  response: response.clone()
                });

              case 68:
                _context2.t5 = _context2.sent;

                if (_context2.t5) {
                  _context2.next = 71;
                  break;
                }

                _context2.t5 = response;

              case 71:
                response = _context2.t5;

              case 72:
                _context2.next = 63;
                break;

              case 74:
                _context2.next = 79;
                break;

              case 76:
                _context2.prev = 76;
                _context2.t6 = _context2["catch"](61);

                _iterator3.e(_context2.t6);

              case 79:
                _context2.prev = 79;

                _iterator3.f();

                return _context2.finish(79);

              case 82:
                return _context2.abrupt("return", response);

              case 83:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[2, 17, 20, 23], [24, 30], [33, 48, 51, 54], [61, 76, 79, 82]]);
      }));

      return function (_x, _x2) {
        return _ref2.apply(this, arguments);
      };
    }());

    this.configuration = configuration;
    this.middleware = configuration.middleware;
  }
  /** @hidden */


  _createClass$1(BaseAPI, [{
    key: "withMiddleware",
    value: function withMiddleware() {
      var _next$middleware;

      var next = this.clone();
      next.middleware = (_next$middleware = next.middleware).concat.apply(_next$middleware, arguments);
      return next;
    }
    /** @hidden */

  }, {
    key: "withPreMiddleware",
    value: function withPreMiddleware() {
      for (var _len = arguments.length, preMiddlewares = new Array(_len), _key = 0; _key < _len; _key++) {
        preMiddlewares[_key] = arguments[_key];
      }

      var middlewares = preMiddlewares.map(function (pre) {
        return {
          pre: pre
        };
      });
      return this.withMiddleware.apply(this, _toConsumableArray(middlewares));
    }
    /** @hidden */

  }, {
    key: "withPostMiddleware",
    value: function withPostMiddleware() {
      for (var _len2 = arguments.length, postMiddlewares = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        postMiddlewares[_key2] = arguments[_key2];
      }

      var middlewares = postMiddlewares.map(function (post) {
        return {
          post: post
        };
      });
      return this.withMiddleware.apply(this, _toConsumableArray(middlewares));
    }
    /** @hidden */

  }, {
    key: "request",
    value: function () {
      var _request = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(context, initOverrides) {
        var _yield$this$createFet, url, init, response;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.createFetchParams(context, initOverrides);

              case 2:
                _yield$this$createFet = _context3.sent;
                url = _yield$this$createFet.url;
                init = _yield$this$createFet.init;
                _context3.next = 7;
                return this.fetchApi(url, init);

              case 7:
                response = _context3.sent;

                if (!(response && response.status >= 200 && response.status < 300)) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt("return", response);

              case 10:
                throw new ResponseError$1(response, 'Response returned an error code');

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function request(_x3, _x4) {
        return _request.apply(this, arguments);
      }

      return request;
    }()
  }, {
    key: "createFetchParams",
    value: function () {
      var _createFetchParams = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(context, initOverrides) {
        var url, headers, initOverrideFn, initParams, overriddenInit, init;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                url = this.configuration.basePath + context.path;

                if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                  // only add the querystring to the URL if there are query parameters.
                  // this is done to avoid urls ending with a "?" character which buggy webservers
                  // do not handle correctly sometimes.
                  url += '?' + this.configuration.queryParamsStringify(context.query);
                }

                headers = Object.assign({}, this.configuration.headers, context.headers);
                Object.keys(headers).forEach(function (key) {
                  return headers[key] === undefined ? delete headers[key] : {};
                });
                initOverrideFn = typeof initOverrides === "function" ? initOverrides : /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                  return regeneratorRuntime.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          return _context4.abrupt("return", initOverrides);

                        case 1:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                }));
                initParams = {
                  method: context.method,
                  headers: headers,
                  body: context.body,
                  credentials: this.configuration.credentials
                };
                _context5.t0 = _objectSpread2;
                _context5.t1 = _objectSpread2({}, initParams);
                _context5.next = 10;
                return initOverrideFn({
                  init: initParams,
                  context: context
                });

              case 10:
                _context5.t2 = _context5.sent;
                overriddenInit = (0, _context5.t0)(_context5.t1, _context5.t2);
                init = _objectSpread2(_objectSpread2({}, overriddenInit), {}, {
                  body: isFormData$1(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob$1(overriddenInit.body) || isString$1(overriddenInit.body) ? overriddenInit.body : JSON.stringify(overriddenInit.body)
                });
                return _context5.abrupt("return", {
                  url: url,
                  init: init
                });

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function createFetchParams(_x5, _x6) {
        return _createFetchParams.apply(this, arguments);
      }

      return createFetchParams;
    }()
  }, {
    key: "clone",
    value:
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    function clone() {
      var constructor = this.constructor;
      var next = new constructor(this.configuration);
      next.middleware = this.middleware.slice();
      return next;
    }
  }]);

  return BaseAPI;
}();

function isBlob$1(value) {
  return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData$1(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}

function isString$1(value) {
  return typeof value === 'string';
}

var ResponseError$1 = /*#__PURE__*/function (_Error) {
  _inherits(ResponseError, _Error);

  var _super = _createSuper(ResponseError);

  function ResponseError(response, msg) {
    var _this2;

    _classCallCheck$1(this, ResponseError);

    _this2 = _super.call(this, msg);

    _defineProperty$4(_assertThisInitialized(_this2), "response", void 0);

    _defineProperty$4(_assertThisInitialized(_this2), "name", "ResponseError");

    _this2.response = response;
    return _this2;
  }

  return _createClass$1(ResponseError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var FetchError$1 = /*#__PURE__*/function (_Error2) {
  _inherits(FetchError, _Error2);

  var _super2 = _createSuper(FetchError);

  function FetchError(cause, msg) {
    var _this3;

    _classCallCheck$1(this, FetchError);

    _this3 = _super2.call(this, msg);

    _defineProperty$4(_assertThisInitialized(_this3), "cause", void 0);

    _defineProperty$4(_assertThisInitialized(_this3), "name", "FetchError");

    _this3.cause = cause;
    return _this3;
  }

  return _createClass$1(FetchError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var RequiredError$1 = /*#__PURE__*/function (_Error3) {
  _inherits(RequiredError, _Error3);

  var _super3 = _createSuper(RequiredError);

  function RequiredError(field, msg) {
    var _this4;

    _classCallCheck$1(this, RequiredError);

    _this4 = _super3.call(this, msg);

    _defineProperty$4(_assertThisInitialized(_this4), "field", void 0);

    _defineProperty$4(_assertThisInitialized(_this4), "name", "RequiredError");

    _this4.field = field;
    return _this4;
  }

  return _createClass$1(RequiredError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var COLLECTION_FORMATS$1 = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|"
};
function exists$1(json, key) {
  var value = json[key];
  return value !== null && value !== undefined;
}
function querystring$1(params) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return Object.keys(params).sort().map(function (key) {
    return querystringSingleKey$1(key, params[key], prefix);
  }).filter(function (part) {
    return part.length > 0;
  }).join('&');
}

function querystringSingleKey$1(key, value) {
  var keyPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);

  if (value instanceof Array) {
    var multiValue = value.map(function (singleValue) {
      return encodeURIComponent(String(singleValue));
    }).join("&".concat(encodeURIComponent(fullKey), "="));
    return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
  }

  if (value instanceof Set) {
    var valueAsArray = Array.from(value);
    return querystringSingleKey$1(key, valueAsArray, keyPrefix);
  }

  if (value instanceof Date) {
    return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
  }

  if (value instanceof Object) {
    return querystring$1(value, fullKey);
  }

  return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
}

function mapValues$1(data, fn) {
  return Object.keys(data).reduce(function (acc, key) {
    return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty$4({}, key, fn(data[key])));
  }, {});
}
function canConsumeForm$1(consumes) {
  var _iterator4 = _createForOfIteratorHelper(consumes),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var consume = _step4.value;

      if ('multipart/form-data' === consume.contentType) {
        return true;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return false;
}
var JSONApiResponse$1 = /*#__PURE__*/function () {
  function JSONApiResponse(raw) {
    var transformer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (jsonValue) {
      return jsonValue;
    };

    _classCallCheck$1(this, JSONApiResponse);

    _defineProperty$4(this, "raw", void 0);

    _defineProperty$4(this, "transformer", void 0);

    this.raw = raw;
    this.transformer = transformer;
  }

  _createClass$1(JSONApiResponse, [{
    key: "value",
    value: function () {
      var _value = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.t0 = this;
                _context6.next = 3;
                return this.raw.json();

              case 3:
                _context6.t1 = _context6.sent;
                return _context6.abrupt("return", _context6.t0.transformer.call(_context6.t0, _context6.t1));

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function value() {
        return _value.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return JSONApiResponse;
}();
var VoidApiResponse$1 = /*#__PURE__*/function () {
  function VoidApiResponse(raw) {
    _classCallCheck$1(this, VoidApiResponse);

    _defineProperty$4(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass$1(VoidApiResponse, [{
    key: "value",
    value: function () {
      var _value2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", undefined);

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function value() {
        return _value2.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return VoidApiResponse;
}();
var BlobApiResponse$1 = /*#__PURE__*/function () {
  function BlobApiResponse(raw) {
    _classCallCheck$1(this, BlobApiResponse);

    _defineProperty$4(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass$1(BlobApiResponse, [{
    key: "value",
    value: function () {
      var _value3 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.raw.blob();

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function value() {
        return _value3.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return BlobApiResponse;
}();
var TextApiResponse$1 = /*#__PURE__*/function () {
  function TextApiResponse(raw) {
    _classCallCheck$1(this, TextApiResponse);

    _defineProperty$4(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass$1(TextApiResponse, [{
    key: "value",
    value: function () {
      var _value4 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.raw.text();

              case 2:
                return _context9.abrupt("return", _context9.sent);

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function value() {
        return _value4.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return TextApiResponse;
}();

/* tslint:disable */
/**
 * Check if a given object implements the Activity interface.
 */

function instanceOfActivity(value) {
  var isInstance = true;
  return isInstance;
}
function ActivityFromJSON(json) {
  return ActivityFromJSONTyped(json);
}
function ActivityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'timestamp': !exists$1(json, 'timestamp') ? undefined : json['timestamp'],
    'itemType': !exists$1(json, 'item_type') ? undefined : json['item_type'],
    'item': !exists$1(json, 'item') ? undefined : json['item']
  };
}
function ActivityToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': value.item
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AuthorizedApp interface.
 */

function instanceOfAuthorizedApp(value) {
  var isInstance = true;
  isInstance = isInstance && "address" in value;
  isInstance = isInstance && "name" in value;
  isInstance = isInstance && "grantorUserId" in value;
  isInstance = isInstance && "grantCreatedAt" in value;
  isInstance = isInstance && "grantUpdatedAt" in value;
  return isInstance;
}
function AuthorizedAppFromJSON(json) {
  return AuthorizedAppFromJSONTyped(json);
}
function AuthorizedAppFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'address': json['address'],
    'name': json['name'],
    'description': !exists$1(json, 'description') ? undefined : json['description'],
    'grantorUserId': json['grantor_user_id'],
    'grantCreatedAt': json['grant_created_at'],
    'grantUpdatedAt': json['grant_updated_at']
  };
}
function AuthorizedAppToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'address': value.address,
    'name': value.name,
    'description': value.description,
    'grantor_user_id': value.grantorUserId,
    'grant_created_at': value.grantCreatedAt,
    'grant_updated_at': value.grantUpdatedAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AuthorizedApps interface.
 */

function instanceOfAuthorizedApps(value) {
  var isInstance = true;
  return isInstance;
}
function AuthorizedAppsFromJSON(json) {
  return AuthorizedAppsFromJSONTyped(json);
}
function AuthorizedAppsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(AuthorizedAppFromJSON)
  };
}
function AuthorizedAppsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(AuthorizedAppToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ConnectedWallets interface.
 */

function instanceOfConnectedWallets(value) {
  var isInstance = true;
  isInstance = isInstance && "ercWallets" in value;
  isInstance = isInstance && "splWallets" in value;
  return isInstance;
}
function ConnectedWalletsFromJSON(json) {
  return ConnectedWalletsFromJSONTyped(json);
}
function ConnectedWalletsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'ercWallets': json['erc_wallets'],
    'splWallets': json['spl_wallets']
  };
}
function ConnectedWalletsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'erc_wallets': value.ercWallets,
    'spl_wallets': value.splWallets
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ConnectedWalletsResponse interface.
 */

function instanceOfConnectedWalletsResponse(value) {
  var isInstance = true;
  return isInstance;
}
function ConnectedWalletsResponseFromJSON(json) {
  return ConnectedWalletsResponseFromJSONTyped(json);
}
function ConnectedWalletsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : ConnectedWalletsFromJSON(json['data'])
  };
}
function ConnectedWalletsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': ConnectedWalletsToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoverPhoto interface.
 */

function instanceOfCoverPhoto$1(value) {
  var isInstance = true;
  return isInstance;
}
function CoverPhotoFromJSON$1(json) {
  return CoverPhotoFromJSONTyped$1(json);
}
function CoverPhotoFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_640x': !exists$1(json, '640x') ? undefined : json['640x'],
    '_2000x': !exists$1(json, '2000x') ? undefined : json['2000x']
  };
}
function CoverPhotoToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '640x': value._640x,
    '2000x': value._2000x
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ProfilePicture interface.
 */

function instanceOfProfilePicture$1(value) {
  var isInstance = true;
  return isInstance;
}
function ProfilePictureFromJSON$1(json) {
  return ProfilePictureFromJSONTyped$1(json);
}
function ProfilePictureFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists$1(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists$1(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists$1(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function ProfilePictureToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DecodedUserToken interface.
 */

function instanceOfDecodedUserToken(value) {
  var isInstance = true;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "email" in value;
  isInstance = isInstance && "name" in value;
  isInstance = isInstance && "handle" in value;
  isInstance = isInstance && "verified" in value;
  isInstance = isInstance && "sub" in value;
  isInstance = isInstance && "iat" in value;
  return isInstance;
}
function DecodedUserTokenFromJSON(json) {
  return DecodedUserTokenFromJSONTyped(json);
}
function DecodedUserTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': json['userId'],
    'email': json['email'],
    'name': json['name'],
    'handle': json['handle'],
    'verified': json['verified'],
    'profilePicture': !exists$1(json, 'profilePicture') ? undefined : ProfilePictureFromJSON$1(json['profilePicture']),
    'sub': json['sub'],
    'iat': json['iat']
  };
}
function DecodedUserTokenToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'userId': value.userId,
    'email': value.email,
    'name': value.name,
    'handle': value.handle,
    'verified': value.verified,
    'profilePicture': ProfilePictureToJSON$1(value.profilePicture),
    'sub': value.sub,
    'iat': value.iat
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DeveloperApp interface.
 */

function instanceOfDeveloperApp(value) {
  var isInstance = true;
  isInstance = isInstance && "address" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "name" in value;
  return isInstance;
}
function DeveloperAppFromJSON(json) {
  return DeveloperAppFromJSONTyped(json);
}
function DeveloperAppFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'address': json['address'],
    'userId': json['user_id'],
    'name': json['name'],
    'description': !exists$1(json, 'description') ? undefined : json['description']
  };
}
function DeveloperAppToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'address': value.address,
    'user_id': value.userId,
    'name': value.name,
    'description': value.description
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DeveloperAppResponse interface.
 */

function instanceOfDeveloperAppResponse(value) {
  var isInstance = true;
  return isInstance;
}
function DeveloperAppResponseFromJSON(json) {
  return DeveloperAppResponseFromJSONTyped(json);
}
function DeveloperAppResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : DeveloperAppFromJSON(json['data'])
  };
}
function DeveloperAppResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': DeveloperAppToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DeveloperApps interface.
 */

function instanceOfDeveloperApps(value) {
  var isInstance = true;
  return isInstance;
}
function DeveloperAppsFromJSON(json) {
  return DeveloperAppsFromJSONTyped(json);
}
function DeveloperAppsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(DeveloperAppFromJSON)
  };
}
function DeveloperAppsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(DeveloperAppToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the EncodedUserId interface.
 */

function instanceOfEncodedUserId(value) {
  var isInstance = true;
  return isInstance;
}
function EncodedUserIdFromJSON(json) {
  return EncodedUserIdFromJSONTyped(json);
}
function EncodedUserIdFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': !exists$1(json, 'user_id') ? undefined : json['user_id']
  };
}
function EncodedUserIdToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'user_id': value.userId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Favorite interface.
 */

function instanceOfFavorite$1(value) {
  var isInstance = true;
  isInstance = isInstance && "favoriteItemId" in value;
  isInstance = isInstance && "favoriteType" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "createdAt" in value;
  return isInstance;
}
function FavoriteFromJSON$1(json) {
  return FavoriteFromJSONTyped$1(json);
}
function FavoriteFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'favoriteItemId': json['favorite_item_id'],
    'favoriteType': json['favorite_type'],
    'userId': json['user_id'],
    'createdAt': json['created_at']
  };
}
function FavoriteToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'favorite_item_id': value.favoriteItemId,
    'favorite_type': value.favoriteType,
    'user_id': value.userId,
    'created_at': value.createdAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FavoritesResponse interface.
 */

function instanceOfFavoritesResponse(value) {
  var isInstance = true;
  return isInstance;
}
function FavoritesResponseFromJSON(json) {
  return FavoritesResponseFromJSONTyped(json);
}
function FavoritesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(FavoriteFromJSON$1)
  };
}
function FavoritesResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(FavoriteToJSON$1)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the User interface.
 */

function instanceOfUser(value) {
  var isInstance = true;
  isInstance = isInstance && "albumCount" in value;
  isInstance = isInstance && "followeeCount" in value;
  isInstance = isInstance && "followerCount" in value;
  isInstance = isInstance && "handle" in value;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isVerified" in value;
  isInstance = isInstance && "name" in value;
  isInstance = isInstance && "playlistCount" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "trackCount" in value;
  isInstance = isInstance && "isDeactivated" in value;
  isInstance = isInstance && "isAvailable" in value;
  isInstance = isInstance && "ercWallet" in value;
  isInstance = isInstance && "splWallet" in value;
  isInstance = isInstance && "supporterCount" in value;
  isInstance = isInstance && "supportingCount" in value;
  isInstance = isInstance && "totalAudioBalance" in value;
  return isInstance;
}
function UserFromJSON(json) {
  return UserFromJSONTyped(json);
}
function UserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'albumCount': json['album_count'],
    'artistPickTrackId': !exists$1(json, 'artist_pick_track_id') ? undefined : json['artist_pick_track_id'],
    'bio': !exists$1(json, 'bio') ? undefined : json['bio'],
    'coverPhoto': !exists$1(json, 'cover_photo') ? undefined : CoverPhotoFromJSON$1(json['cover_photo']),
    'followeeCount': json['followee_count'],
    'followerCount': json['follower_count'],
    'doesFollowCurrentUser': !exists$1(json, 'does_follow_current_user') ? undefined : json['does_follow_current_user'],
    'handle': json['handle'],
    'id': json['id'],
    'isVerified': json['is_verified'],
    'location': !exists$1(json, 'location') ? undefined : json['location'],
    'name': json['name'],
    'playlistCount': json['playlist_count'],
    'profilePicture': !exists$1(json, 'profile_picture') ? undefined : ProfilePictureFromJSON$1(json['profile_picture']),
    'repostCount': json['repost_count'],
    'trackCount': json['track_count'],
    'isDeactivated': json['is_deactivated'],
    'isAvailable': json['is_available'],
    'ercWallet': json['erc_wallet'],
    'splWallet': json['spl_wallet'],
    'supporterCount': json['supporter_count'],
    'supportingCount': json['supporting_count'],
    'totalAudioBalance': json['total_audio_balance']
  };
}
function UserToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'album_count': value.albumCount,
    'artist_pick_track_id': value.artistPickTrackId,
    'bio': value.bio,
    'cover_photo': CoverPhotoToJSON$1(value.coverPhoto),
    'followee_count': value.followeeCount,
    'follower_count': value.followerCount,
    'does_follow_current_user': value.doesFollowCurrentUser,
    'handle': value.handle,
    'id': value.id,
    'is_verified': value.isVerified,
    'location': value.location,
    'name': value.name,
    'playlist_count': value.playlistCount,
    'profile_picture': ProfilePictureToJSON$1(value.profilePicture),
    'repost_count': value.repostCount,
    'track_count': value.trackCount,
    'is_deactivated': value.isDeactivated,
    'is_available': value.isAvailable,
    'erc_wallet': value.ercWallet,
    'spl_wallet': value.splWallet,
    'supporter_count': value.supporterCount,
    'supporting_count': value.supportingCount,
    'total_audio_balance': value.totalAudioBalance
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowersResponse interface.
 */

function instanceOfFollowersResponse(value) {
  var isInstance = true;
  return isInstance;
}
function FollowersResponseFromJSON(json) {
  return FollowersResponseFromJSONTyped(json);
}
function FollowersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function FollowersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowingResponse interface.
 */

function instanceOfFollowingResponse$1(value) {
  var isInstance = true;
  return isInstance;
}
function FollowingResponseFromJSON$1(json) {
  return FollowingResponseFromJSONTyped$1(json);
}
function FollowingResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function FollowingResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Supporter interface.
 */

function instanceOfSupporter(value) {
  var isInstance = true;
  isInstance = isInstance && "rank" in value;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "sender" in value;
  return isInstance;
}
function SupporterFromJSON(json) {
  return SupporterFromJSONTyped(json);
}
function SupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'sender': UserFromJSON(json['sender'])
  };
}
function SupporterToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'rank': value.rank,
    'amount': value.amount,
    'sender': UserToJSON(value.sender)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetSupporters interface.
 */

function instanceOfGetSupporters(value) {
  var isInstance = true;
  return isInstance;
}
function GetSupportersFromJSON(json) {
  return GetSupportersFromJSONTyped(json);
}
function GetSupportersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(SupporterFromJSON)
  };
}
function GetSupportersToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(SupporterToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Supporting interface.
 */

function instanceOfSupporting(value) {
  var isInstance = true;
  isInstance = isInstance && "rank" in value;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "receiver" in value;
  return isInstance;
}
function SupportingFromJSON(json) {
  return SupportingFromJSONTyped(json);
}
function SupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'receiver': UserFromJSON(json['receiver'])
  };
}
function SupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'rank': value.rank,
    'amount': value.amount,
    'receiver': UserToJSON(value.receiver)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetSupporting interface.
 */

function instanceOfGetSupporting(value) {
  var isInstance = true;
  return isInstance;
}
function GetSupportingFromJSON(json) {
  return GetSupportingFromJSONTyped(json);
}
function GetSupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(SupportingFromJSON)
  };
}
function GetSupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(SupportingToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Tip interface.
 */

function instanceOfTip(value) {
  var isInstance = true;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "createdAt" in value;
  return isInstance;
}
function TipFromJSON(json) {
  return TipFromJSONTyped(json);
}
function TipFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'amount': json['amount'],
    'sender': !exists$1(json, 'sender') ? undefined : UserFromJSON(json['sender']),
    'receiver': !exists$1(json, 'receiver') ? undefined : UserFromJSON(json['receiver']),
    'createdAt': json['created_at']
  };
}
function TipToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'amount': value.amount,
    'sender': UserToJSON(value.sender),
    'receiver': UserToJSON(value.receiver),
    'created_at': value.createdAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetTipsResponse interface.
 */

function instanceOfGetTipsResponse$1(value) {
  var isInstance = true;
  return isInstance;
}
function GetTipsResponseFromJSON$1(json) {
  return GetTipsResponseFromJSONTyped$1(json);
}
function GetTipsResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(TipFromJSON)
  };
}
function GetTipsResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(TipToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistAddedTimestamp interface.
 */

function instanceOfPlaylistAddedTimestamp$1(value) {
  var isInstance = true;
  isInstance = isInstance && "metadataTimestamp" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "trackId" in value;
  return isInstance;
}
function PlaylistAddedTimestampFromJSON$1(json) {
  return PlaylistAddedTimestampFromJSONTyped$1(json);
}
function PlaylistAddedTimestampFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'metadataTimestamp': json['metadata_timestamp'],
    'timestamp': json['timestamp'],
    'trackId': json['track_id']
  };
}
function PlaylistAddedTimestampToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'metadata_timestamp': value.metadataTimestamp,
    'timestamp': value.timestamp,
    'track_id': value.trackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistArtwork interface.
 */

function instanceOfPlaylistArtwork$1(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistArtworkFromJSON$1(json) {
  return PlaylistArtworkFromJSONTyped$1(json);
}
function PlaylistArtworkFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists$1(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists$1(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists$1(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function PlaylistArtworkToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Playlist interface.
 */

function instanceOfPlaylist(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isAlbum" in value;
  isInstance = isInstance && "isImageAutogenerated" in value;
  isInstance = isInstance && "playlistName" in value;
  isInstance = isInstance && "playlistContents" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "totalPlayCount" in value;
  isInstance = isInstance && "user" in value;
  return isInstance;
}
function PlaylistFromJSON(json) {
  return PlaylistFromJSONTyped(json);
}
function PlaylistFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists$1(json, 'artwork') ? undefined : PlaylistArtworkFromJSON$1(json['artwork']),
    'description': !exists$1(json, 'description') ? undefined : json['description'],
    'permalink': !exists$1(json, 'permalink') ? undefined : json['permalink'],
    'id': json['id'],
    'isAlbum': json['is_album'],
    'isImageAutogenerated': json['is_image_autogenerated'],
    'playlistName': json['playlist_name'],
    'playlistContents': json['playlist_contents'].map(PlaylistAddedTimestampFromJSON$1),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'totalPlayCount': json['total_play_count'],
    'user': UserFromJSON(json['user'])
  };
}
function PlaylistToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': PlaylistArtworkToJSON$1(value.artwork),
    'description': value.description,
    'permalink': value.permalink,
    'id': value.id,
    'is_album': value.isAlbum,
    'is_image_autogenerated': value.isImageAutogenerated,
    'playlist_name': value.playlistName,
    'playlist_contents': value.playlistContents.map(PlaylistAddedTimestampToJSON$1),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'total_play_count': value.totalPlayCount,
    'user': UserToJSON(value.user)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistResponse interface.
 */

function instanceOfPlaylistResponse(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistResponseFromJSON(json) {
  return PlaylistResponseFromJSONTyped(json);
}
function PlaylistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(PlaylistFromJSON)
  };
}
function PlaylistResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(PlaylistToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistSearchResult interface.
 */

function instanceOfPlaylistSearchResult(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistSearchResultFromJSON(json) {
  return PlaylistSearchResultFromJSONTyped(json);
}
function PlaylistSearchResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(PlaylistFromJSON)
  };
}
function PlaylistSearchResultToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(PlaylistToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackElement interface.
 */

function instanceOfTrackElement(value) {
  var isInstance = true;
  isInstance = isInstance && "parentTrackId" in value;
  return isInstance;
}
function TrackElementFromJSON(json) {
  return TrackElementFromJSONTyped(json);
}
function TrackElementFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'parentTrackId': json['parent_track_id']
  };
}
function TrackElementToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'parent_track_id': value.parentTrackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixParent interface.
 */

function instanceOfRemixParent(value) {
  var isInstance = true;
  return isInstance;
}
function RemixParentFromJSON(json) {
  return RemixParentFromJSONTyped(json);
}
function RemixParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'tracks': !exists$1(json, 'tracks') ? undefined : json['tracks'].map(TrackElementFromJSON)
  };
}
function RemixParentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackElementToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackArtwork interface.
 */

function instanceOfTrackArtwork$1(value) {
  var isInstance = true;
  return isInstance;
}
function TrackArtworkFromJSON$1(json) {
  return TrackArtworkFromJSONTyped$1(json);
}
function TrackArtworkFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists$1(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists$1(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists$1(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function TrackArtworkToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Track interface.
 */

function instanceOfTrack(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "title" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "duration" in value;
  isInstance = isInstance && "playCount" in value;
  return isInstance;
}
function TrackFromJSON(json) {
  return TrackFromJSONTyped(json);
}
function TrackFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists$1(json, 'artwork') ? undefined : TrackArtworkFromJSON$1(json['artwork']),
    'description': !exists$1(json, 'description') ? undefined : json['description'],
    'genre': !exists$1(json, 'genre') ? undefined : json['genre'],
    'id': json['id'],
    'trackCid': !exists$1(json, 'track_cid') ? undefined : json['track_cid'],
    'previewCid': !exists$1(json, 'preview_cid') ? undefined : json['preview_cid'],
    'mood': !exists$1(json, 'mood') ? undefined : json['mood'],
    'releaseDate': !exists$1(json, 'release_date') ? undefined : json['release_date'],
    'remixOf': !exists$1(json, 'remix_of') ? undefined : RemixParentFromJSON(json['remix_of']),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'tags': !exists$1(json, 'tags') ? undefined : json['tags'],
    'title': json['title'],
    'user': UserFromJSON(json['user']),
    'duration': json['duration'],
    'downloadable': !exists$1(json, 'downloadable') ? undefined : json['downloadable'],
    'playCount': json['play_count'],
    'permalink': !exists$1(json, 'permalink') ? undefined : json['permalink'],
    'isStreamable': !exists$1(json, 'is_streamable') ? undefined : json['is_streamable']
  };
}
function TrackToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': TrackArtworkToJSON$1(value.artwork),
    'description': value.description,
    'genre': value.genre,
    'id': value.id,
    'track_cid': value.trackCid,
    'preview_cid': value.previewCid,
    'mood': value.mood,
    'release_date': value.releaseDate,
    'remix_of': RemixParentToJSON(value.remixOf),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'tags': value.tags,
    'title': value.title,
    'user': UserToJSON(value.user),
    'duration': value.duration,
    'downloadable': value.downloadable,
    'play_count': value.playCount,
    'permalink': value.permalink,
    'is_streamable': value.isStreamable
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistTracksResponse interface.
 */

function instanceOfPlaylistTracksResponse(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistTracksResponseFromJSON(json) {
  return PlaylistTracksResponseFromJSONTyped(json);
}
function PlaylistTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(TrackFromJSON)
  };
}
function PlaylistTracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(TrackToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RelatedArtistResponse interface.
 */

function instanceOfRelatedArtistResponse(value) {
  var isInstance = true;
  return isInstance;
}
function RelatedArtistResponseFromJSON(json) {
  return RelatedArtistResponseFromJSONTyped(json);
}
function RelatedArtistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function RelatedArtistResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Reposts interface.
 */

function instanceOfReposts(value) {
  var isInstance = true;
  return isInstance;
}
function RepostsFromJSON(json) {
  return RepostsFromJSONTyped(json);
}
function RepostsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(ActivityFromJSON)
  };
}
function RepostsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(ActivityToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SubscribersResponse interface.
 */

function instanceOfSubscribersResponse(value) {
  var isInstance = true;
  return isInstance;
}
function SubscribersResponseFromJSON(json) {
  return SubscribersResponseFromJSONTyped(json);
}
function SubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function SubscribersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TagsResponse interface.
 */

function instanceOfTagsResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TagsResponseFromJSON(json) {
  return TagsResponseFromJSONTyped(json);
}
function TagsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data']
  };
}
function TagsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackResponse interface.
 */

function instanceOfTrackResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TrackResponseFromJSON(json) {
  return TrackResponseFromJSONTyped(json);
}
function TrackResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : TrackFromJSON(json['data'])
  };
}
function TrackResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': TrackToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackSearch interface.
 */

function instanceOfTrackSearch(value) {
  var isInstance = true;
  return isInstance;
}
function TrackSearchFromJSON(json) {
  return TrackSearchFromJSONTyped(json);
}
function TrackSearchFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(TrackFromJSON)
  };
}
function TrackSearchToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(TrackToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TracksResponse interface.
 */

function instanceOfTracksResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TracksResponseFromJSON(json) {
  return TracksResponseFromJSONTyped(json);
}
function TracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(TrackFromJSON)
  };
}
function TracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(TrackToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingPlaylistsResponse interface.
 */

function instanceOfTrendingPlaylistsResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TrendingPlaylistsResponseFromJSON(json) {
  return TrendingPlaylistsResponseFromJSONTyped(json);
}
function TrendingPlaylistsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(PlaylistFromJSON)
  };
}
function TrendingPlaylistsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(PlaylistToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserAssociatedWalletResponse interface.
 */

function instanceOfUserAssociatedWalletResponse(value) {
  var isInstance = true;
  return isInstance;
}
function UserAssociatedWalletResponseFromJSON(json) {
  return UserAssociatedWalletResponseFromJSONTyped(json);
}
function UserAssociatedWalletResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : EncodedUserIdFromJSON(json['data'])
  };
}
function UserAssociatedWalletResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': EncodedUserIdToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserResponse interface.
 */

function instanceOfUserResponse(value) {
  var isInstance = true;
  return isInstance;
}
function UserResponseFromJSON(json) {
  return UserResponseFromJSONTyped(json);
}
function UserResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : UserFromJSON(json['data'])
  };
}
function UserResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': UserToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserSearch interface.
 */

function instanceOfUserSearch(value) {
  var isInstance = true;
  return isInstance;
}
function UserSearchFromJSON(json) {
  return UserSearchFromJSONTyped(json);
}
function UserSearchFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function UserSearchToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the VerifyToken interface.
 */

function instanceOfVerifyToken(value) {
  var isInstance = true;
  return isInstance;
}
function VerifyTokenFromJSON(json) {
  return VerifyTokenFromJSONTyped(json);
}
function VerifyTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : DecodedUserTokenFromJSON(json['data'])
  };
}
function VerifyTokenToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': DecodedUserTokenToJSON(value.data)
  };
}

/**
 *
 */

var DeveloperAppsApi$1 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(DeveloperAppsApi, _runtime$BaseAPI);

  var _super = _createSuper(DeveloperAppsApi);

  function DeveloperAppsApi() {
    _classCallCheck$1(this, DeveloperAppsApi);

    return _super.apply(this, arguments);
  }

  _createClass$1(DeveloperAppsApi, [{
    key: "getDeveloperAppRaw",
    value:
    /** @hidden
     * Gets developer app matching given address (API key)
     */
    function () {
      var _getDeveloperAppRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.address === null || params.address === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('address', 'Required parameter params.address was null or undefined when calling getDeveloperApp.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context.next = 6;
                return this.request({
                  path: "/developer_apps/{address}".replace("{".concat("address", "}"), encodeURIComponent(String(params.address))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return DeveloperAppResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getDeveloperAppRaw(_x, _x2) {
        return _getDeveloperAppRaw.apply(this, arguments);
      }

      return getDeveloperAppRaw;
    }()
    /**
     * Gets developer app matching given address (API key)
     */

  }, {
    key: "getDeveloperApp",
    value: function () {
      var _getDeveloperApp = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getDeveloperAppRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getDeveloperApp(_x3, _x4) {
        return _getDeveloperApp.apply(this, arguments);
      }

      return getDeveloperApp;
    }()
  }]);

  return DeveloperAppsApi;
}(BaseAPI$1);

/**
 *
 */

var PlaylistsApi$2 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(PlaylistsApi, _runtime$BaseAPI);

  var _super = _createSuper(PlaylistsApi);

  function PlaylistsApi() {
    _classCallCheck$1(this, PlaylistsApi);

    return _super.apply(this, arguments);
  }

  _createClass$1(PlaylistsApi, [{
    key: "getPlaylistRaw",
    value:
    /** @hidden
     * Get a playlist by ID
     */
    function () {
      var _getPlaylistRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylist.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context.next = 7;
                return this.request({
                  path: "/playlists/{playlist_id}".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return PlaylistResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getPlaylistRaw(_x, _x2) {
        return _getPlaylistRaw.apply(this, arguments);
      }

      return getPlaylistRaw;
    }()
    /**
     * Get a playlist by ID
     */

  }, {
    key: "getPlaylist",
    value: function () {
      var _getPlaylist = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getPlaylistRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getPlaylist(_x3, _x4) {
        return _getPlaylist.apply(this, arguments);
      }

      return getPlaylist;
    }()
    /** @hidden
     * Fetch tracks within a playlist.
     */

  }, {
    key: "getPlaylistTracksRaw",
    value: function () {
      var _getPlaylistTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError$1('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylistTracks.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context3.next = 6;
                return this.request({
                  path: "/playlists/{playlist_id}/tracks".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return PlaylistTracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getPlaylistTracksRaw(_x5, _x6) {
        return _getPlaylistTracksRaw.apply(this, arguments);
      }

      return getPlaylistTracksRaw;
    }()
    /**
     * Fetch tracks within a playlist.
     */

  }, {
    key: "getPlaylistTracks",
    value: function () {
      var _getPlaylistTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getPlaylistTracksRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getPlaylistTracks(_x7, _x8) {
        return _getPlaylistTracks.apply(this, arguments);
      }

      return getPlaylistTracks;
    }()
    /** @hidden
     * Gets trending playlists for a time period
     */

  }, {
    key: "getTrendingPlaylistsRaw",
    value: function () {
      var _getTrendingPlaylistsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                queryParameters = {};

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context5.next = 5;
                return this.request({
                  path: "/playlists/trending",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 5:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TrendingPlaylistsResponseFromJSON(jsonValue);
                }));

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getTrendingPlaylistsRaw(_x9, _x10) {
        return _getTrendingPlaylistsRaw.apply(this, arguments);
      }

      return getTrendingPlaylistsRaw;
    }()
    /**
     * Gets trending playlists for a time period
     */

  }, {
    key: "getTrendingPlaylists",
    value: function () {
      var _getTrendingPlaylists = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var params,
            initOverrides,
            response,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                params = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
                initOverrides = _args6.length > 1 ? _args6[1] : undefined;
                _context6.next = 4;
                return this.getTrendingPlaylistsRaw(params, initOverrides);

              case 4:
                response = _context6.sent;
                _context6.next = 7;
                return response.value();

              case 7:
                return _context6.abrupt("return", _context6.sent);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getTrendingPlaylists() {
        return _getTrendingPlaylists.apply(this, arguments);
      }

      return getTrendingPlaylists;
    }()
    /** @hidden
     * Search for a playlist
     */

  }, {
    key: "searchPlaylistsRaw",
    value: function () {
      var _searchPlaylistsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context7.next = 2;
                  break;
                }

                throw new RequiredError$1('query', 'Required parameter params.query was null or undefined when calling searchPlaylists.');

              case 2:
                queryParameters = {};

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                headerParameters = {};
                _context7.next = 7;
                return this.request({
                  path: "/playlists/search",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return PlaylistSearchResultFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function searchPlaylistsRaw(_x11, _x12) {
        return _searchPlaylistsRaw.apply(this, arguments);
      }

      return searchPlaylistsRaw;
    }()
    /**
     * Search for a playlist
     */

  }, {
    key: "searchPlaylists",
    value: function () {
      var _searchPlaylists = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.searchPlaylistsRaw(params, initOverrides);

              case 2:
                response = _context8.sent;
                _context8.next = 5;
                return response.value();

              case 5:
                return _context8.abrupt("return", _context8.sent);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function searchPlaylists(_x13, _x14) {
        return _searchPlaylists.apply(this, arguments);
      }

      return searchPlaylists;
    }()
  }]);

  return PlaylistsApi;
}(BaseAPI$1);
/**
 * @export
 */

var GetTrendingPlaylistsTimeEnum$1 = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};

/**
 *
 */

var TipsApi$1 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TipsApi, _runtime$BaseAPI);

  var _super = _createSuper(TipsApi);

  function TipsApi() {
    _classCallCheck$1(this, TipsApi);

    return _super.apply(this, arguments);
  }

  _createClass$1(TipsApi, [{
    key: "getTipsRaw",
    value:
    /** @hidden
     * Gets the most recent tips on the network
     */
    function () {
      var _getTipsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.receiverMinFollowers !== undefined) {
                  queryParameters['receiver_min_followers'] = params.receiverMinFollowers;
                }

                if (params.receiverIsVerified !== undefined) {
                  queryParameters['receiver_is_verified'] = params.receiverIsVerified;
                }

                if (params.currentUserFollows !== undefined) {
                  queryParameters['current_user_follows'] = params.currentUserFollows;
                }

                if (params.uniqueBy !== undefined) {
                  queryParameters['unique_by'] = params.uniqueBy;
                }

                headerParameters = {};
                _context.next = 11;
                return this.request({
                  path: "/tips",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return GetTipsResponseFromJSON$1(jsonValue);
                }));

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getTipsRaw(_x, _x2) {
        return _getTipsRaw.apply(this, arguments);
      }

      return getTipsRaw;
    }()
    /**
     * Gets the most recent tips on the network
     */

  }, {
    key: "getTips",
    value: function () {
      var _getTips = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var params,
            initOverrides,
            response,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                params = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                initOverrides = _args2.length > 1 ? _args2[1] : undefined;
                _context2.next = 4;
                return this.getTipsRaw(params, initOverrides);

              case 4:
                response = _context2.sent;
                _context2.next = 7;
                return response.value();

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getTips() {
        return _getTips.apply(this, arguments);
      }

      return getTips;
    }()
  }]);

  return TipsApi;
}(BaseAPI$1);
/**
 * @export
 */

var GetTipsCurrentUserFollowsEnum$1 = {
  Sender: 'sender',
  Receiver: 'receiver',
  SenderOrReceiver: 'sender_or_receiver'
};
/**
 * @export
 */

var GetTipsUniqueByEnum$1 = {
  Sender: 'sender',
  Receiver: 'receiver'
};

/**
 *
 */

var TracksApi$2 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TracksApi, _runtime$BaseAPI);

  var _super = _createSuper(TracksApi);

  function TracksApi() {
    _classCallCheck$1(this, TracksApi);

    return _super.apply(this, arguments);
  }

  _createClass$1(TracksApi, [{
    key: "getBulkTracksRaw",
    value:
    /** @hidden
     * Gets a list of tracks using their IDs or permalinks
     */
    function () {
      var _getBulkTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                queryParameters = {};

                if (params.permalink) {
                  queryParameters['permalink'] = params.permalink;
                }

                if (params.id) {
                  queryParameters['id'] = params.id;
                }

                headerParameters = {};
                _context.next = 6;
                return this.request({
                  path: "/tracks",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getBulkTracksRaw(_x, _x2) {
        return _getBulkTracksRaw.apply(this, arguments);
      }

      return getBulkTracksRaw;
    }()
    /**
     * Gets a list of tracks using their IDs or permalinks
     */

  }, {
    key: "getBulkTracks",
    value: function () {
      var _getBulkTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var params,
            initOverrides,
            response,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                params = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                initOverrides = _args2.length > 1 ? _args2[1] : undefined;
                _context2.next = 4;
                return this.getBulkTracksRaw(params, initOverrides);

              case 4:
                response = _context2.sent;
                _context2.next = 7;
                return response.value();

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getBulkTracks() {
        return _getBulkTracks.apply(this, arguments);
      }

      return getBulkTracks;
    }()
    /** @hidden
     * Gets a track by ID
     */

  }, {
    key: "getTrackRaw",
    value: function () {
      var _getTrackRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrack.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context3.next = 6;
                return this.request({
                  path: "/tracks/{track_id}".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TrackResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getTrackRaw(_x3, _x4) {
        return _getTrackRaw.apply(this, arguments);
      }

      return getTrackRaw;
    }()
    /**
     * Gets a track by ID
     */

  }, {
    key: "getTrack",
    value: function () {
      var _getTrack = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getTrackRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getTrack(_x5, _x6) {
        return _getTrack.apply(this, arguments);
      }

      return getTrack;
    }()
    /** @hidden
     * Gets the top 100 trending (most popular) tracks on Audius
     */

  }, {
    key: "getTrendingTracksRaw",
    value: function () {
      var _getTrendingTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                queryParameters = {};

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context5.next = 6;
                return this.request({
                  path: "/tracks/trending",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getTrendingTracksRaw(_x7, _x8) {
        return _getTrendingTracksRaw.apply(this, arguments);
      }

      return getTrendingTracksRaw;
    }()
    /**
     * Gets the top 100 trending (most popular) tracks on Audius
     */

  }, {
    key: "getTrendingTracks",
    value: function () {
      var _getTrendingTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var params,
            initOverrides,
            response,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                params = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
                initOverrides = _args6.length > 1 ? _args6[1] : undefined;
                _context6.next = 4;
                return this.getTrendingTracksRaw(params, initOverrides);

              case 4:
                response = _context6.sent;
                _context6.next = 7;
                return response.value();

              case 7:
                return _context6.abrupt("return", _context6.sent);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getTrendingTracks() {
        return _getTrendingTracks.apply(this, arguments);
      }

      return getTrendingTracks;
    }()
    /** @hidden
     * Gets the top 100 trending underground tracks on Audius
     */

  }, {
    key: "getUndergroundTrendingTracksRaw",
    value: function () {
      var _getUndergroundTrendingTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                headerParameters = {};
                _context7.next = 6;
                return this.request({
                  path: "/tracks/trending/underground",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getUndergroundTrendingTracksRaw(_x9, _x10) {
        return _getUndergroundTrendingTracksRaw.apply(this, arguments);
      }

      return getUndergroundTrendingTracksRaw;
    }()
    /**
     * Gets the top 100 trending underground tracks on Audius
     */

  }, {
    key: "getUndergroundTrendingTracks",
    value: function () {
      var _getUndergroundTrendingTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var params,
            initOverrides,
            response,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                params = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};
                initOverrides = _args8.length > 1 ? _args8[1] : undefined;
                _context8.next = 4;
                return this.getUndergroundTrendingTracksRaw(params, initOverrides);

              case 4:
                response = _context8.sent;
                _context8.next = 7;
                return response.value();

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getUndergroundTrendingTracks() {
        return _getUndergroundTrendingTracks.apply(this, arguments);
      }

      return getUndergroundTrendingTracks;
    }()
    /** @hidden
     * Search for a track or tracks
     */

  }, {
    key: "searchTracksRaw",
    value: function () {
      var _searchTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError$1('query', 'Required parameter params.query was null or undefined when calling searchTracks.');

              case 2:
                queryParameters = {};

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.onlyDownloadable !== undefined) {
                  queryParameters['only_downloadable'] = params.onlyDownloadable;
                }

                headerParameters = {};
                _context9.next = 8;
                return this.request({
                  path: "/tracks/search",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context9.sent;
                return _context9.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TrackSearchFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function searchTracksRaw(_x11, _x12) {
        return _searchTracksRaw.apply(this, arguments);
      }

      return searchTracksRaw;
    }()
    /**
     * Search for a track or tracks
     */

  }, {
    key: "searchTracks",
    value: function () {
      var _searchTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.searchTracksRaw(params, initOverrides);

              case 2:
                response = _context10.sent;
                _context10.next = 5;
                return response.value();

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function searchTracks(_x13, _x14) {
        return _searchTracks.apply(this, arguments);
      }

      return searchTracks;
    }()
    /** @hidden
     * This endpoint accepts the Range header for streaming. https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests
     * Get the streamable MP3 file of a track
     */

  }, {
    key: "streamTrackRaw",
    value: function () {
      var _streamTrackRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context11.next = 2;
                  break;
                }

                throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling streamTrack.');

              case 2:
                queryParameters = {};

                if (params.preview !== undefined) {
                  queryParameters['preview'] = params.preview;
                }

                if (params.userSignature !== undefined) {
                  queryParameters['user_signature'] = params.userSignature;
                }

                if (params.userData !== undefined) {
                  queryParameters['user_data'] = params.userData;
                }

                if (params.premiumContentSignature !== undefined) {
                  queryParameters['premium_content_signature'] = params.premiumContentSignature;
                }

                if (params.filename !== undefined) {
                  queryParameters['filename'] = params.filename;
                }

                if (params.skipPlayCount !== undefined) {
                  queryParameters['skip_play_count'] = params.skipPlayCount;
                }

                headerParameters = {};
                _context11.next = 12;
                return this.request({
                  path: "/tracks/{track_id}/stream".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 12:
                response = _context11.sent;
                return _context11.abrupt("return", new VoidApiResponse$1(response));

              case 14:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function streamTrackRaw(_x15, _x16) {
        return _streamTrackRaw.apply(this, arguments);
      }

      return streamTrackRaw;
    }()
    /**
     * This endpoint accepts the Range header for streaming. https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests
     * Get the streamable MP3 file of a track
     */

  }, {
    key: "streamTrack",
    value: function () {
      var _streamTrack = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.streamTrackRaw(params, initOverrides);

              case 2:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function streamTrack(_x17, _x18) {
        return _streamTrack.apply(this, arguments);
      }

      return streamTrack;
    }()
  }]);

  return TracksApi;
}(BaseAPI$1);
/**
 * @export
 */

var GetTrendingTracksTimeEnum$1 = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};

/**
 *
 */

var UsersApi$2 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(UsersApi, _runtime$BaseAPI);

  var _super = _createSuper(UsersApi);

  function UsersApi() {
    _classCallCheck$1(this, UsersApi);

    return _super.apply(this, arguments);
  }

  _createClass$1(UsersApi, [{
    key: "getAIAttributedTracksByUserHandleRaw",
    value:
    /** @hidden
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */
    function () {
      var _getAIAttributedTracksByUserHandleRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('handle', 'Required parameter params.handle was null or undefined when calling getAIAttributedTracksByUserHandle.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context.next = 14;
                return this.request({
                  path: "/users/handle/{handle}/tracks/ai_attributed".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAIAttributedTracksByUserHandleRaw(_x, _x2) {
        return _getAIAttributedTracksByUserHandleRaw.apply(this, arguments);
      }

      return getAIAttributedTracksByUserHandleRaw;
    }()
    /**
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */

  }, {
    key: "getAIAttributedTracksByUserHandle",
    value: function () {
      var _getAIAttributedTracksByUserHandle = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getAIAttributedTracksByUserHandleRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getAIAttributedTracksByUserHandle(_x3, _x4) {
        return _getAIAttributedTracksByUserHandle.apply(this, arguments);
      }

      return getAIAttributedTracksByUserHandle;
    }()
    /** @hidden
     * Get the apps that user has authorized to write to their account
     */

  }, {
    key: "getAuthorizedAppsRaw",
    value: function () {
      var _getAuthorizedAppsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getAuthorizedApps.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context3.next = 6;
                return this.request({
                  path: "/users/{id}/authorized_apps".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return AuthorizedAppsFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getAuthorizedAppsRaw(_x5, _x6) {
        return _getAuthorizedAppsRaw.apply(this, arguments);
      }

      return getAuthorizedAppsRaw;
    }()
    /**
     * Get the apps that user has authorized to write to their account
     */

  }, {
    key: "getAuthorizedApps",
    value: function () {
      var _getAuthorizedApps = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getAuthorizedAppsRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAuthorizedApps(_x7, _x8) {
        return _getAuthorizedApps.apply(this, arguments);
      }

      return getAuthorizedApps;
    }()
    /** @hidden
     * Get the User\'s ERC and SPL connected wallets
     */

  }, {
    key: "getConnectedWalletsRaw",
    value: function () {
      var _getConnectedWalletsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context5.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getConnectedWallets.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context5.next = 6;
                return this.request({
                  path: "/users/{id}/connected_wallets".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return ConnectedWalletsResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getConnectedWalletsRaw(_x9, _x10) {
        return _getConnectedWalletsRaw.apply(this, arguments);
      }

      return getConnectedWalletsRaw;
    }()
    /**
     * Get the User\'s ERC and SPL connected wallets
     */

  }, {
    key: "getConnectedWallets",
    value: function () {
      var _getConnectedWallets = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getConnectedWalletsRaw(params, initOverrides);

              case 2:
                response = _context6.sent;
                _context6.next = 5;
                return response.value();

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getConnectedWallets(_x11, _x12) {
        return _getConnectedWallets.apply(this, arguments);
      }

      return getConnectedWallets;
    }()
    /** @hidden
     * Gets the developer apps that the user owns
     */

  }, {
    key: "getDeveloperAppsRaw",
    value: function () {
      var _getDeveloperAppsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context7.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getDeveloperApps.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context7.next = 6;
                return this.request({
                  path: "/users/{id}/developer_apps".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return DeveloperAppsFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getDeveloperAppsRaw(_x13, _x14) {
        return _getDeveloperAppsRaw.apply(this, arguments);
      }

      return getDeveloperAppsRaw;
    }()
    /**
     * Gets the developer apps that the user owns
     */

  }, {
    key: "getDeveloperApps",
    value: function () {
      var _getDeveloperApps = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getDeveloperAppsRaw(params, initOverrides);

              case 2:
                response = _context8.sent;
                _context8.next = 5;
                return response.value();

              case 5:
                return _context8.abrupt("return", _context8.sent);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getDeveloperApps(_x15, _x16) {
        return _getDeveloperApps.apply(this, arguments);
      }

      return getDeveloperApps;
    }()
    /** @hidden
     * Gets a user\'s favorite tracks
     */

  }, {
    key: "getFavoritesRaw",
    value: function () {
      var _getFavoritesRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getFavorites.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context9.next = 6;
                return this.request({
                  path: "/users/{id}/favorites".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context9.sent;
                return _context9.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return FavoritesResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getFavoritesRaw(_x17, _x18) {
        return _getFavoritesRaw.apply(this, arguments);
      }

      return getFavoritesRaw;
    }()
    /**
     * Gets a user\'s favorite tracks
     */

  }, {
    key: "getFavorites",
    value: function () {
      var _getFavorites = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getFavoritesRaw(params, initOverrides);

              case 2:
                response = _context10.sent;
                _context10.next = 5;
                return response.value();

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getFavorites(_x19, _x20) {
        return _getFavorites.apply(this, arguments);
      }

      return getFavorites;
    }()
    /** @hidden
     * All users that follow the provided user
     */

  }, {
    key: "getFollowersRaw",
    value: function () {
      var _getFollowersRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context11.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getFollowers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context11.next = 9;
                return this.request({
                  path: "/users/{id}/followers".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context11.sent;
                return _context11.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return FollowersResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getFollowersRaw(_x21, _x22) {
        return _getFollowersRaw.apply(this, arguments);
      }

      return getFollowersRaw;
    }()
    /**
     * All users that follow the provided user
     */

  }, {
    key: "getFollowers",
    value: function () {
      var _getFollowers = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getFollowersRaw(params, initOverrides);

              case 2:
                response = _context12.sent;
                _context12.next = 5;
                return response.value();

              case 5:
                return _context12.abrupt("return", _context12.sent);

              case 6:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getFollowers(_x23, _x24) {
        return _getFollowers.apply(this, arguments);
      }

      return getFollowers;
    }()
    /** @hidden
     * All users that the provided user follows
     */

  }, {
    key: "getFollowingRaw",
    value: function () {
      var _getFollowingRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context13.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getFollowing.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context13.next = 9;
                return this.request({
                  path: "/users/{id}/following".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context13.sent;
                return _context13.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return FollowingResponseFromJSON$1(jsonValue);
                }));

              case 11:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getFollowingRaw(_x25, _x26) {
        return _getFollowingRaw.apply(this, arguments);
      }

      return getFollowingRaw;
    }()
    /**
     * All users that the provided user follows
     */

  }, {
    key: "getFollowing",
    value: function () {
      var _getFollowing = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getFollowingRaw(params, initOverrides);

              case 2:
                response = _context14.sent;
                _context14.next = 5;
                return response.value();

              case 5:
                return _context14.abrupt("return", _context14.sent);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getFollowing(_x27, _x28) {
        return _getFollowing.apply(this, arguments);
      }

      return getFollowing;
    }()
    /** @hidden
     * Gets a list of users that might be of interest to followers of this user.
     */

  }, {
    key: "getRelatedUsersRaw",
    value: function () {
      var _getRelatedUsersRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context15.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getRelatedUsers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context15.next = 9;
                return this.request({
                  path: "/users/{id}/related".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context15.sent;
                return _context15.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return RelatedArtistResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getRelatedUsersRaw(_x29, _x30) {
        return _getRelatedUsersRaw.apply(this, arguments);
      }

      return getRelatedUsersRaw;
    }()
    /**
     * Gets a list of users that might be of interest to followers of this user.
     */

  }, {
    key: "getRelatedUsers",
    value: function () {
      var _getRelatedUsers = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.getRelatedUsersRaw(params, initOverrides);

              case 2:
                response = _context16.sent;
                _context16.next = 5;
                return response.value();

              case 5:
                return _context16.abrupt("return", _context16.sent);

              case 6:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getRelatedUsers(_x31, _x32) {
        return _getRelatedUsers.apply(this, arguments);
      }

      return getRelatedUsers;
    }()
    /** @hidden
     * Gets the given user\'s reposts
     */

  }, {
    key: "getRepostsRaw",
    value: function () {
      var _getRepostsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context17.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getReposts.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context17.next = 9;
                return this.request({
                  path: "/users/{id}/reposts".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context17.sent;
                return _context17.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return RepostsFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getRepostsRaw(_x33, _x34) {
        return _getRepostsRaw.apply(this, arguments);
      }

      return getRepostsRaw;
    }()
    /**
     * Gets the given user\'s reposts
     */

  }, {
    key: "getReposts",
    value: function () {
      var _getReposts = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.getRepostsRaw(params, initOverrides);

              case 2:
                response = _context18.sent;
                _context18.next = 5;
                return response.value();

              case 5:
                return _context18.abrupt("return", _context18.sent);

              case 6:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getReposts(_x35, _x36) {
        return _getReposts.apply(this, arguments);
      }

      return getReposts;
    }()
    /** @hidden
     * All users that subscribe to the provided user
     */

  }, {
    key: "getSubscribersRaw",
    value: function () {
      var _getSubscribersRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context19.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getSubscribers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context19.next = 9;
                return this.request({
                  path: "/users/{id}/subscribers".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context19.sent;
                return _context19.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return SubscribersResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getSubscribersRaw(_x37, _x38) {
        return _getSubscribersRaw.apply(this, arguments);
      }

      return getSubscribersRaw;
    }()
    /**
     * All users that subscribe to the provided user
     */

  }, {
    key: "getSubscribers",
    value: function () {
      var _getSubscribers = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getSubscribersRaw(params, initOverrides);

              case 2:
                response = _context20.sent;
                _context20.next = 5;
                return response.value();

              case 5:
                return _context20.abrupt("return", _context20.sent);

              case 6:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getSubscribers(_x39, _x40) {
        return _getSubscribers.apply(this, arguments);
      }

      return getSubscribers;
    }()
    /** @hidden
     * Gets the supporters of the given user
     */

  }, {
    key: "getSupportersRaw",
    value: function () {
      var _getSupportersRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context21.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getSupporters.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                headerParameters = {};
                _context21.next = 8;
                return this.request({
                  path: "/users/{id}/supporters".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context21.sent;
                return _context21.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return GetSupportersFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getSupportersRaw(_x41, _x42) {
        return _getSupportersRaw.apply(this, arguments);
      }

      return getSupportersRaw;
    }()
    /**
     * Gets the supporters of the given user
     */

  }, {
    key: "getSupporters",
    value: function () {
      var _getSupporters = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getSupportersRaw(params, initOverrides);

              case 2:
                response = _context22.sent;
                _context22.next = 5;
                return response.value();

              case 5:
                return _context22.abrupt("return", _context22.sent);

              case 6:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getSupporters(_x43, _x44) {
        return _getSupporters.apply(this, arguments);
      }

      return getSupporters;
    }()
    /** @hidden
     * Gets the users that the given user supports
     */

  }, {
    key: "getSupportingsRaw",
    value: function () {
      var _getSupportingsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context23.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getSupportings.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                headerParameters = {};
                _context23.next = 8;
                return this.request({
                  path: "/users/{id}/supporting".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context23.sent;
                return _context23.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return GetSupportingFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getSupportingsRaw(_x45, _x46) {
        return _getSupportingsRaw.apply(this, arguments);
      }

      return getSupportingsRaw;
    }()
    /**
     * Gets the users that the given user supports
     */

  }, {
    key: "getSupportings",
    value: function () {
      var _getSupportings = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.getSupportingsRaw(params, initOverrides);

              case 2:
                response = _context24.sent;
                _context24.next = 5;
                return response.value();

              case 5:
                return _context24.abrupt("return", _context24.sent);

              case 6:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getSupportings(_x47, _x48) {
        return _getSupportings.apply(this, arguments);
      }

      return getSupportings;
    }()
    /** @hidden
     * Gets the most used track tags by a user.
     * Fetch most used tags in a user\'s tracks
     */

  }, {
    key: "getTopTrackTagsRaw",
    value: function () {
      var _getTopTrackTagsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context25.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getTopTrackTags.');

              case 2:
                queryParameters = {};

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context25.next = 8;
                return this.request({
                  path: "/users/{id}/tags".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context25.sent;
                return _context25.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TagsResponseFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getTopTrackTagsRaw(_x49, _x50) {
        return _getTopTrackTagsRaw.apply(this, arguments);
      }

      return getTopTrackTagsRaw;
    }()
    /**
     * Gets the most used track tags by a user.
     * Fetch most used tags in a user\'s tracks
     */

  }, {
    key: "getTopTrackTags",
    value: function () {
      var _getTopTrackTags = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.getTopTrackTagsRaw(params, initOverrides);

              case 2:
                response = _context26.sent;
                _context26.next = 5;
                return response.value();

              case 5:
                return _context26.abrupt("return", _context26.sent);

              case 6:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function getTopTrackTags(_x51, _x52) {
        return _getTopTrackTags.apply(this, arguments);
      }

      return getTopTrackTags;
    }()
    /** @hidden
     * Gets the tracks created by a user using their user ID
     */

  }, {
    key: "getTracksByUserRaw",
    value: function () {
      var _getTracksByUserRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context27.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getTracksByUser.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context27.next = 14;
                return this.request({
                  path: "/users/{id}/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context27.sent;
                return _context27.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getTracksByUserRaw(_x53, _x54) {
        return _getTracksByUserRaw.apply(this, arguments);
      }

      return getTracksByUserRaw;
    }()
    /**
     * Gets the tracks created by a user using their user ID
     */

  }, {
    key: "getTracksByUser",
    value: function () {
      var _getTracksByUser = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.getTracksByUserRaw(params, initOverrides);

              case 2:
                response = _context28.sent;
                _context28.next = 5;
                return response.value();

              case 5:
                return _context28.abrupt("return", _context28.sent);

              case 6:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getTracksByUser(_x55, _x56) {
        return _getTracksByUser.apply(this, arguments);
      }

      return getTracksByUser;
    }()
    /** @hidden
     * Gets a single user by their user ID
     */

  }, {
    key: "getUserRaw",
    value: function () {
      var _getUserRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context29.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getUser.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context29.next = 6;
                return this.request({
                  path: "/users/{id}".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context29.sent;
                return _context29.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return UserResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getUserRaw(_x57, _x58) {
        return _getUserRaw.apply(this, arguments);
      }

      return getUserRaw;
    }()
    /**
     * Gets a single user by their user ID
     */

  }, {
    key: "getUser",
    value: function () {
      var _getUser = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this.getUserRaw(params, initOverrides);

              case 2:
                response = _context30.sent;
                _context30.next = 5;
                return response.value();

              case 5:
                return _context30.abrupt("return", _context30.sent);

              case 6:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getUser(_x59, _x60) {
        return _getUser.apply(this, arguments);
      }

      return getUser;
    }()
    /** @hidden
     * Gets a single user by their handle
     */

  }, {
    key: "getUserByHandleRaw",
    value: function () {
      var _getUserByHandleRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context31.next = 2;
                  break;
                }

                throw new RequiredError$1('handle', 'Required parameter params.handle was null or undefined when calling getUserByHandle.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context31.next = 7;
                return this.request({
                  path: "/users/handle/{handle}".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context31.sent;
                return _context31.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return UserResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getUserByHandleRaw(_x61, _x62) {
        return _getUserByHandleRaw.apply(this, arguments);
      }

      return getUserByHandleRaw;
    }()
    /**
     * Gets a single user by their handle
     */

  }, {
    key: "getUserByHandle",
    value: function () {
      var _getUserByHandle = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.getUserByHandleRaw(params, initOverrides);

              case 2:
                response = _context32.sent;
                _context32.next = 5;
                return response.value();

              case 5:
                return _context32.abrupt("return", _context32.sent);

              case 6:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getUserByHandle(_x63, _x64) {
        return _getUserByHandle.apply(this, arguments);
      }

      return getUserByHandle;
    }()
    /** @hidden
     * Gets a User ID from an associated wallet address
     */

  }, {
    key: "getUserIDFromWalletRaw",
    value: function () {
      var _getUserIDFromWalletRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                if (!(params.associatedWallet === null || params.associatedWallet === undefined)) {
                  _context33.next = 2;
                  break;
                }

                throw new RequiredError$1('associatedWallet', 'Required parameter params.associatedWallet was null or undefined when calling getUserIDFromWallet.');

              case 2:
                queryParameters = {};

                if (params.associatedWallet !== undefined) {
                  queryParameters['associated_wallet'] = params.associatedWallet;
                }

                headerParameters = {};
                _context33.next = 7;
                return this.request({
                  path: "/users/id",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context33.sent;
                return _context33.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return UserAssociatedWalletResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getUserIDFromWalletRaw(_x65, _x66) {
        return _getUserIDFromWalletRaw.apply(this, arguments);
      }

      return getUserIDFromWalletRaw;
    }()
    /**
     * Gets a User ID from an associated wallet address
     */

  }, {
    key: "getUserIDFromWallet",
    value: function () {
      var _getUserIDFromWallet = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                _context34.next = 2;
                return this.getUserIDFromWalletRaw(params, initOverrides);

              case 2:
                response = _context34.sent;
                _context34.next = 5;
                return response.value();

              case 5:
                return _context34.abrupt("return", _context34.sent);

              case 6:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function getUserIDFromWallet(_x67, _x68) {
        return _getUserIDFromWallet.apply(this, arguments);
      }

      return getUserIDFromWallet;
    }()
    /** @hidden
     * Search for users that match the given query
     */

  }, {
    key: "searchUsersRaw",
    value: function () {
      var _searchUsersRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context35.next = 2;
                  break;
                }

                throw new RequiredError$1('query', 'Required parameter params.query was null or undefined when calling searchUsers.');

              case 2:
                queryParameters = {};

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                headerParameters = {};
                _context35.next = 7;
                return this.request({
                  path: "/users/search",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context35.sent;
                return _context35.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return UserSearchFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function searchUsersRaw(_x69, _x70) {
        return _searchUsersRaw.apply(this, arguments);
      }

      return searchUsersRaw;
    }()
    /**
     * Search for users that match the given query
     */

  }, {
    key: "searchUsers",
    value: function () {
      var _searchUsers = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee36(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                _context36.next = 2;
                return this.searchUsersRaw(params, initOverrides);

              case 2:
                response = _context36.sent;
                _context36.next = 5;
                return response.value();

              case 5:
                return _context36.abrupt("return", _context36.sent);

              case 6:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function searchUsers(_x71, _x72) {
        return _searchUsers.apply(this, arguments);
      }

      return searchUsers;
    }()
    /** @hidden
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     */

  }, {
    key: "verifyIDTokenRaw",
    value: function () {
      var _verifyIDTokenRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                if (!(params.token === null || params.token === undefined)) {
                  _context37.next = 2;
                  break;
                }

                throw new RequiredError$1('token', 'Required parameter params.token was null or undefined when calling verifyIDToken.');

              case 2:
                queryParameters = {};

                if (params.token !== undefined) {
                  queryParameters['token'] = params.token;
                }

                headerParameters = {};
                _context37.next = 7;
                return this.request({
                  path: "/users/verify_token",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context37.sent;
                return _context37.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return VerifyTokenFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function verifyIDTokenRaw(_x73, _x74) {
        return _verifyIDTokenRaw.apply(this, arguments);
      }

      return verifyIDTokenRaw;
    }()
    /**
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     */

  }, {
    key: "verifyIDToken",
    value: function () {
      var _verifyIDToken = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                _context38.next = 2;
                return this.verifyIDTokenRaw(params, initOverrides);

              case 2:
                response = _context38.sent;
                _context38.next = 5;
                return response.value();

              case 5:
                return _context38.abrupt("return", _context38.sent);

              case 6:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function verifyIDToken(_x75, _x76) {
        return _verifyIDToken.apply(this, arguments);
      }

      return verifyIDToken;
    }()
  }]);

  return UsersApi;
}(BaseAPI$1);
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortEnum$1 = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortMethodEnum$1 = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Length: 'length',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortDirectionEnum$1 = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleFilterTracksEnum$1 = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */

var GetTracksByUserSortEnum$1 = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetTracksByUserSortMethodEnum$1 = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Length: 'length',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetTracksByUserSortDirectionEnum$1 = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetTracksByUserFilterTracksEnum$1 = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};

var CreateDeveloperAppSchema = z.object({
  name: z.string(),
  description: z.optional(z.string().max(128)),
  userId: HashId
});
var DeleteDeveloperAppSchema = z.object({
  userId: HashId,
  appApiKey: z.custom(function (data) {
    return isApiKeyValid(data);
  })
});

var DeveloperAppsApi = /*#__PURE__*/function (_GeneratedDeveloperAp) {
  _inherits(DeveloperAppsApi, _GeneratedDeveloperAp);

  var _super = _createSuper(DeveloperAppsApi);

  function DeveloperAppsApi(config, entityManager, auth) {
    var _this;

    _classCallCheck$1(this, DeveloperAppsApi);

    _this = _super.call(this, config);

    _defineProperty$4(_assertThisInitialized(_this), "entityManager", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "web3", void 0);

    _this.entityManager = entityManager;
    _this.auth = auth;
    _this.web3 = new Web3$1();
    return _this;
  }
  /**
   * Create a developer app
   */


  _createClass$1(DeveloperAppsApi, [{
    key: "createDeveloperApp",
    value: function () {
      var _createDeveloperApp = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, advancedOptions) {
        var _yield$parseParams, name, userId, description, wallet, privateKey, address, unixTs, message, signature, response, apiKey, apiSecret;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return parseParams('createDeveloperApp', CreateDeveloperAppSchema)(params);

              case 2:
                _yield$parseParams = _context.sent;
                name = _yield$parseParams.name;
                userId = _yield$parseParams.userId;
                description = _yield$parseParams.description;
                wallet = this.web3.eth.accounts.create();
                privateKey = wallet.privateKey;
                address = wallet.address;
                unixTs = Math.round(new Date().getTime() / 1000); // current unix timestamp (sec)

                message = "Creating Audius developer app at ".concat(unixTs);
                signature = wallet.sign(message).signature;
                _context.next = 14;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.DEVELOPER_APP,
                  entityId: 0,
                  action: Action.CREATE,
                  metadata: JSON.stringify({
                    name: name,
                    description: description,
                    app_signature: {
                      message: message,
                      signature: signature
                    }
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 14:
                response = _context.sent;
                apiKey = address.slice(2).toLowerCase();
                apiSecret = privateKey.slice(2).toLowerCase();
                return _context.abrupt("return", _objectSpread2(_objectSpread2({}, response), {}, {
                  apiKey: apiKey,
                  apiSecret: apiSecret
                }));

              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function createDeveloperApp(_x, _x2) {
        return _createDeveloperApp.apply(this, arguments);
      }

      return createDeveloperApp;
    }()
    /**
     * Delete a developer app
     */

  }, {
    key: "deleteDeveloperApp",
    value: function () {
      var _deleteDeveloperApp = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        var _yield$parseParams2, userId, appApiKey;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return parseParams('deleteDeveloperApp', DeleteDeveloperAppSchema)(params);

              case 2:
                _yield$parseParams2 = _context2.sent;
                userId = _yield$parseParams2.userId;
                appApiKey = _yield$parseParams2.appApiKey;
                _context2.next = 7;
                return this.entityManager.manageEntity({
                  userId: userId,
                  entityType: EntityType.DEVELOPER_APP,
                  entityId: 0,
                  action: Action.DELETE,
                  metadata: JSON.stringify({
                    address: "0x".concat(appApiKey)
                  }),
                  auth: this.auth
                });

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function deleteDeveloperApp(_x3) {
        return _deleteDeveloperApp.apply(this, arguments);
      }

      return deleteDeveloperApp;
    }()
  }]);

  return DeveloperAppsApi;
}(DeveloperAppsApi$1);

var global$1 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

var lookup$1 = [];
var revLookup$1 = [];
var Arr$1 = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup$1[i] = code[i];
    revLookup$1[code.charCodeAt(i)] = i;
  }

  revLookup$1['-'.charCodeAt(0)] = 62;
  revLookup$1['_'.charCodeAt(0)] = 63;
}

function toByteArray$1 (b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr$1(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup$1[b64.charCodeAt(i)] << 18) | (revLookup$1[b64.charCodeAt(i + 1)] << 12) | (revLookup$1[b64.charCodeAt(i + 2)] << 6) | revLookup$1[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = (revLookup$1[b64.charCodeAt(i)] << 2) | (revLookup$1[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup$1[b64.charCodeAt(i)] << 10) | (revLookup$1[b64.charCodeAt(i + 1)] << 4) | (revLookup$1[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64$1 (num) {
  return lookup$1[num >> 18 & 0x3F] + lookup$1[num >> 12 & 0x3F] + lookup$1[num >> 6 & 0x3F] + lookup$1[num & 0x3F]
}

function encodeChunk$1 (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64$1(tmp));
  }
  return output.join('')
}

function fromByteArray$1 (uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk$1(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup$1[tmp >> 2];
    output += lookup$1[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup$1[tmp >> 10];
    output += lookup$1[(tmp >> 4) & 0x3F];
    output += lookup$1[(tmp << 2) & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('')
}

function read$1 (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

function write (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString$1 = {}.toString;

var isArray$5 = Array.isArray || function (arr) {
  return toString$1.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer$6.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
  ? global$1.TYPED_ARRAY_SUPPORT
  : true;

function kMaxLength () {
  return Buffer$6.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer$6.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer$6.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer$6(length);
    }
    that.length = length;
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer$6 (arg, encodingOrOffset, length) {
  if (!Buffer$6.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$6)) {
    return new Buffer$6(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from$4(this, arg, encodingOrOffset, length)
}

Buffer$6.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer$6._augment = function (arr) {
  arr.__proto__ = Buffer$6.prototype;
  return arr
};

function from$4 (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer$6.from = function (value, encodingOrOffset, length) {
  return from$4(null, value, encodingOrOffset, length)
};

if (Buffer$6.TYPED_ARRAY_SUPPORT) {
  Buffer$6.prototype.__proto__ = Uint8Array.prototype;
  Buffer$6.__proto__ = Uint8Array;
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer$6.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
};

function allocUnsafe (that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer$6.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer$6.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer$6.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
};

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer$6.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength$1(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer$6.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer$6.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that
}

function fromObject (that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len);
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray$5(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}
Buffer$6.isBuffer = isBuffer$4;
function internalIsBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer$6.compare = function compare (a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer$6.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer$6.concat = function concat (list, length) {
  if (!isArray$5(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer$6.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer$6.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

function byteLength$1 (string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$6.byteLength = byteLength$1;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer$6.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer$6.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer$6.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer$6.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer$6.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer$6.prototype.equals = function equals (b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer$6.compare(this, b) === 0
};

Buffer$6.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};

Buffer$6.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset;  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer$6.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer$6.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer$6.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer$6.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer$6.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer$6.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer$6.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray$1(buf)
  } else {
    return fromByteArray$1(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}

Buffer$6.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer$6.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$6.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$6(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer$6.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer$6.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer$6.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer$6.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer$6.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer$6.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer$6.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer$6.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$6.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$6.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer$6.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$6.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$6.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer$6.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer$6.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read$1(this, offset, true, 23, 4)
};

Buffer$6.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read$1(this, offset, false, 23, 4)
};

Buffer$6.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read$1(this, offset, true, 52, 8)
};

Buffer$6.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read$1(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer$6.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$6.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$6.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer$6.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer$6.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$6.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$6.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$6.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}

Buffer$6.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$6.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$6.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$6.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

Buffer$6.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$6.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$6.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer$6.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer$6.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$6.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$6.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$6.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

Buffer$6.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer$6.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$6.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer$6.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer$6.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer$6.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer$6.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer$6.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer$6.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer$6.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer$6.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer$6.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val)
      ? val
      : utf8ToBytes(new Buffer$6(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}


function base64ToBytes (str) {
  return toByteArray$1(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer$4(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}

function isFastBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
}

var browser$2 = {exports: {}};

var lib$4 = {};

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser = true;
var env = {};
var argv = [];
var version$1 = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};

function noop$2() {}

var on = noop$2;
var addListener = noop$2;
var once$3 = noop$2;
var off = noop$2;
var removeListener = noop$2;
var removeAllListeners = noop$2;
var emit = noop$2;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var browser$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version$1,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once$3,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

var readable = {exports: {}};

var events = {exports: {}};

var R = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

events.exports = EventEmitter;
events.exports.once = once$2; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + _typeof(listener));
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) {
      ReflectApply(listeners[i], this, args);
    }
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) {
    copy[i] = arr[i];
  }

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) {
    list[index] = list[index + 1];
  }

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once$2(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });

    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }

      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + _typeof(emitter));
  }
}

var EventEmitter$1 = events.exports;

var stream$1 = require$$0$3;

var buffer = {};

var base64Js = {};

base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code$1.length; i < len; ++i) {
  lookup[i] = code$1[i];
  revLookup[code$1.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

var ieee754 = {};

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

(function (exports) {

  var base64 = base64Js;
  var ieee754$1 = ieee754;
  var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
  ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
  : null;
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 0x7fffffff;
  exports.kMaxLength = K_MAX_LENGTH;
  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Print warning and recommend using `buffer` v4.x which has an Object
   *               implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * We report that the browser does not support typed arrays if the are not subclassable
   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
   * for __proto__ and has a buggy typed array implementation.
   */

  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
  }

  function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
      var arr = new Uint8Array(1);
      var proto = {
        foo: function foo() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }

  Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function get() {
      if (!Buffer.isBuffer(this)) return undefined;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function get() {
      if (!Buffer.isBuffer(this)) return undefined;
      return this.byteOffset;
    }
  });

  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    } // Return an augmented `Uint8Array` instance


    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */


  function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }

      return allocUnsafe(arg);
    }

    return from(arg, encodingOrOffset, length);
  }

  Buffer.poolSize = 8192; // not used by this implementation

  function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') {
      return fromString(value, encodingOrOffset);
    }

    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }

    if (value == null) {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
    }

    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }

    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }

    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }

    var valueOf = value.valueOf && value.valueOf();

    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length);
    }

    var b = fromObject(value);
    if (b) return b;

    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
      return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    }

    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
  }
  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/


  Buffer.from = function (value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
  // https://github.com/feross/buffer/pull/148


  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer, Uint8Array);

  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }

  function alloc(size, fill, encoding) {
    assertSize(size);

    if (size <= 0) {
      return createBuffer(size);
    }

    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpreted as a start offset.
      return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }

    return createBuffer(size);
  }
  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/


  Buffer.alloc = function (size, fill, encoding) {
    return alloc(size, fill, encoding);
  };

  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */


  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(size);
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */


  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(size);
  };

  function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }

    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      buf = buf.slice(0, actual);
    }

    return buf;
  }

  function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);

    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }

    return buf;
  }

  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }

    return fromArrayLike(arrayView);
  }

  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }

    var buf;

    if (byteOffset === undefined && length === undefined) {
      buf = new Uint8Array(array);
    } else if (length === undefined) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    } // Return an augmented `Uint8Array` instance


    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }

  function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer(len);

      if (buf.length === 0) {
        return buf;
      }

      obj.copy(buf, 0, 0, len);
      return buf;
    }

    if (obj.length !== undefined) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }

      return fromArrayLike(obj);
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }

  function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
    }

    return length | 0;
  }

  function SlowBuffer(length) {
    if (+length != length) {
      // eslint-disable-line eqeqeq
      length = 0;
    }

    return Buffer.alloc(+length);
  }

  Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
  };

  Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }

    if (a === b) return 0;
    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;

      default:
        return false;
    }
  };

  Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    if (list.length === 0) {
      return Buffer.alloc(0);
    }

    var i;

    if (length === undefined) {
      length = 0;

      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;

    for (i = 0; i < list.length; ++i) {
      var buf = list[i];

      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer.length) {
          if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
          buf.copy(buffer, pos);
        } else {
          Uint8Array.prototype.set.call(buffer, buf, pos);
        }
      } else if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer, pos);
      }

      pos += buf.length;
    }

    return buffer;
  };

  function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length;
    }

    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }

    if (typeof string !== 'string') {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));
    }

    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len;

        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;

        case 'hex':
          return len >>> 1;

        case 'base64':
          return base64ToBytes(string).length;

        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
          }

          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }

  Buffer.byteLength = byteLength;

  function slowToString(encoding, start, end) {
    var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

    if (start === undefined || start < 0) {
      start = 0;
    } // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.


    if (start > this.length) {
      return '';
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return '';
    } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.


    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return '';
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);

        case 'ascii':
          return asciiSlice(this, start, end);

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end);

        case 'base64':
          return base64Slice(this, start, end);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  } // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
  // reliably in a browserify context because there could be multiple different
  // copies of the 'buffer' package in use. This method works even for Buffer
  // instances that were created from another copy of the `buffer` package.
  // See: https://github.com/feross/buffer/issues/154


  Buffer.prototype._isBuffer = true;

  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16() {
    var len = this.length;

    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }

    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }

    return this;
  };

  Buffer.prototype.swap32 = function swap32() {
    var len = this.length;

    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }

    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }

    return this;
  };

  Buffer.prototype.swap64 = function swap64() {
    var len = this.length;

    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }

    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }

    return this;
  };

  Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };

  Buffer.prototype.toLocaleString = Buffer.prototype.toString;

  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };

  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
  };

  if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
  }

  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength);
    }

    if (!Buffer.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));
    }

    if (start === undefined) {
      start = 0;
    }

    if (end === undefined) {
      end = target ? target.length : 0;
    }

    if (thisStart === undefined) {
      thisStart = 0;
    }

    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index');
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }

    if (thisStart >= thisEnd) {
      return -1;
    }

    if (start >= end) {
      return 1;
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf


  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1; // Normalize byteOffset

    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }

    byteOffset = +byteOffset; // Coerce to Number.

    if (numberIsNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : buffer.length - 1;
    } // Normalize byteOffset: negative offsets start from the end of the buffer


    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

    if (byteOffset >= buffer.length) {
      if (dir) return -1;else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;else return -1;
    } // Normalize val


    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    } // Finally, search either indexOf (if dir is true) or lastIndexOf


    if (Buffer.isBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1;
      }

      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]

      if (typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }

      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }

    throw new TypeError('val must be string, number or Buffer');
  }

  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();

      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }

        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read(buf, i) {
      if (indexSize === 1) {
        return buf[i];
      } else {
        return buf.readUInt16BE(i * indexSize);
      }
    }

    var i;

    if (dir) {
      var foundIndex = -1;

      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

      for (i = byteOffset; i >= 0; i--) {
        var found = true;

        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }

        if (found) return i;
      }
    }

    return -1;
  }

  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };

  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };

  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;

    if (!length) {
      length = remaining;
    } else {
      length = Number(length);

      if (length > remaining) {
        length = remaining;
      }
    }

    var strLen = string.length;

    if (length > strLen / 2) {
      length = strLen / 2;
    }

    var i;

    for (i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }

    return i;
  }

  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }

  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }

  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }

  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }

  Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0; // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0; // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset >>> 0;

      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';
    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);

        case 'ascii':
        case 'latin1':
        case 'binary':
          return asciiWrite(this, string, offset, length);

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };

  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }

  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;

    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte = void 0,
            thirdByte = void 0,
            fourthByte = void 0,
            tempCodePoint = void 0;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }

            break;

          case 2:
            secondByte = buf[i + 1];

            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }

        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res);
  } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety


  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;

    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    } // Decode in chunks to avoid "call stack size exceeded".


    var res = '';
    var i = 0;

    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }

    return res;
  }

  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }

    return ret;
  }

  function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }

    return ret;
  }

  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';

    for (var i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }

    return out;
  }

  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)

    for (var i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }

    return res;
  }

  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;
    var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
  };
  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */


  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }

  Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;

    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;

    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };

  Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };

  Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };

  Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };

  Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };

  Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    var first = this[offset];
    var last = this[offset + 7];

    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8);
    }

    var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
    var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    var first = this[offset];
    var last = this[offset + 7];

    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8);
    }

    var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
    var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });

  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];

    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };

  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };

  Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    var first = this[offset];
    var last = this[offset + 7];

    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8);
    }

    var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24); // Overflow

    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
  });
  Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    var first = this[offset];
    var last = this[offset + 7];

    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8);
    }

    var val = (first << 24) + // Overflow
    this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
  });

  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };

  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };

  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
  }

  Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };

  Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
  };

  Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
  };

  Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
  };

  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    var lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }

  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    var lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }

  Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
  });
  Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
  });

  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
  };

  Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
  });
  Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
  });

  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
  }

  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;

    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }

    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };

  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;

    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }

    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }

    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

    if (end > this.length) end = this.length;

    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;

    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
      // Use built-in when available, missing from IE11
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }

    return len;
  }; // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])


  Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }

      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }

      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }

      if (val.length === 1) {
        var code = val.charCodeAt(0);

        if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
          // Fast path: If `val` fits into a single byte, use that numeric value.
          val = code;
        }
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    } else if (typeof val === 'boolean') {
      val = Number(val);
    } // Invalid ranges are not set to a default, so can range check early.


    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }

    if (end <= start) {
      return this;
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;

    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
      var len = bytes.length;

      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }

      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this;
  }; // CUSTOM ERRORS
  // =============
  // Simplified versions from Node, changed for Buffer-only usage


  var errors = {};

  function E(sym, getMessage, Base) {
    errors[sym] = /*#__PURE__*/function (_Base) {
      _inherits(NodeError, _Base);

      var _super = _createSuper(NodeError);

      function NodeError() {
        var _this;

        _classCallCheck$1(this, NodeError);

        _this = _super.call(this);
        Object.defineProperty(_assertThisInitialized(_this), 'message', {
          value: getMessage.apply(_assertThisInitialized(_this), arguments),
          writable: true,
          configurable: true
        }); // Add the error code to the name to include it in the stack trace.

        _this.name = "".concat(_this.name, " [").concat(sym, "]"); // Access the stack to generate the error message including the error code
        // from the name.

        _this.stack; // eslint-disable-line no-unused-expressions
        // Reset the name to the actual name.

        delete _this.name;
        return _this;
      }

      _createClass$1(NodeError, [{
        key: "code",
        get: function get() {
          return sym;
        },
        set: function set(value) {
          Object.defineProperty(this, 'code', {
            configurable: true,
            enumerable: true,
            value: value,
            writable: true
          });
        }
      }, {
        key: "toString",
        value: function toString() {
          return "".concat(this.name, " [").concat(sym, "]: ").concat(this.message);
        }
      }]);

      return NodeError;
    }(Base);
  }

  E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
    if (name) {
      return "".concat(name, " is outside of buffer bounds");
    }

    return 'Attempt to access memory outside buffer bounds';
  }, RangeError);
  E('ERR_INVALID_ARG_TYPE', function (name, actual) {
    return "The \"".concat(name, "\" argument must be of type number. Received type ").concat(_typeof(actual));
  }, TypeError);
  E('ERR_OUT_OF_RANGE', function (str, range, input) {
    var msg = "The value of \"".concat(str, "\" is out of range.");
    var received = input;

    if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === 'bigint') {
      received = String(input);

      if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
        received = addNumericalSeparator(received);
      }

      received += 'n';
    }

    msg += " It must be ".concat(range, ". Received ").concat(received);
    return msg;
  }, RangeError);

  function addNumericalSeparator(val) {
    var res = '';
    var i = val.length;
    var start = val[0] === '-' ? 1 : 0;

    for (; i >= start + 4; i -= 3) {
      res = "_".concat(val.slice(i - 3, i)).concat(res);
    }

    return "".concat(val.slice(0, i)).concat(res);
  } // CHECK FUNCTIONS
  // ===============


  function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, 'offset');

    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
      boundsError(offset, buf.length - (byteLength + 1));
    }
  }

  function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
      var n = typeof min === 'bigint' ? 'n' : '';
      var range;

      if (byteLength > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = ">= 0".concat(n, " and < 2").concat(n, " ** ").concat((byteLength + 1) * 8).concat(n);
        } else {
          range = ">= -(2".concat(n, " ** ").concat((byteLength + 1) * 8 - 1).concat(n, ") and < 2 ** ") + "".concat((byteLength + 1) * 8 - 1).concat(n);
        }
      } else {
        range = ">= ".concat(min).concat(n, " and <= ").concat(max).concat(n);
      }

      throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }

    checkBounds(buf, offset, byteLength);
  }

  function validateNumber(value, name) {
    if (typeof value !== 'number') {
      throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
    }
  }

  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
    }

    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }

    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', ">= ".concat(type ? 1 : 0, " and <= ").concat(length), value);
  } // HELPER FUNCTIONS
  // ================


  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

  function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

    str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

    if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

    while (str.length % 4 !== 0) {
      str = str + '=';
    }

    return str;
  }

  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i); // is surrogate component

      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } // valid lead


          leadSurrogate = codePoint;
          continue;
        } // 2 leads in a row


        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        } // valid surrogate pair


        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null; // encode utf8

      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function asciiToBytes(str) {
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }

    return byteArray;
  }

  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray;
  }

  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }

  function blitBuffer(src, dst, offset, length) {
    var i;

    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }

    return i;
  } // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
  // the `instanceof` check but they should be treated as of that type.
  // See: https://github.com/feross/buffer/issues/166


  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }

  function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj; // eslint-disable-line no-self-compare
  } // Create lookup table for `toString('hex')`
  // See: https://github.com/feross/buffer/issues/219


  var hexSliceLookupTable = function () {
    var alphabet = '0123456789abcdef';
    var table = new Array(256);

    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16;

      for (var j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }

    return table;
  }(); // Return not function with Error if BigInt not supported


  function defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
  }

  function BufferBigIntNotDefined() {
    throw new Error('BigInt not supported');
  }
})(buffer);

var util$2 = {};

var types$1 = {};

/* eslint complexity: [2, 18], max-statements: [2, 33] */


var shams$1 = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }

  if (_typeof(Symbol.iterator) === 'symbol') {
    return true;
  }

  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);

  if (typeof sym === 'string') {
    return false;
  }

  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }

  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  } // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }
  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }


  var symVal = 42;
  obj[sym] = symVal;

  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax, no-unreachable-loop


  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }

  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }

  var syms = Object.getOwnPropertySymbols(obj);

  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }

  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }

  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);

    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }

  return true;
};

var hasSymbols$2 = shams$1;

var shams = function hasToStringTagShams() {
  return hasSymbols$2() && !!Symbol.toStringTag;
};

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = shams$1;

var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }

  if (typeof Symbol !== 'function') {
    return false;
  }

  if (_typeof(origSymbol('foo')) !== 'symbol') {
    return false;
  }

  if (_typeof(Symbol('bar')) !== 'symbol') {
    return false;
  }

  return hasSymbolSham();
};

/* eslint no-invalid-this: 1 */


var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr$1 = Object.prototype.toString;
var funcType = '[object Function]';

var implementation$1 = function bind(that) {
  var target = this;

  if (typeof target !== 'function' || toStr$1.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }

  var args = slice.call(arguments, 1);
  var bound;

  var binder = function binder() {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice.call(arguments)));

      if (Object(result) === result) {
        return result;
      }

      return this;
    } else {
      return target.apply(that, args.concat(slice.call(arguments)));
    }
  };

  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];

  for (var i = 0; i < boundLength; i++) {
    boundArgs.push('$' + i);
  }

  bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

  if (target.prototype) {
    var Empty = function Empty() {};

    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }

  return bound;
};

var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;

var bind$1 = functionBind;
var src$3 = bind$1.call(Function.call, Object.prototype.hasOwnProperty);

var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError; // eslint-disable-next-line consistent-return

var getEvalledConstructor = function getEvalledConstructor(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  } catch (e) {}
};

var $gOPD$1 = Object.getOwnPropertyDescriptor;

if ($gOPD$1) {
  try {
    $gOPD$1({}, '');
  } catch (e) {
    $gOPD$1 = null; // this is IE 8, which has a broken gOPD
  }
}

var throwTypeError = function throwTypeError() {
  throw new $TypeError();
};

var ThrowTypeError = $gOPD$1 ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here

    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD$1(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols = hasSymbols$1();

var getProto$1 = Object.getPrototypeOf || function (x) {
  return x.__proto__;
}; // eslint-disable-line no-proto


var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto$1(Uint8Array);
var INTRINSICS = {
  '%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
  '%ArrayIteratorPrototype%': hasSymbols ? getProto$1([][Symbol.iterator]()) : undefined$1,
  '%AsyncFromSyncIteratorPrototype%': undefined$1,
  '%AsyncFunction%': needsEval,
  '%AsyncGenerator%': needsEval,
  '%AsyncGeneratorFunction%': needsEval,
  '%AsyncIteratorPrototype%': needsEval,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
  '%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
  '%Boolean%': Boolean,
  '%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
  '%Date%': Date,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': Error,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': EvalError,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
  '%Function%': $Function,
  '%GeneratorFunction%': needsEval,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  '%JSON%': (typeof JSON === "undefined" ? "undefined" : _typeof(JSON)) === 'object' ? JSON : undefined$1,
  '%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined$1 : getProto$1(new Map()[Symbol.iterator]()),
  '%Math%': Math,
  '%Number%': Number,
  '%Object%': Object,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
  '%RangeError%': RangeError,
  '%ReferenceError%': ReferenceError,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
  '%RegExp%': RegExp,
  '%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined$1 : getProto$1(new Set()[Symbol.iterator]()),
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols ? getProto$1(''[Symbol.iterator]()) : undefined$1,
  '%Symbol%': hasSymbols ? Symbol : undefined$1,
  '%SyntaxError%': $SyntaxError,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypeError%': $TypeError,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
  '%URIError%': URIError,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
  '%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet
};

var doEval = function doEval(name) {
  var value;

  if (name === '%AsyncFunction%') {
    value = getEvalledConstructor('async function () {}');
  } else if (name === '%GeneratorFunction%') {
    value = getEvalledConstructor('function* () {}');
  } else if (name === '%AsyncGeneratorFunction%') {
    value = getEvalledConstructor('async function* () {}');
  } else if (name === '%AsyncGenerator%') {
    var fn = doEval('%AsyncGeneratorFunction%');

    if (fn) {
      value = fn.prototype;
    }
  } else if (name === '%AsyncIteratorPrototype%') {
    var gen = doEval('%AsyncGenerator%');

    if (gen) {
      value = getProto$1(gen.prototype);
    }
  }

  INTRINSICS[name] = value;
  return value;
};

var LEGACY_ALIASES = {
  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  '%ArrayPrototype%': ['Array', 'prototype'],
  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  '%BooleanPrototype%': ['Boolean', 'prototype'],
  '%DataViewPrototype%': ['DataView', 'prototype'],
  '%DatePrototype%': ['Date', 'prototype'],
  '%ErrorPrototype%': ['Error', 'prototype'],
  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  '%FunctionPrototype%': ['Function', 'prototype'],
  '%Generator%': ['GeneratorFunction', 'prototype'],
  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  '%JSONParse%': ['JSON', 'parse'],
  '%JSONStringify%': ['JSON', 'stringify'],
  '%MapPrototype%': ['Map', 'prototype'],
  '%NumberPrototype%': ['Number', 'prototype'],
  '%ObjectPrototype%': ['Object', 'prototype'],
  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  '%PromisePrototype%': ['Promise', 'prototype'],
  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  '%Promise_all%': ['Promise', 'all'],
  '%Promise_reject%': ['Promise', 'reject'],
  '%Promise_resolve%': ['Promise', 'resolve'],
  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  '%RegExpPrototype%': ['RegExp', 'prototype'],
  '%SetPrototype%': ['Set', 'prototype'],
  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  '%StringPrototype%': ['String', 'prototype'],
  '%SymbolPrototype%': ['Symbol', 'prototype'],
  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  '%URIErrorPrototype%': ['URIError', 'prototype'],
  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
  '%WeakSetPrototype%': ['WeakSet', 'prototype']
};
var bind = functionBind;
var hasOwn$2 = src$3;
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */

var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
/** Used to match backslashes in property paths. */

var stringToPath = function stringToPath(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);

  if (first === '%' && last !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
  } else if (last === '%' && first !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
  }

  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */


var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;

  if (hasOwn$2(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = '%' + alias[0] + '%';
  }

  if (hasOwn$2(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];

    if (value === needsEval) {
      value = doEval(intrinsicName);
    }

    if (typeof value === 'undefined' && !allowMissing) {
      throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }

    return {
      alias: alias,
      name: intrinsicName,
      value: value
    };
  }

  throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new $TypeError('intrinsic name must be a non-empty string');
  }

  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }

  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
  var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;

  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }

  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);

    if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
      throw new $SyntaxError('property names with quotes must have matching quotes');
    }

    if (part === 'constructor' || !isOwn) {
      skipFurtherCaching = true;
    }

    intrinsicBaseName += '.' + part;
    intrinsicRealName = '%' + intrinsicBaseName + '%';

    if (hasOwn$2(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }

        return void undefined$1;
      }

      if ($gOPD$1 && i + 1 >= parts.length) {
        var desc = $gOPD$1(value, part);
        isOwn = !!desc; // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.

        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$2(value, part);
        value = value[part];
      }

      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }

  return value;
};

var callBind$1 = {exports: {}};

(function (module) {

  var bind = functionBind;
  var GetIntrinsic = getIntrinsic;
  var $apply = GetIntrinsic('%Function.prototype.apply%');
  var $call = GetIntrinsic('%Function.prototype.call%');
  var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
  var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
  var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
  var $max = GetIntrinsic('%Math.max%');

  if ($defineProperty) {
    try {
      $defineProperty({}, 'a', {
        value: 1
      });
    } catch (e) {
      // IE 8 has a broken defineProperty
      $defineProperty = null;
    }
  }

  module.exports = function callBind(originalFunction) {
    var func = $reflectApply(bind, $call, arguments);

    if ($gOPD && $defineProperty) {
      var desc = $gOPD(func, 'length');

      if (desc.configurable) {
        // original length, plus the receiver, minus any additional arguments (after the receiver)
        $defineProperty(func, 'length', {
          value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
        });
      }
    }

    return func;
  };

  var applyBind = function applyBind() {
    return $reflectApply(bind, $apply, arguments);
  };

  if ($defineProperty) {
    $defineProperty(module.exports, 'apply', {
      value: applyBind
    });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$1);

var GetIntrinsic$1 = getIntrinsic;
var callBind = callBind$1.exports;
var $indexOf$1 = callBind(GetIntrinsic$1('String.prototype.indexOf'));

var callBound$3 = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic$1(name, !!allowMissing);

  if (typeof intrinsic === 'function' && $indexOf$1(name, '.prototype.') > -1) {
    return callBind(intrinsic);
  }

  return intrinsic;
};

var hasToStringTag$3 = shams();
var callBound$2 = callBound$3;
var $toString$2 = callBound$2('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
  if (hasToStringTag$3 && value && _typeof(value) === 'object' && Symbol.toStringTag in value) {
    return false;
  }

  return $toString$2(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
  if (isStandardArguments(value)) {
    return true;
  }

  return value !== null && _typeof(value) === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString$2(value) !== '[object Array]' && $toString$2(value.callee) === '[object Function]';
};

var supportsStandardArguments = function () {
  return isStandardArguments(arguments);
}();

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

var isArguments$4 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag$2 = shams();
var getProto = Object.getPrototypeOf;

var getGeneratorFunc = function getGeneratorFunc() {
  // eslint-disable-line consistent-return
  if (!hasToStringTag$2) {
    return false;
  }

  try {
    return Function('return function*() {}')();
  } catch (e) {}
};

var GeneratorFunction;

var isGeneratorFunction = function isGeneratorFunction(fn) {
  if (typeof fn !== 'function') {
    return false;
  }

  if (isFnRegex.test(fnToStr.call(fn))) {
    return true;
  }

  if (!hasToStringTag$2) {
    var str = toStr.call(fn);
    return str === '[object GeneratorFunction]';
  }

  if (!getProto) {
    return false;
  }

  if (typeof GeneratorFunction === 'undefined') {
    var generatorFunc = getGeneratorFunc();
    GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
  }

  return getProto(fn) === GeneratorFunction;
};

var hasOwn$1 = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

var foreach = function forEach(obj, fn, ctx) {
  if (toString.call(fn) !== '[object Function]') {
    throw new TypeError('iterator must be a function');
  }

  var l = obj.length;

  if (l === +l) {
    for (var i = 0; i < l; i++) {
      fn.call(ctx, obj[i], i, obj);
    }
  } else {
    for (var k in obj) {
      if (hasOwn$1.call(obj, k)) {
        fn.call(ctx, obj[k], k, obj);
      }
    }
  }
};

var possibleNames = ['BigInt64Array', 'BigUint64Array', 'Float32Array', 'Float64Array', 'Int16Array', 'Int32Array', 'Int8Array', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray'];
var g$2 = typeof globalThis === 'undefined' ? commonjsGlobal : globalThis;

var availableTypedArrays$2 = function availableTypedArrays() {
  var out = [];

  for (var i = 0; i < possibleNames.length; i++) {
    if (typeof g$2[possibleNames[i]] === 'function') {
      out[out.length] = possibleNames[i];
    }
  }

  return out;
};

var GetIntrinsic = getIntrinsic;
var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
  try {
    $gOPD([], 'length');
  } catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
  }
}

var getOwnPropertyDescriptor = $gOPD;

var forEach$1 = foreach;
var availableTypedArrays$1 = availableTypedArrays$2;
var callBound$1 = callBound$3;
var $toString$1 = callBound$1('Object.prototype.toString');
var hasToStringTag$1 = shams();
var g$1 = typeof globalThis === 'undefined' ? commonjsGlobal : globalThis;
var typedArrays$1 = availableTypedArrays$1();

var $indexOf = callBound$1('Array.prototype.indexOf', true) || function indexOf(array, value) {
  for (var i = 0; i < array.length; i += 1) {
    if (array[i] === value) {
      return i;
    }
  }

  return -1;
};

var $slice$1 = callBound$1('String.prototype.slice');
var toStrTags$1 = {};
var gOPD$1 = getOwnPropertyDescriptor;
var getPrototypeOf$1 = Object.getPrototypeOf; // require('getprototypeof');

if (hasToStringTag$1 && gOPD$1 && getPrototypeOf$1) {
  forEach$1(typedArrays$1, function (typedArray) {
    var arr = new g$1[typedArray]();

    if (Symbol.toStringTag in arr) {
      var proto = getPrototypeOf$1(arr);
      var descriptor = gOPD$1(proto, Symbol.toStringTag);

      if (!descriptor) {
        var superProto = getPrototypeOf$1(proto);
        descriptor = gOPD$1(superProto, Symbol.toStringTag);
      }

      toStrTags$1[typedArray] = descriptor.get;
    }
  });
}

var tryTypedArrays$1 = function tryAllTypedArrays(value) {
  var anyTrue = false;
  forEach$1(toStrTags$1, function (getter, typedArray) {
    if (!anyTrue) {
      try {
        anyTrue = getter.call(value) === typedArray;
      } catch (e) {
        /**/
      }
    }
  });
  return anyTrue;
};

var isTypedArray$4 = function isTypedArray(value) {
  if (!value || _typeof(value) !== 'object') {
    return false;
  }

  if (!hasToStringTag$1 || !(Symbol.toStringTag in value)) {
    var tag = $slice$1($toString$1(value), 8, -1);
    return $indexOf(typedArrays$1, tag) > -1;
  }

  if (!gOPD$1) {
    return false;
  }

  return tryTypedArrays$1(value);
};

var forEach = foreach;
var availableTypedArrays = availableTypedArrays$2;
var callBound = callBound$3;
var $toString = callBound('Object.prototype.toString');
var hasToStringTag = shams();
var g = typeof globalThis === 'undefined' ? commonjsGlobal : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

if (hasToStringTag && gOPD && getPrototypeOf) {
  forEach(typedArrays, function (typedArray) {
    if (typeof g[typedArray] === 'function') {
      var arr = new g[typedArray]();

      if (Symbol.toStringTag in arr) {
        var proto = getPrototypeOf(arr);
        var descriptor = gOPD(proto, Symbol.toStringTag);

        if (!descriptor) {
          var superProto = getPrototypeOf(proto);
          descriptor = gOPD(superProto, Symbol.toStringTag);
        }

        toStrTags[typedArray] = descriptor.get;
      }
    }
  });
}

var tryTypedArrays = function tryAllTypedArrays(value) {
  var foundName = false;
  forEach(toStrTags, function (getter, typedArray) {
    if (!foundName) {
      try {
        var name = getter.call(value);

        if (name === typedArray) {
          foundName = name;
        }
      } catch (e) {}
    }
  });
  return foundName;
};

var isTypedArray$3 = isTypedArray$4;

var whichTypedArray = function whichTypedArray(value) {
  if (!isTypedArray$3(value)) {
    return false;
  }

  if (!hasToStringTag || !(Symbol.toStringTag in value)) {
    return $slice($toString(value), 8, -1);
  }

  return tryTypedArrays(value);
};

(function (exports) {

  var isArgumentsObject = isArguments$4;
  var isGeneratorFunction$1 = isGeneratorFunction;
  var whichTypedArray$1 = whichTypedArray;
  var isTypedArray = isTypedArray$4;

  function uncurryThis(f) {
    return f.call.bind(f);
  }

  var BigIntSupported = typeof BigInt !== 'undefined';
  var SymbolSupported = typeof Symbol !== 'undefined';
  var ObjectToString = uncurryThis(Object.prototype.toString);
  var numberValue = uncurryThis(Number.prototype.valueOf);
  var stringValue = uncurryThis(String.prototype.valueOf);
  var booleanValue = uncurryThis(Boolean.prototype.valueOf);

  if (BigIntSupported) {
    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
  }

  if (SymbolSupported) {
    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
  }

  function checkBoxedPrimitive(value, prototypeValueOf) {
    if (_typeof(value) !== 'object') {
      return false;
    }

    try {
      prototypeValueOf(value);
      return true;
    } catch (e) {
      return false;
    }
  }

  exports.isArgumentsObject = isArgumentsObject;
  exports.isGeneratorFunction = isGeneratorFunction$1;
  exports.isTypedArray = isTypedArray; // Taken from here and modified for better browser support
  // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js

  function isPromise(input) {
    return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && _typeof(input) === 'object' && typeof input.then === 'function' && typeof input["catch"] === 'function';
  }

  exports.isPromise = isPromise;

  function isArrayBufferView(value) {
    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
      return ArrayBuffer.isView(value);
    }

    return isTypedArray(value) || isDataView(value);
  }

  exports.isArrayBufferView = isArrayBufferView;

  function isUint8Array(value) {
    return whichTypedArray$1(value) === 'Uint8Array';
  }

  exports.isUint8Array = isUint8Array;

  function isUint8ClampedArray(value) {
    return whichTypedArray$1(value) === 'Uint8ClampedArray';
  }

  exports.isUint8ClampedArray = isUint8ClampedArray;

  function isUint16Array(value) {
    return whichTypedArray$1(value) === 'Uint16Array';
  }

  exports.isUint16Array = isUint16Array;

  function isUint32Array(value) {
    return whichTypedArray$1(value) === 'Uint32Array';
  }

  exports.isUint32Array = isUint32Array;

  function isInt8Array(value) {
    return whichTypedArray$1(value) === 'Int8Array';
  }

  exports.isInt8Array = isInt8Array;

  function isInt16Array(value) {
    return whichTypedArray$1(value) === 'Int16Array';
  }

  exports.isInt16Array = isInt16Array;

  function isInt32Array(value) {
    return whichTypedArray$1(value) === 'Int32Array';
  }

  exports.isInt32Array = isInt32Array;

  function isFloat32Array(value) {
    return whichTypedArray$1(value) === 'Float32Array';
  }

  exports.isFloat32Array = isFloat32Array;

  function isFloat64Array(value) {
    return whichTypedArray$1(value) === 'Float64Array';
  }

  exports.isFloat64Array = isFloat64Array;

  function isBigInt64Array(value) {
    return whichTypedArray$1(value) === 'BigInt64Array';
  }

  exports.isBigInt64Array = isBigInt64Array;

  function isBigUint64Array(value) {
    return whichTypedArray$1(value) === 'BigUint64Array';
  }

  exports.isBigUint64Array = isBigUint64Array;

  function isMapToString(value) {
    return ObjectToString(value) === '[object Map]';
  }

  isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());

  function isMap(value) {
    if (typeof Map === 'undefined') {
      return false;
    }

    return isMapToString.working ? isMapToString(value) : value instanceof Map;
  }

  exports.isMap = isMap;

  function isSetToString(value) {
    return ObjectToString(value) === '[object Set]';
  }

  isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());

  function isSet(value) {
    if (typeof Set === 'undefined') {
      return false;
    }

    return isSetToString.working ? isSetToString(value) : value instanceof Set;
  }

  exports.isSet = isSet;

  function isWeakMapToString(value) {
    return ObjectToString(value) === '[object WeakMap]';
  }

  isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());

  function isWeakMap(value) {
    if (typeof WeakMap === 'undefined') {
      return false;
    }

    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
  }

  exports.isWeakMap = isWeakMap;

  function isWeakSetToString(value) {
    return ObjectToString(value) === '[object WeakSet]';
  }

  isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());

  function isWeakSet(value) {
    return isWeakSetToString(value);
  }

  exports.isWeakSet = isWeakSet;

  function isArrayBufferToString(value) {
    return ObjectToString(value) === '[object ArrayBuffer]';
  }

  isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());

  function isArrayBuffer(value) {
    if (typeof ArrayBuffer === 'undefined') {
      return false;
    }

    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
  }

  exports.isArrayBuffer = isArrayBuffer;

  function isDataViewToString(value) {
    return ObjectToString(value) === '[object DataView]';
  }

  isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));

  function isDataView(value) {
    if (typeof DataView === 'undefined') {
      return false;
    }

    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
  }

  exports.isDataView = isDataView; // Store a copy of SharedArrayBuffer in case it's deleted elsewhere

  var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;

  function isSharedArrayBufferToString(value) {
    return ObjectToString(value) === '[object SharedArrayBuffer]';
  }

  function isSharedArrayBuffer(value) {
    if (typeof SharedArrayBufferCopy === 'undefined') {
      return false;
    }

    if (typeof isSharedArrayBufferToString.working === 'undefined') {
      isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
    }

    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
  }

  exports.isSharedArrayBuffer = isSharedArrayBuffer;

  function isAsyncFunction(value) {
    return ObjectToString(value) === '[object AsyncFunction]';
  }

  exports.isAsyncFunction = isAsyncFunction;

  function isMapIterator(value) {
    return ObjectToString(value) === '[object Map Iterator]';
  }

  exports.isMapIterator = isMapIterator;

  function isSetIterator(value) {
    return ObjectToString(value) === '[object Set Iterator]';
  }

  exports.isSetIterator = isSetIterator;

  function isGeneratorObject(value) {
    return ObjectToString(value) === '[object Generator]';
  }

  exports.isGeneratorObject = isGeneratorObject;

  function isWebAssemblyCompiledModule(value) {
    return ObjectToString(value) === '[object WebAssembly.Module]';
  }

  exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

  function isNumberObject(value) {
    return checkBoxedPrimitive(value, numberValue);
  }

  exports.isNumberObject = isNumberObject;

  function isStringObject(value) {
    return checkBoxedPrimitive(value, stringValue);
  }

  exports.isStringObject = isStringObject;

  function isBooleanObject(value) {
    return checkBoxedPrimitive(value, booleanValue);
  }

  exports.isBooleanObject = isBooleanObject;

  function isBigIntObject(value) {
    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
  }

  exports.isBigIntObject = isBigIntObject;

  function isSymbolObject(value) {
    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
  }

  exports.isSymbolObject = isSymbolObject;

  function isBoxedPrimitive(value) {
    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
  }

  exports.isBoxedPrimitive = isBoxedPrimitive;

  function isAnyArrayBuffer(value) {
    return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
  }

  exports.isAnyArrayBuffer = isAnyArrayBuffer;
  ['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function (method) {
    Object.defineProperty(exports, method, {
      enumerable: false,
      value: function value() {
        throw new Error(method + ' is not supported in userland');
      }
    });
  });
})(types$1);

var isBuffer$3 = function isBuffer(arg) {
  return arg instanceof Buffer$6;
};

var inherits = {exports: {}};

var inherits_browser = {exports: {}};

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function TempCtor() {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

try {
  var util$1 = require('util');
  /* istanbul ignore next */


  if (typeof util$1.inherits !== 'function') throw '';
  inherits.exports = util$1.inherits;
} catch (e) {
  /* istanbul ignore next */
  inherits.exports = inherits_browser.exports;
}

(function (exports) {
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};

    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }

    return descriptors;
  };

  var formatRegExp = /%[sdj%]/g;

  exports.format = function (f) {
    if (!isString(f)) {
      var objects = [];

      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }

      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function (x) {
      if (x === '%%') return '%';
      if (i >= len) return x;

      switch (x) {
        case '%s':
          return String(args[i++]);

        case '%d':
          return Number(args[i++]);

        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }

        default:
          return x;
      }
    });

    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }

    return str;
  }; // Mark that a method should not be used.
  // Returns a modified function which warns once by default.
  // If --no-deprecation is set, then it is a no-op.


  exports.deprecate = function (fn, msg) {
    if (typeof browser$1 !== 'undefined' && browser$1.noDeprecation === true) {
      return fn;
    } // Allow for deprecating things in the process of starting up.


    if (typeof browser$1 === 'undefined') {
      return function () {
        return exports.deprecate(fn, msg).apply(this, arguments);
      };
    }

    var warned = false;

    function deprecated() {
      if (!warned) {
        if (browser$1.throwDeprecation) {
          throw new Error(msg);
        } else if (browser$1.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }

        warned = true;
      }

      return fn.apply(this, arguments);
    }

    return deprecated;
  };

  var debugs = {};
  var debugEnvRegex = /^$/;

  if (browser$1.env.NODE_DEBUG) {
    var debugEnv = browser$1.env.NODE_DEBUG;
    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
    debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
  }

  exports.debuglog = function (set) {
    set = set.toUpperCase();

    if (!debugs[set]) {
      if (debugEnvRegex.test(set)) {
        var pid = browser$1.pid;

        debugs[set] = function () {
          var msg = exports.format.apply(exports, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        debugs[set] = function () {};
      }
    }

    return debugs[set];
  };
  /**
   * Echos the value of a value. Trys to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Object} opts Optional options object that alters the output.
   */

  /* legacy: obj, showHidden, depth, colors*/


  function inspect(obj, opts) {
    // default options
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    }; // legacy...

    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];

    if (isBoolean(opts)) {
      // legacy...
      ctx.showHidden = opts;
    } else if (opts) {
      // got an "options" object
      exports._extend(ctx, opts);
    } // set default options


    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }

  exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

  inspect.colors = {
    'bold': [1, 22],
    'italic': [3, 23],
    'underline': [4, 24],
    'inverse': [7, 27],
    'white': [37, 39],
    'grey': [90, 39],
    'black': [30, 39],
    'blue': [34, 39],
    'cyan': [36, 39],
    'green': [32, 39],
    'magenta': [35, 39],
    'red': [31, 39],
    'yellow': [33, 39]
  }; // Don't use 'blue' not visible on cmd.exe

  inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
  };

  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];

    if (style) {
      return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
    } else {
      return str;
    }
  }

  function stylizeNoColor(str, styleType) {
    return str;
  }

  function arrayToHash(array) {
    var hash = {};
    array.forEach(function (val, idx) {
      hash[val] = true;
    });
    return hash;
  }

  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);

      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }

      return ret;
    } // Primitive types cannot have properties


    var primitive = formatPrimitive(ctx, value);

    if (primitive) {
      return primitive;
    } // Look up the keys of the object.


    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);

    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    } // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
      return formatError(value);
    } // Some type of object without properties can be shortcutted.


    if (keys.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }

      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }

      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }

      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '',
        array = false,
        braces = ['{', '}']; // Make Array say that they are Array

    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    } // Make functions say that they are functions


    if (isFunction(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    } // Make RegExps say that they are RegExps


    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    } // Make dates with properties first say the date


    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    } // Make error with message first say the error


    if (isError(value)) {
      base = ' ' + formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);
    var output;

    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function (key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }

  function formatPrimitive(ctx, value) {
    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

    if (isString(value)) {
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');
    }

    if (isNumber(value)) return ctx.stylize('' + value, 'number');
    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

    if (isNull(value)) return ctx.stylize('null', 'null');
  }

  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }

  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];

    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
      } else {
        output.push('');
      }
    }

    keys.forEach(function (key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }

  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {
      value: value[key]
    };

    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }

    if (!hasOwnProperty(visibleKeys, key)) {
      name = '[' + key + ']';
    }

    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }

        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function (line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function (line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }

    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }

      name = JSON.stringify('' + key);

      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }

  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function (prev, cur) {
      if (cur.indexOf('\n') >= 0) ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  } // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.


  exports.types = types$1;

  function isArray(ar) {
    return Array.isArray(ar);
  }

  exports.isArray = isArray;

  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }

  exports.isBoolean = isBoolean;

  function isNull(arg) {
    return arg === null;
  }

  exports.isNull = isNull;

  function isNullOrUndefined(arg) {
    return arg == null;
  }

  exports.isNullOrUndefined = isNullOrUndefined;

  function isNumber(arg) {
    return typeof arg === 'number';
  }

  exports.isNumber = isNumber;

  function isString(arg) {
    return typeof arg === 'string';
  }

  exports.isString = isString;

  function isSymbol(arg) {
    return _typeof(arg) === 'symbol';
  }

  exports.isSymbol = isSymbol;

  function isUndefined(arg) {
    return arg === void 0;
  }

  exports.isUndefined = isUndefined;

  function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
  }

  exports.isRegExp = isRegExp;
  exports.types.isRegExp = isRegExp;

  function isObject(arg) {
    return _typeof(arg) === 'object' && arg !== null;
  }

  exports.isObject = isObject;

  function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
  }

  exports.isDate = isDate;
  exports.types.isDate = isDate;

  function isError(e) {
    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
  }

  exports.isError = isError;
  exports.types.isNativeError = isError;

  function isFunction(arg) {
    return typeof arg === 'function';
  }

  exports.isFunction = isFunction;

  function isPrimitive(arg) {
    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' || // ES6 symbol
    typeof arg === 'undefined';
  }

  exports.isPrimitive = isPrimitive;
  exports.isBuffer = isBuffer$3;

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }

  function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
  }

  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

  function timestamp() {
    var d = new Date();
    var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
    return [d.getDate(), months[d.getMonth()], time].join(' ');
  } // log is just a thin wrapper to console.log that prepends a timestamp


  exports.log = function () {
    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
  };
  /**
   * Inherit the prototype methods from one constructor into another.
   *
   * The Function.prototype.inherits from lang.js rewritten as a standalone
   * function (not on Function.prototype). NOTE: If this file is to be loaded
   * during bootstrapping this function needs to be rewritten using some native
   * functions as prototype setup using normal JavaScript does not work as
   * expected during bootstrapping (see mirror.js in r114903).
   *
   * @param {function} ctor Constructor function which needs to inherit the
   *     prototype.
   * @param {function} superCtor Constructor function to inherit prototype from.
   */


  exports.inherits = inherits.exports;

  exports._extend = function (origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;
    var keys = Object.keys(add);
    var i = keys.length;

    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }

    return origin;
  };

  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

  exports.promisify = function promisify(original) {
    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
      var fn = original[kCustomPromisifiedSymbol];

      if (typeof fn !== 'function') {
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      }

      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return fn;
    }

    function fn() {
      var promiseResolve, promiseReject;
      var promise = new Promise(function (resolve, reject) {
        promiseResolve = resolve;
        promiseReject = reject;
      });
      var args = [];

      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }

      args.push(function (err, value) {
        if (err) {
          promiseReject(err);
        } else {
          promiseResolve(value);
        }
      });

      try {
        original.apply(this, args);
      } catch (err) {
        promiseReject(err);
      }

      return promise;
    }

    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
  };

  exports.promisify.custom = kCustomPromisifiedSymbol;

  function callbackifyOnRejected(reason, cb) {
    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
    // Because `null` is a special error value in callbacks which means "no error
    // occurred", we error-wrap so the callback consumer can distinguish between
    // "the promise rejected with null" or "the promise fulfilled with undefined".
    if (!reason) {
      var newReason = new Error('Promise was rejected with a falsy value');
      newReason.reason = reason;
      reason = newReason;
    }

    return cb(reason);
  }

  function callbackify(original) {
    if (typeof original !== 'function') {
      throw new TypeError('The "original" argument must be of type Function');
    } // We DO NOT return the promise as it gives the user a false sense that
    // the promise is actually somehow related to the callback's execution
    // and that the callback throwing will reject the promise.


    function callbackified() {
      var args = [];

      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }

      var maybeCb = args.pop();

      if (typeof maybeCb !== 'function') {
        throw new TypeError('The last argument must be of type Function');
      }

      var self = this;

      var cb = function cb() {
        return maybeCb.apply(self, arguments);
      }; // In true node style we process the callback on `nextTick` with all the
      // implications (stack, `uncaughtException`, `async_hooks`)


      original.apply(this, args).then(function (ret) {
        browser$1.nextTick(cb.bind(null, null, ret));
      }, function (rej) {
        browser$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
      });
    }

    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
    return callbackified;
  }

  exports.callbackify = callbackify;
})(util$2);

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function (key) {
        _defineProperty$3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var _require$2 = buffer,
    Buffer$5 = _require$2.Buffer;
var _require2 = util$2,
    inspect$1 = _require2.inspect;
var custom = inspect$1 && inspect$1.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer$5.prototype.copy.call(src, target, offset);
}

var buffer_list = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer$5.alloc(0);
      var ret = Buffer$5.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer$5.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect$1(this, _objectSpread$1({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        browser$1.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        browser$1.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        browser$1.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        browser$1.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        browser$1.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      browser$1.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      browser$1.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy$2(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

var destroy_1 = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy$2
};

var errors = {};

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError = /*#__PURE__*/function (_Base) {
    _inherits(NodeError, _Base);

    var _super = _createSuper(NodeError);

    function NodeError(arg1, arg2, arg3) {
      _classCallCheck$1(this, NodeError);

      return _super.call(this, getMessage(arg1, arg2, arg3));
    }

    return _createClass$1(NodeError);
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
errors.codes = codes;

var ERR_INVALID_OPT_VALUE = errors.codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark$2(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

var state = {
  getHighWaterMark: getHighWaterMark$2
};

/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

var node = util$2.deprecate;

var _stream_writable = Writable$1;
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex$3;
/*</replacement>*/

Writable$1.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: node
};
/*</replacement>*/

/*<replacement>*/

var Stream$1 = stream$1;
/*</replacement>*/

var Buffer$4 = buffer.Buffer;

var OurUint8Array$1 = commonjsGlobal.Uint8Array || function () {};

function _uint8ArrayToBuffer$1(chunk) {
  return Buffer$4.from(chunk);
}

function _isUint8Array$1(obj) {
  return Buffer$4.isBuffer(obj) || obj instanceof OurUint8Array$1;
}

var destroyImpl$1 = destroy_1;
var _require$1 = state,
    getHighWaterMark$1 = _require$1.getHighWaterMark;
var _require$codes$3 = errors.codes,
    ERR_INVALID_ARG_TYPE$2 = _require$codes$3.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK$1 = _require$codes$3.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes$3.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED$1 = _require$codes$3.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes$3.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes$3.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes$3.ERR_UNKNOWN_ENCODING;
var errorOrDestroy$1 = destroyImpl$1.errorOrDestroy;
inherits.exports(Writable$1, Stream$1);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex$3 = Duplex$3 || _stream_duplex;
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex$3; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark$1(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable$1, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable$1) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable$1(options) {
  Duplex$3 = Duplex$3 || _stream_duplex; // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex$3;
  if (!isDuplex && !realHasInstance.call(Writable$1, this)) return new Writable$1(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options["final"] === 'function') this._final = options["final"];
  }

  Stream$1.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable$1.prototype.pipe = function () {
  errorOrDestroy$1(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy$1(stream, er);
  browser$1.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE$2('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy$1(stream, er);
    browser$1.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable$1.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array$1(chunk);

  if (isBuf && !Buffer$4.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer$1(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable$1.prototype.cork = function () {
  this._writableState.corked++;
};

Writable$1.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable$1.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable$1.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer$4.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable$1.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED$1('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    browser$1.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    browser$1.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy$1(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy$1(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK$1();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      browser$1.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable$1.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED$2('_write()'));
};

Writable$1.prototype._writev = null;

Writable$1.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable$1.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy$1(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish$1(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      browser$1.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish$1(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) browser$1.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable$1.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable$1.prototype.destroy = destroyImpl$1.destroy;
Writable$1.prototype._undestroy = destroyImpl$1.undestroy;

Writable$1.prototype._destroy = function (err, cb) {
  cb(err);
};

/*<replacement>*/


var objectKeys$1 = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


var _stream_duplex = Duplex$2;
var Readable$1 = _stream_readable;
var Writable = _stream_writable;
inherits.exports(Duplex$2, Readable$1);
{
  // Allow the keys array to be GC'ed.
  var keys$2 = objectKeys$1(Writable.prototype);

  for (var v = 0; v < keys$2.length; v++) {
    var method = keys$2[v];
    if (!Duplex$2.prototype[method]) Duplex$2.prototype[method] = Writable.prototype[method];
  }
}

function Duplex$2(options) {
  if (!(this instanceof Duplex$2)) return new Duplex$2(options);
  Readable$1.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex$2.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex$2.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex$2.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  browser$1.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex$2.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

var string_decoder = {};

/*<replacement>*/


var Buffer$3 = require$$0$4.Buffer;
/*</replacement>*/

var isEncoding = Buffer$3.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer$3.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


string_decoder.StringDecoder = StringDecoder$1;

function StringDecoder$1(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer$3.allocUnsafe(nb);
}

StringDecoder$1.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder$1.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder$1.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder$1.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(_byte) {
  if (_byte <= 0x7F) return 0;else if (_byte >> 5 === 0x06) return 2;else if (_byte >> 4 === 0x0E) return 3;else if (_byte >> 3 === 0x1E) return 4;
  return _byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return "\uFFFD";
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return "\uFFFD";
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + "\uFFFD";
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

var ERR_STREAM_PREMATURE_CLOSE = errors.codes.ERR_STREAM_PREMATURE_CLOSE;

function once$1(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop$1() {}

function isRequest$1(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos$1(stream, opts, callback) {
  if (typeof opts === 'function') return eos$1(stream, null, opts);
  if (!opts) opts = {};
  callback = once$1(callback || noop$1);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest$1(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

var endOfStream = eos$1;

var _Object$setPrototypeO;

function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var finished = endOfStream;
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  browser$1.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this; // if we have detected an error in the meanwhile
    // reject straight away


    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        browser$1.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty$2(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty$2(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this; // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to


  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator$1 = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty$2(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty$2(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty$2(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty$2(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty$2(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty$2(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

var async_iterator = createReadableStreamAsyncIterator$1;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var ERR_INVALID_ARG_TYPE$1 = errors.codes.ERR_INVALID_ARG_TYPE;

function from$3(Readable, iterable, opts) {
  var iterator;

  if (iterable && typeof iterable.next === 'function') {
    iterator = iterable;
  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE$1('iterable', ['Iterable'], iterable);

  var readable = new Readable(_objectSpread({
    objectMode: true
  }, opts)); // Reading boolean to protect against _read
  // being called before last iteration completion.

  var reading = false;

  readable._read = function () {
    if (!reading) {
      reading = true;
      next();
    }
  };

  function next() {
    return _next2.apply(this, arguments);
  }

  function _next2() {
    _next2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var _ref, value, done;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return iterator.next();

            case 3:
              _ref = _context.sent;
              value = _ref.value;
              done = _ref.done;

              if (!done) {
                _context.next = 10;
                break;
              }

              readable.push(null);
              _context.next = 19;
              break;

            case 10:
              _context.t0 = readable;
              _context.next = 13;
              return value;

            case 13:
              _context.t1 = _context.sent;

              if (!_context.t0.push.call(_context.t0, _context.t1)) {
                _context.next = 18;
                break;
              }

              next();
              _context.next = 19;
              break;

            case 18:
              reading = false;

            case 19:
              _context.next = 24;
              break;

            case 21:
              _context.prev = 21;
              _context.t2 = _context["catch"](0);
              readable.destroy(_context.t2);

            case 24:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 21]]);
    }));
    return _next2.apply(this, arguments);
  }

  return readable;
}

var from_1 = from$3;

var _stream_readable = Readable;
/*<replacement>*/

var Duplex$1;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

events.exports.EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = stream$1;
/*</replacement>*/

var Buffer$2 = buffer.Buffer;

var OurUint8Array = commonjsGlobal.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer$2.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer$2.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = util$2;
var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = buffer_list;
var destroyImpl = destroy_1;
var _require = state,
    getHighWaterMark = _require.getHighWaterMark;
var _require$codes$2 = errors.codes,
    ERR_INVALID_ARG_TYPE = _require$codes$2.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes$2.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.

var StringDecoder;
var createReadableStreamAsyncIterator;
var from$2;
inherits.exports(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex$1 = Duplex$1 || _stream_duplex;
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex$1; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = string_decoder.StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex$1 = Duplex$1 || _stream_duplex;
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex$1;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer$2.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer$2.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = string_decoder.StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    browser$1.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    browser$1.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED$1('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== browser$1.stdout && dest !== browser$1.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) browser$1.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        browser$1.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    browser$1.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    browser$1.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    browser$1.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = async_iterator;
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    browser$1.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from$2 === undefined) {
      from$2 = from_1;
    }

    return from$2(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

var _stream_transform = Transform$3;
var _require$codes$1 = errors.codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = _stream_duplex;
inherits.exports(Transform$3, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform$3(options) {
  if (!(this instanceof Transform$3)) return new Transform$3(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform$3.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform$3.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform$3.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform$3.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform$3.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

var _stream_passthrough = PassThrough;
var Transform$2 = _stream_transform;
inherits.exports(PassThrough, Transform$2);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform$2.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = errors.codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = endOfStream;
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

var pipeline_1 = pipeline;

(function (module, exports) {
  var Stream = require$$0$3;

  if (browser$1.env.READABLE_STREAM === 'disable' && Stream) {
    module.exports = Stream.Readable;
    Object.assign(module.exports, Stream);
    module.exports.Stream = Stream;
  } else {
    exports = module.exports = _stream_readable;
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = _stream_writable;
    exports.Duplex = _stream_duplex;
    exports.Transform = _stream_transform;
    exports.PassThrough = _stream_passthrough;
    exports.finished = endOfStream;
    exports.pipeline = pipeline_1;
  }
})(readable, readable.exports);

Object.defineProperty(lib$4, "__esModule", {
  value: true
});
lib$4.ReadableWebToNodeStream = void 0;
var readable_stream_1 = readable.exports;
/**
 * Converts a Web-API stream into Node stream.Readable class
 * Node stream readable: https://nodejs.org/api/stream.html#stream_readable_streams
 * Web API readable-stream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
 * Node readable stream: https://nodejs.org/api/stream.html#stream_readable_streams
 */

var ReadableWebToNodeStream = /*#__PURE__*/function (_readable_stream_1$Re) {
  _inherits(ReadableWebToNodeStream, _readable_stream_1$Re);

  var _super = _createSuper(ReadableWebToNodeStream);

  /**
   *
   * @param stream ReadableStream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
   */
  function ReadableWebToNodeStream(stream) {
    var _this;

    _classCallCheck$1(this, ReadableWebToNodeStream);

    _this = _super.call(this);
    _this.bytesRead = 0;
    _this.released = false;
    _this.reader = stream.getReader();
    return _this;
  }
  /**
   * Implementation of readable._read(size).
   * When readable._read() is called, if data is available from the resource,
   * the implementation should begin pushing that data into the read queue
   * https://nodejs.org/api/stream.html#stream_readable_read_size_1
   */


  _createClass$1(ReadableWebToNodeStream, [{
    key: "_read",
    value: function () {
      var _read2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var data;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.released) {
                  _context.next = 3;
                  break;
                }

                this.push(null); // Signal EOF

                return _context.abrupt("return");

              case 3:
                this.pendingRead = this.reader.read();
                _context.next = 6;
                return this.pendingRead;

              case 6:
                data = _context.sent;
                // clear the promise before pushing pushing new data to the queue and allow sequential calls to _read()
                delete this.pendingRead;

                if (data.done || this.released) {
                  this.push(null); // Signal EOF
                } else {
                  this.bytesRead += data.value.length;
                  this.push(data.value); // Push new data to the queue
                }

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _read() {
        return _read2.apply(this, arguments);
      }

      return _read;
    }()
    /**
     * If there is no unresolved read call to Web-API ReadableStream immediately returns;
     * otherwise will wait until the read is resolved.
     */

  }, {
    key: "waitForReadToComplete",
    value: function () {
      var _waitForReadToComplete = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.pendingRead) {
                  _context2.next = 3;
                  break;
                }

                _context2.next = 3;
                return this.pendingRead;

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function waitForReadToComplete() {
        return _waitForReadToComplete.apply(this, arguments);
      }

      return waitForReadToComplete;
    }()
    /**
     * Close wrapper
     */

  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.syncAndRelease();

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "syncAndRelease",
    value: function () {
      var _syncAndRelease = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.released = true;
                _context4.next = 3;
                return this.waitForReadToComplete();

              case 3:
                _context4.next = 5;
                return this.reader.releaseLock();

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function syncAndRelease() {
        return _syncAndRelease.apply(this, arguments);
      }

      return syncAndRelease;
    }()
  }]);

  return ReadableWebToNodeStream;
}(readable_stream_1.Readable);

lib$4.ReadableWebToNodeStream = ReadableWebToNodeStream;

var lib$3 = {};

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AnsiStringType = exports.StringType = exports.BufferType = exports.Uint8ArrayType = exports.IgnoreType = exports.Float80_LE = exports.Float80_BE = exports.Float64_LE = exports.Float64_BE = exports.Float32_LE = exports.Float32_BE = exports.Float16_LE = exports.Float16_BE = exports.INT64_BE = exports.UINT64_BE = exports.INT64_LE = exports.UINT64_LE = exports.INT32_LE = exports.INT32_BE = exports.INT24_BE = exports.INT24_LE = exports.INT16_LE = exports.INT16_BE = exports.INT8 = exports.UINT32_BE = exports.UINT32_LE = exports.UINT24_BE = exports.UINT24_LE = exports.UINT16_BE = exports.UINT16_LE = exports.UINT8 = void 0;
  var ieee754$1 = ieee754; // Primitive types

  function dv(array) {
    return new DataView(array.buffer, array.byteOffset);
  }
  /**
   * 8-bit unsigned integer
   */


  exports.UINT8 = {
    len: 1,
    get: function get(array, offset) {
      return dv(array).getUint8(offset);
    },
    put: function put(array, offset, value) {
      dv(array).setUint8(offset, value);
      return offset + 1;
    }
  };
  /**
   * 16-bit unsigned integer, Little Endian byte order
   */

  exports.UINT16_LE = {
    len: 2,
    get: function get(array, offset) {
      return dv(array).getUint16(offset, true);
    },
    put: function put(array, offset, value) {
      dv(array).setUint16(offset, value, true);
      return offset + 2;
    }
  };
  /**
   * 16-bit unsigned integer, Big Endian byte order
   */

  exports.UINT16_BE = {
    len: 2,
    get: function get(array, offset) {
      return dv(array).getUint16(offset);
    },
    put: function put(array, offset, value) {
      dv(array).setUint16(offset, value);
      return offset + 2;
    }
  };
  /**
   * 24-bit unsigned integer, Little Endian byte order
   */

  exports.UINT24_LE = {
    len: 3,
    get: function get(array, offset) {
      var dataView = dv(array);
      return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
    },
    put: function put(array, offset, value) {
      var dataView = dv(array);
      dataView.setUint8(offset, value & 0xff);
      dataView.setUint16(offset + 1, value >> 8, true);
      return offset + 3;
    }
  };
  /**
   * 24-bit unsigned integer, Big Endian byte order
   */

  exports.UINT24_BE = {
    len: 3,
    get: function get(array, offset) {
      var dataView = dv(array);
      return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
    },
    put: function put(array, offset, value) {
      var dataView = dv(array);
      dataView.setUint16(offset, value >> 8);
      dataView.setUint8(offset + 2, value & 0xff);
      return offset + 3;
    }
  };
  /**
   * 32-bit unsigned integer, Little Endian byte order
   */

  exports.UINT32_LE = {
    len: 4,
    get: function get(array, offset) {
      return dv(array).getUint32(offset, true);
    },
    put: function put(array, offset, value) {
      dv(array).setUint32(offset, value, true);
      return offset + 4;
    }
  };
  /**
   * 32-bit unsigned integer, Big Endian byte order
   */

  exports.UINT32_BE = {
    len: 4,
    get: function get(array, offset) {
      return dv(array).getUint32(offset);
    },
    put: function put(array, offset, value) {
      dv(array).setUint32(offset, value);
      return offset + 4;
    }
  };
  /**
   * 8-bit signed integer
   */

  exports.INT8 = {
    len: 1,
    get: function get(array, offset) {
      return dv(array).getInt8(offset);
    },
    put: function put(array, offset, value) {
      dv(array).setInt8(offset, value);
      return offset + 1;
    }
  };
  /**
   * 16-bit signed integer, Big Endian byte order
   */

  exports.INT16_BE = {
    len: 2,
    get: function get(array, offset) {
      return dv(array).getInt16(offset);
    },
    put: function put(array, offset, value) {
      dv(array).setInt16(offset, value);
      return offset + 2;
    }
  };
  /**
   * 16-bit signed integer, Little Endian byte order
   */

  exports.INT16_LE = {
    len: 2,
    get: function get(array, offset) {
      return dv(array).getInt16(offset, true);
    },
    put: function put(array, offset, value) {
      dv(array).setInt16(offset, value, true);
      return offset + 2;
    }
  };
  /**
   * 24-bit signed integer, Little Endian byte order
   */

  exports.INT24_LE = {
    len: 3,
    get: function get(array, offset) {
      var unsigned = exports.UINT24_LE.get(array, offset);
      return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
    },
    put: function put(array, offset, value) {
      var dataView = dv(array);
      dataView.setUint8(offset, value & 0xff);
      dataView.setUint16(offset + 1, value >> 8, true);
      return offset + 3;
    }
  };
  /**
   * 24-bit signed integer, Big Endian byte order
   */

  exports.INT24_BE = {
    len: 3,
    get: function get(array, offset) {
      var unsigned = exports.UINT24_BE.get(array, offset);
      return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
    },
    put: function put(array, offset, value) {
      var dataView = dv(array);
      dataView.setUint16(offset, value >> 8);
      dataView.setUint8(offset + 2, value & 0xff);
      return offset + 3;
    }
  };
  /**
   * 32-bit signed integer, Big Endian byte order
   */

  exports.INT32_BE = {
    len: 4,
    get: function get(array, offset) {
      return dv(array).getInt32(offset);
    },
    put: function put(array, offset, value) {
      dv(array).setInt32(offset, value);
      return offset + 4;
    }
  };
  /**
   * 32-bit signed integer, Big Endian byte order
   */

  exports.INT32_LE = {
    len: 4,
    get: function get(array, offset) {
      return dv(array).getInt32(offset, true);
    },
    put: function put(array, offset, value) {
      dv(array).setInt32(offset, value, true);
      return offset + 4;
    }
  };
  /**
   * 64-bit unsigned integer, Little Endian byte order
   */

  exports.UINT64_LE = {
    len: 8,
    get: function get(array, offset) {
      return dv(array).getBigUint64(offset, true);
    },
    put: function put(array, offset, value) {
      dv(array).setBigUint64(offset, value, true);
      return offset + 8;
    }
  };
  /**
   * 64-bit signed integer, Little Endian byte order
   */

  exports.INT64_LE = {
    len: 8,
    get: function get(array, offset) {
      return dv(array).getBigInt64(offset, true);
    },
    put: function put(array, offset, value) {
      dv(array).setBigInt64(offset, value, true);
      return offset + 8;
    }
  };
  /**
   * 64-bit unsigned integer, Big Endian byte order
   */

  exports.UINT64_BE = {
    len: 8,
    get: function get(array, offset) {
      return dv(array).getBigUint64(offset);
    },
    put: function put(array, offset, value) {
      dv(array).setBigUint64(offset, value);
      return offset + 8;
    }
  };
  /**
   * 64-bit signed integer, Big Endian byte order
   */

  exports.INT64_BE = {
    len: 8,
    get: function get(array, offset) {
      return dv(array).getBigInt64(offset);
    },
    put: function put(array, offset, value) {
      dv(array).setBigInt64(offset, value);
      return offset + 8;
    }
  };
  /**
   * IEEE 754 16-bit (half precision) float, big endian
   */

  exports.Float16_BE = {
    len: 2,
    get: function get(dataView, offset) {
      return ieee754$1.read(dataView, offset, false, 10, this.len);
    },
    put: function put(dataView, offset, value) {
      ieee754$1.write(dataView, value, offset, false, 10, this.len);
      return offset + this.len;
    }
  };
  /**
   * IEEE 754 16-bit (half precision) float, little endian
   */

  exports.Float16_LE = {
    len: 2,
    get: function get(array, offset) {
      return ieee754$1.read(array, offset, true, 10, this.len);
    },
    put: function put(array, offset, value) {
      ieee754$1.write(array, value, offset, true, 10, this.len);
      return offset + this.len;
    }
  };
  /**
   * IEEE 754 32-bit (single precision) float, big endian
   */

  exports.Float32_BE = {
    len: 4,
    get: function get(array, offset) {
      return dv(array).getFloat32(offset);
    },
    put: function put(array, offset, value) {
      dv(array).setFloat32(offset, value);
      return offset + 4;
    }
  };
  /**
   * IEEE 754 32-bit (single precision) float, little endian
   */

  exports.Float32_LE = {
    len: 4,
    get: function get(array, offset) {
      return dv(array).getFloat32(offset, true);
    },
    put: function put(array, offset, value) {
      dv(array).setFloat32(offset, value, true);
      return offset + 4;
    }
  };
  /**
   * IEEE 754 64-bit (double precision) float, big endian
   */

  exports.Float64_BE = {
    len: 8,
    get: function get(array, offset) {
      return dv(array).getFloat64(offset);
    },
    put: function put(array, offset, value) {
      dv(array).setFloat64(offset, value);
      return offset + 8;
    }
  };
  /**
   * IEEE 754 64-bit (double precision) float, little endian
   */

  exports.Float64_LE = {
    len: 8,
    get: function get(array, offset) {
      return dv(array).getFloat64(offset, true);
    },
    put: function put(array, offset, value) {
      dv(array).setFloat64(offset, value, true);
      return offset + 8;
    }
  };
  /**
   * IEEE 754 80-bit (extended precision) float, big endian
   */

  exports.Float80_BE = {
    len: 10,
    get: function get(array, offset) {
      return ieee754$1.read(array, offset, false, 63, this.len);
    },
    put: function put(array, offset, value) {
      ieee754$1.write(array, value, offset, false, 63, this.len);
      return offset + this.len;
    }
  };
  /**
   * IEEE 754 80-bit (extended precision) float, little endian
   */

  exports.Float80_LE = {
    len: 10,
    get: function get(array, offset) {
      return ieee754$1.read(array, offset, true, 63, this.len);
    },
    put: function put(array, offset, value) {
      ieee754$1.write(array, value, offset, true, 63, this.len);
      return offset + this.len;
    }
  };
  /**
   * Ignore a given number of bytes
   */

  var IgnoreType = /*#__PURE__*/function () {
    /**
     * @param len number of bytes to ignore
     */
    function IgnoreType(len) {
      _classCallCheck$1(this, IgnoreType);

      this.len = len;
    } // ToDo: don't read, but skip data


    _createClass$1(IgnoreType, [{
      key: "get",
      value: function get(array, off) {}
    }]);

    return IgnoreType;
  }();

  exports.IgnoreType = IgnoreType;

  var Uint8ArrayType = /*#__PURE__*/function () {
    function Uint8ArrayType(len) {
      _classCallCheck$1(this, Uint8ArrayType);

      this.len = len;
    }

    _createClass$1(Uint8ArrayType, [{
      key: "get",
      value: function get(array, offset) {
        return array.subarray(offset, offset + this.len);
      }
    }]);

    return Uint8ArrayType;
  }();

  exports.Uint8ArrayType = Uint8ArrayType;

  var BufferType = /*#__PURE__*/function () {
    function BufferType(len) {
      _classCallCheck$1(this, BufferType);

      this.len = len;
    }

    _createClass$1(BufferType, [{
      key: "get",
      value: function get(uint8Array, off) {
        return Buffer$6.from(uint8Array.subarray(off, off + this.len));
      }
    }]);

    return BufferType;
  }();

  exports.BufferType = BufferType;
  /**
   * Consume a fixed number of bytes from the stream and return a string with a specified encoding.
   */

  var StringType = /*#__PURE__*/function () {
    function StringType(len, encoding) {
      _classCallCheck$1(this, StringType);

      this.len = len;
      this.encoding = encoding;
    }

    _createClass$1(StringType, [{
      key: "get",
      value: function get(uint8Array, offset) {
        return Buffer$6.from(uint8Array).toString(this.encoding, offset, offset + this.len);
      }
    }]);

    return StringType;
  }();

  exports.StringType = StringType;
  /**
   * ANSI Latin 1 String
   * Using windows-1252 / ISO 8859-1 decoding
   */

  var AnsiStringType = /*#__PURE__*/function () {
    function AnsiStringType(len) {
      _classCallCheck$1(this, AnsiStringType);

      this.len = len;
    }

    _createClass$1(AnsiStringType, [{
      key: "get",
      value: function get(buffer) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return AnsiStringType.decode(buffer, offset, offset + this.len);
      }
    }], [{
      key: "decode",
      value: function decode(buffer, offset, until) {
        var str = '';

        for (var i = offset; i < until; ++i) {
          str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i]));
        }

        return str;
      }
    }, {
      key: "inRange",
      value: function inRange(a, min, max) {
        return min <= a && a <= max;
      }
    }, {
      key: "codePointToString",
      value: function codePointToString(cp) {
        if (cp <= 0xFFFF) {
          return String.fromCharCode(cp);
        } else {
          cp -= 0x10000;
          return String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);
        }
      }
    }, {
      key: "singleByteDecoder",
      value: function singleByteDecoder(bite) {
        if (AnsiStringType.inRange(bite, 0x00, 0x7F)) {
          return bite;
        }

        var codePoint = AnsiStringType.windows1252[bite - 0x80];

        if (codePoint === null) {
          throw Error('invaliding encoding');
        }

        return codePoint;
      }
    }]);

    return AnsiStringType;
  }();

  exports.AnsiStringType = AnsiStringType;
  AnsiStringType.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
})(lib$3);

var core$1 = {};

var ReadStreamTokenizer$1 = {};

var AbstractTokenizer$1 = {};

var lib$2 = {};

var EndOfFileStream = {};

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.EndOfStreamError = exports.defaultMessages = void 0;
  exports.defaultMessages = 'End-Of-Stream';
  /**
   * Thrown on read operation of the end of file or stream has been reached
   */

  var EndOfStreamError = /*#__PURE__*/function (_Error) {
    _inherits(EndOfStreamError, _Error);

    var _super = _createSuper(EndOfStreamError);

    function EndOfStreamError() {
      _classCallCheck$1(this, EndOfStreamError);

      return _super.call(this, exports.defaultMessages);
    }

    return _createClass$1(EndOfStreamError);
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  exports.EndOfStreamError = EndOfStreamError;
})(EndOfFileStream);

var StreamReader = {};

var Deferred$1 = {};

Object.defineProperty(Deferred$1, "__esModule", {
  value: true
});
Deferred$1.Deferred = void 0;

var Deferred = /*#__PURE__*/_createClass$1(function Deferred() {
  var _this = this;

  _classCallCheck$1(this, Deferred);

  this.resolve = function () {
    return null;
  };

  this.reject = function () {
    return null;
  };

  this.promise = new Promise(function (resolve, reject) {
    _this.reject = reject;
    _this.resolve = resolve;
  });
});

Deferred$1.Deferred = Deferred;

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StreamReader = exports.EndOfStreamError = void 0;
  var EndOfFileStream_1 = EndOfFileStream;
  var Deferred_1 = Deferred$1;
  var EndOfFileStream_2 = EndOfFileStream;
  Object.defineProperty(exports, "EndOfStreamError", {
    enumerable: true,
    get: function get() {
      return EndOfFileStream_2.EndOfStreamError;
    }
  });
  var maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation

  var StreamReader = /*#__PURE__*/function () {
    function StreamReader(s) {
      var _this = this;

      _classCallCheck$1(this, StreamReader);

      this.s = s;
      /**
       * Deferred used for postponed read request (as not data is yet available to read)
       */

      this.deferred = null;
      this.endOfStream = false;
      /**
       * Store peeked data
       * @type {Array}
       */

      this.peekQueue = [];

      if (!s.read || !s.once) {
        throw new Error('Expected an instance of stream.Readable');
      }

      this.s.once('end', function () {
        return _this.reject(new EndOfFileStream_1.EndOfStreamError());
      });
      this.s.once('error', function (err) {
        return _this.reject(err);
      });
      this.s.once('close', function () {
        return _this.reject(new Error('Stream closed'));
      });
    }
    /**
     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
     * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes peeked
     */


    _createClass$1(StreamReader, [{
      key: "peek",
      value: function () {
        var _peek = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(uint8Array, offset, length) {
          var bytesRead;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return this.read(uint8Array, offset, length);

                case 2:
                  bytesRead = _context.sent;
                  this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer

                  return _context.abrupt("return", bytesRead);

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function peek(_x, _x2, _x3) {
          return _peek.apply(this, arguments);
        }

        return peek;
      }()
      /**
       * Read chunk from stream
       * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
       * @param offset - Offset target
       * @param length - Number of bytes to read
       * @returns Number of bytes read
       */

    }, {
      key: "read",
      value: function () {
        var _read = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(buffer, offset, length) {
          var remaining, bytesRead, peekData, lenCopy, reqLen, chunkLen;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!(length === 0)) {
                    _context2.next = 2;
                    break;
                  }

                  return _context2.abrupt("return", 0);

                case 2:
                  if (!(this.peekQueue.length === 0 && this.endOfStream)) {
                    _context2.next = 4;
                    break;
                  }

                  throw new EndOfFileStream_1.EndOfStreamError();

                case 4:
                  remaining = length;
                  bytesRead = 0; // consume peeked data first

                case 6:
                  if (!(this.peekQueue.length > 0 && remaining > 0)) {
                    _context2.next = 17;
                    break;
                  }

                  peekData = this.peekQueue.pop(); // Front of queue

                  if (peekData) {
                    _context2.next = 10;
                    break;
                  }

                  throw new Error('peekData should be defined');

                case 10:
                  lenCopy = Math.min(peekData.length, remaining);
                  buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
                  bytesRead += lenCopy;
                  remaining -= lenCopy;

                  if (lenCopy < peekData.length) {
                    // remainder back to queue
                    this.peekQueue.push(peekData.subarray(lenCopy));
                  }

                  _context2.next = 6;
                  break;

                case 17:
                  if (!(remaining > 0 && !this.endOfStream)) {
                    _context2.next = 28;
                    break;
                  }

                  reqLen = Math.min(remaining, maxStreamReadSize);
                  _context2.next = 21;
                  return this.readFromStream(buffer, offset + bytesRead, reqLen);

                case 21:
                  chunkLen = _context2.sent;
                  bytesRead += chunkLen;

                  if (!(chunkLen < reqLen)) {
                    _context2.next = 25;
                    break;
                  }

                  return _context2.abrupt("break", 28);

                case 25:
                  remaining -= chunkLen;
                  _context2.next = 17;
                  break;

                case 28:
                  return _context2.abrupt("return", bytesRead);

                case 29:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function read(_x4, _x5, _x6) {
          return _read.apply(this, arguments);
        }

        return read;
      }()
      /**
       * Read chunk from stream
       * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
       * @param offset Offset target
       * @param length Number of bytes to read
       * @returns Number of bytes read
       */

    }, {
      key: "readFromStream",
      value: function () {
        var _readFromStream = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(buffer, offset, length) {
          var _this2 = this;

          var readBuffer, request;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  readBuffer = this.s.read(length);

                  if (!readBuffer) {
                    _context3.next = 6;
                    break;
                  }

                  buffer.set(readBuffer, offset);
                  return _context3.abrupt("return", readBuffer.length);

                case 6:
                  request = {
                    buffer: buffer,
                    offset: offset,
                    length: length,
                    deferred: new Deferred_1.Deferred()
                  };
                  this.deferred = request.deferred;
                  this.s.once('readable', function () {
                    _this2.readDeferred(request);
                  });
                  return _context3.abrupt("return", request.deferred.promise);

                case 10:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function readFromStream(_x7, _x8, _x9) {
          return _readFromStream.apply(this, arguments);
        }

        return readFromStream;
      }()
      /**
       * Process deferred read request
       * @param request Deferred read request
       */

    }, {
      key: "readDeferred",
      value: function readDeferred(request) {
        var _this3 = this;

        var readBuffer = this.s.read(request.length);

        if (readBuffer) {
          request.buffer.set(readBuffer, request.offset);
          request.deferred.resolve(readBuffer.length);
          this.deferred = null;
        } else {
          this.s.once('readable', function () {
            _this3.readDeferred(request);
          });
        }
      }
    }, {
      key: "reject",
      value: function reject(err) {
        this.endOfStream = true;

        if (this.deferred) {
          this.deferred.reject(err);
          this.deferred = null;
        }
      }
    }]);

    return StreamReader;
  }();

  exports.StreamReader = StreamReader;
})(StreamReader);

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StreamReader = exports.EndOfStreamError = void 0;
  var EndOfFileStream_1 = EndOfFileStream;
  Object.defineProperty(exports, "EndOfStreamError", {
    enumerable: true,
    get: function get() {
      return EndOfFileStream_1.EndOfStreamError;
    }
  });
  var StreamReader_1 = StreamReader;
  Object.defineProperty(exports, "StreamReader", {
    enumerable: true,
    get: function get() {
      return StreamReader_1.StreamReader;
    }
  });
})(lib$2);

Object.defineProperty(AbstractTokenizer$1, "__esModule", {
  value: true
});
AbstractTokenizer$1.AbstractTokenizer = void 0;
var peek_readable_1$2 = lib$2;
/**
 * Core tokenizer
 */

var AbstractTokenizer = /*#__PURE__*/function () {
  function AbstractTokenizer(fileInfo) {
    _classCallCheck$1(this, AbstractTokenizer);

    /**
     * Tokenizer-stream position
     */
    this.position = 0;
    this.numBuffer = new Uint8Array(8);
    this.fileInfo = fileInfo ? fileInfo : {};
  }
  /**
   * Read a token from the tokenizer-stream
   * @param token - The token to read
   * @param position - If provided, the desired position in the tokenizer-stream
   * @returns Promise with token data
   */


  _createClass$1(AbstractTokenizer, [{
    key: "readToken",
    value: function () {
      var _readToken = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(token) {
        var position,
            uint8Array,
            len,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                position = _args.length > 1 && _args[1] !== undefined ? _args[1] : this.position;
                uint8Array = Buffer$6.alloc(token.len);
                _context.next = 4;
                return this.readBuffer(uint8Array, {
                  position: position
                });

              case 4:
                len = _context.sent;

                if (!(len < token.len)) {
                  _context.next = 7;
                  break;
                }

                throw new peek_readable_1$2.EndOfStreamError();

              case 7:
                return _context.abrupt("return", token.get(uint8Array, 0));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function readToken(_x) {
        return _readToken.apply(this, arguments);
      }

      return readToken;
    }()
    /**
     * Peek a token from the tokenizer-stream.
     * @param token - Token to peek from the tokenizer-stream.
     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
     * @returns Promise with token data
     */

  }, {
    key: "peekToken",
    value: function () {
      var _peekToken = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(token) {
        var position,
            uint8Array,
            len,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                position = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : this.position;
                uint8Array = Buffer$6.alloc(token.len);
                _context2.next = 4;
                return this.peekBuffer(uint8Array, {
                  position: position
                });

              case 4:
                len = _context2.sent;

                if (!(len < token.len)) {
                  _context2.next = 7;
                  break;
                }

                throw new peek_readable_1$2.EndOfStreamError();

              case 7:
                return _context2.abrupt("return", token.get(uint8Array, 0));

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function peekToken(_x2) {
        return _peekToken.apply(this, arguments);
      }

      return peekToken;
    }()
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */

  }, {
    key: "readNumber",
    value: function () {
      var _readNumber = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(token) {
        var len;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.readBuffer(this.numBuffer, {
                  length: token.len
                });

              case 2:
                len = _context3.sent;

                if (!(len < token.len)) {
                  _context3.next = 5;
                  break;
                }

                throw new peek_readable_1$2.EndOfStreamError();

              case 5:
                return _context3.abrupt("return", token.get(this.numBuffer, 0));

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function readNumber(_x3) {
        return _readNumber.apply(this, arguments);
      }

      return readNumber;
    }()
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */

  }, {
    key: "peekNumber",
    value: function () {
      var _peekNumber = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(token) {
        var len;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.peekBuffer(this.numBuffer, {
                  length: token.len
                });

              case 2:
                len = _context4.sent;

                if (!(len < token.len)) {
                  _context4.next = 5;
                  break;
                }

                throw new peek_readable_1$2.EndOfStreamError();

              case 5:
                return _context4.abrupt("return", token.get(this.numBuffer, 0));

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function peekNumber(_x4) {
        return _peekNumber.apply(this, arguments);
      }

      return peekNumber;
    }()
    /**
     * Ignore number of bytes, advances the pointer in under tokenizer-stream.
     * @param length - Number of bytes to ignore
     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
     */

  }, {
    key: "ignore",
    value: function () {
      var _ignore = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(length) {
        var bytesLeft;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(this.fileInfo.size !== undefined)) {
                  _context5.next = 5;
                  break;
                }

                bytesLeft = this.fileInfo.size - this.position;

                if (!(length > bytesLeft)) {
                  _context5.next = 5;
                  break;
                }

                this.position += bytesLeft;
                return _context5.abrupt("return", bytesLeft);

              case 5:
                this.position += length;
                return _context5.abrupt("return", length);

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function ignore(_x5) {
        return _ignore.apply(this, arguments);
      }

      return ignore;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "normalizeOptions",
    value: function normalizeOptions(uint8Array, options) {
      if (options && options.position !== undefined && options.position < this.position) {
        throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
      }

      if (options) {
        return {
          mayBeLess: options.mayBeLess === true,
          offset: options.offset ? options.offset : 0,
          length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
          position: options.position ? options.position : this.position
        };
      }

      return {
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      };
    }
  }]);

  return AbstractTokenizer;
}();

AbstractTokenizer$1.AbstractTokenizer = AbstractTokenizer;

Object.defineProperty(ReadStreamTokenizer$1, "__esModule", {
  value: true
});
ReadStreamTokenizer$1.ReadStreamTokenizer = void 0;
var AbstractTokenizer_1$1 = AbstractTokenizer$1;
var peek_readable_1$1 = lib$2;
var maxBufferSize = 256000;

var ReadStreamTokenizer = /*#__PURE__*/function (_AbstractTokenizer_1$) {
  _inherits(ReadStreamTokenizer, _AbstractTokenizer_1$);

  var _super = _createSuper(ReadStreamTokenizer);

  function ReadStreamTokenizer(stream, fileInfo) {
    var _this;

    _classCallCheck$1(this, ReadStreamTokenizer);

    _this = _super.call(this, fileInfo);
    _this.streamReader = new peek_readable_1$1.StreamReader(stream);
    return _this;
  }
  /**
   * Get file information, an HTTP-client may implement this doing a HEAD request
   * @return Promise with file information
   */


  _createClass$1(ReadStreamTokenizer, [{
    key: "getFileInfo",
    value: function () {
      var _getFileInfo = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.fileInfo);

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getFileInfo() {
        return _getFileInfo.apply(this, arguments);
      }

      return getFileInfo;
    }()
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
     * @param options - Read behaviour options
     * @returns Promise with number of bytes read
     */

  }, {
    key: "readBuffer",
    value: function () {
      var _readBuffer = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(uint8Array, options) {
        var normOptions, skipBytes, bytesRead;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                normOptions = this.normalizeOptions(uint8Array, options);
                skipBytes = normOptions.position - this.position;

                if (!(skipBytes > 0)) {
                  _context2.next = 8;
                  break;
                }

                _context2.next = 5;
                return this.ignore(skipBytes);

              case 5:
                return _context2.abrupt("return", this.readBuffer(uint8Array, options));

              case 8:
                if (!(skipBytes < 0)) {
                  _context2.next = 10;
                  break;
                }

                throw new Error('`options.position` must be equal or greater than `tokenizer.position`');

              case 10:
                if (!(normOptions.length === 0)) {
                  _context2.next = 12;
                  break;
                }

                return _context2.abrupt("return", 0);

              case 12:
                _context2.next = 14;
                return this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);

              case 14:
                bytesRead = _context2.sent;
                this.position += bytesRead;

                if (!((!options || !options.mayBeLess) && bytesRead < normOptions.length)) {
                  _context2.next = 18;
                  break;
                }

                throw new peek_readable_1$1.EndOfStreamError();

              case 18:
                return _context2.abrupt("return", bytesRead);

              case 19:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function readBuffer(_x, _x2) {
        return _readBuffer.apply(this, arguments);
      }

      return readBuffer;
    }()
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array - Uint8Array (or Buffer) to write data to
     * @param options - Read behaviour options
     * @returns Promise with number of bytes peeked
     */

  }, {
    key: "peekBuffer",
    value: function () {
      var _peekBuffer = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(uint8Array, options) {
        var normOptions, bytesRead, skipBytes, skipBuffer;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                normOptions = this.normalizeOptions(uint8Array, options);
                bytesRead = 0;

                if (!normOptions.position) {
                  _context3.next = 15;
                  break;
                }

                skipBytes = normOptions.position - this.position;

                if (!(skipBytes > 0)) {
                  _context3.next = 13;
                  break;
                }

                skipBuffer = new Uint8Array(normOptions.length + skipBytes);
                _context3.next = 8;
                return this.peekBuffer(skipBuffer, {
                  mayBeLess: normOptions.mayBeLess
                });

              case 8:
                bytesRead = _context3.sent;
                uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
                return _context3.abrupt("return", bytesRead - skipBytes);

              case 13:
                if (!(skipBytes < 0)) {
                  _context3.next = 15;
                  break;
                }

                throw new Error('Cannot peek from a negative offset in a stream');

              case 15:
                if (!(normOptions.length > 0)) {
                  _context3.next = 29;
                  break;
                }

                _context3.prev = 16;
                _context3.next = 19;
                return this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);

              case 19:
                bytesRead = _context3.sent;
                _context3.next = 27;
                break;

              case 22:
                _context3.prev = 22;
                _context3.t0 = _context3["catch"](16);

                if (!(options && options.mayBeLess && _context3.t0 instanceof peek_readable_1$1.EndOfStreamError)) {
                  _context3.next = 26;
                  break;
                }

                return _context3.abrupt("return", 0);

              case 26:
                throw _context3.t0;

              case 27:
                if (!(!normOptions.mayBeLess && bytesRead < normOptions.length)) {
                  _context3.next = 29;
                  break;
                }

                throw new peek_readable_1$1.EndOfStreamError();

              case 29:
                return _context3.abrupt("return", bytesRead);

              case 30:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[16, 22]]);
      }));

      function peekBuffer(_x3, _x4) {
        return _peekBuffer.apply(this, arguments);
      }

      return peekBuffer;
    }()
  }, {
    key: "ignore",
    value: function () {
      var _ignore = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(length) {
        var bufSize, buf, totBytesRead, remaining, bytesRead;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                // debug(`ignore ${this.position}...${this.position + length - 1}`);
                bufSize = Math.min(maxBufferSize, length);
                buf = new Uint8Array(bufSize);
                totBytesRead = 0;

              case 3:
                if (!(totBytesRead < length)) {
                  _context4.next = 13;
                  break;
                }

                remaining = length - totBytesRead;
                _context4.next = 7;
                return this.readBuffer(buf, {
                  length: Math.min(bufSize, remaining)
                });

              case 7:
                bytesRead = _context4.sent;

                if (!(bytesRead < 0)) {
                  _context4.next = 10;
                  break;
                }

                return _context4.abrupt("return", bytesRead);

              case 10:
                totBytesRead += bytesRead;
                _context4.next = 3;
                break;

              case 13:
                return _context4.abrupt("return", totBytesRead);

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function ignore(_x5) {
        return _ignore.apply(this, arguments);
      }

      return ignore;
    }()
  }]);

  return ReadStreamTokenizer;
}(AbstractTokenizer_1$1.AbstractTokenizer);

ReadStreamTokenizer$1.ReadStreamTokenizer = ReadStreamTokenizer;

var BufferTokenizer$1 = {};

Object.defineProperty(BufferTokenizer$1, "__esModule", {
  value: true
});
BufferTokenizer$1.BufferTokenizer = void 0;
var peek_readable_1 = lib$2;
var AbstractTokenizer_1 = AbstractTokenizer$1;

var BufferTokenizer = /*#__PURE__*/function (_AbstractTokenizer_1$) {
  _inherits(BufferTokenizer, _AbstractTokenizer_1$);

  var _super = _createSuper(BufferTokenizer);

  /**
   * Construct BufferTokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param fileInfo - Pass additional file information to the tokenizer
   */
  function BufferTokenizer(uint8Array, fileInfo) {
    var _this;

    _classCallCheck$1(this, BufferTokenizer);

    _this = _super.call(this, fileInfo);
    _this.uint8Array = uint8Array;
    _this.fileInfo.size = _this.fileInfo.size ? _this.fileInfo.size : uint8Array.length;
    return _this;
  }
  /**
   * Read buffer from tokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param options - Read behaviour options
   * @returns {Promise<number>}
   */


  _createClass$1(BufferTokenizer, [{
    key: "readBuffer",
    value: function () {
      var _readBuffer = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(uint8Array, options) {
        var bytesRead;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(options && options.position)) {
                  _context.next = 4;
                  break;
                }

                if (!(options.position < this.position)) {
                  _context.next = 3;
                  break;
                }

                throw new Error('`options.position` must be equal or greater than `tokenizer.position`');

              case 3:
                this.position = options.position;

              case 4:
                _context.next = 6;
                return this.peekBuffer(uint8Array, options);

              case 6:
                bytesRead = _context.sent;
                this.position += bytesRead;
                return _context.abrupt("return", bytesRead);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function readBuffer(_x, _x2) {
        return _readBuffer.apply(this, arguments);
      }

      return readBuffer;
    }()
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */

  }, {
    key: "peekBuffer",
    value: function () {
      var _peekBuffer = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(uint8Array, options) {
        var normOptions, bytes2read;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                normOptions = this.normalizeOptions(uint8Array, options);
                bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);

                if (!(!normOptions.mayBeLess && bytes2read < normOptions.length)) {
                  _context2.next = 6;
                  break;
                }

                throw new peek_readable_1.EndOfStreamError();

              case 6:
                uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
                return _context2.abrupt("return", bytes2read);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function peekBuffer(_x3, _x4) {
        return _peekBuffer.apply(this, arguments);
      }

      return peekBuffer;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }]);

  return BufferTokenizer;
}(AbstractTokenizer_1.AbstractTokenizer);

BufferTokenizer$1.BufferTokenizer = BufferTokenizer;

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.fromBuffer = exports.fromStream = exports.EndOfStreamError = void 0;
  var ReadStreamTokenizer_1 = ReadStreamTokenizer$1;
  var BufferTokenizer_1 = BufferTokenizer$1;
  var peek_readable_1 = lib$2;
  Object.defineProperty(exports, "EndOfStreamError", {
    enumerable: true,
    get: function get() {
      return peek_readable_1.EndOfStreamError;
    }
  });
  /**
   * Construct ReadStreamTokenizer from given Stream.
   * Will set fileSize, if provided given Stream has set the .path property/
   * @param stream - Read from Node.js Stream.Readable
   * @param fileInfo - Pass the file information, like size and MIME-type of the corresponding stream.
   * @returns ReadStreamTokenizer
   */

  function fromStream(stream, fileInfo) {
    fileInfo = fileInfo ? fileInfo : {};
    return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream, fileInfo);
  }

  exports.fromStream = fromStream;
  /**
   * Construct ReadStreamTokenizer from given Buffer.
   * @param uint8Array - Uint8Array to tokenize
   * @param fileInfo - Pass additional file information to the tokenizer
   * @returns BufferTokenizer
   */

  function fromBuffer(uint8Array, fileInfo) {
    return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);
  }

  exports.fromBuffer = fromBuffer;
})(core$1);

var util = {};

util.stringToBytes = function (string) {
  return _toConsumableArray(string).map(function (character) {
    return character.charCodeAt(0);
  });
};
/**
Checks whether the TAR checksum is valid.

@param {Buffer} buffer - The TAR header `[offset ... offset + 512]`.
@param {number} offset - TAR header offset.
@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.
*/


util.tarHeaderChecksumMatches = function (buffer) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var readSum = parseInt(buffer.toString('utf8', 148, 154).replace(/\0.*$/, '').trim(), 8); // Read sum in header

  if (isNaN(readSum)) {
    return false;
  }

  var sum = 8 * 0x20; // Initialize signed bit sum

  for (var i = offset; i < offset + 148; i++) {
    sum += buffer[i];
  }

  for (var _i = offset + 156; _i < offset + 512; _i++) {
    sum += buffer[_i];
  }

  return readSum === sum;
};
/**
ID3 UINT32 sync-safe tokenizer token.
28 bits (representing up to 256MB) integer, the msb is 0 to avoid "false syncsignals".
*/


util.uint32SyncSafeToken = {
  get: function get(buffer, offset) {
    return buffer[offset + 3] & 0x7F | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21;
  },
  len: 4
};

var supported$1 = {
  extensions: ['jpg', 'png', 'apng', 'gif', 'webp', 'flif', 'xcf', 'cr2', 'cr3', 'orf', 'arw', 'dng', 'nef', 'rw2', 'raf', 'tif', 'bmp', 'icns', 'jxr', 'psd', 'indd', 'zip', 'tar', 'rar', 'gz', 'bz2', '7z', 'dmg', 'mp4', 'mid', 'mkv', 'webm', 'mov', 'avi', 'mpg', 'mp2', 'mp3', 'm4a', 'oga', 'ogg', 'ogv', 'opus', 'flac', 'wav', 'spx', 'amr', 'pdf', 'epub', 'exe', 'swf', 'rtf', 'wasm', 'woff', 'woff2', 'eot', 'ttf', 'otf', 'ico', 'flv', 'ps', 'xz', 'sqlite', 'nes', 'crx', 'xpi', 'cab', 'deb', 'ar', 'rpm', 'Z', 'lz', 'cfb', 'mxf', 'mts', 'blend', 'bpg', 'docx', 'pptx', 'xlsx', '3gp', '3g2', 'jp2', 'jpm', 'jpx', 'mj2', 'aif', 'qcp', 'odt', 'ods', 'odp', 'xml', 'mobi', 'heic', 'cur', 'ktx', 'ape', 'wv', 'dcm', 'ics', 'glb', 'pcap', 'dsf', 'lnk', 'alias', 'voc', 'ac3', 'm4v', 'm4p', 'm4b', 'f4v', 'f4p', 'f4b', 'f4a', 'mie', 'asf', 'ogm', 'ogx', 'mpc', 'arrow', 'shp', 'aac', 'mp1', 'it', 's3m', 'xm', 'ai', 'skp', 'avif', 'eps', 'lzh', 'pgp', 'asar', 'stl', 'chm', '3mf', 'zst', 'jxl', 'vcf'],
  mimeTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/flif', 'image/x-xcf', 'image/x-canon-cr2', 'image/x-canon-cr3', 'image/tiff', 'image/bmp', 'image/vnd.ms-photo', 'image/vnd.adobe.photoshop', 'application/x-indesign', 'application/epub+zip', 'application/x-xpinstall', 'application/vnd.oasis.opendocument.text', 'application/vnd.oasis.opendocument.spreadsheet', 'application/vnd.oasis.opendocument.presentation', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.openxmlformats-officedocument.presentationml.presentation', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/zip', 'application/x-tar', 'application/x-rar-compressed', 'application/gzip', 'application/x-bzip2', 'application/x-7z-compressed', 'application/x-apple-diskimage', 'application/x-apache-arrow', 'video/mp4', 'audio/midi', 'video/x-matroska', 'video/webm', 'video/quicktime', 'video/vnd.avi', 'audio/vnd.wave', 'audio/qcelp', 'audio/x-ms-asf', 'video/x-ms-asf', 'application/vnd.ms-asf', 'video/mpeg', 'video/3gpp', 'audio/mpeg', 'audio/mp4', // RFC 4337
  'audio/opus', 'video/ogg', 'audio/ogg', 'application/ogg', 'audio/x-flac', 'audio/ape', 'audio/wavpack', 'audio/amr', 'application/pdf', 'application/x-msdownload', 'application/x-shockwave-flash', 'application/rtf', 'application/wasm', 'font/woff', 'font/woff2', 'application/vnd.ms-fontobject', 'font/ttf', 'font/otf', 'image/x-icon', 'video/x-flv', 'application/postscript', 'application/eps', 'application/x-xz', 'application/x-sqlite3', 'application/x-nintendo-nes-rom', 'application/x-google-chrome-extension', 'application/vnd.ms-cab-compressed', 'application/x-deb', 'application/x-unix-archive', 'application/x-rpm', 'application/x-compress', 'application/x-lzip', 'application/x-cfb', 'application/x-mie', 'application/mxf', 'video/mp2t', 'application/x-blender', 'image/bpg', 'image/jp2', 'image/jpx', 'image/jpm', 'image/mj2', 'audio/aiff', 'application/xml', 'application/x-mobipocket-ebook', 'image/heif', 'image/heif-sequence', 'image/heic', 'image/heic-sequence', 'image/icns', 'image/ktx', 'application/dicom', 'audio/x-musepack', 'text/calendar', 'text/vcard', 'model/gltf-binary', 'application/vnd.tcpdump.pcap', 'audio/x-dsf', // Non-standard
  'application/x.ms.shortcut', // Invented by us
  'application/x.apple.alias', // Invented by us
  'audio/x-voc', 'audio/vnd.dolby.dd-raw', 'audio/x-m4a', 'image/apng', 'image/x-olympus-orf', 'image/x-sony-arw', 'image/x-adobe-dng', 'image/x-nikon-nef', 'image/x-panasonic-rw2', 'image/x-fujifilm-raf', 'video/x-m4v', 'video/3gpp2', 'application/x-esri-shape', 'audio/aac', 'audio/x-it', 'audio/x-s3m', 'audio/x-xm', 'video/MP1S', 'video/MP2P', 'application/vnd.sketchup.skp', 'image/avif', 'application/x-lzh-compressed', 'application/pgp-encrypted', 'application/x-asar', 'model/stl', 'application/vnd.ms-htmlhelp', 'model/3mf', 'image/jxl', 'application/zstd']
};

var Token = lib$3;
var strtok3 = core$1;
var stringToBytes = util.stringToBytes,
    tarHeaderChecksumMatches = util.tarHeaderChecksumMatches,
    uint32SyncSafeToken = util.uint32SyncSafeToken;
var supported = supported$1;
var minimumBytes = 4100; // A fair amount of file-types are detectable within this range

function fromStream(_x) {
  return _fromStream.apply(this, arguments);
}

function _fromStream() {
  _fromStream = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(stream) {
    var tokenizer;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return strtok3.fromStream(stream);

          case 2:
            tokenizer = _context2.sent;
            _context2.prev = 3;
            _context2.next = 6;
            return fromTokenizer(tokenizer);

          case 6:
            return _context2.abrupt("return", _context2.sent);

          case 7:
            _context2.prev = 7;
            _context2.next = 10;
            return tokenizer.close();

          case 10:
            return _context2.finish(7);

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3,, 7, 11]]);
  }));
  return _fromStream.apply(this, arguments);
}

function fromBuffer(_x2) {
  return _fromBuffer.apply(this, arguments);
}

function _fromBuffer() {
  _fromBuffer = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(input) {
    var buffer, tokenizer;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer$6.isBuffer(input)) {
              _context3.next = 2;
              break;
            }

            throw new TypeError("Expected the `input` argument to be of type `Uint8Array` or `Buffer` or `ArrayBuffer`, got `".concat(_typeof(input), "`"));

          case 2:
            buffer = input instanceof Buffer$6 ? input : Buffer$6.from(input);

            if (buffer && buffer.length > 1) {
              _context3.next = 5;
              break;
            }

            return _context3.abrupt("return");

          case 5:
            tokenizer = strtok3.fromBuffer(buffer);
            return _context3.abrupt("return", fromTokenizer(tokenizer));

          case 7:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _fromBuffer.apply(this, arguments);
}

function _check(buffer, headers, options) {
  options = _objectSpread2({
    offset: 0
  }, options);

  var _iterator = _createForOfIteratorHelper(headers.entries()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
          index = _step$value[0],
          header = _step$value[1];

      // If a bitmask is set
      if (options.mask) {
        // If header doesn't equal `buf` with bits masked off
        if (header !== (options.mask[index] & buffer[index + options.offset])) {
          return false;
        }
      } else if (header !== buffer[index + options.offset]) {
        return false;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return true;
}

function fromTokenizer(_x3) {
  return _fromTokenizer2.apply(this, arguments);
}

function _fromTokenizer2() {
  _fromTokenizer2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(tokenizer) {
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            return _context4.abrupt("return", _fromTokenizer(tokenizer));

          case 4:
            _context4.prev = 4;
            _context4.t0 = _context4["catch"](0);

            if (_context4.t0 instanceof strtok3.EndOfStreamError) {
              _context4.next = 8;
              break;
            }

            throw _context4.t0;

          case 8:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[0, 4]]);
  }));
  return _fromTokenizer2.apply(this, arguments);
}

function _fromTokenizer(_x4) {
  return _fromTokenizer3.apply(this, arguments);
}

function _fromTokenizer3() {
  _fromTokenizer3 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(tokenizer) {
    var buffer, bytesRead, check, checkString, id3HeaderLen, zipHeader, type, mimeType, nextHeaderIndex, _type, brandMajor, maxBufferSize, _buffer, readField, readElement, readChildren, re, docType, str, readChunkHeader, chunk, readHeader, header, payload, typeId, _type2, jsonSize, _header, json;

    return regeneratorRuntime.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            buffer = Buffer$6.alloc(minimumBytes);
            bytesRead = 12;

            check = function check(header, options) {
              return _check(buffer, header, options);
            };

            checkString = function checkString(header, options) {
              return check(stringToBytes(header), options);
            }; // Keep reading until EOF if the file size is unknown.


            if (!tokenizer.fileInfo.size) {
              tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
            }

            _context10.next = 7;
            return tokenizer.peekBuffer(buffer, {
              length: bytesRead,
              mayBeLess: true
            });

          case 7:
            if (!check([0x42, 0x4D])) {
              _context10.next = 9;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'bmp',
              mime: 'image/bmp'
            });

          case 9:
            if (!check([0x0B, 0x77])) {
              _context10.next = 11;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'ac3',
              mime: 'audio/vnd.dolby.dd-raw'
            });

          case 11:
            if (!check([0x78, 0x01])) {
              _context10.next = 13;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'dmg',
              mime: 'application/x-apple-diskimage'
            });

          case 13:
            if (!check([0x4D, 0x5A])) {
              _context10.next = 15;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'exe',
              mime: 'application/x-msdownload'
            });

          case 15:
            if (!check([0x25, 0x21])) {
              _context10.next = 21;
              break;
            }

            _context10.next = 18;
            return tokenizer.peekBuffer(buffer, {
              length: 24,
              mayBeLess: true
            });

          case 18:
            if (!(checkString('PS-Adobe-', {
              offset: 2
            }) && checkString(' EPSF-', {
              offset: 14
            }))) {
              _context10.next = 20;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'eps',
              mime: 'application/eps'
            });

          case 20:
            return _context10.abrupt("return", {
              ext: 'ps',
              mime: 'application/postscript'
            });

          case 21:
            if (!(check([0x1F, 0xA0]) || check([0x1F, 0x9D]))) {
              _context10.next = 23;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'Z',
              mime: 'application/x-compress'
            });

          case 23:
            if (!check([0xFF, 0xD8, 0xFF])) {
              _context10.next = 25;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'jpg',
              mime: 'image/jpeg'
            });

          case 25:
            if (!check([0x49, 0x49, 0xBC])) {
              _context10.next = 27;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'jxr',
              mime: 'image/vnd.ms-photo'
            });

          case 27:
            if (!check([0x1F, 0x8B, 0x8])) {
              _context10.next = 29;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'gz',
              mime: 'application/gzip'
            });

          case 29:
            if (!check([0x42, 0x5A, 0x68])) {
              _context10.next = 31;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'bz2',
              mime: 'application/x-bzip2'
            });

          case 31:
            if (!checkString('ID3')) {
              _context10.next = 42;
              break;
            }

            _context10.next = 34;
            return tokenizer.ignore(6);

          case 34:
            _context10.next = 36;
            return tokenizer.readToken(uint32SyncSafeToken);

          case 36:
            id3HeaderLen = _context10.sent;

            if (!(tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size)) {
              _context10.next = 39;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mp3',
              mime: 'audio/mpeg'
            });

          case 39:
            _context10.next = 41;
            return tokenizer.ignore(id3HeaderLen);

          case 41:
            return _context10.abrupt("return", fromTokenizer(tokenizer));

          case 42:
            if (!checkString('MP+')) {
              _context10.next = 44;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mpc',
              mime: 'audio/x-musepack'
            });

          case 44:
            if (!((buffer[0] === 0x43 || buffer[0] === 0x46) && check([0x57, 0x53], {
              offset: 1
            }))) {
              _context10.next = 46;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'swf',
              mime: 'application/x-shockwave-flash'
            });

          case 46:
            if (!check([0x47, 0x49, 0x46])) {
              _context10.next = 48;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'gif',
              mime: 'image/gif'
            });

          case 48:
            if (!checkString('FLIF')) {
              _context10.next = 50;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'flif',
              mime: 'image/flif'
            });

          case 50:
            if (!checkString('8BPS')) {
              _context10.next = 52;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'psd',
              mime: 'image/vnd.adobe.photoshop'
            });

          case 52:
            if (!checkString('WEBP', {
              offset: 8
            })) {
              _context10.next = 54;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'webp',
              mime: 'image/webp'
            });

          case 54:
            if (!checkString('MPCK')) {
              _context10.next = 56;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mpc',
              mime: 'audio/x-musepack'
            });

          case 56:
            if (!checkString('FORM')) {
              _context10.next = 58;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'aif',
              mime: 'audio/aiff'
            });

          case 58:
            if (!checkString('icns', {
              offset: 0
            })) {
              _context10.next = 60;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'icns',
              mime: 'image/icns'
            });

          case 60:
            if (!check([0x50, 0x4B, 0x3, 0x4])) {
              _context10.next = 121;
              break;
            }

            _context10.prev = 61;

          case 62:
            if (!(tokenizer.position + 30 < tokenizer.fileInfo.size)) {
              _context10.next = 114;
              break;
            }

            _context10.next = 65;
            return tokenizer.readBuffer(buffer, {
              length: 30
            });

          case 65:
            // https://en.wikipedia.org/wiki/Zip_(file_format)#File_headers
            zipHeader = {
              compressedSize: buffer.readUInt32LE(18),
              uncompressedSize: buffer.readUInt32LE(22),
              filenameLength: buffer.readUInt16LE(26),
              extraFieldLength: buffer.readUInt16LE(28)
            };
            _context10.next = 68;
            return tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, 'utf-8'));

          case 68:
            zipHeader.filename = _context10.sent;
            _context10.next = 71;
            return tokenizer.ignore(zipHeader.extraFieldLength);

          case 71:
            if (!(zipHeader.filename === 'META-INF/mozilla.rsa')) {
              _context10.next = 73;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'xpi',
              mime: 'application/x-xpinstall'
            });

          case 73:
            if (!(zipHeader.filename.endsWith('.rels') || zipHeader.filename.endsWith('.xml'))) {
              _context10.next = 83;
              break;
            }

            type = zipHeader.filename.split('/')[0];
            _context10.t0 = type;
            _context10.next = _context10.t0 === '_rels' ? 78 : _context10.t0 === 'word' ? 79 : _context10.t0 === 'ppt' ? 80 : _context10.t0 === 'xl' ? 81 : 82;
            break;

          case 78:
            return _context10.abrupt("break", 83);

          case 79:
            return _context10.abrupt("return", {
              ext: 'docx',
              mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
            });

          case 80:
            return _context10.abrupt("return", {
              ext: 'pptx',
              mime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
            });

          case 81:
            return _context10.abrupt("return", {
              ext: 'xlsx',
              mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            });

          case 82:
            return _context10.abrupt("break", 83);

          case 83:
            if (!zipHeader.filename.startsWith('xl/')) {
              _context10.next = 85;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'xlsx',
              mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            });

          case 85:
            if (!(zipHeader.filename.startsWith('3D/') && zipHeader.filename.endsWith('.model'))) {
              _context10.next = 87;
              break;
            }

            return _context10.abrupt("return", {
              ext: '3mf',
              mime: 'model/3mf'
            });

          case 87:
            if (!(zipHeader.filename === 'mimetype' && zipHeader.compressedSize === zipHeader.uncompressedSize)) {
              _context10.next = 98;
              break;
            }

            _context10.next = 90;
            return tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, 'utf-8'));

          case 90:
            mimeType = _context10.sent;
            _context10.t1 = mimeType;
            _context10.next = _context10.t1 === 'application/epub+zip' ? 94 : _context10.t1 === 'application/vnd.oasis.opendocument.text' ? 95 : _context10.t1 === 'application/vnd.oasis.opendocument.spreadsheet' ? 96 : _context10.t1 === 'application/vnd.oasis.opendocument.presentation' ? 97 : 98;
            break;

          case 94:
            return _context10.abrupt("return", {
              ext: 'epub',
              mime: 'application/epub+zip'
            });

          case 95:
            return _context10.abrupt("return", {
              ext: 'odt',
              mime: 'application/vnd.oasis.opendocument.text'
            });

          case 96:
            return _context10.abrupt("return", {
              ext: 'ods',
              mime: 'application/vnd.oasis.opendocument.spreadsheet'
            });

          case 97:
            return _context10.abrupt("return", {
              ext: 'odp',
              mime: 'application/vnd.oasis.opendocument.presentation'
            });

          case 98:
            if (!(zipHeader.compressedSize === 0)) {
              _context10.next = 110;
              break;
            }

            nextHeaderIndex = -1;

          case 100:
            if (!(nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size)) {
              _context10.next = 108;
              break;
            }

            _context10.next = 103;
            return tokenizer.peekBuffer(buffer, {
              mayBeLess: true
            });

          case 103:
            nextHeaderIndex = buffer.indexOf('504B0304', 0, 'hex'); // Move position to the next header if found, skip the whole buffer otherwise

            _context10.next = 106;
            return tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);

          case 106:
            _context10.next = 100;
            break;

          case 108:
            _context10.next = 112;
            break;

          case 110:
            _context10.next = 112;
            return tokenizer.ignore(zipHeader.compressedSize);

          case 112:
            _context10.next = 62;
            break;

          case 114:
            _context10.next = 120;
            break;

          case 116:
            _context10.prev = 116;
            _context10.t2 = _context10["catch"](61);

            if (_context10.t2 instanceof strtok3.EndOfStreamError) {
              _context10.next = 120;
              break;
            }

            throw _context10.t2;

          case 120:
            return _context10.abrupt("return", {
              ext: 'zip',
              mime: 'application/zip'
            });

          case 121:
            if (!checkString('OggS')) {
              _context10.next = 140;
              break;
            }

            _context10.next = 124;
            return tokenizer.ignore(28);

          case 124:
            _type = Buffer$6.alloc(8);
            _context10.next = 127;
            return tokenizer.readBuffer(_type);

          case 127:
            if (!_check(_type, [0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64])) {
              _context10.next = 129;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'opus',
              mime: 'audio/opus'
            });

          case 129:
            if (!_check(_type, [0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61])) {
              _context10.next = 131;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'ogv',
              mime: 'video/ogg'
            });

          case 131:
            if (!_check(_type, [0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00])) {
              _context10.next = 133;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'ogm',
              mime: 'video/ogg'
            });

          case 133:
            if (!_check(_type, [0x7F, 0x46, 0x4C, 0x41, 0x43])) {
              _context10.next = 135;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'oga',
              mime: 'audio/ogg'
            });

          case 135:
            if (!_check(_type, [0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20])) {
              _context10.next = 137;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'spx',
              mime: 'audio/ogg'
            });

          case 137:
            if (!_check(_type, [0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73])) {
              _context10.next = 139;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'ogg',
              mime: 'audio/ogg'
            });

          case 139:
            return _context10.abrupt("return", {
              ext: 'ogx',
              mime: 'application/ogg'
            });

          case 140:
            if (!(check([0x50, 0x4B]) && (buffer[2] === 0x3 || buffer[2] === 0x5 || buffer[2] === 0x7) && (buffer[3] === 0x4 || buffer[3] === 0x6 || buffer[3] === 0x8))) {
              _context10.next = 142;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'zip',
              mime: 'application/zip'
            });

          case 142:
            if (!(checkString('ftyp', {
              offset: 4
            }) && (buffer[8] & 0x60) !== 0x00 // Brand major, first character ASCII?
            )) {
              _context10.next = 167;
              break;
            }

            // They all can have MIME `video/mp4` except `application/mp4` special-case which is hard to detect.
            // For some cases, we're specific, everything else falls to `video/mp4` with `mp4` extension.
            brandMajor = buffer.toString('binary', 8, 12).replace('\0', ' ').trim();
            _context10.t3 = brandMajor;
            _context10.next = _context10.t3 === 'avif' ? 147 : _context10.t3 === 'mif1' ? 148 : _context10.t3 === 'msf1' ? 149 : _context10.t3 === 'heic' ? 150 : _context10.t3 === 'heix' ? 150 : _context10.t3 === 'hevc' ? 151 : _context10.t3 === 'hevx' ? 151 : _context10.t3 === 'qt' ? 152 : _context10.t3 === 'M4V' ? 153 : _context10.t3 === 'M4VH' ? 153 : _context10.t3 === 'M4VP' ? 153 : _context10.t3 === 'M4P' ? 154 : _context10.t3 === 'M4B' ? 155 : _context10.t3 === 'M4A' ? 156 : _context10.t3 === 'F4V' ? 157 : _context10.t3 === 'F4P' ? 158 : _context10.t3 === 'F4A' ? 159 : _context10.t3 === 'F4B' ? 160 : _context10.t3 === 'crx' ? 161 : 162;
            break;

          case 147:
            return _context10.abrupt("return", {
              ext: 'avif',
              mime: 'image/avif'
            });

          case 148:
            return _context10.abrupt("return", {
              ext: 'heic',
              mime: 'image/heif'
            });

          case 149:
            return _context10.abrupt("return", {
              ext: 'heic',
              mime: 'image/heif-sequence'
            });

          case 150:
            return _context10.abrupt("return", {
              ext: 'heic',
              mime: 'image/heic'
            });

          case 151:
            return _context10.abrupt("return", {
              ext: 'heic',
              mime: 'image/heic-sequence'
            });

          case 152:
            return _context10.abrupt("return", {
              ext: 'mov',
              mime: 'video/quicktime'
            });

          case 153:
            return _context10.abrupt("return", {
              ext: 'm4v',
              mime: 'video/x-m4v'
            });

          case 154:
            return _context10.abrupt("return", {
              ext: 'm4p',
              mime: 'video/mp4'
            });

          case 155:
            return _context10.abrupt("return", {
              ext: 'm4b',
              mime: 'audio/mp4'
            });

          case 156:
            return _context10.abrupt("return", {
              ext: 'm4a',
              mime: 'audio/x-m4a'
            });

          case 157:
            return _context10.abrupt("return", {
              ext: 'f4v',
              mime: 'video/mp4'
            });

          case 158:
            return _context10.abrupt("return", {
              ext: 'f4p',
              mime: 'video/mp4'
            });

          case 159:
            return _context10.abrupt("return", {
              ext: 'f4a',
              mime: 'audio/mp4'
            });

          case 160:
            return _context10.abrupt("return", {
              ext: 'f4b',
              mime: 'audio/mp4'
            });

          case 161:
            return _context10.abrupt("return", {
              ext: 'cr3',
              mime: 'image/x-canon-cr3'
            });

          case 162:
            if (!brandMajor.startsWith('3g')) {
              _context10.next = 166;
              break;
            }

            if (!brandMajor.startsWith('3g2')) {
              _context10.next = 165;
              break;
            }

            return _context10.abrupt("return", {
              ext: '3g2',
              mime: 'video/3gpp2'
            });

          case 165:
            return _context10.abrupt("return", {
              ext: '3gp',
              mime: 'video/3gpp'
            });

          case 166:
            return _context10.abrupt("return", {
              ext: 'mp4',
              mime: 'video/mp4'
            });

          case 167:
            if (!checkString('MThd')) {
              _context10.next = 169;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mid',
              mime: 'audio/midi'
            });

          case 169:
            if (!(checkString('wOFF') && (check([0x00, 0x01, 0x00, 0x00], {
              offset: 4
            }) || checkString('OTTO', {
              offset: 4
            })))) {
              _context10.next = 171;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'woff',
              mime: 'font/woff'
            });

          case 171:
            if (!(checkString('wOF2') && (check([0x00, 0x01, 0x00, 0x00], {
              offset: 4
            }) || checkString('OTTO', {
              offset: 4
            })))) {
              _context10.next = 173;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'woff2',
              mime: 'font/woff2'
            });

          case 173:
            if (!(check([0xD4, 0xC3, 0xB2, 0xA1]) || check([0xA1, 0xB2, 0xC3, 0xD4]))) {
              _context10.next = 175;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'pcap',
              mime: 'application/vnd.tcpdump.pcap'
            });

          case 175:
            if (!checkString('DSD ')) {
              _context10.next = 177;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'dsf',
              mime: 'audio/x-dsf' // Non-standard

            });

          case 177:
            if (!checkString('LZIP')) {
              _context10.next = 179;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'lz',
              mime: 'application/x-lzip'
            });

          case 179:
            if (!checkString('fLaC')) {
              _context10.next = 181;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'flac',
              mime: 'audio/x-flac'
            });

          case 181:
            if (!check([0x42, 0x50, 0x47, 0xFB])) {
              _context10.next = 183;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'bpg',
              mime: 'image/bpg'
            });

          case 183:
            if (!checkString('wvpk')) {
              _context10.next = 185;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'wv',
              mime: 'audio/wavpack'
            });

          case 185:
            if (!checkString('%PDF')) {
              _context10.next = 195;
              break;
            }

            _context10.next = 188;
            return tokenizer.ignore(1350);

          case 188:
            maxBufferSize = 10 * 1024 * 1024;
            _buffer = Buffer$6.alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));
            _context10.next = 192;
            return tokenizer.readBuffer(_buffer, {
              mayBeLess: true
            });

          case 192:
            if (!_buffer.includes(Buffer$6.from('AIPrivateData'))) {
              _context10.next = 194;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'ai',
              mime: 'application/postscript'
            });

          case 194:
            return _context10.abrupt("return", {
              ext: 'pdf',
              mime: 'application/pdf'
            });

          case 195:
            if (!check([0x00, 0x61, 0x73, 0x6D])) {
              _context10.next = 197;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'wasm',
              mime: 'application/wasm'
            });

          case 197:
            if (!check([0x49, 0x49, 0x2A, 0x0])) {
              _context10.next = 210;
              break;
            }

            if (!checkString('CR', {
              offset: 8
            })) {
              _context10.next = 200;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'cr2',
              mime: 'image/x-canon-cr2'
            });

          case 200:
            if (!(check([0x1C, 0x00, 0xFE, 0x00], {
              offset: 8
            }) || check([0x1F, 0x00, 0x0B, 0x00], {
              offset: 8
            }))) {
              _context10.next = 202;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'nef',
              mime: 'image/x-nikon-nef'
            });

          case 202:
            if (!(check([0x08, 0x00, 0x00, 0x00], {
              offset: 4
            }) && (check([0x2D, 0x00, 0xFE, 0x00], {
              offset: 8
            }) || check([0x27, 0x00, 0xFE, 0x00], {
              offset: 8
            })))) {
              _context10.next = 204;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'dng',
              mime: 'image/x-adobe-dng'
            });

          case 204:
            buffer = Buffer$6.alloc(24);
            _context10.next = 207;
            return tokenizer.peekBuffer(buffer);

          case 207:
            if (!((check([0x10, 0xFB, 0x86, 0x01], {
              offset: 4
            }) || check([0x08, 0x00, 0x00, 0x00], {
              offset: 4
            })) && // This pattern differentiates ARW from other TIFF-ish file types:
            check([0x00, 0xFE, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x01], {
              offset: 9
            }))) {
              _context10.next = 209;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'arw',
              mime: 'image/x-sony-arw'
            });

          case 209:
            return _context10.abrupt("return", {
              ext: 'tif',
              mime: 'image/tiff'
            });

          case 210:
            if (!check([0x4D, 0x4D, 0x0, 0x2A])) {
              _context10.next = 212;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'tif',
              mime: 'image/tiff'
            });

          case 212:
            if (!checkString('MAC ')) {
              _context10.next = 214;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'ape',
              mime: 'audio/ape'
            });

          case 214:
            if (!check([0x1A, 0x45, 0xDF, 0xA3])) {
              _context10.next = 230;
              break;
            }

            // Root element: EBML
            readField = /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
                var msb, mask, ic, id;
                return regeneratorRuntime.wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        _context5.next = 2;
                        return tokenizer.peekNumber(Token.UINT8);

                      case 2:
                        msb = _context5.sent;
                        mask = 0x80;
                        ic = 0; // 0 = A, 1 = B, 2 = C, 3 = D

                        while ((msb & mask) === 0) {
                          ++ic;
                          mask >>= 1;
                        }

                        id = Buffer$6.alloc(ic + 1);
                        _context5.next = 9;
                        return tokenizer.readBuffer(id);

                      case 9:
                        return _context5.abrupt("return", id);

                      case 10:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5);
              }));

              return function readField() {
                return _ref2.apply(this, arguments);
              };
            }();

            readElement = /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
                var id, lenField, nrLen;
                return regeneratorRuntime.wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        _context6.next = 2;
                        return readField();

                      case 2:
                        id = _context6.sent;
                        _context6.next = 5;
                        return readField();

                      case 5:
                        lenField = _context6.sent;
                        lenField[0] ^= 0x80 >> lenField.length - 1;
                        nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer

                        return _context6.abrupt("return", {
                          id: id.readUIntBE(0, id.length),
                          len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
                        });

                      case 9:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6);
              }));

              return function readElement() {
                return _ref3.apply(this, arguments);
              };
            }();

            readChildren = /*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(level, children) {
                var e;
                return regeneratorRuntime.wrap(function _callee7$(_context7) {
                  while (1) {
                    switch (_context7.prev = _context7.next) {
                      case 0:
                        if (!(children > 0)) {
                          _context7.next = 11;
                          break;
                        }

                        _context7.next = 3;
                        return readElement();

                      case 3:
                        e = _context7.sent;

                        if (!(e.id === 0x4282)) {
                          _context7.next = 6;
                          break;
                        }

                        return _context7.abrupt("return", tokenizer.readToken(new Token.StringType(e.len, 'utf-8')));

                      case 6:
                        _context7.next = 8;
                        return tokenizer.ignore(e.len);

                      case 8:
                        // ignore payload
                        --children;
                        _context7.next = 0;
                        break;

                      case 11:
                      case "end":
                        return _context7.stop();
                    }
                  }
                }, _callee7);
              }));

              return function readChildren(_x5, _x6) {
                return _ref4.apply(this, arguments);
              };
            }();

            _context10.next = 220;
            return readElement();

          case 220:
            re = _context10.sent;
            _context10.next = 223;
            return readChildren(1, re.len);

          case 223:
            docType = _context10.sent;
            _context10.t4 = docType;
            _context10.next = _context10.t4 === 'webm' ? 227 : _context10.t4 === 'matroska' ? 228 : 229;
            break;

          case 227:
            return _context10.abrupt("return", {
              ext: 'webm',
              mime: 'video/webm'
            });

          case 228:
            return _context10.abrupt("return", {
              ext: 'mkv',
              mime: 'video/x-matroska'
            });

          case 229:
            return _context10.abrupt("return");

          case 230:
            if (!check([0x52, 0x49, 0x46, 0x46])) {
              _context10.next = 237;
              break;
            }

            if (!check([0x41, 0x56, 0x49], {
              offset: 8
            })) {
              _context10.next = 233;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'avi',
              mime: 'video/vnd.avi'
            });

          case 233:
            if (!check([0x57, 0x41, 0x56, 0x45], {
              offset: 8
            })) {
              _context10.next = 235;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'wav',
              mime: 'audio/vnd.wave'
            });

          case 235:
            if (!check([0x51, 0x4C, 0x43, 0x4D], {
              offset: 8
            })) {
              _context10.next = 237;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'qcp',
              mime: 'audio/qcelp'
            });

          case 237:
            if (!checkString('SQLi')) {
              _context10.next = 239;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'sqlite',
              mime: 'application/x-sqlite3'
            });

          case 239:
            if (!check([0x4E, 0x45, 0x53, 0x1A])) {
              _context10.next = 241;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'nes',
              mime: 'application/x-nintendo-nes-rom'
            });

          case 241:
            if (!checkString('Cr24')) {
              _context10.next = 243;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'crx',
              mime: 'application/x-google-chrome-extension'
            });

          case 243:
            if (!(checkString('MSCF') || checkString('ISc('))) {
              _context10.next = 245;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'cab',
              mime: 'application/vnd.ms-cab-compressed'
            });

          case 245:
            if (!check([0xED, 0xAB, 0xEE, 0xDB])) {
              _context10.next = 247;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'rpm',
              mime: 'application/x-rpm'
            });

          case 247:
            if (!check([0xC5, 0xD0, 0xD3, 0xC6])) {
              _context10.next = 249;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'eps',
              mime: 'application/eps'
            });

          case 249:
            if (!check([0x28, 0xB5, 0x2F, 0xFD])) {
              _context10.next = 251;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'zst',
              mime: 'application/zstd'
            });

          case 251:
            if (!check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {
              _context10.next = 253;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'otf',
              mime: 'font/otf'
            });

          case 253:
            if (!checkString('#!AMR')) {
              _context10.next = 255;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'amr',
              mime: 'audio/amr'
            });

          case 255:
            if (!checkString('{\\rtf')) {
              _context10.next = 257;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'rtf',
              mime: 'application/rtf'
            });

          case 257:
            if (!check([0x46, 0x4C, 0x56, 0x01])) {
              _context10.next = 259;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'flv',
              mime: 'video/x-flv'
            });

          case 259:
            if (!checkString('IMPM')) {
              _context10.next = 261;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'it',
              mime: 'audio/x-it'
            });

          case 261:
            if (!(checkString('-lh0-', {
              offset: 2
            }) || checkString('-lh1-', {
              offset: 2
            }) || checkString('-lh2-', {
              offset: 2
            }) || checkString('-lh3-', {
              offset: 2
            }) || checkString('-lh4-', {
              offset: 2
            }) || checkString('-lh5-', {
              offset: 2
            }) || checkString('-lh6-', {
              offset: 2
            }) || checkString('-lh7-', {
              offset: 2
            }) || checkString('-lzs-', {
              offset: 2
            }) || checkString('-lz4-', {
              offset: 2
            }) || checkString('-lz5-', {
              offset: 2
            }) || checkString('-lhd-', {
              offset: 2
            }))) {
              _context10.next = 263;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'lzh',
              mime: 'application/x-lzh-compressed'
            });

          case 263:
            if (!check([0x00, 0x00, 0x01, 0xBA])) {
              _context10.next = 268;
              break;
            }

            if (!check([0x21], {
              offset: 4,
              mask: [0xF1]
            })) {
              _context10.next = 266;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mpg',
              // May also be .ps, .mpeg
              mime: 'video/MP1S'
            });

          case 266:
            if (!check([0x44], {
              offset: 4,
              mask: [0xC4]
            })) {
              _context10.next = 268;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mpg',
              // May also be .mpg, .m2p, .vob or .sub
              mime: 'video/MP2P'
            });

          case 268:
            if (!checkString('ITSF')) {
              _context10.next = 270;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'chm',
              mime: 'application/vnd.ms-htmlhelp'
            });

          case 270:
            if (!check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {
              _context10.next = 272;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'xz',
              mime: 'application/x-xz'
            });

          case 272:
            if (!checkString('<?xml ')) {
              _context10.next = 274;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'xml',
              mime: 'application/xml'
            });

          case 274:
            if (!check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {
              _context10.next = 276;
              break;
            }

            return _context10.abrupt("return", {
              ext: '7z',
              mime: 'application/x-7z-compressed'
            });

          case 276:
            if (!(check([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7]) && (buffer[6] === 0x0 || buffer[6] === 0x1))) {
              _context10.next = 278;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'rar',
              mime: 'application/x-rar-compressed'
            });

          case 278:
            if (!checkString('solid ')) {
              _context10.next = 280;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'stl',
              mime: 'model/stl'
            });

          case 280:
            if (!checkString('BLENDER')) {
              _context10.next = 282;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'blend',
              mime: 'application/x-blender'
            });

          case 282:
            if (!checkString('!<arch>')) {
              _context10.next = 291;
              break;
            }

            _context10.next = 285;
            return tokenizer.ignore(8);

          case 285:
            _context10.next = 287;
            return tokenizer.readToken(new Token.StringType(13, 'ascii'));

          case 287:
            str = _context10.sent;

            if (!(str === 'debian-binary')) {
              _context10.next = 290;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'deb',
              mime: 'application/x-deb'
            });

          case 290:
            return _context10.abrupt("return", {
              ext: 'ar',
              mime: 'application/x-unix-archive'
            });

          case 291:
            if (!check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {
              _context10.next = 309;
              break;
            }

            // ignore PNG signature
            readChunkHeader = /*#__PURE__*/function () {
              var _ref5 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
                return regeneratorRuntime.wrap(function _callee8$(_context8) {
                  while (1) {
                    switch (_context8.prev = _context8.next) {
                      case 0:
                        _context8.next = 2;
                        return tokenizer.readToken(Token.INT32_BE);

                      case 2:
                        _context8.t0 = _context8.sent;
                        _context8.next = 5;
                        return tokenizer.readToken(new Token.StringType(4, 'binary'));

                      case 5:
                        _context8.t1 = _context8.sent;
                        return _context8.abrupt("return", {
                          length: _context8.t0,
                          type: _context8.t1
                        });

                      case 7:
                      case "end":
                        return _context8.stop();
                    }
                  }
                }, _callee8);
              }));

              return function readChunkHeader() {
                return _ref5.apply(this, arguments);
              };
            }();

            _context10.next = 295;
            return tokenizer.ignore(8);

          case 295:
            _context10.next = 297;
            return readChunkHeader();

          case 297:
            chunk = _context10.sent;

            if (!(chunk.length < 0)) {
              _context10.next = 300;
              break;
            }

            return _context10.abrupt("return");

          case 300:
            _context10.t5 = chunk.type;
            _context10.next = _context10.t5 === 'IDAT' ? 303 : _context10.t5 === 'acTL' ? 304 : 305;
            break;

          case 303:
            return _context10.abrupt("return", {
              ext: 'png',
              mime: 'image/png'
            });

          case 304:
            return _context10.abrupt("return", {
              ext: 'apng',
              mime: 'image/apng'
            });

          case 305:
            _context10.next = 307;
            return tokenizer.ignore(chunk.length + 4);

          case 307:
            if (tokenizer.position + 8 < tokenizer.fileInfo.size) {
              _context10.next = 295;
              break;
            }

          case 308:
            return _context10.abrupt("return", {
              ext: 'png',
              mime: 'image/png'
            });

          case 309:
            if (!check([0x41, 0x52, 0x52, 0x4F, 0x57, 0x31, 0x00, 0x00])) {
              _context10.next = 311;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'arrow',
              mime: 'application/x-apache-arrow'
            });

          case 311:
            if (!check([0x67, 0x6C, 0x54, 0x46, 0x02, 0x00, 0x00, 0x00])) {
              _context10.next = 313;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'glb',
              mime: 'model/gltf-binary'
            });

          case 313:
            if (!(check([0x66, 0x72, 0x65, 0x65], {
              offset: 4
            }) || // `free`
            check([0x6D, 0x64, 0x61, 0x74], {
              offset: 4
            }) || // `mdat` MJPEG
            check([0x6D, 0x6F, 0x6F, 0x76], {
              offset: 4
            }) || // `moov`
            check([0x77, 0x69, 0x64, 0x65], {
              offset: 4
            }) // `wide`
            )) {
              _context10.next = 315;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mov',
              mime: 'video/quicktime'
            });

          case 315:
            if (!check([0x49, 0x49, 0x52, 0x4F, 0x08, 0x00, 0x00, 0x00, 0x18])) {
              _context10.next = 317;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'orf',
              mime: 'image/x-olympus-orf'
            });

          case 317:
            if (!checkString('gimp xcf ')) {
              _context10.next = 319;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'xcf',
              mime: 'image/x-xcf'
            });

          case 319:
            if (!check([0x49, 0x49, 0x55, 0x00, 0x18, 0x00, 0x00, 0x00, 0x88, 0xE7, 0x74, 0xD8])) {
              _context10.next = 321;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'rw2',
              mime: 'image/x-panasonic-rw2'
            });

          case 321:
            if (!check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {
              _context10.next = 346;
              break;
            }

            readHeader = /*#__PURE__*/function () {
              var _ref6 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
                var guid;
                return regeneratorRuntime.wrap(function _callee9$(_context9) {
                  while (1) {
                    switch (_context9.prev = _context9.next) {
                      case 0:
                        guid = Buffer$6.alloc(16);
                        _context9.next = 3;
                        return tokenizer.readBuffer(guid);

                      case 3:
                        _context9.t0 = guid;
                        _context9.t1 = Number;
                        _context9.next = 7;
                        return tokenizer.readToken(Token.UINT64_LE);

                      case 7:
                        _context9.t2 = _context9.sent;
                        _context9.t3 = (0, _context9.t1)(_context9.t2);
                        return _context9.abrupt("return", {
                          id: _context9.t0,
                          size: _context9.t3
                        });

                      case 10:
                      case "end":
                        return _context9.stop();
                    }
                  }
                }, _callee9);
              }));

              return function readHeader() {
                return _ref6.apply(this, arguments);
              };
            }();

            _context10.next = 325;
            return tokenizer.ignore(30);

          case 325:
            if (!(tokenizer.position + 24 < tokenizer.fileInfo.size)) {
              _context10.next = 345;
              break;
            }

            _context10.next = 328;
            return readHeader();

          case 328:
            header = _context10.sent;
            payload = header.size - 24;

            if (!_check(header.id, [0x91, 0x07, 0xDC, 0xB7, 0xB7, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65])) {
              _context10.next = 341;
              break;
            }

            // Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)
            typeId = Buffer$6.alloc(16);
            _context10.t6 = payload;
            _context10.next = 335;
            return tokenizer.readBuffer(typeId);

          case 335:
            payload = _context10.t6 -= _context10.sent;

            if (!_check(typeId, [0x40, 0x9E, 0x69, 0xF8, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
              _context10.next = 338;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'asf',
              mime: 'audio/x-ms-asf'
            });

          case 338:
            if (!_check(typeId, [0xC0, 0xEF, 0x19, 0xBC, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
              _context10.next = 340;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'asf',
              mime: 'video/x-ms-asf'
            });

          case 340:
            return _context10.abrupt("break", 345);

          case 341:
            _context10.next = 343;
            return tokenizer.ignore(payload);

          case 343:
            _context10.next = 325;
            break;

          case 345:
            return _context10.abrupt("return", {
              ext: 'asf',
              mime: 'application/vnd.ms-asf'
            });

          case 346:
            if (!check([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A])) {
              _context10.next = 348;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'ktx',
              mime: 'image/ktx'
            });

          case 348:
            if (!((check([0x7E, 0x10, 0x04]) || check([0x7E, 0x18, 0x04])) && check([0x30, 0x4D, 0x49, 0x45], {
              offset: 4
            }))) {
              _context10.next = 350;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mie',
              mime: 'application/x-mie'
            });

          case 350:
            if (!check([0x27, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], {
              offset: 2
            })) {
              _context10.next = 352;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'shp',
              mime: 'application/x-esri-shape'
            });

          case 352:
            if (!check([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {
              _context10.next = 366;
              break;
            }

            _context10.next = 355;
            return tokenizer.ignore(20);

          case 355:
            _context10.next = 357;
            return tokenizer.readToken(new Token.StringType(4, 'ascii'));

          case 357:
            _type2 = _context10.sent;
            _context10.t7 = _type2;
            _context10.next = _context10.t7 === 'jp2 ' ? 361 : _context10.t7 === 'jpx ' ? 362 : _context10.t7 === 'jpm ' ? 363 : _context10.t7 === 'mjp2' ? 364 : 365;
            break;

          case 361:
            return _context10.abrupt("return", {
              ext: 'jp2',
              mime: 'image/jp2'
            });

          case 362:
            return _context10.abrupt("return", {
              ext: 'jpx',
              mime: 'image/jpx'
            });

          case 363:
            return _context10.abrupt("return", {
              ext: 'jpm',
              mime: 'image/jpm'
            });

          case 364:
            return _context10.abrupt("return", {
              ext: 'mj2',
              mime: 'image/mj2'
            });

          case 365:
            return _context10.abrupt("return");

          case 366:
            if (!(check([0xFF, 0x0A]) || check([0x00, 0x00, 0x00, 0x0C, 0x4A, 0x58, 0x4C, 0x20, 0x0D, 0x0A, 0x87, 0x0A]))) {
              _context10.next = 368;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'jxl',
              mime: 'image/jxl'
            });

          case 368:
            if (!(check([0x0, 0x0, 0x1, 0xBA]) || check([0x0, 0x0, 0x1, 0xB3]))) {
              _context10.next = 370;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mpg',
              mime: 'video/mpeg'
            });

          case 370:
            if (!check([0x00, 0x01, 0x00, 0x00, 0x00])) {
              _context10.next = 372;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'ttf',
              mime: 'font/ttf'
            });

          case 372:
            if (!check([0x00, 0x00, 0x01, 0x00])) {
              _context10.next = 374;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'ico',
              mime: 'image/x-icon'
            });

          case 374:
            if (!check([0x00, 0x00, 0x02, 0x00])) {
              _context10.next = 376;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'cur',
              mime: 'image/x-icon'
            });

          case 376:
            if (!check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {
              _context10.next = 378;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'cfb',
              mime: 'application/x-cfb'
            });

          case 378:
            _context10.next = 380;
            return tokenizer.peekBuffer(buffer, {
              length: Math.min(256, tokenizer.fileInfo.size),
              mayBeLess: true
            });

          case 380:
            if (!checkString('BEGIN:')) {
              _context10.next = 385;
              break;
            }

            if (!checkString('VCARD', {
              offset: 6
            })) {
              _context10.next = 383;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'vcf',
              mime: 'text/vcard'
            });

          case 383:
            if (!checkString('VCALENDAR', {
              offset: 6
            })) {
              _context10.next = 385;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'ics',
              mime: 'text/calendar'
            });

          case 385:
            if (!checkString('FUJIFILMCCD-RAW')) {
              _context10.next = 387;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'raf',
              mime: 'image/x-fujifilm-raf'
            });

          case 387:
            if (!checkString('Extended Module:')) {
              _context10.next = 389;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'xm',
              mime: 'audio/x-xm'
            });

          case 389:
            if (!checkString('Creative Voice File')) {
              _context10.next = 391;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'voc',
              mime: 'audio/x-voc'
            });

          case 391:
            if (!(check([0x04, 0x00, 0x00, 0x00]) && buffer.length >= 16)) {
              _context10.next = 403;
              break;
            }

            // Rough & quick check Pickle/ASAR
            jsonSize = buffer.readUInt32LE(12);

            if (!(jsonSize > 12 && buffer.length >= jsonSize + 16)) {
              _context10.next = 403;
              break;
            }

            _context10.prev = 394;
            _header = buffer.slice(16, jsonSize + 16).toString();
            json = JSON.parse(_header); // Check if Pickle is ASAR

            if (!json.files) {
              _context10.next = 399;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'asar',
              mime: 'application/x-asar'
            });

          case 399:
            _context10.next = 403;
            break;

          case 401:
            _context10.prev = 401;
            _context10.t8 = _context10["catch"](394);

          case 403:
            if (!check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {
              _context10.next = 405;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mxf',
              mime: 'application/mxf'
            });

          case 405:
            if (!checkString('SCRM', {
              offset: 44
            })) {
              _context10.next = 407;
              break;
            }

            return _context10.abrupt("return", {
              ext: 's3m',
              mime: 'audio/x-s3m'
            });

          case 407:
            if (!(check([0x47], {
              offset: 4
            }) && (check([0x47], {
              offset: 192
            }) || check([0x47], {
              offset: 196
            })))) {
              _context10.next = 409;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mts',
              mime: 'video/mp2t'
            });

          case 409:
            if (!check([0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49], {
              offset: 60
            })) {
              _context10.next = 411;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mobi',
              mime: 'application/x-mobipocket-ebook'
            });

          case 411:
            if (!check([0x44, 0x49, 0x43, 0x4D], {
              offset: 128
            })) {
              _context10.next = 413;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'dcm',
              mime: 'application/dicom'
            });

          case 413:
            if (!check([0x4C, 0x00, 0x00, 0x00, 0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46])) {
              _context10.next = 415;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'lnk',
              mime: 'application/x.ms.shortcut' // Invented by us

            });

          case 415:
            if (!check([0x62, 0x6F, 0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x72, 0x6B, 0x00, 0x00, 0x00, 0x00])) {
              _context10.next = 417;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'alias',
              mime: 'application/x.apple.alias' // Invented by us

            });

          case 417:
            if (!(check([0x4C, 0x50], {
              offset: 34
            }) && (check([0x00, 0x00, 0x01], {
              offset: 8
            }) || check([0x01, 0x00, 0x02], {
              offset: 8
            }) || check([0x02, 0x00, 0x02], {
              offset: 8
            })))) {
              _context10.next = 419;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'eot',
              mime: 'application/vnd.ms-fontobject'
            });

          case 419:
            if (!check([0x06, 0x06, 0xED, 0xF5, 0xD8, 0x1D, 0x46, 0xE5, 0xBD, 0x31, 0xEF, 0xE7, 0xFE, 0x74, 0xB7, 0x1D])) {
              _context10.next = 421;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'indd',
              mime: 'application/x-indesign'
            });

          case 421:
            _context10.next = 423;
            return tokenizer.peekBuffer(buffer, {
              length: Math.min(512, tokenizer.fileInfo.size),
              mayBeLess: true
            });

          case 423:
            if (!tarHeaderChecksumMatches(buffer)) {
              _context10.next = 425;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'tar',
              mime: 'application/x-tar'
            });

          case 425:
            if (!check([0xFF, 0xFE, 0xFF, 0x0E, 0x53, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x74, 0x00, 0x63, 0x00, 0x68, 0x00, 0x55, 0x00, 0x70, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x65, 0x00, 0x6C, 0x00])) {
              _context10.next = 427;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'skp',
              mime: 'application/vnd.sketchup.skp'
            });

          case 427:
            if (!checkString('-----BEGIN PGP MESSAGE-----')) {
              _context10.next = 429;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'pgp',
              mime: 'application/pgp-encrypted'
            });

          case 429:
            if (!(buffer.length >= 2 && check([0xFF, 0xE0], {
              offset: 0,
              mask: [0xFF, 0xE0]
            }))) {
              _context10.next = 440;
              break;
            }

            if (!check([0x10], {
              offset: 1,
              mask: [0x16]
            })) {
              _context10.next = 434;
              break;
            }

            if (!check([0x08], {
              offset: 1,
              mask: [0x08]
            })) {
              _context10.next = 433;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'aac',
              mime: 'audio/aac'
            });

          case 433:
            return _context10.abrupt("return", {
              ext: 'aac',
              mime: 'audio/aac'
            });

          case 434:
            if (!check([0x02], {
              offset: 1,
              mask: [0x06]
            })) {
              _context10.next = 436;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mp3',
              mime: 'audio/mpeg'
            });

          case 436:
            if (!check([0x04], {
              offset: 1,
              mask: [0x06]
            })) {
              _context10.next = 438;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mp2',
              mime: 'audio/mpeg'
            });

          case 438:
            if (!check([0x06], {
              offset: 1,
              mask: [0x06]
            })) {
              _context10.next = 440;
              break;
            }

            return _context10.abrupt("return", {
              ext: 'mp1',
              mime: 'audio/mpeg'
            });

          case 440:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10, null, [[61, 116], [394, 401]]);
  }));
  return _fromTokenizer3.apply(this, arguments);
}

var stream = function stream(readableStream) {
  return new Promise(function (resolve, reject) {
    // Using `eval` to work around issues when bundling with Webpack
    var stream = eval('require')('stream'); // eslint-disable-line no-eval

    readableStream.on('error', reject);
    readableStream.once('readable', /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var pass, outputStream, chunk, _fileType;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // Set up output stream
              pass = new stream.PassThrough();

              if (stream.pipeline) {
                outputStream = stream.pipeline(readableStream, pass, function () {});
              } else {
                outputStream = readableStream.pipe(pass);
              } // Read the input stream and detect the filetype


              chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer$6.alloc(0);
              _context.prev = 3;
              _context.next = 6;
              return fromBuffer(chunk);

            case 6:
              _fileType = _context.sent;
              pass.fileType = _fileType;
              _context.next = 13;
              break;

            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](3);
              reject(_context.t0);

            case 13:
              resolve(outputStream);

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 10]]);
    })));
  });
};

var fileType = {
  fromStream: fromStream,
  fromTokenizer: fromTokenizer,
  fromBuffer: fromBuffer,
  stream: stream
};
Object.defineProperty(fileType, 'extensions', {
  get: function get() {
    return new Set(supported.extensions);
  }
});
Object.defineProperty(fileType, 'mimeTypes', {
  get: function get() {
    return new Set(supported.mimeTypes);
  }
});
var core = fileType;

(function (module) {

  var ReadableWebToNodeStream = lib$4.ReadableWebToNodeStream;
  var core$1 = core;

  function fromStream(_x) {
    return _fromStream.apply(this, arguments);
  }

  function _fromStream() {
    _fromStream = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(stream) {
      var readableWebToNodeStream, fileType;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              readableWebToNodeStream = new ReadableWebToNodeStream(stream);
              _context.next = 3;
              return core$1.fromStream(readableWebToNodeStream);

            case 3:
              fileType = _context.sent;
              _context.next = 6;
              return readableWebToNodeStream.close();

            case 6:
              return _context.abrupt("return", fileType);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _fromStream.apply(this, arguments);
  }

  function fromBlob(_x2) {
    return _fromBlob.apply(this, arguments);
  }
  /**
  Convert Blobs to ArrayBuffer.
  @param {Blob} blob - Web API Blob.
  @returns {Promise<ArrayBuffer>}
  */


  function _fromBlob() {
    _fromBlob = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(blob) {
      var buffer;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return blobToArrayBuffer(blob);

            case 2:
              buffer = _context2.sent;
              return _context2.abrupt("return", core$1.fromBuffer(Buffer$6.from(buffer)));

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _fromBlob.apply(this, arguments);
  }

  function blobToArrayBuffer(blob) {
    if (blob.arrayBuffer) {
      return blob.arrayBuffer();
    } // TODO: Remove when stop supporting older environments


    return new Promise(function (resolve, reject) {
      var fileReader = new FileReader();
      fileReader.addEventListener('loadend', function (event) {
        resolve(event.target.result);
      });
      fileReader.addEventListener('error', function (event) {
        reject(new Error(event.message));
      });
      fileReader.addEventListener('abort', function (event) {
        reject(new Error(event.type));
      });
      fileReader.readAsArrayBuffer(blob);
    });
  }

  Object.assign(module.exports, core$1, {
    fromStream: fromStream,
    fromBlob: fromBlob
  });
})(browser$2);

var fileTypeBrowser;

if (typeof window !== 'undefined' && window) {
  fileTypeBrowser = browser$2.exports;
}
/**
 * Type representing a file in Node environment
 */


var NodeFileSchema = z.object({
  buffer: z.custom(function (data) {
    return data;
  }),
  name: z.optional(z.string())
});
var BrowserFileSchema = z.custom(function (data) {
  return data;
});
/**
 * Type representing a file in Node and browser environments
 */

var CrossPlatformFileSchema = z.union([NodeFileSchema, BrowserFileSchema]);
var isNodeFile = function isNodeFile(file) {
  if (file && file.buffer) {
    return true;
  }

  return false;
};
var ALLOWED_IMAGE_MIME_TYPES = ['image/jpeg', 'image/png', 'image/bmp', 'image/tiff', 'image/gif', 'image/webp'];
var ALLOWED_AUDIO_MIME_TYPES = ['audio/mpeg', 'audio/mp3', 'audio/aiff', 'audio/flac', 'audio/ogg', 'audio/wav', 'audio/vnd.wave'];

var getFileType = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(file) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!isNodeFile(file)) {
              _context.next = 6;
              break;
            }

            _context.next = 3;
            return fileType$1.fromBuffer(file.buffer);

          case 3:
            _context.t0 = _context.sent;
            _context.next = 9;
            break;

          case 6:
            _context.next = 8;
            return fileTypeBrowser.fromBlob(file);

          case 8:
            _context.t0 = _context.sent;

          case 9:
            return _context.abrupt("return", _context.t0);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getFileType(_x) {
    return _ref.apply(this, arguments);
  };
}();

var ImageFile = CrossPlatformFileSchema.refine( /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(file) {
    var fileType;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getFileType(file);

          case 2:
            fileType = _context2.sent;
            return _context2.abrupt("return", fileType && ALLOWED_IMAGE_MIME_TYPES.includes(fileType.mime));

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}(), "Image file has invalid file type. Supported file types are: ".concat(ALLOWED_IMAGE_MIME_TYPES.join(', ')));
var AudioFile = CrossPlatformFileSchema.refine( /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(file) {
    var fileType;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return getFileType(file);

          case 2:
            fileType = _context3.sent;
            return _context3.abrupt("return", fileType && ALLOWED_AUDIO_MIME_TYPES.includes(fileType.mime));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
}(), "Audio file has invalid file type. Supported file types are: ".concat(ALLOWED_AUDIO_MIME_TYPES.join(', ')));

var Mood;

(function (Mood) {
  Mood["PEACEFUL"] = "Peaceful";
  Mood["ROMANTIC"] = "Romantic";
  Mood["SENTIMENTAL"] = "Sentimental";
  Mood["TENDER"] = "Tender";
  Mood["EASYGOING"] = "Easygoing";
  Mood["YEARNING"] = "Yearning";
  Mood["SOPHISTICATED"] = "Sophisticated";
  Mood["SENSUAL"] = "Sensual";
  Mood["COOL"] = "Cool";
  Mood["GRITTY"] = "Gritty";
  Mood["MELANCHOLY"] = "Melancholy";
  Mood["SERIOUS"] = "Serious";
  Mood["BROODING"] = "Brooding";
  Mood["FIERY"] = "Fiery";
  Mood["DEFIANT"] = "Defiant";
  Mood["AGGRESSIVE"] = "Aggressive";
  Mood["ROWDY"] = "Rowdy";
  Mood["EXCITED"] = "Excited";
  Mood["ENERGIZING"] = "Energizing";
  Mood["EMPOWERING"] = "Empowering";
  Mood["STIRRING"] = "Stirring";
  Mood["UPBEAT"] = "Upbeat";
  Mood["OTHER"] = "Other";
})(Mood || (Mood = {}));

var Genre;

(function (Genre) {
  Genre["ALL"] = "All Genres";
  Genre["ELECTRONIC"] = "Electronic";
  Genre["ROCK"] = "Rock";
  Genre["METAL"] = "Metal";
  Genre["ALTERNATIVE"] = "Alternative";
  Genre["HIP_HOP_RAP"] = "Hip-Hop/Rap";
  Genre["EXPERIMENTAL"] = "Experimental";
  Genre["PUNK"] = "Punk";
  Genre["FOLK"] = "Folk";
  Genre["POP"] = "Pop";
  Genre["AMBIENT"] = "Ambient";
  Genre["SOUNDTRACK"] = "Soundtrack";
  Genre["WORLD"] = "World";
  Genre["JAZZ"] = "Jazz";
  Genre["ACOUSTIC"] = "Acoustic";
  Genre["FUNK"] = "Funk";
  Genre["R_AND_B_SOUL"] = "R&B/Soul";
  Genre["DEVOTIONAL"] = "Devotional";
  Genre["CLASSICAL"] = "Classical";
  Genre["REGGAE"] = "Reggae";
  Genre["PODCASTS"] = "Podcasts";
  Genre["COUNTRY"] = "Country";
  Genre["SPOKEN_WORK"] = "Spoken Word";
  Genre["COMEDY"] = "Comedy";
  Genre["BLUES"] = "Blues";
  Genre["KIDS"] = "Kids";
  Genre["AUDIOBOOKS"] = "Audiobooks";
  Genre["LATIN"] = "Latin";
  Genre["LOFI"] = "Lo-Fi";
  Genre["HYPERPOP"] = "Hyperpop"; // Electronic Subgenres

  Genre["TECHNO"] = "Techno";
  Genre["TRAP"] = "Trap";
  Genre["HOUSE"] = "House";
  Genre["TECH_HOUSE"] = "Tech House";
  Genre["DEEP_HOUSE"] = "Deep House";
  Genre["DISCO"] = "Disco";
  Genre["ELECTRO"] = "Electro";
  Genre["JUNGLE"] = "Jungle";
  Genre["PROGRESSIVE_HOUSE"] = "Progressive House";
  Genre["HARDSTYLE"] = "Hardstyle";
  Genre["GLITCH_HOP"] = "Glitch Hop";
  Genre["TRANCE"] = "Trance";
  Genre["FUTURE_BASS"] = "Future Bass";
  Genre["FUTURE_HOUSE"] = "Future House";
  Genre["TROPICAL_HOUSE"] = "Tropical House";
  Genre["DOWNTEMPO"] = "Downtempo";
  Genre["DRUM_AND_BASS"] = "Drum & Bass";
  Genre["DUBSTEP"] = "Dubstep";
  Genre["JERSEY_CLUB"] = "Jersey Club";
  Genre["VAPORWAVE"] = "Vaporwave";
  Genre["MOOMBAHTON"] = "Moombahton";
})(Genre || (Genre = {}));

var messages = {
  titleRequiredError: 'Your track must have a name',
  artworkRequiredError: 'Artwork is required',
  genreRequiredError: 'Genre is required',
  invalidReleaseDateError: 'Release date should not be in the future'
};
var PremiumConditionsEthNFTCollection = z.object({
  chain: z.literal('eth'),
  address: z.string(),
  standard: z.union([z.literal('ERC721'), z.literal('ERC1155')]),
  name: z.string(),
  slug: z.string(),
  imageUrl: z.optional(z.string()),
  externalLink: z.optional(z.string())
}).strict();
var PremiumConditionsSolNFTCollection = z.object({
  chain: z.literal('sol'),
  address: z.string(),
  name: z.string(),
  imageUrl: z.optional(z.string()),
  externalLink: z.optional(z.string())
}).strict();
var PremiumConditionsNFTCollection = z.union([PremiumConditionsEthNFTCollection, PremiumConditionsSolNFTCollection]);
var PremiumConditionsFollowUserId = z.object({
  followUserId: HashId
}).strict();
var PremiumConditionsTipUserId = z.object({
  tipUserId: HashId
}).strict();
var createUploadTrackMetadataSchema = function createUploadTrackMetadataSchema() {
  return z.object({
    aiAttributionUserId: z.optional(HashId),
    description: z.optional(z.string().max(1000)),
    download: z.optional(z.object({
      cid: z.string(),
      isDownloadable: z["boolean"](),
      requiresFollow: z["boolean"]()
    }).strict().nullable()),
    fieldVisibility: z.optional(z.object({
      mood: z.optional(z["boolean"]()),
      tags: z.optional(z["boolean"]()),
      genre: z.optional(z["boolean"]()),
      share: z.optional(z["boolean"]()),
      playCount: z.optional(z["boolean"]()),
      remixes: z.optional(z["boolean"]())
    })),
    genre: z["enum"](Object.values(Genre)).nullable().refine(function (val) {
      return val !== null;
    }, {
      message: messages.genreRequiredError
    }),
    isPremium: z.optional(z["boolean"]()),
    isrc: z.optional(z.string().nullable()),
    isUnlisted: z.optional(z["boolean"]()),
    iswc: z.optional(z.string().nullable()),
    license: z.optional(z.string().nullable()),
    mood: z.optional(z["enum"](Object.values(Mood))).nullable(),
    premiumConditions: z.optional(z.union([PremiumConditionsNFTCollection, PremiumConditionsFollowUserId, PremiumConditionsTipUserId])),
    releaseDate: z.optional(z.date().max(new Date(), {
      message: messages.invalidReleaseDateError
    })),
    remixOf: z.optional(z.object({
      tracks: z.array(z.object({
        parentTrackId: HashId
      })).min(1)
    }).strict()),
    tags: z.optional(z.string()),
    title: z.string({
      required_error: messages.titleRequiredError
    }),
    previewStartSeconds: z.optional(z.number()),
    audioUploadId: z.optional(z.string()),
    previewCid: z.optional(z.string())
  });
};
var createUploadTrackSchema = function createUploadTrackSchema() {
  return z.object({
    userId: HashId,
    coverArtFile: ImageFile,
    metadata: createUploadTrackMetadataSchema().strict(),
    onProgress: z.optional(z["function"]().args(z.number())),
    trackFile: AudioFile
  }).strict();
};
var createUpdateTrackSchema = function createUpdateTrackSchema() {
  return z.object({
    userId: HashId,
    trackId: HashId,
    metadata: createUploadTrackMetadataSchema().strict().partial(),
    transcodePreview: z.optional(z["boolean"]()),
    coverArtFile: z.optional(ImageFile),
    onProgress: z.optional(z["function"]().args(z.number()))
  }).strict();
};
var DeleteTrackSchema = z.object({
  userId: HashId,
  trackId: HashId
}).strict();
var FavoriteTrackSchema = z.object({
  userId: HashId,
  trackId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: z["boolean"]()
  }).strict())
}).strict();
var UnfavoriteTrackSchema = z.object({
  userId: HashId,
  trackId: HashId
}).strict();
var RepostTrackSchema = z.object({
  userId: HashId,
  trackId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: z["boolean"]()
  }).strict())
}).strict();
var UnrepostTrackSchema = z.object({
  userId: HashId,
  trackId: HashId
}).strict();

var CreatePlaylistMetadataSchema = z.object({
  description: z.optional(z.string().max(1000)),
  playlistName: z.string(),
  isPrivate: z.optional(z["boolean"]())
}).strict();
var CreatePlaylistSchema = z.object({
  coverArtFile: z.optional(ImageFile),
  metadata: CreatePlaylistMetadataSchema,
  onProgress: z.optional(z["function"]().args(z.number())),
  trackIds: z.optional(z.array(HashId)),
  userId: HashId
}).strict();
var createUpdatePlaylistMetadataSchema = function createUpdatePlaylistMetadataSchema() {
  return createUploadPlaylistMetadataSchema().partial().merge(z.object({
    isPrivate: z.optional(z["boolean"]()),
    playlistContents: z.optional(z.array(z.object({
      timestamp: z.number(),
      metadataTimestamp: z.optional(z.number()),
      trackId: HashId
    })))
  })).strict();
};
var createUpdatePlaylistSchema = function createUpdatePlaylistSchema() {
  return z.object({
    userId: HashId,
    playlistId: HashId,
    coverArtFile: z.optional(ImageFile),
    metadata: createUpdatePlaylistMetadataSchema(),
    onProgress: z.optional(z["function"]().args(z.number()))
  }).strict();
};

var createUploadPlaylistMetadataSchema = function createUploadPlaylistMetadataSchema() {
  return z.object({
    description: z.optional(z.string().max(1000)),
    genre: z["enum"](Object.values(Genre)),
    license: z.optional(z.string()),
    mood: z.optional(z["enum"](Object.values(Mood))),
    playlistName: z.string(),
    releaseDate: z.optional(z.date().max(new Date(), {
      message: 'should not be in the future'
    })),
    tags: z.optional(z.string()),
    upc: z.optional(z.string())
  }).strict();
};

var createPlaylistTrackMetadataSchema = function createPlaylistTrackMetadataSchema() {
  return createUploadTrackMetadataSchema().partial({
    genre: true,
    mood: true,
    tags: true
  });
};

var createUploadPlaylistSchema = function createUploadPlaylistSchema() {
  return z.object({
    userId: HashId,
    coverArtFile: ImageFile,
    metadata: createUploadPlaylistMetadataSchema(),
    onProgress: z.optional(z["function"]().args(z.number())),

    /**
     * Track metadata is populated from the playlist if fields are missing
     */
    trackMetadatas: z.array(createPlaylistTrackMetadataSchema()),
    trackFiles: z.array(AudioFile)
  }).strict();
};
var PublishPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
var AddTrackToPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  trackId: HashId
}).strict();
var RemoveTrackFromPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  trackIndex: z.number()
}).strict();
var DeletePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
var FavoritePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: z["boolean"]()
  }).strict())
}).strict();
var UnfavoritePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
var RepostPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: z["boolean"]()
  }).strict())
}).strict();
var UnrepostPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();

/**
 * Calls fn and then retries once after 500ms, again after 1500ms, and again after 4000ms
 */

var retry3 = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(fn) {
    var onRetry,
        _args = arguments;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            onRetry = _args.length > 1 && _args[1] !== undefined ? _args[1] : function (_err) {};
            _context.next = 3;
            return retry(fn, {
              minTimeout: 500,
              maxTimeout: 4000,
              factor: 3,
              retries: 3,
              onRetry: onRetry
            });

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function retry3(_x) {
    return _ref.apply(this, arguments);
  };
}();

var TrackUploadHelper = /*#__PURE__*/function (_BaseAPI) {
  _inherits(TrackUploadHelper, _BaseAPI);

  var _super = _createSuper(TrackUploadHelper);

  function TrackUploadHelper() {
    _classCallCheck$1(this, TrackUploadHelper);

    return _super.apply(this, arguments);
  }

  _createClass$1(TrackUploadHelper, [{
    key: "generateId",
    value: function () {
      var _generateId = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(type) {
        var response, _yield$response$json, data, id;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.request({
                  path: "/".concat(type, "s/unclaimed_id"),
                  method: 'GET',
                  headers: {},
                  query: {
                    noCache: Math.floor(Math.random() * 1000).toString()
                  }
                });

              case 2:
                response = _context.sent;
                _context.next = 5;
                return response.json();

              case 5:
                _yield$response$json = _context.sent;
                data = _yield$response$json.data;
                id = decodeHashId(data);

                if (!(id === null)) {
                  _context.next = 10;
                  break;
                }

                throw new Error("Could not generate ".concat(type, " id"));

              case 10:
                return _context.abrupt("return", id);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function generateId(_x) {
        return _generateId.apply(this, arguments);
      }

      return generateId;
    }()
  }, {
    key: "transformTrackUploadMetadata",
    value: function transformTrackUploadMetadata(inputMetadata, userId) {
      var metadata = _objectSpread2(_objectSpread2({}, inputMetadata), {}, {
        ownerId: userId
      });

      var isPremium = metadata.isPremium;
      var isUnlisted = metadata.isUnlisted; // If track is premium, set remixes to false

      if (isPremium && metadata.fieldVisibility) {
        metadata.fieldVisibility.remixes = false;
      } // If track is public, set required visibility fields to true


      if (!isUnlisted) {
        metadata.fieldVisibility = _objectSpread2(_objectSpread2({}, metadata.fieldVisibility), {}, {
          genre: true,
          mood: true,
          tags: true,
          share: true,
          playCount: true
        });
      }

      return metadata;
    }
  }, {
    key: "populateTrackMetadataWithUploadResponse",
    value: function populateTrackMetadataWithUploadResponse(trackMetadata, audioResponse, coverArtResponse) {
      var _trackMetadata$downlo;

      return _objectSpread2(_objectSpread2({}, trackMetadata), {}, {
        trackSegments: [],
        trackCid: audioResponse.results['320'],
        previewCid: trackMetadata.previewStartSeconds ? audioResponse.results["320_preview|".concat(trackMetadata.previewStartSeconds)] : trackMetadata.previewCid,
        audioUploadId: audioResponse.id,
        download: (_trackMetadata$downlo = trackMetadata.download) !== null && _trackMetadata$downlo !== void 0 && _trackMetadata$downlo.isDownloadable ? _objectSpread2(_objectSpread2({}, trackMetadata.download), {}, {
          cid: audioResponse.results['320']
        }) : trackMetadata.download,
        coverArtSizes: coverArtResponse.id,
        duration: parseInt(audioResponse.probe.format.duration, 10)
      });
    }
  }]);

  return TrackUploadHelper;
}(BaseAPI$1);

var PlaylistsApi$1 = /*#__PURE__*/function (_GeneratedPlaylistsAp) {
  _inherits(PlaylistsApi, _GeneratedPlaylistsAp);

  var _super = _createSuper(PlaylistsApi);

  function PlaylistsApi(configuration, storage, entityManager, auth, logger) {
    var _this;

    _classCallCheck$1(this, PlaylistsApi);

    _this = _super.call(this, configuration);

    _defineProperty$4(_assertThisInitialized(_this), "storage", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "entityManager", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "logger", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "trackUploadHelper", void 0);

    _this.storage = storage;
    _this.entityManager = entityManager;
    _this.auth = auth;
    _this.logger = logger;
    _this.trackUploadHelper = new TrackUploadHelper(configuration);
    _this.logger = logger.createPrefixedLogger('[playlists-api]');
    return _this;
  }
  /** @hidden
   * Create a playlist from existing tracks
   */


  _createClass$1(PlaylistsApi, [{
    key: "createPlaylist",
    value: function () {
      var _createPlaylist = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, advancedOptions) {
        var _this2 = this;

        var _yield$parseParams, userId, coverArtFile, metadata, onProgress, trackIds, coverArtResponse, playlistId, currentBlock, updatedMetadata, response;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return parseParams('createPlaylist', CreatePlaylistSchema)(params);

              case 2:
                _yield$parseParams = _context2.sent;
                userId = _yield$parseParams.userId;
                coverArtFile = _yield$parseParams.coverArtFile;
                metadata = _yield$parseParams.metadata;
                onProgress = _yield$parseParams.onProgress;
                trackIds = _yield$parseParams.trackIds;
                _context2.t0 = coverArtFile;

                if (!_context2.t0) {
                  _context2.next = 13;
                  break;
                }

                _context2.next = 12;
                return retry3( /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.next = 2;
                          return _this2.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context.abrupt("return", _context.sent);

                        case 3:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                })), function (e) {
                  _this2.logger.info('Retrying uploadPlaylistCoverArt', e);
                });

              case 12:
                _context2.t0 = _context2.sent;

              case 13:
                coverArtResponse = _context2.t0;
                _context2.next = 16;
                return this.trackUploadHelper.generateId('playlist');

              case 16:
                playlistId = _context2.sent;
                _context2.next = 19;
                return this.entityManager.getCurrentBlock();

              case 19:
                currentBlock = _context2.sent;
                // Update metadata to include track ids
                updatedMetadata = _objectSpread2(_objectSpread2({}, metadata), {}, {
                  playlistContents: {
                    trackIds: (trackIds !== null && trackIds !== void 0 ? trackIds : []).map(function (trackId) {
                      return {
                        track: trackId,
                        time: currentBlock.timestamp
                      };
                    })
                  },
                  playlistImageSizesMultihash: coverArtResponse === null || coverArtResponse === void 0 ? void 0 : coverArtResponse.id
                }); // Write playlist metadata to chain

                _context2.next = 23;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.CREATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys(updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 23:
                response = _context2.sent;
                return _context2.abrupt("return", _objectSpread2(_objectSpread2({}, response), {}, {
                  playlistId: encodeHashId(playlistId)
                }));

              case 25:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function createPlaylist(_x, _x2) {
        return _createPlaylist.apply(this, arguments);
      }

      return createPlaylist;
    }()
    /** @hidden
     * Upload a playlist
     * Uploads the specified tracks and combines them into a playlist
     */

  }, {
    key: "uploadPlaylist",
    value: function () {
      var _uploadPlaylist = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, advancedOptions) {
        var parsedParameters;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return parseParams('uploadPlaylist', createUploadPlaylistSchema())(params);

              case 2:
                parsedParameters = _context3.sent;
                _context3.next = 5;
                return this.uploadPlaylistInternal(parsedParameters, advancedOptions);

              case 5:
                return _context3.abrupt("return", _context3.sent);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function uploadPlaylist(_x3, _x4) {
        return _uploadPlaylist.apply(this, arguments);
      }

      return uploadPlaylist;
    }()
    /** @hidden
     * Publish a playlist
     * Changes a playlist from private to public
     */

  }, {
    key: "publishPlaylist",
    value: function () {
      var _publishPlaylist = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, advancedOptions) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('publishPlaylist', PublishPlaylistSchema)(params);

              case 2:
                _context4.next = 4;
                return this.fetchAndUpdatePlaylist({
                  userId: params.userId,
                  playlistId: params.playlistId,
                  updateMetadata: function updateMetadata(playlist) {
                    return _objectSpread2(_objectSpread2({}, playlist), {}, {
                      isPrivate: false
                    });
                  }
                }, advancedOptions);

              case 4:
                return _context4.abrupt("return", _context4.sent);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function publishPlaylist(_x5, _x6) {
        return _publishPlaylist.apply(this, arguments);
      }

      return publishPlaylist;
    }()
    /** @hidden
     * Add a single track to the end of a playlist
     * For more control use updatePlaylist
     */

  }, {
    key: "addTrackToPlaylist",
    value: function () {
      var _addTrackToPlaylist = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, advancedOptions) {
        var currentBlock;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return parseParams('addTrackToPlaylist', AddTrackToPlaylistSchema)(params);

              case 2:
                _context5.next = 4;
                return this.entityManager.getCurrentBlock();

              case 4:
                currentBlock = _context5.sent;
                _context5.next = 7;
                return this.fetchAndUpdatePlaylist({
                  userId: params.userId,
                  playlistId: params.playlistId,
                  updateMetadata: function updateMetadata(playlist) {
                    var _playlist$playlistCon;

                    return _objectSpread2(_objectSpread2({}, playlist), {}, {
                      playlistContents: [].concat(_toConsumableArray((_playlist$playlistCon = playlist.playlistContents) !== null && _playlist$playlistCon !== void 0 ? _playlist$playlistCon : []), [{
                        trackId: params.trackId,
                        timestamp: currentBlock.timestamp
                      }])
                    });
                  }
                }, advancedOptions);

              case 7:
                return _context5.abrupt("return", _context5.sent);

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function addTrackToPlaylist(_x7, _x8) {
        return _addTrackToPlaylist.apply(this, arguments);
      }

      return addTrackToPlaylist;
    }()
    /** @hidden
     * Removes a single track at the given index of playlist
     * For more control use updatePlaylist
     */

  }, {
    key: "removeTrackFromPlaylist",
    value: function () {
      var _removeTrackFromPlaylist = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, advancedOptions) {
        var _yield$parseParams2, trackIndex;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return parseParams('removeTrackFromPlaylist', RemoveTrackFromPlaylistSchema)(params);

              case 2:
                _yield$parseParams2 = _context6.sent;
                trackIndex = _yield$parseParams2.trackIndex;
                _context6.next = 6;
                return this.fetchAndUpdatePlaylist({
                  userId: params.userId,
                  playlistId: params.playlistId,
                  updateMetadata: function updateMetadata(playlist) {
                    if (!playlist.playlistContents || playlist.playlistContents.length <= trackIndex) {
                      throw new Error("No track exists at index ".concat(trackIndex));
                    }

                    playlist.playlistContents.splice(trackIndex, 1);
                    return _objectSpread2(_objectSpread2({}, playlist), {}, {
                      playlistContents: playlist.playlistContents
                    });
                  }
                }, advancedOptions);

              case 6:
                return _context6.abrupt("return", _context6.sent);

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function removeTrackFromPlaylist(_x9, _x10) {
        return _removeTrackFromPlaylist.apply(this, arguments);
      }

      return removeTrackFromPlaylist;
    }()
    /** @hidden
     * Update a playlist
     */

  }, {
    key: "updatePlaylist",
    value: function () {
      var _updatePlaylist = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, advancedOptions) {
        var parsedParameters;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('updatePlaylist', createUpdatePlaylistSchema())(params);

              case 2:
                parsedParameters = _context7.sent;
                _context7.next = 5;
                return this.updatePlaylistInternal(parsedParameters, advancedOptions);

              case 5:
                return _context7.abrupt("return", _context7.sent);

              case 6:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function updatePlaylist(_x11, _x12) {
        return _updatePlaylist.apply(this, arguments);
      }

      return updatePlaylist;
    }()
    /** @hidden
     * Delete a playlist
     */

  }, {
    key: "deletePlaylist",
    value: function () {
      var _deletePlaylist = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, advancedOptions) {
        var _yield$parseParams3, userId, playlistId;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return parseParams('deletePlaylist', DeletePlaylistSchema)(params);

              case 2:
                _yield$parseParams3 = _context8.sent;
                userId = _yield$parseParams3.userId;
                playlistId = _yield$parseParams3.playlistId;
                _context8.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.DELETE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function deletePlaylist(_x13, _x14) {
        return _deletePlaylist.apply(this, arguments);
      }

      return deletePlaylist;
    }()
    /** @hidden
     * Favorite a playlist
     */

  }, {
    key: "favoritePlaylist",
    value: function () {
      var _favoritePlaylist = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, advancedOptions) {
        var _yield$parseParams4, userId, playlistId, metadata;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return parseParams('favoritePlaylist', FavoritePlaylistSchema)(params);

              case 2:
                _yield$parseParams4 = _context9.sent;
                userId = _yield$parseParams4.userId;
                playlistId = _yield$parseParams4.playlistId;
                metadata = _yield$parseParams4.metadata;
                _context9.next = 8;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.SAVE,
                  metadata: metadata && JSON.stringify(snakecaseKeys(metadata)),
                  auth: this.auth
                }, advancedOptions));

              case 8:
                return _context9.abrupt("return", _context9.sent);

              case 9:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function favoritePlaylist(_x15, _x16) {
        return _favoritePlaylist.apply(this, arguments);
      }

      return favoritePlaylist;
    }()
    /** @hidden
     * Unfavorite a playlist
     */

  }, {
    key: "unfavoritePlaylist",
    value: function () {
      var _unfavoritePlaylist = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, advancedOptions) {
        var _yield$parseParams5, userId, playlistId;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return parseParams('unfavoritePlaylist', UnfavoritePlaylistSchema)(params);

              case 2:
                _yield$parseParams5 = _context10.sent;
                userId = _yield$parseParams5.userId;
                playlistId = _yield$parseParams5.playlistId;
                _context10.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.UNSAVE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context10.abrupt("return", _context10.sent);

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function unfavoritePlaylist(_x17, _x18) {
        return _unfavoritePlaylist.apply(this, arguments);
      }

      return unfavoritePlaylist;
    }()
    /** @hidden
     * Repost a playlist
     */

  }, {
    key: "repostPlaylist",
    value: function () {
      var _repostPlaylist = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, advancedOptions) {
        var _yield$parseParams6, userId, playlistId, metadata;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return parseParams('respostPlaylist', RepostPlaylistSchema)(params);

              case 2:
                _yield$parseParams6 = _context11.sent;
                userId = _yield$parseParams6.userId;
                playlistId = _yield$parseParams6.playlistId;
                metadata = _yield$parseParams6.metadata;
                _context11.next = 8;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.REPOST,
                  metadata: metadata && JSON.stringify(snakecaseKeys(metadata)),
                  auth: this.auth
                }, advancedOptions));

              case 8:
                return _context11.abrupt("return", _context11.sent);

              case 9:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function repostPlaylist(_x19, _x20) {
        return _repostPlaylist.apply(this, arguments);
      }

      return repostPlaylist;
    }()
    /** @hidden
     * Unrepost a playlist
     */

  }, {
    key: "unrepostPlaylist",
    value: function () {
      var _unrepostPlaylist = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, advancedOptions) {
        var _yield$parseParams7, userId, playlistId;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return parseParams('unrepostPlaylist', UnrepostPlaylistSchema)(params);

              case 2:
                _yield$parseParams7 = _context12.sent;
                userId = _yield$parseParams7.userId;
                playlistId = _yield$parseParams7.playlistId;
                _context12.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.UNREPOST,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context12.abrupt("return", _context12.sent);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function unrepostPlaylist(_x21, _x22) {
        return _unrepostPlaylist.apply(this, arguments);
      }

      return unrepostPlaylist;
    }()
    /** @internal
     * Combines the metadata for a track and a collection (playlist or album),
     * taking the metadata from the playlist when the track is missing it.
     */

  }, {
    key: "combineMetadata",
    value: function combineMetadata(trackMetadata, playlistMetadata) {
      var metadata = trackMetadata;
      if (!metadata.mood) metadata.mood = playlistMetadata.mood;

      if (playlistMetadata.tags) {
        if (!metadata.tags) {
          // Take playlist tags
          metadata.tags = playlistMetadata.tags;
        } else {
          // Combine tags and dedupe
          metadata.tags = _toConsumableArray(new Set([].concat(_toConsumableArray(metadata.tags.split(',')), _toConsumableArray(playlistMetadata.tags.split(','))))).join(',');
        }
      }

      return trackMetadata;
    }
    /** @internal
     * Update helper method that first fetches a playlist and then updates it
     */

  }, {
    key: "fetchAndUpdatePlaylist",
    value: function () {
      var _fetchAndUpdatePlaylist = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref2, advancedOptions) {
        var _playlistResponse$dat;

        var userId, playlistId, updateMetadata, playlistResponse, playlist, supportedUpdateFields;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                userId = _ref2.userId, playlistId = _ref2.playlistId, updateMetadata = _ref2.updateMetadata;
                _context13.next = 3;
                return this.getPlaylist({
                  playlistId: playlistId,
                  userId: userId
                });

              case 3:
                playlistResponse = _context13.sent;
                playlist = (_playlistResponse$dat = playlistResponse.data) === null || _playlistResponse$dat === void 0 ? void 0 : _playlistResponse$dat[0];

                if (playlist) {
                  _context13.next = 7;
                  break;
                }

                throw new Error("Could not fetch playlist: ".concat(playlistId));

              case 7:
                supportedUpdateFields = Object.keys(createUpdatePlaylistMetadataSchema().shape);
                _context13.next = 10;
                return this.updatePlaylist({
                  userId: userId,
                  playlistId: playlistId,
                  metadata: updateMetadata(pick(playlist, supportedUpdateFields))
                }, advancedOptions);

              case 10:
                return _context13.abrupt("return", _context13.sent);

              case 11:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function fetchAndUpdatePlaylist(_x23, _x24) {
        return _fetchAndUpdatePlaylist.apply(this, arguments);
      }

      return fetchAndUpdatePlaylist;
    }()
    /** @internal
     * Method to upload a playlist with already parsed inputs
     * This is used for both playlists and albums
     */

  }, {
    key: "uploadPlaylistInternal",
    value: function () {
      var _uploadPlaylistInternal = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(_ref3, advancedOptions) {
        var _this3 = this;

        var userId, coverArtFile, trackFiles, onProgress, metadata, trackMetadatas, _yield$Promise$all, _yield$Promise$all2, coverArtResponse, audioResponses, trackIds, playlistId, currentBlock, updatedMetadata, response;

        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                userId = _ref3.userId, coverArtFile = _ref3.coverArtFile, trackFiles = _ref3.trackFiles, onProgress = _ref3.onProgress, metadata = _ref3.metadata, trackMetadatas = _ref3.trackMetadatas;
                _context18.next = 3;
                return Promise.all([retry3( /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
                  return regeneratorRuntime.wrap(function _callee14$(_context14) {
                    while (1) {
                      switch (_context14.prev = _context14.next) {
                        case 0:
                          _context14.next = 2;
                          return _this3.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context14.abrupt("return", _context14.sent);

                        case 3:
                        case "end":
                          return _context14.stop();
                      }
                    }
                  }, _callee14);
                })), function (e) {
                  _this3.logger.info('Retrying uploadPlaylistCoverArt', e);
                })].concat(_toConsumableArray(trackFiles.map( /*#__PURE__*/function () {
                  var _ref5 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(trackFile) {
                    return regeneratorRuntime.wrap(function _callee16$(_context16) {
                      while (1) {
                        switch (_context16.prev = _context16.next) {
                          case 0:
                            _context16.next = 2;
                            return retry3( /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
                              return regeneratorRuntime.wrap(function _callee15$(_context15) {
                                while (1) {
                                  switch (_context15.prev = _context15.next) {
                                    case 0:
                                      _context15.next = 2;
                                      return _this3.storage.uploadFile({
                                        file: trackFile,
                                        onProgress: onProgress,
                                        template: 'audio'
                                      });

                                    case 2:
                                      return _context15.abrupt("return", _context15.sent);

                                    case 3:
                                    case "end":
                                      return _context15.stop();
                                  }
                                }
                              }, _callee15);
                            })), function (e) {
                              _this3.logger.info('Retrying uploadTrackAudio', e);
                            });

                          case 2:
                            return _context16.abrupt("return", _context16.sent);

                          case 3:
                          case "end":
                            return _context16.stop();
                        }
                      }
                    }, _callee16);
                  }));

                  return function (_x27) {
                    return _ref5.apply(this, arguments);
                  };
                }()))));

              case 3:
                _yield$Promise$all = _context18.sent;
                _yield$Promise$all2 = _toArray(_yield$Promise$all);
                coverArtResponse = _yield$Promise$all2[0];
                audioResponses = _yield$Promise$all2.slice(1);
                _context18.next = 9;
                return Promise.all(trackMetadatas.map( /*#__PURE__*/function () {
                  var _ref7 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(parsedTrackMetadata, i) {
                    var trackMetadata, audioResponse, updatedMetadata, trackId;
                    return regeneratorRuntime.wrap(function _callee17$(_context17) {
                      while (1) {
                        switch (_context17.prev = _context17.next) {
                          case 0:
                            // Transform track metadata
                            trackMetadata = _this3.combineMetadata(_this3.trackUploadHelper.transformTrackUploadMetadata(parsedTrackMetadata, userId), metadata);
                            audioResponse = audioResponses[i];

                            if (audioResponse) {
                              _context17.next = 4;
                              break;
                            }

                            throw new Error("Failed to upload track: ".concat(trackMetadata.title));

                          case 4:
                            // Update metadata to include uploaded CIDs
                            updatedMetadata = _this3.trackUploadHelper.populateTrackMetadataWithUploadResponse(trackMetadata, audioResponse, coverArtResponse);
                            _context17.next = 7;
                            return _this3.trackUploadHelper.generateId('track');

                          case 7:
                            trackId = _context17.sent;
                            _context17.next = 10;
                            return _this3.entityManager.manageEntity(_objectSpread2({
                              userId: userId,
                              entityType: EntityType.TRACK,
                              entityId: trackId,
                              action: Action.CREATE,
                              metadata: JSON.stringify({
                                cid: '',
                                data: snakecaseKeys(updatedMetadata)
                              }),
                              auth: _this3.auth
                            }, advancedOptions));

                          case 10:
                            return _context17.abrupt("return", trackId);

                          case 11:
                          case "end":
                            return _context17.stop();
                        }
                      }
                    }, _callee17);
                  }));

                  return function (_x28, _x29) {
                    return _ref7.apply(this, arguments);
                  };
                }()));

              case 9:
                trackIds = _context18.sent;
                _context18.next = 12;
                return this.trackUploadHelper.generateId('playlist');

              case 12:
                playlistId = _context18.sent;
                _context18.next = 15;
                return this.entityManager.getCurrentBlock();

              case 15:
                currentBlock = _context18.sent;
                // Update metadata to include track ids and cover art cid
                updatedMetadata = _objectSpread2(_objectSpread2({}, metadata), {}, {
                  isPrivate: false,
                  playlistContents: {
                    trackIds: trackIds.map(function (trackId) {
                      return {
                        track: trackId,
                        time: currentBlock.timestamp
                      };
                    })
                  },
                  playlistImageSizesMultihash: coverArtResponse.id
                }); // Write playlist metadata to chain

                _context18.next = 19;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.CREATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys(updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 19:
                response = _context18.sent;
                return _context18.abrupt("return", _objectSpread2(_objectSpread2({}, response), {}, {
                  playlistId: encodeHashId(playlistId)
                }));

              case 21:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function uploadPlaylistInternal(_x25, _x26) {
        return _uploadPlaylistInternal.apply(this, arguments);
      }

      return uploadPlaylistInternal;
    }()
    /** @internal
     * Method to update a playlist with already parsed inputs
     * This is used for both playlists and albums
     */

  }, {
    key: "updatePlaylistInternal",
    value: function () {
      var _updatePlaylistInternal = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(_ref8, advancedOptions) {
        var _this4 = this;

        var userId, playlistId, coverArtFile, onProgress, metadata, coverArtResponse, updatedMetadata;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                userId = _ref8.userId, playlistId = _ref8.playlistId, coverArtFile = _ref8.coverArtFile, onProgress = _ref8.onProgress, metadata = _ref8.metadata;
                _context20.t0 = coverArtFile;

                if (!_context20.t0) {
                  _context20.next = 6;
                  break;
                }

                _context20.next = 5;
                return retry3( /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
                  return regeneratorRuntime.wrap(function _callee19$(_context19) {
                    while (1) {
                      switch (_context19.prev = _context19.next) {
                        case 0:
                          _context19.next = 2;
                          return _this4.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context19.abrupt("return", _context19.sent);

                        case 3:
                        case "end":
                          return _context19.stop();
                      }
                    }
                  }, _callee19);
                })), function (e) {
                  _this4.logger.info('Retrying uploadPlaylistCoverArt', e);
                });

              case 5:
                _context20.t0 = _context20.sent;

              case 6:
                coverArtResponse = _context20.t0;
                updatedMetadata = _objectSpread2(_objectSpread2(_objectSpread2({}, metadata), metadata.playlistContents ? {
                  playlistContents: {
                    trackIds: metadata.playlistContents.map(function (_ref10) {
                      var trackId = _ref10.trackId,
                          metadataTimestamp = _ref10.metadataTimestamp,
                          timestamp = _ref10.timestamp;
                      return {
                        track: trackId,
                        // default to timestamp for legacy playlists
                        time: metadataTimestamp !== null && metadataTimestamp !== void 0 ? metadataTimestamp : timestamp
                      };
                    })
                  }
                } : {}), coverArtResponse ? {
                  playlistImageSizesMultihash: coverArtResponse.id
                } : {});
                _context20.next = 10;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.UPDATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys(updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 10:
                return _context20.abrupt("return", _context20.sent);

              case 11:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function updatePlaylistInternal(_x30, _x31) {
        return _updatePlaylistInternal.apply(this, arguments);
      }

      return updatePlaylistInternal;
    }()
  }]);

  return PlaylistsApi;
}(PlaylistsApi$2);

var getAlbumSchema = z.object({
  userId: z.string(),
  albumId: z.string()
});
var getAlbumTracksSchema = z.object({
  albumId: z.string()
});
var createUploadAlbumMetadataSchema = function createUploadAlbumMetadataSchema() {
  return z.object({
    albumName: z.string(),
    description: z.optional(z.string().max(1000)),
    genre: z["enum"](Object.values(Genre)),
    license: z.optional(z.string()),
    mood: z.optional(z["enum"](Object.values(Mood))),
    releaseDate: z.optional(z.date().max(new Date(), {
      message: 'should not be in the future'
    })),
    tags: z.optional(z.string()),
    upc: z.optional(z.string())
  }).strict();
};

var createAlbumTrackMetadataSchema = function createAlbumTrackMetadataSchema() {
  return createUploadTrackMetadataSchema().partial({
    genre: true,
    mood: true,
    tags: true
  });
};

var createUploadAlbumSchema = function createUploadAlbumSchema() {
  return z.object({
    userId: HashId,
    coverArtFile: ImageFile,
    metadata: createUploadAlbumMetadataSchema(),
    onProgress: z.optional(z["function"]().args(z.number())),

    /**
     * Track metadata is populated from the album if fields are missing
     */
    trackMetadatas: z.array(createAlbumTrackMetadataSchema()),
    trackFiles: z.array(AudioFile)
  }).strict();
};
var createUpdateAlbumSchema = function createUpdateAlbumSchema() {
  return z.object({
    userId: HashId,
    albumId: HashId,
    coverArtFile: z.optional(ImageFile),
    metadata: createUploadAlbumMetadataSchema().partial(),
    onProgress: z.optional(z["function"]().args(z.number()))
  }).strict();
};
var DeleteAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId
}).strict();
var FavoriteAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: z["boolean"]()
  }))
}).strict();
var UnfavoriteAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId
}).strict();
var RepostAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: z["boolean"]()
  }))
}).strict();
var UnrepostAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId
}).strict();

var _excluded = ["metadata"],
    _excluded2 = ["albumName"],
    _excluded3 = ["albumId", "metadata"],
    _excluded4 = ["albumName"];
var AlbumsApi = /*#__PURE__*/function () {
  function AlbumsApi(configuration, storage, entityManager, auth, logger) {
    _classCallCheck$1(this, AlbumsApi);

    _defineProperty$4(this, "playlistsApi", void 0);

    this.playlistsApi = new PlaylistsApi$1(configuration, storage, entityManager, auth, logger);
  } // READS


  _createClass$1(AlbumsApi, [{
    key: "getAlbum",
    value: function () {
      var _getAlbum = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var userId, albumId;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                userId = params.userId, albumId = params.albumId;
                _context.next = 3;
                return this.playlistsApi.getPlaylist({
                  userId: userId,
                  playlistId: albumId
                });

              case 3:
                return _context.abrupt("return", _context.sent);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAlbum(_x) {
        return _getAlbum.apply(this, arguments);
      }

      return getAlbum;
    }()
  }, {
    key: "getAlbumTracks",
    value: function () {
      var _getAlbumTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        var albumId;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                albumId = params.albumId;
                _context2.next = 3;
                return this.playlistsApi.getPlaylistTracks({
                  playlistId: albumId
                });

              case 3:
                return _context2.abrupt("return", _context2.sent);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getAlbumTracks(_x2) {
        return _getAlbumTracks.apply(this, arguments);
      }

      return getAlbumTracks;
    }() // WRITES

    /** @hidden
     * Upload an album
     * Uploads the specified tracks and combines them into an album
     */

  }, {
    key: "uploadAlbum",
    value: function () {
      var _uploadAlbum = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, advancedOptions) {
        var _yield$parseParams, metadata, parsedParameters, albumName, playlistMetadata, response;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return parseParams('uploadAlbum', createUploadAlbumSchema())(params);

              case 2:
                _yield$parseParams = _context3.sent;
                metadata = _yield$parseParams.metadata;
                parsedParameters = _objectWithoutProperties(_yield$parseParams, _excluded);
                albumName = metadata.albumName, playlistMetadata = _objectWithoutProperties(metadata, _excluded2); // Call uploadPlaylistInternal with parsed inputs

                _context3.next = 8;
                return this.playlistsApi.uploadPlaylistInternal(_objectSpread2(_objectSpread2({}, parsedParameters), {}, {
                  metadata: _objectSpread2(_objectSpread2({}, playlistMetadata), {}, {
                    playlistName: albumName,
                    isAlbum: true
                  })
                }), advancedOptions);

              case 8:
                response = _context3.sent;
                return _context3.abrupt("return", {
                  blockHash: response.blockHash,
                  blockNumber: response.blockNumber,
                  albumId: response.playlistId
                });

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function uploadAlbum(_x3, _x4) {
        return _uploadAlbum.apply(this, arguments);
      }

      return uploadAlbum;
    }()
    /** @hidden
     * Update an album
     */

  }, {
    key: "updateAlbum",
    value: function () {
      var _updateAlbum = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, advancedOptions) {
        var _yield$parseParams2, albumId, metadata, parsedParameters, albumName, playlistMetadata;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('updateAlbum', createUpdateAlbumSchema())(params);

              case 2:
                _yield$parseParams2 = _context4.sent;
                albumId = _yield$parseParams2.albumId;
                metadata = _yield$parseParams2.metadata;
                parsedParameters = _objectWithoutProperties(_yield$parseParams2, _excluded3);
                albumName = metadata.albumName, playlistMetadata = _objectWithoutProperties(metadata, _excluded4); // Call updatePlaylistInternal with parsed inputs

                _context4.next = 9;
                return this.playlistsApi.updatePlaylistInternal(_objectSpread2(_objectSpread2({}, parsedParameters), {}, {
                  playlistId: albumId,
                  metadata: _objectSpread2(_objectSpread2({}, playlistMetadata), {}, {
                    playlistName: albumName
                  })
                }), advancedOptions);

              case 9:
                return _context4.abrupt("return", _context4.sent);

              case 10:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function updateAlbum(_x5, _x6) {
        return _updateAlbum.apply(this, arguments);
      }

      return updateAlbum;
    }()
    /** @hidden
     * Delete an album
     */

  }, {
    key: "deleteAlbum",
    value: function () {
      var _deleteAlbum = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, advancedOptions) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return parseParams('deleteAlbum', DeleteAlbumSchema)(params);

              case 2:
                _context5.next = 4;
                return this.playlistsApi.deletePlaylist({
                  userId: params.userId,
                  playlistId: params.albumId
                }, advancedOptions);

              case 4:
                return _context5.abrupt("return", _context5.sent);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function deleteAlbum(_x7, _x8) {
        return _deleteAlbum.apply(this, arguments);
      }

      return deleteAlbum;
    }()
    /** @hidden
     * Favorite an album
     */

  }, {
    key: "favoriteAlbum",
    value: function () {
      var _favoriteAlbum = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, advancedOptions) {
        var _yield$parseParams3, metadata;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return parseParams('favoriteAlbum', FavoriteAlbumSchema)(params);

              case 2:
                _yield$parseParams3 = _context6.sent;
                metadata = _yield$parseParams3.metadata;
                _context6.next = 6;
                return this.playlistsApi.favoritePlaylist({
                  userId: params.userId,
                  playlistId: params.albumId,
                  metadata: metadata
                }, advancedOptions);

              case 6:
                return _context6.abrupt("return", _context6.sent);

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function favoriteAlbum(_x9, _x10) {
        return _favoriteAlbum.apply(this, arguments);
      }

      return favoriteAlbum;
    }()
    /** @hidden
     * Unfavorite an album
     */

  }, {
    key: "unfavoriteAlbum",
    value: function () {
      var _unfavoriteAlbum = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, advancedOptions) {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('unfavoriteAlbum', UnfavoriteAlbumSchema)(params);

              case 2:
                _context7.next = 4;
                return this.playlistsApi.unfavoritePlaylist({
                  userId: params.userId,
                  playlistId: params.albumId
                }, advancedOptions);

              case 4:
                return _context7.abrupt("return", _context7.sent);

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function unfavoriteAlbum(_x11, _x12) {
        return _unfavoriteAlbum.apply(this, arguments);
      }

      return unfavoriteAlbum;
    }()
    /** @hidden
     * Repost an album
     */

  }, {
    key: "repostAlbum",
    value: function () {
      var _repostAlbum = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, advancedOptions) {
        var _yield$parseParams4, metadata;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return parseParams('repostAlbum', RepostAlbumSchema)(params);

              case 2:
                _yield$parseParams4 = _context8.sent;
                metadata = _yield$parseParams4.metadata;
                _context8.next = 6;
                return this.playlistsApi.repostPlaylist({
                  userId: params.userId,
                  playlistId: params.albumId,
                  metadata: metadata
                }, advancedOptions);

              case 6:
                return _context8.abrupt("return", _context8.sent);

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function repostAlbum(_x13, _x14) {
        return _repostAlbum.apply(this, arguments);
      }

      return repostAlbum;
    }()
    /** @hidden
     * Unrepost an album
     */

  }, {
    key: "unrepostAlbum",
    value: function () {
      var _unrepostAlbum = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, advancedOptions) {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return parseParams('unrepostAlbum', UnrepostAlbumSchema)(params);

              case 2:
                _context9.next = 4;
                return this.playlistsApi.unrepostPlaylist({
                  userId: params.userId,
                  playlistId: params.albumId
                }, advancedOptions);

              case 4:
                return _context9.abrupt("return", _context9.sent);

              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function unrepostAlbum(_x15, _x16) {
        return _unrepostAlbum.apply(this, arguments);
      }

      return unrepostAlbum;
    }()
  }]);

  return AlbumsApi;
}();

var TracksApi$1 = /*#__PURE__*/function (_GeneratedTracksApi) {
  _inherits(TracksApi, _GeneratedTracksApi);

  var _super = _createSuper(TracksApi);

  function TracksApi(configuration, discoveryNodeSelectorService, storage, entityManager, auth, logger) {
    var _this;

    _classCallCheck$1(this, TracksApi);

    _this = _super.call(this, configuration);

    _defineProperty$4(_assertThisInitialized(_this), "discoveryNodeSelectorService", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "storage", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "entityManager", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "logger", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "trackUploadHelper", void 0);

    _this.discoveryNodeSelectorService = discoveryNodeSelectorService;
    _this.storage = storage;
    _this.entityManager = entityManager;
    _this.auth = auth;
    _this.logger = logger;
    _this.trackUploadHelper = new TrackUploadHelper(configuration);
    _this.logger = logger.createPrefixedLogger('[tracks-api]');
    return _this;
  }
  /**
   * Get the url of the track's streamable mp3 file
   */
  // @ts-expect-error


  _createClass$1(TracksApi, [{
    key: "streamTrack",
    value: function () {
      var _streamTrack = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var path, host;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrack.');

              case 2:
                path = "/tracks/{track_id}/stream".replace("{".concat('track_id', "}"), encodeURIComponent(String(params.trackId)));
                _context.next = 5;
                return this.discoveryNodeSelectorService.getSelectedEndpoint();

              case 5:
                host = _context.sent;
                return _context.abrupt("return", "".concat(host).concat(BASE_PATH$1).concat(path));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function streamTrack(_x) {
        return _streamTrack.apply(this, arguments);
      }

      return streamTrack;
    }()
    /** @hidden
     * Upload a track
     */

  }, {
    key: "uploadTrack",
    value: function () {
      var _uploadTrack = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, advancedOptions) {
        var _this2 = this;

        var _yield$parseParams, userId, trackFile, coverArtFile, parsedMetadata, onProgress, metadata, uploadOptions, _yield$Promise$all, _yield$Promise$all2, coverArtResponse, audioResponse, updatedMetadata, trackId, response;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('uploadTrack', createUploadTrackSchema())(params);

              case 2:
                _yield$parseParams = _context4.sent;
                userId = _yield$parseParams.userId;
                trackFile = _yield$parseParams.trackFile;
                coverArtFile = _yield$parseParams.coverArtFile;
                parsedMetadata = _yield$parseParams.metadata;
                onProgress = _yield$parseParams.onProgress;
                // Transform metadata
                metadata = this.trackUploadHelper.transformTrackUploadMetadata(parsedMetadata, userId);
                uploadOptions = {};

                if (metadata.previewStartSeconds) {
                  uploadOptions['previewStartSeconds'] = metadata.previewStartSeconds.toString();
                } // Upload track audio and cover art to storage node


                _context4.next = 13;
                return Promise.all([retry3( /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                  return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.next = 2;
                          return _this2.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context2.abrupt("return", _context2.sent);

                        case 3:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                })), function (e) {
                  _this2.logger.info('Retrying uploadTrackCoverArt', e);
                }), retry3( /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                  return regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 2;
                          return _this2.storage.uploadFile({
                            file: trackFile,
                            onProgress: onProgress,
                            template: 'audio',
                            options: uploadOptions
                          });

                        case 2:
                          return _context3.abrupt("return", _context3.sent);

                        case 3:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                })), function (e) {
                  _this2.logger.info('Retrying uploadTrackAudio', e);
                })]);

              case 13:
                _yield$Promise$all = _context4.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                coverArtResponse = _yield$Promise$all2[0];
                audioResponse = _yield$Promise$all2[1];
                // Update metadata to include uploaded CIDs
                updatedMetadata = this.trackUploadHelper.populateTrackMetadataWithUploadResponse(metadata, audioResponse, coverArtResponse); // Write metadata to chain

                _context4.next = 20;
                return this.trackUploadHelper.generateId('track');

              case 20:
                trackId = _context4.sent;
                _context4.next = 23;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.TRACK,
                  entityId: trackId,
                  action: Action.CREATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys(updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 23:
                response = _context4.sent;
                return _context4.abrupt("return", _objectSpread2(_objectSpread2({}, response), {}, {
                  trackId: encodeHashId(trackId)
                }));

              case 25:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function uploadTrack(_x2, _x3) {
        return _uploadTrack.apply(this, arguments);
      }

      return uploadTrack;
    }()
    /** @hidden
     * Update a track
     */

  }, {
    key: "updateTrack",
    value: function () {
      var _updateTrack = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, advancedOptions) {
        var _this3 = this;

        var _yield$parseParams2, userId, trackId, coverArtFile, parsedMetadata, onProgress, transcodePreview, metadata, coverArtResp, updatedMetadata, editFileData, updatePreviewResp, previewKey;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('updateTrack', createUpdateTrackSchema())(params);

              case 2:
                _yield$parseParams2 = _context7.sent;
                userId = _yield$parseParams2.userId;
                trackId = _yield$parseParams2.trackId;
                coverArtFile = _yield$parseParams2.coverArtFile;
                parsedMetadata = _yield$parseParams2.metadata;
                onProgress = _yield$parseParams2.onProgress;
                transcodePreview = _yield$parseParams2.transcodePreview;
                // Transform metadata
                metadata = this.trackUploadHelper.transformTrackUploadMetadata(parsedMetadata, userId); // Upload track cover art to storage node

                _context7.t0 = coverArtFile;

                if (!_context7.t0) {
                  _context7.next = 15;
                  break;
                }

                _context7.next = 14;
                return retry3( /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
                  return regeneratorRuntime.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return _this3.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context5.abrupt("return", _context5.sent);

                        case 3:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                })), function (e) {
                  _this3.logger.info('Retrying uploadTrackCoverArt', e);
                });

              case 14:
                _context7.t0 = _context7.sent;

              case 15:
                coverArtResp = _context7.t0;
                // Update metadata to include uploaded CIDs
                updatedMetadata = _objectSpread2(_objectSpread2({}, metadata), coverArtResp ? {
                  coverArtSizes: coverArtResp.id
                } : {});

                if (!transcodePreview) {
                  _context7.next = 28;
                  break;
                }

                if (updatedMetadata.previewStartSeconds) {
                  _context7.next = 20;
                  break;
                }

                throw new Error('No track preview start time specified');

              case 20:
                if (updatedMetadata.audioUploadId) {
                  _context7.next = 22;
                  break;
                }

                throw new Error('Missing required audio_upload_id');

              case 22:
                // Transocde track preview
                editFileData = {
                  previewStartSeconds: updatedMetadata.previewStartSeconds.toString()
                };
                _context7.next = 25;
                return retry3( /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
                  return regeneratorRuntime.wrap(function _callee6$(_context6) {
                    while (1) {
                      switch (_context6.prev = _context6.next) {
                        case 0:
                          _context6.next = 2;
                          return _this3.storage.editFile({
                            uploadId: updatedMetadata.audioUploadId,
                            data: editFileData,
                            auth: _this3.auth
                          });

                        case 2:
                          return _context6.abrupt("return", _context6.sent);

                        case 3:
                        case "end":
                          return _context6.stop();
                      }
                    }
                  }, _callee6);
                })), function (e) {
                  _this3.logger.info('Retrying editFileV2', e);
                });

              case 25:
                updatePreviewResp = _context7.sent;
                // Update metadata to include updated preview CID
                previewKey = "320_preview|".concat(updatedMetadata.previewStartSeconds);
                updatedMetadata.previewCid = updatePreviewResp.results[previewKey];

              case 28:
                _context7.next = 30;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.TRACK,
                  entityId: trackId,
                  action: Action.UPDATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys(updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 30:
                return _context7.abrupt("return", _context7.sent);

              case 31:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function updateTrack(_x4, _x5) {
        return _updateTrack.apply(this, arguments);
      }

      return updateTrack;
    }()
    /** @hidden
     * Delete a track
     */

  }, {
    key: "deleteTrack",
    value: function () {
      var _deleteTrack = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, advancedOptions) {
        var _yield$parseParams3, userId, trackId;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return parseParams('deleteTrack', DeleteTrackSchema)(params);

              case 2:
                _yield$parseParams3 = _context8.sent;
                userId = _yield$parseParams3.userId;
                trackId = _yield$parseParams3.trackId;
                _context8.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.TRACK,
                  entityId: trackId,
                  action: Action.DELETE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function deleteTrack(_x6, _x7) {
        return _deleteTrack.apply(this, arguments);
      }

      return deleteTrack;
    }()
    /** @hidden
     * Favorite a track
     */

  }, {
    key: "favoriteTrack",
    value: function () {
      var _favoriteTrack = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, advancedOptions) {
        var _yield$parseParams4, userId, trackId, metadata;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return parseParams('favoriteTrack', FavoriteTrackSchema)(params);

              case 2:
                _yield$parseParams4 = _context9.sent;
                userId = _yield$parseParams4.userId;
                trackId = _yield$parseParams4.trackId;
                metadata = _yield$parseParams4.metadata;
                _context9.next = 8;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.TRACK,
                  entityId: trackId,
                  action: Action.SAVE,
                  metadata: metadata && JSON.stringify(snakecaseKeys(metadata)),
                  auth: this.auth
                }, advancedOptions));

              case 8:
                return _context9.abrupt("return", _context9.sent);

              case 9:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function favoriteTrack(_x8, _x9) {
        return _favoriteTrack.apply(this, arguments);
      }

      return favoriteTrack;
    }()
    /** @hidden
     * Unfavorite a track
     */

  }, {
    key: "unfavoriteTrack",
    value: function () {
      var _unfavoriteTrack = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, advancedOptions) {
        var _yield$parseParams5, userId, trackId;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return parseParams('unfavoriteTrack', UnfavoriteTrackSchema)(params);

              case 2:
                _yield$parseParams5 = _context10.sent;
                userId = _yield$parseParams5.userId;
                trackId = _yield$parseParams5.trackId;
                _context10.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.TRACK,
                  entityId: trackId,
                  action: Action.UNSAVE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context10.abrupt("return", _context10.sent);

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function unfavoriteTrack(_x10, _x11) {
        return _unfavoriteTrack.apply(this, arguments);
      }

      return unfavoriteTrack;
    }()
    /** @hidden
     * Repost a track
     */

  }, {
    key: "repostTrack",
    value: function () {
      var _repostTrack = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, advancedOptions) {
        var _yield$parseParams6, userId, trackId, metadata;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return parseParams('respostTrack', RepostTrackSchema)(params);

              case 2:
                _yield$parseParams6 = _context11.sent;
                userId = _yield$parseParams6.userId;
                trackId = _yield$parseParams6.trackId;
                metadata = _yield$parseParams6.metadata;
                _context11.next = 8;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.TRACK,
                  entityId: trackId,
                  action: Action.REPOST,
                  metadata: metadata && JSON.stringify(snakecaseKeys(metadata)),
                  auth: this.auth
                }, advancedOptions));

              case 8:
                return _context11.abrupt("return", _context11.sent);

              case 9:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function repostTrack(_x12, _x13) {
        return _repostTrack.apply(this, arguments);
      }

      return repostTrack;
    }()
    /** @hidden
     * Unrepost a track
     */

  }, {
    key: "unrepostTrack",
    value: function () {
      var _unrepostTrack = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, advancedOptions) {
        var _yield$parseParams7, userId, trackId;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return parseParams('unrepostTrack', UnrepostTrackSchema)(params);

              case 2:
                _yield$parseParams7 = _context12.sent;
                userId = _yield$parseParams7.userId;
                trackId = _yield$parseParams7.trackId;
                _context12.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.TRACK,
                  entityId: trackId,
                  action: Action.UNREPOST,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context12.abrupt("return", _context12.sent);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function unrepostTrack(_x14, _x15) {
        return _unrepostTrack.apply(this, arguments);
      }

      return unrepostTrack;
    }()
  }]);

  return TracksApi;
}(TracksApi$2);

var UpdateProfileSchema = z.object({
  userId: HashId,
  profilePictureFile: z.optional(ImageFile),
  coverArtFile: z.optional(ImageFile),
  onProgress: z.optional(z["function"]().args(z.number())),
  metadata: z.object({
    name: z.optional(z.string()),
    bio: z.optional(z.string()),
    location: z.optional(z.string()),
    isDeactivated: z.optional(z["boolean"]()),
    artistPickTrackId: z.optional(HashId)
  }).strict()
}).strict();
var FollowUserSchema = z.object({
  userId: HashId,
  followeeUserId: HashId
}).strict();
var UnfollowUserSchema = z.object({
  userId: HashId,
  followeeUserId: HashId
}).strict();
var SubscribeToUserSchema = z.object({
  userId: HashId,
  subscribeeUserId: HashId
}).strict();
var UnsubscribeFromUserSchema = z.object({
  userId: HashId,
  subscribeeUserId: HashId
}).strict();

var UsersApi$1 = /*#__PURE__*/function (_GeneratedUsersApi) {
  _inherits(UsersApi, _GeneratedUsersApi);

  var _super = _createSuper(UsersApi);

  function UsersApi(configuration, storage, entityManager, auth, logger) {
    var _this;

    _classCallCheck$1(this, UsersApi);

    _this = _super.call(this, configuration);

    _defineProperty$4(_assertThisInitialized(_this), "storage", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "entityManager", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "logger", void 0);

    _this.storage = storage;
    _this.entityManager = entityManager;
    _this.auth = auth;
    _this.logger = logger;
    _this.logger = logger.createPrefixedLogger('[users-api]');
    return _this;
  }
  /** @hidden
   * Update a user profile
   */


  _createClass$1(UsersApi, [{
    key: "updateProfile",
    value: function () {
      var _updateProfile = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, advancedOptions) {
        var _this2 = this;

        var _yield$parseParams, onProgress, profilePictureFile, coverArtFile, userId, metadata, _yield$Promise$all, _yield$Promise$all2, profilePictureResp, coverArtResp, updatedMetadata;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return parseParams('updateProfile', UpdateProfileSchema)(params);

              case 2:
                _yield$parseParams = _context3.sent;
                onProgress = _yield$parseParams.onProgress;
                profilePictureFile = _yield$parseParams.profilePictureFile;
                coverArtFile = _yield$parseParams.coverArtFile;
                userId = _yield$parseParams.userId;
                metadata = _yield$parseParams.metadata;
                _context3.next = 10;
                return Promise.all([profilePictureFile && retry3( /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.next = 2;
                          return _this2.storage.uploadFile({
                            file: profilePictureFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context.abrupt("return", _context.sent);

                        case 3:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                })), function (e) {
                  _this2.logger.info('Retrying uploadProfilePicture', e);
                }), coverArtFile && retry3( /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                  return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.next = 2;
                          return _this2.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_backdrop'
                          });

                        case 2:
                          return _context2.abrupt("return", _context2.sent);

                        case 3:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                })), function (e) {
                  _this2.logger.info('Retrying uploadProfileCoverArt', e);
                })]);

              case 10:
                _yield$Promise$all = _context3.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                profilePictureResp = _yield$Promise$all2[0];
                coverArtResp = _yield$Promise$all2[1];
                updatedMetadata = _objectSpread2(_objectSpread2(_objectSpread2({}, metadata), profilePictureResp ? {
                  profilePicture: profilePictureResp === null || profilePictureResp === void 0 ? void 0 : profilePictureResp.id
                } : {}), coverArtResp ? {
                  coverPhoto: coverArtResp === null || coverArtResp === void 0 ? void 0 : coverArtResp.id
                } : {}); // Write metadata to chain

                _context3.next = 17;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.USER,
                  entityId: userId,
                  action: Action.UPDATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys(updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 17:
                return _context3.abrupt("return", _context3.sent);

              case 18:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function updateProfile(_x, _x2) {
        return _updateProfile.apply(this, arguments);
      }

      return updateProfile;
    }()
    /** @hidden
     * Follow a user
     */

  }, {
    key: "followUser",
    value: function () {
      var _followUser = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, advancedOptions) {
        var _yield$parseParams2, userId, followeeUserId;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('followUser', FollowUserSchema)(params);

              case 2:
                _yield$parseParams2 = _context4.sent;
                userId = _yield$parseParams2.userId;
                followeeUserId = _yield$parseParams2.followeeUserId;
                _context4.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.USER,
                  entityId: followeeUserId,
                  action: Action.FOLLOW,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context4.abrupt("return", _context4.sent);

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function followUser(_x3, _x4) {
        return _followUser.apply(this, arguments);
      }

      return followUser;
    }()
    /** @hidden
     * Unfollow a user
     */

  }, {
    key: "unfollowUser",
    value: function () {
      var _unfollowUser = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, advancedOptions) {
        var _yield$parseParams3, userId, followeeUserId;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return parseParams('unfollowUser', UnfollowUserSchema)(params);

              case 2:
                _yield$parseParams3 = _context5.sent;
                userId = _yield$parseParams3.userId;
                followeeUserId = _yield$parseParams3.followeeUserId;
                _context5.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.USER,
                  entityId: followeeUserId,
                  action: Action.UNFOLLOW,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context5.abrupt("return", _context5.sent);

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function unfollowUser(_x5, _x6) {
        return _unfollowUser.apply(this, arguments);
      }

      return unfollowUser;
    }()
    /** @hidden
     * Subscribe to a user
     */

  }, {
    key: "subscribeToUser",
    value: function () {
      var _subscribeToUser = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, advancedOptions) {
        var _yield$parseParams4, userId, subscribeeUserId;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return parseParams('subscribeToUser', SubscribeToUserSchema)(params);

              case 2:
                _yield$parseParams4 = _context6.sent;
                userId = _yield$parseParams4.userId;
                subscribeeUserId = _yield$parseParams4.subscribeeUserId;
                _context6.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.USER,
                  entityId: subscribeeUserId,
                  action: Action.SUBSCRIBE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context6.abrupt("return", _context6.sent);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function subscribeToUser(_x7, _x8) {
        return _subscribeToUser.apply(this, arguments);
      }

      return subscribeToUser;
    }()
    /** @hidden
     * Unsubscribe from a user
     */

  }, {
    key: "unsubscribeFromUser",
    value: function () {
      var _unsubscribeFromUser = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, advancedOptions) {
        var _yield$parseParams5, userId, subscribeeUserId;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('unsubscribeFromUser', UnsubscribeFromUserSchema)(params);

              case 2:
                _yield$parseParams5 = _context7.sent;
                userId = _yield$parseParams5.userId;
                subscribeeUserId = _yield$parseParams5.subscribeeUserId;
                _context7.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.USER,
                  entityId: subscribeeUserId,
                  action: Action.UNSUBSCRIBE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context7.abrupt("return", _context7.sent);

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function unsubscribeFromUser(_x9, _x10) {
        return _unsubscribeFromUser.apply(this, arguments);
      }

      return unsubscribeFromUser;
    }()
  }]);

  return UsersApi;
}(UsersApi$2);

var ResolveApi = /*#__PURE__*/function (_BaseAPI) {
  _inherits(ResolveApi, _BaseAPI);

  var _super = _createSuper(ResolveApi);

  function ResolveApi() {
    _classCallCheck$1(this, ResolveApi);

    return _super.apply(this, arguments);
  }

  _createClass$1(ResolveApi, [{
    key: "resolveRaw",
    value:
    /**
     * Resolves a provided Audius app URL to the API resource it represents
     */
    function () {
      var _resolveRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.url === null || params.url === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('url', 'Required parameter params.url was null or undefined when calling resolve.');

              case 2:
                queryParameters = {};

                if (params.url !== undefined) {
                  queryParameters.url = params.url;
                }

                headerParameters = {};
                _context.next = 7;
                return this.request({
                  path: "/resolve",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                });

              case 7:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (json) {
                  {
                    return TrackResponseFromJSON(json);
                  }
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function resolveRaw(_x) {
        return _resolveRaw.apply(this, arguments);
      }

      return resolveRaw;
    }()
  }, {
    key: "resolve",
    value: function () {
      var _resolve = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.resolveRaw(params);

              case 2:
                _context2.next = 4;
                return _context2.sent.value();

              case 4:
                return _context2.abrupt("return", _context2.sent);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function resolve(_x2) {
        return _resolve.apply(this, arguments);
      }

      return resolve;
    }()
  }]);

  return ResolveApi;
}(BaseAPI$1);

// NOTE: No imports allowed - quicktype is not yet able to track imports!

/**
 * Defines who the user allows to message them
 */
var ChatPermission;

(function (ChatPermission) {
  /**
   * Messages are allowed for everyone
   */
  ChatPermission["ALL"] = "all";
  /**
   * Messages are only allowed for users that have tipped me
   */

  ChatPermission["TIPPERS"] = "tippers";
  /**
   * Messages are only allowed for users I follow
   */

  ChatPermission["FOLLOWEES"] = "followees";
  /**
   * Messages are not allowed
   */

  ChatPermission["NONE"] = "none";
})(ChatPermission || (ChatPermission = {}));

var ChatListenRequestSchema = z.optional(z.object({
  currentUserId: z.optional(z.string())
}));
var ChatGetAllRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  limit: z.optional(z.number()),
  before: z.optional(z.string()),
  after: z.optional(z.string())
});
var ChatGetRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string()
});
var ChatGetMessagesRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  limit: z.optional(z.number()),
  before: z.optional(z.string()),
  after: z.optional(z.string())
});
var ChatGetUnreadCountRequestSchema = z.optional(z.object({
  currentUserId: z.optional(z.string())
}));
var ChatGetBlockersRequestSchema = z.optional(z.object({
  currentUserId: z.optional(z.string())
}));
var ChatCreateRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userId: z.string(),
  invitedUserIds: z.array(z.string()).min(1)
});
var ChatInviteRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  userId: z.string(),
  invitedUserIds: z.array(z.string()).min(1)
});
var ChatMessageRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  messageId: z.optional(z.string()),
  message: z.string()
});
var ChatReactRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  messageId: z.string(),
  reaction: z.nullable(z.string())
});
var ChatReadRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string()
});
var ChatBlockRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userId: z.string()
});
var ChatDeleteRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string()
});
var ChatPermitRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  permit: z.nativeEnum(ChatPermission)
});
var ChatValidateCanCreateRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userIds: z.array(z.string()).min(1)
});
var ChatGetPermissionRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userIds: z.array(z.string()).min(1)
});
var ChatUnfurlRequestSchema = z.object({
  urls: z.array(z.string()).min(1)
});

var GENERIC_MESSAGE_ERROR = 'Error: this message can not be displayed';
var ChatsApi = /*#__PURE__*/function (_BaseAPI) {
  _inherits(ChatsApi, _BaseAPI);

  var _super = _createSuper(ChatsApi);

  /**
   * A map of chatId => chatSecret so we don't have to repeatedly fetch it
   */

  /**
   * An event emitter that's used for consumers to listen for chat events
   */

  /**
   * The websocket currently in use
   */

  /**
   * The current user ID to use when connecting/reconnecting the websocket
   */

  /**
   * Proxy to the event emitter addListener
   */

  /**
   * Proxy to the event emitter removeListener
   */
  function ChatsApi(config, auth, discoveryNodeSelectorService, logger) {
    var _this;

    _classCallCheck$1(this, ChatsApi);

    _this = _super.call(this, config);

    _defineProperty$4(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "discoveryNodeSelectorService", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "logger", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "chatSecrets", {});

    _defineProperty$4(_assertThisInitialized(_this), "eventEmitter", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "websocket", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "listenUserId", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "addEventListener", void 0);

    _defineProperty$4(_assertThisInitialized(_this), "removeEventListener", void 0);

    _this.auth = auth;
    _this.discoveryNodeSelectorService = discoveryNodeSelectorService;
    _this.logger = logger;
    _this.eventEmitter = new EventEmitter$1();
    _this.addEventListener = _this.eventEmitter.addListener.bind(_this.eventEmitter);
    _this.removeEventListener = _this.eventEmitter.removeListener.bind(_this.eventEmitter); // Listen for discovery node selection changes and reinit websocket

    _this.discoveryNodeSelectorService.addEventListener('change', function (endpoint) {
      if (_this.websocket) {
        _this.websocket.close();

        _this.createWebsocket(endpoint).then(function (ws) {
          _this.websocket = ws;
        });
      }
    });

    _this.logger = logger.createPrefixedLogger('[chats-api]');
    return _this;
  } // #region QUERY

  /**
   * Establishes a websocket connection for listening to chat events.
   * @param params.currentUserId the user to listen for chat events for
   */


  _createClass$1(ChatsApi, [{
    key: "listen",
    value: function () {
      var _listen = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var parsedArgs, endpoint;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return parseParams('listen', ChatListenRequestSchema)(params);

              case 2:
                parsedArgs = _context.sent;
                this.listenUserId = parsedArgs === null || parsedArgs === void 0 ? void 0 : parsedArgs.currentUserId;
                _context.next = 6;
                return this.discoveryNodeSelectorService.getSelectedEndpoint();

              case 6:
                endpoint = _context.sent;

                if (!endpoint) {
                  _context.next = 13;
                  break;
                }

                _context.next = 10;
                return this.createWebsocket(endpoint);

              case 10:
                this.websocket = _context.sent;
                _context.next = 14;
                break;

              case 13:
                throw new Error('No services available to listen to');

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function listen(_x) {
        return _listen.apply(this, arguments);
      }

      return listen;
    }()
    /**
     * Gets a single chat
     * @param params.chatId the chat to get
     * @param params.currentUserId the user to act on behalf of
     * @returns the chat response
     */

  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        var _yield$parseParams, chatId, currentUserId, response;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return parseParams('get', ChatGetRequestSchema)(params);

              case 2:
                _yield$parseParams = _context2.sent;
                chatId = _yield$parseParams.chatId;
                currentUserId = _yield$parseParams.currentUserId;
                _context2.next = 7;
                return this.getRaw(chatId, currentUserId);

              case 7:
                response = _context2.sent;
                _context2.t0 = _objectSpread2;
                _context2.t1 = _objectSpread2({}, response);
                _context2.t2 = {};

                if (!response.data) {
                  _context2.next = 17;
                  break;
                }

                _context2.next = 14;
                return this.decryptLastChatMessage(response.data);

              case 14:
                _context2.t3 = _context2.sent;
                _context2.next = 18;
                break;

              case 17:
                _context2.t3 = response.data;

              case 18:
                _context2.t4 = _context2.t3;
                _context2.t5 = {
                  data: _context2.t4
                };
                return _context2.abrupt("return", (0, _context2.t0)(_context2.t1, _context2.t2, _context2.t5));

              case 21:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function get(_x2) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
    /**
     * Gets a list of chats
     * @param params.limit the max number of chats to get
     * @param params.before a timestamp cursor for pagination
     * @param params.after a timestamp cursor for pagination
     * @param params.currentUserId the user to act on behalf of
     * @returns the chat list response
     */

  }, {
    key: "getAll",
    value: function () {
      var _getAll = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params) {
        var _this2 = this;

        var _yield$parseParams2, currentUserId, limit, before, after, path, query, response, json, decrypted;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('getAll', ChatGetAllRequestSchema)(params);

              case 2:
                _yield$parseParams2 = _context4.sent;
                currentUserId = _yield$parseParams2.currentUserId;
                limit = _yield$parseParams2.limit;
                before = _yield$parseParams2.before;
                after = _yield$parseParams2.after;
                path = "/comms/chats";
                query = {
                  timestamp: new Date().getTime()
                };

                if (limit) {
                  query['limit'] = limit;
                }

                if (before) {
                  query['before'] = before;
                }

                if (after) {
                  query['after'] = after;
                }

                if (currentUserId) {
                  query['current_user_id'] = currentUserId;
                }

                _context4.next = 15;
                return this.signAndSendRequest({
                  method: 'GET',
                  headers: {},
                  path: path,
                  query: query
                });

              case 15:
                response = _context4.sent;
                _context4.next = 18;
                return response.json();

              case 18:
                json = _context4.sent;
                _context4.next = 21;
                return Promise.all(json.data.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(c) {
                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.next = 2;
                            return _this2.decryptLastChatMessage(c);

                          case 2:
                            return _context3.abrupt("return", _context3.sent);

                          case 3:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function (_x4) {
                    return _ref.apply(this, arguments);
                  };
                }()));

              case 21:
                decrypted = _context4.sent;
                return _context4.abrupt("return", _objectSpread2(_objectSpread2({}, json), {}, {
                  data: decrypted
                }));

              case 23:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAll(_x3) {
        return _getAll.apply(this, arguments);
      }

      return getAll;
    }()
    /**
     * Gets a list of messages
     * @param params.chatId the chat to get messages for
     * @param params.before a timestamp cursor for pagination
     * @param params.after a timestamp cursor for pagination
     * @param params.currentUserId the user to act on behalf of
     * @returns the messages list response
     */

  }, {
    key: "getMessages",
    value: function () {
      var _getMessages = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params) {
        var _this3 = this;

        var _yield$parseParams3, currentUserId, chatId, limit, before, after, sharedSecret, path, query, response, json, decrypted;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return parseParams('getMessages', ChatGetMessagesRequestSchema)(params);

              case 2:
                _yield$parseParams3 = _context6.sent;
                currentUserId = _yield$parseParams3.currentUserId;
                chatId = _yield$parseParams3.chatId;
                limit = _yield$parseParams3.limit;
                before = _yield$parseParams3.before;
                after = _yield$parseParams3.after;
                _context6.prev = 8;
                _context6.next = 11;
                return this.getChatSecret(chatId);

              case 11:
                sharedSecret = _context6.sent;
                _context6.next = 18;
                break;

              case 14:
                _context6.prev = 14;
                _context6.t0 = _context6["catch"](8);
                this.logger.error("[audius-sdk] Couldn't get chat secret", _context6.t0);
                throw new Error("[audius-sdk] Couldn't get chat secret");

              case 18:
                path = "/comms/chats/".concat(chatId, "/messages");
                query = {
                  timestamp: new Date().getTime()
                };

                if (limit) {
                  query['limit'] = limit;
                }

                if (before) {
                  query['before'] = before;
                }

                if (after) {
                  query['after'] = after;
                }

                if (currentUserId) {
                  query['current_user_id'] = currentUserId;
                }

                _context6.next = 26;
                return this.signAndSendRequest({
                  method: 'GET',
                  headers: {},
                  path: path,
                  query: query
                });

              case 26:
                response = _context6.sent;
                _context6.next = 29;
                return response.json();

              case 29:
                json = _context6.sent;
                _context6.next = 32;
                return Promise.all(json.data.map( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(m) {
                    return regeneratorRuntime.wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            _context5.t0 = _objectSpread2;
                            _context5.t1 = _objectSpread2({}, m);
                            _context5.t2 = {};
                            _context5.next = 5;
                            return _this3.decryptString(sharedSecret, base64.decode(m.message))["catch"](function (e) {
                              _this3.logger.error("[audius-sdk]: Error: Couldn't decrypt chat message", m, e);

                              return GENERIC_MESSAGE_ERROR;
                            });

                          case 5:
                            _context5.t3 = _context5.sent;
                            _context5.t4 = {
                              message: _context5.t3
                            };
                            return _context5.abrupt("return", (0, _context5.t0)(_context5.t1, _context5.t2, _context5.t4));

                          case 8:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function (_x6) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 32:
                decrypted = _context6.sent;
                return _context6.abrupt("return", _objectSpread2(_objectSpread2({}, json), {}, {
                  data: decrypted
                }));

              case 34:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[8, 14]]);
      }));

      function getMessages(_x5) {
        return _getMessages.apply(this, arguments);
      }

      return getMessages;
    }()
    /**
     * Gets the total unread message count for a user
     * @param params.currentUserId the user to act on behalf of
     * @returns the unread count response
     */

  }, {
    key: "getUnreadCount",
    value: function () {
      var _getUnreadCount = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params) {
        var parsedArgs, query, res;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('getUnreadCount', ChatGetUnreadCountRequestSchema)(params);

              case 2:
                parsedArgs = _context7.sent;
                query = {
                  timestamp: new Date().getTime()
                };

                if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
                  query['current_user_id'] = parsedArgs.currentUserId;
                }

                _context7.next = 7;
                return this.signAndSendRequest({
                  method: 'GET',
                  path: "/comms/chats/unread",
                  headers: {},
                  query: query
                });

              case 7:
                res = _context7.sent;
                _context7.next = 10;
                return res.json();

              case 10:
                return _context7.abrupt("return", _context7.sent);

              case 11:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getUnreadCount(_x7) {
        return _getUnreadCount.apply(this, arguments);
      }

      return getUnreadCount;
    }()
    /**
     * Gets the permission settings of the given users
     * @param params.userIds the users to fetch permissions of
     * @param params.currentUserId the user to act on behalf of
     * @returns the permissions response
     */

  }, {
    key: "getPermissions",
    value: function () {
      var _getPermissions = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params) {
        var query, _yield$parseParams4, userIds, currentUserId, res;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                query = {
                  timestamp: new Date().getTime()
                };
                _context8.next = 3;
                return parseParams('getPermissions', ChatGetPermissionRequestSchema)(params);

              case 3:
                _yield$parseParams4 = _context8.sent;
                userIds = _yield$parseParams4.userIds;
                currentUserId = _yield$parseParams4.currentUserId;
                query['id'] = userIds;

                if (currentUserId) {
                  query['current_user_id'] = currentUserId;
                }

                _context8.next = 10;
                return this.signAndSendRequest({
                  method: 'GET',
                  path: '/comms/chats/permissions',
                  headers: {},
                  query: query
                });

              case 10:
                res = _context8.sent;
                _context8.next = 13;
                return res.json();

              case 13:
                return _context8.abrupt("return", _context8.sent);

              case 14:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getPermissions(_x8) {
        return _getPermissions.apply(this, arguments);
      }

      return getPermissions;
    }()
    /**
     * Gets the user ids that have blocked the current user
     * @param params.currentUserId the user to act on behalf of
     * @returns the blockers response
     */

  }, {
    key: "getBlockers",
    value: function () {
      var _getBlockers = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params) {
        var parsedArgs, query, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return parseParams('getBlockers', ChatGetBlockersRequestSchema)(params);

              case 2:
                parsedArgs = _context9.sent;
                query = {
                  timestamp: new Date().getTime()
                };

                if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
                  query['current_user_id'] = parsedArgs.currentUserId;
                }

                _context9.next = 7;
                return this.signAndSendRequest({
                  method: 'GET',
                  path: "/comms/chats/blockers",
                  headers: {},
                  query: query
                });

              case 7:
                response = _context9.sent;
                _context9.next = 10;
                return response.json();

              case 10:
                return _context9.abrupt("return", _context9.sent);

              case 11:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getBlockers(_x9) {
        return _getBlockers.apply(this, arguments);
      }

      return getBlockers;
    }()
    /**
     * Gets the user ids the current user has blocked
     * @param params.currentUserId the user to act on behalf of
     * @returns
     */

  }, {
    key: "getBlockees",
    value: function () {
      var _getBlockees = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params) {
        var parsedArgs, query, response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return parseParams('getBlockees', ChatGetBlockersRequestSchema)(params);

              case 2:
                parsedArgs = _context10.sent;
                query = {
                  timestamp: new Date().getTime()
                };

                if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
                  query['current_user_id'] = parsedArgs.currentUserId;
                }

                _context10.next = 7;
                return this.signAndSendRequest({
                  method: 'GET',
                  path: "/comms/chats/blockees",
                  headers: {},
                  query: query
                });

              case 7:
                response = _context10.sent;
                _context10.next = 10;
                return response.json();

              case 10:
                return _context10.abrupt("return", _context10.sent);

              case 11:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getBlockees(_x10) {
        return _getBlockees.apply(this, arguments);
      }

      return getBlockees;
    }()
    /**
     * Gets URL metadata useful for link previews
     * @param params.content the urls to get metadata for
     * @returns the unfurl response
     */

  }, {
    key: "unfurl",
    value: function () {
      var _unfurl = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params) {
        var _yield$parseParams5, urls, query, res;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return parseParams('unfurl', ChatUnfurlRequestSchema)(params);

              case 2:
                _yield$parseParams5 = _context11.sent;
                urls = _yield$parseParams5.urls;
                query = {
                  content: urls
                };
                _context11.next = 7;
                return this.request({
                  method: 'GET',
                  path: '/comms/unfurl',
                  query: query,
                  headers: {}
                });

              case 7:
                res = _context11.sent;
                _context11.next = 10;
                return res.json();

              case 10:
                return _context11.abrupt("return", _context11.sent);

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function unfurl(_x11) {
        return _unfurl.apply(this, arguments);
      }

      return unfurl;
    }() // #endregion
    // #region MUTATE

    /**
     * Creates a chat between users
     * @param params.userId the user id who is creating the chat
     * @param params.invitedUserIds the user ids to add to the chat
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "create",
    value: function () {
      var _create = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params) {
        var _yield$parseParams6, currentUserId, userId, invitedUserIds, chatId, chatSecret, invites;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return parseParams('create', ChatCreateRequestSchema)(params);

              case 2:
                _yield$parseParams6 = _context12.sent;
                currentUserId = _yield$parseParams6.currentUserId;
                userId = _yield$parseParams6.userId;
                invitedUserIds = _yield$parseParams6.invitedUserIds;
                chatId = [userId].concat(_toConsumableArray(invitedUserIds)).sort().join(':');
                chatSecret = secp.utils.randomPrivateKey();
                _context12.next = 10;
                return this.createInvites(userId, invitedUserIds, chatSecret);

              case 10:
                invites = _context12.sent;
                _context12.next = 13;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.create',
                  params: {
                    chat_id: chatId,
                    invites: invites
                  }
                });

              case 13:
                return _context12.abrupt("return", _context12.sent);

              case 14:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function create(_x12) {
        return _create.apply(this, arguments);
      }

      return create;
    }()
    /**
     * Invites other users to an existing chat
     * @param params.chatId the chat id of the chat to invite to
     * @param params.userId the user id who is creating the chat
     * @param params.invitedUserIds the user ids to add to the chat
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "invite",
    value: function () {
      var _invite = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params) {
        var _yield$parseParams7, currentUserId, chatId, userId, invitedUserIds, chatSecret, invites;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return parseParams('invite', ChatInviteRequestSchema)(params);

              case 2:
                _yield$parseParams7 = _context13.sent;
                currentUserId = _yield$parseParams7.currentUserId;
                chatId = _yield$parseParams7.chatId;
                userId = _yield$parseParams7.userId;
                invitedUserIds = _yield$parseParams7.invitedUserIds;
                _context13.next = 9;
                return this.getChatSecret(chatId);

              case 9:
                chatSecret = _context13.sent;
                _context13.next = 12;
                return this.createInvites(userId, invitedUserIds, chatSecret);

              case 12:
                invites = _context13.sent;
                _context13.next = 15;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.invite',
                  params: {
                    chat_id: chatId,
                    invites: invites
                  }
                });

              case 15:
                return _context13.abrupt("return", _context13.sent);

              case 16:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function invite(_x13) {
        return _invite.apply(this, arguments);
      }

      return invite;
    }()
    /**
     * Sends a message to a user in a chat
     * @param params.message the message
     * @param params.chatId the chat to send a message in
     * @param params.messageId the id of the message
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "message",
    value: function () {
      var _message = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params) {
        var _yield$parseParams8, currentUserId, chatId, message, messageId, chatSecret, encrypted, encodedMessage;

        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return parseParams('message', ChatMessageRequestSchema)(params);

              case 2:
                _yield$parseParams8 = _context14.sent;
                currentUserId = _yield$parseParams8.currentUserId;
                chatId = _yield$parseParams8.chatId;
                message = _yield$parseParams8.message;
                messageId = _yield$parseParams8.messageId;
                _context14.next = 9;
                return this.getChatSecret(chatId);

              case 9:
                chatSecret = _context14.sent;
                _context14.next = 12;
                return this.encryptString(chatSecret, message);

              case 12:
                encrypted = _context14.sent;
                encodedMessage = base64.encode(encrypted);
                _context14.next = 16;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.message',
                  params: {
                    chat_id: chatId,
                    message_id: messageId !== null && messageId !== void 0 ? messageId : ulid(),
                    message: encodedMessage
                  }
                });

              case 16:
                return _context14.abrupt("return", _context14.sent);

              case 17:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function message(_x14) {
        return _message.apply(this, arguments);
      }

      return message;
    }()
    /**
     * Reacts to a message
     * @param params.reaction the reaction
     * @param params.chatId the chat to send a reaction in
     * @param params.messageId the id of the message to react to
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "react",
    value: function () {
      var _react = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(params) {
        var _yield$parseParams9, currentUserId, chatId, messageId, reaction;

        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return parseParams('react', ChatReactRequestSchema)(params);

              case 2:
                _yield$parseParams9 = _context15.sent;
                currentUserId = _yield$parseParams9.currentUserId;
                chatId = _yield$parseParams9.chatId;
                messageId = _yield$parseParams9.messageId;
                reaction = _yield$parseParams9.reaction;
                _context15.next = 9;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.react',
                  params: {
                    chat_id: chatId,
                    message_id: messageId,
                    reaction: reaction
                  }
                });

              case 9:
                return _context15.abrupt("return", _context15.sent);

              case 10:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function react(_x15) {
        return _react.apply(this, arguments);
      }

      return react;
    }()
    /**
     * Marks a chat as read
     * @param params.chatId the chat to mark as read
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "read",
    value: function () {
      var _read = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(params) {
        var _yield$parseParams10, currentUserId, chatId;

        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return parseParams('read', ChatReadRequestSchema)(params);

              case 2:
                _yield$parseParams10 = _context16.sent;
                currentUserId = _yield$parseParams10.currentUserId;
                chatId = _yield$parseParams10.chatId;
                _context16.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.read',
                  params: {
                    chat_id: chatId
                  }
                });

              case 7:
                return _context16.abrupt("return", _context16.sent);

              case 8:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function read(_x16) {
        return _read.apply(this, arguments);
      }

      return read;
    }()
    /**
     * Blocks a user from sending messages to the current user
     * @param params.userId the user to block
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "block",
    value: function () {
      var _block = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(params) {
        var _yield$parseParams11, currentUserId, userId;

        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return parseParams('block', ChatBlockRequestSchema)(params);

              case 2:
                _yield$parseParams11 = _context17.sent;
                currentUserId = _yield$parseParams11.currentUserId;
                userId = _yield$parseParams11.userId;
                _context17.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.block',
                  params: {
                    user_id: userId
                  }
                });

              case 7:
                return _context17.abrupt("return", _context17.sent);

              case 8:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function block(_x17) {
        return _block.apply(this, arguments);
      }

      return block;
    }()
    /**
     * Unblocks a user from sending messages to the current user
     * @param params.userId the user to unblock
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "unblock",
    value: function () {
      var _unblock = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(params) {
        var _yield$parseParams12, currentUserId, userId;

        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return parseParams('unblock', ChatBlockRequestSchema)(params);

              case 2:
                _yield$parseParams12 = _context18.sent;
                currentUserId = _yield$parseParams12.currentUserId;
                userId = _yield$parseParams12.userId;
                _context18.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.unblock',
                  params: {
                    user_id: userId
                  }
                });

              case 7:
                return _context18.abrupt("return", _context18.sent);

              case 8:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function unblock(_x18) {
        return _unblock.apply(this, arguments);
      }

      return unblock;
    }()
    /**
     * Clears a chat's history for the current user
     * @param params.chatId the chat to clear
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(params) {
        var _yield$parseParams13, currentUserId, chatId;

        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return parseParams('delete', ChatDeleteRequestSchema)(params);

              case 2:
                _yield$parseParams13 = _context19.sent;
                currentUserId = _yield$parseParams13.currentUserId;
                chatId = _yield$parseParams13.chatId;
                _context19.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.delete',
                  params: {
                    chat_id: chatId
                  }
                });

              case 7:
                return _context19.abrupt("return", _context19.sent);

              case 8:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function _delete(_x19) {
        return _delete2.apply(this, arguments);
      }

      return _delete;
    }()
    /**
     * Sets the inbox settings permissions of the current user
     * @param params.permit the permission to set
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "permit",
    value: function () {
      var _permit = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(params) {
        var _yield$parseParams14, currentUserId, permit;

        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return parseParams('permit', ChatPermitRequestSchema)(params);

              case 2:
                _yield$parseParams14 = _context20.sent;
                currentUserId = _yield$parseParams14.currentUserId;
                permit = _yield$parseParams14.permit;
                _context20.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.permit',
                  params: {
                    permit: permit
                  }
                });

              case 7:
                return _context20.abrupt("return", _context20.sent);

              case 8:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function permit(_x20) {
        return _permit.apply(this, arguments);
      }

      return permit;
    }() // #endregion
    // #region PRIVATE

  }, {
    key: "createInvites",
    value: function () {
      var _createInvites = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(userId, invitedUserIds, chatSecret) {
        var _this4 = this;

        var userPublicKey;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getPublicKey(userId);

              case 2:
                userPublicKey = _context22.sent;
                _context22.next = 5;
                return Promise.all([userId].concat(_toConsumableArray(invitedUserIds)).map( /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(userId) {
                    var inviteePublicKey, inviteCode;
                    return regeneratorRuntime.wrap(function _callee21$(_context21) {
                      while (1) {
                        switch (_context21.prev = _context21.next) {
                          case 0:
                            _context21.next = 2;
                            return _this4.getPublicKey(userId);

                          case 2:
                            inviteePublicKey = _context21.sent;
                            _context21.next = 5;
                            return _this4.createInviteCode(userPublicKey, inviteePublicKey, chatSecret);

                          case 5:
                            inviteCode = _context21.sent;
                            return _context21.abrupt("return", {
                              user_id: userId,
                              invite_code: base64.encode(inviteCode)
                            });

                          case 7:
                          case "end":
                            return _context21.stop();
                        }
                      }
                    }, _callee21);
                  }));

                  return function (_x24) {
                    return _ref3.apply(this, arguments);
                  };
                }()));

              case 5:
                return _context22.abrupt("return", _context22.sent);

              case 6:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function createInvites(_x21, _x22, _x23) {
        return _createInvites.apply(this, arguments);
      }

      return createInvites;
    }()
  }, {
    key: "createInviteCode",
    value: function () {
      var _createInviteCode = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(userPublicKey, inviteePublicKey, chatSecret) {
        var sharedSecret, encryptedChatSecret, inviteCode;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.auth.getSharedSecret(inviteePublicKey);

              case 2:
                sharedSecret = _context23.sent;
                _context23.next = 5;
                return this.encrypt(sharedSecret, chatSecret);

              case 5:
                encryptedChatSecret = _context23.sent;
                inviteCode = new Uint8Array(65 + encryptedChatSecret.length);
                inviteCode.set(userPublicKey);
                inviteCode.set(encryptedChatSecret, 65);
                return _context23.abrupt("return", inviteCode);

              case 10:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function createInviteCode(_x25, _x26, _x27) {
        return _createInviteCode.apply(this, arguments);
      }

      return createInviteCode;
    }()
  }, {
    key: "readInviteCode",
    value: function () {
      var _readInviteCode = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(inviteCode) {
        var friendPublicKey, chatSecretEncrypted, sharedSecret;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                friendPublicKey = inviteCode.slice(0, 65);
                chatSecretEncrypted = inviteCode.slice(65);
                _context24.next = 4;
                return this.auth.getSharedSecret(friendPublicKey);

              case 4:
                sharedSecret = _context24.sent;
                _context24.next = 7;
                return this.decrypt(sharedSecret, chatSecretEncrypted);

              case 7:
                return _context24.abrupt("return", _context24.sent);

              case 8:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function readInviteCode(_x28) {
        return _readInviteCode.apply(this, arguments);
      }

      return readInviteCode;
    }()
  }, {
    key: "encrypt",
    value: function () {
      var _encrypt = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(secret, payload) {
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return aes.encrypt(secret.slice(secret.length - 32), payload);

              case 2:
                return _context25.abrupt("return", _context25.sent);

              case 3:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25);
      }));

      function encrypt(_x29, _x30) {
        return _encrypt.apply(this, arguments);
      }

      return encrypt;
    }()
  }, {
    key: "encryptString",
    value: function () {
      var _encryptString = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(secret, payload) {
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.encrypt(secret, new TextEncoder().encode(payload));

              case 2:
                return _context26.abrupt("return", _context26.sent);

              case 3:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function encryptString(_x31, _x32) {
        return _encryptString.apply(this, arguments);
      }

      return encryptString;
    }()
  }, {
    key: "decrypt",
    value: function () {
      var _decrypt = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(secret, payload) {
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                _context27.next = 2;
                return aes.decrypt(secret.slice(secret.length - 32), payload);

              case 2:
                return _context27.abrupt("return", _context27.sent);

              case 3:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27);
      }));

      function decrypt(_x33, _x34) {
        return _decrypt.apply(this, arguments);
      }

      return decrypt;
    }()
  }, {
    key: "decryptString",
    value: function () {
      var _decryptString = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(secret, payload) {
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.t0 = new TextDecoder();
                _context28.next = 3;
                return this.decrypt(secret, payload);

              case 3:
                _context28.t1 = _context28.sent;
                return _context28.abrupt("return", _context28.t0.decode.call(_context28.t0, _context28.t1));

              case 5:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function decryptString(_x35, _x36) {
        return _decryptString.apply(this, arguments);
      }

      return decryptString;
    }()
  }, {
    key: "decryptLastChatMessage",
    value: function () {
      var _decryptLastChatMessage = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(c) {
        var lastMessage, sharedSecret;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                lastMessage = '';
                _context29.prev = 1;
                _context29.next = 4;
                return this.getChatSecret(c.chat_id);

              case 4:
                sharedSecret = _context29.sent;

                if (!(c.last_message && c.last_message.length > 0)) {
                  _context29.next = 9;
                  break;
                }

                _context29.next = 8;
                return this.decryptString(sharedSecret, base64.decode(c.last_message));

              case 8:
                lastMessage = _context29.sent;

              case 9:
                _context29.next = 15;
                break;

              case 11:
                _context29.prev = 11;
                _context29.t0 = _context29["catch"](1);
                this.logger.error("[audius-sdk]: Error: Couldn't decrypt last chat message", c, _context29.t0);
                lastMessage = GENERIC_MESSAGE_ERROR;

              case 15:
                return _context29.abrupt("return", _objectSpread2(_objectSpread2({}, c), {}, {
                  last_message: lastMessage
                }));

              case 16:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this, [[1, 11]]);
      }));

      function decryptLastChatMessage(_x37) {
        return _decryptLastChatMessage.apply(this, arguments);
      }

      return decryptLastChatMessage;
    }()
  }, {
    key: "getRaw",
    value: function () {
      var _getRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(chatId, currentUserId) {
        var path, queryParameters, response;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                path = "/comms/chats/".concat(chatId);
                queryParameters = {
                  timestamp: new Date().getTime()
                };

                if (currentUserId) {
                  queryParameters['current_user_id'] = currentUserId;
                }

                _context30.next = 5;
                return this.signAndSendRequest({
                  method: 'GET',
                  headers: {},
                  path: path,
                  query: queryParameters
                });

              case 5:
                response = _context30.sent;
                _context30.next = 8;
                return response.json();

              case 8:
                return _context30.abrupt("return", _context30.sent);

              case 9:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getRaw(_x38, _x39) {
        return _getRaw.apply(this, arguments);
      }

      return getRaw;
    }()
  }, {
    key: "getChatSecret",
    value: function () {
      var _getChatSecret = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(chatId) {
        var existingChatSecret, response, chatSecret;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                existingChatSecret = this.chatSecrets[chatId];

                if (existingChatSecret) {
                  _context31.next = 10;
                  break;
                }

                _context31.next = 4;
                return this.getRaw(chatId);

              case 4:
                response = _context31.sent;
                _context31.next = 7;
                return this.readInviteCode(base64.decode(response.data.invite_code));

              case 7:
                chatSecret = _context31.sent;
                this.chatSecrets[chatId] = chatSecret;
                return _context31.abrupt("return", chatSecret);

              case 10:
                return _context31.abrupt("return", existingChatSecret);

              case 11:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getChatSecret(_x40) {
        return _getChatSecret.apply(this, arguments);
      }

      return getChatSecret;
    }()
  }, {
    key: "getPublicKey",
    value: function () {
      var _getPublicKey = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(userId) {
        var response, json;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.request({
                  path: "/comms/pubkey/".concat(userId),
                  method: 'GET',
                  headers: {}
                });

              case 2:
                response = _context32.sent;
                _context32.next = 5;
                return response.json();

              case 5:
                json = _context32.sent;
                return _context32.abrupt("return", base64.decode(json.data));

              case 7:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getPublicKey(_x41) {
        return _getPublicKey.apply(this, arguments);
      }

      return getPublicKey;
    }()
  }, {
    key: "getSignatureHeader",
    value: function () {
      var _getSignatureHeader = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(payload) {
        var _yield$this$auth$sign, _yield$this$auth$sign2, allSignatureBytes, recoveryByte, signatureBytes;

        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                _context33.next = 2;
                return this.auth.sign(payload);

              case 2:
                _yield$this$auth$sign = _context33.sent;
                _yield$this$auth$sign2 = _slicedToArray(_yield$this$auth$sign, 2);
                allSignatureBytes = _yield$this$auth$sign2[0];
                recoveryByte = _yield$this$auth$sign2[1];
                signatureBytes = new Uint8Array(65);
                signatureBytes.set(allSignatureBytes, 0);
                signatureBytes[64] = recoveryByte;
                return _context33.abrupt("return", {
                  'x-sig': base64.encode(signatureBytes)
                });

              case 10:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getSignatureHeader(_x42) {
        return _getSignatureHeader.apply(this, arguments);
      }

      return getSignatureHeader;
    }()
  }, {
    key: "signAndSendRequest",
    value: function () {
      var _signAndSendRequest = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(request) {
        var payload;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                payload = request.method === 'GET' ? request.query ? "".concat(request.path, "?").concat(this.configuration.queryParamsStringify(request.query)) : request.path : request.body;
                _context34.t0 = this;
                _context34.t1 = _objectSpread2;
                _context34.t2 = _objectSpread2({}, request);
                _context34.t3 = {};
                _context34.t4 = _objectSpread2;
                _context34.t5 = _objectSpread2({}, request.headers);
                _context34.next = 9;
                return this.getSignatureHeader(payload);

              case 9:
                _context34.t6 = _context34.sent;
                _context34.t7 = (0, _context34.t4)(_context34.t5, _context34.t6);
                _context34.t8 = {
                  headers: _context34.t7
                };
                _context34.t9 = (0, _context34.t1)(_context34.t2, _context34.t3, _context34.t8);
                _context34.next = 15;
                return _context34.t0.request.call(_context34.t0, _context34.t9);

              case 15:
                return _context34.abrupt("return", _context34.sent);

              case 16:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function signAndSendRequest(_x43) {
        return _signAndSendRequest.apply(this, arguments);
      }

      return signAndSendRequest;
    }()
  }, {
    key: "sendRpc",
    value: function () {
      var _sendRpc = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(args) {
        var payload;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                payload = JSON.stringify(_objectSpread2(_objectSpread2({}, args), {}, {
                  timestamp: new Date().getTime()
                }));
                _context35.next = 3;
                return this.signAndSendRequest({
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  path: "/comms/mutate",
                  body: payload
                });

              case 3:
                return _context35.abrupt("return", args);

              case 4:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function sendRpc(_x44) {
        return _sendRpc.apply(this, arguments);
      }

      return sendRpc;
    }()
  }, {
    key: "createWebsocket",
    value: function () {
      var _createWebsocket = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(endpoint) {
        var _this5 = this;

        var timestamp, originalUrl, signatureHeader, host, url, ws;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                timestamp = new Date().getTime();
                originalUrl = "/comms/chats/ws?timestamp=".concat(timestamp);

                if (this.listenUserId) {
                  originalUrl = "".concat(originalUrl, "&current_user_id=").concat(this.listenUserId);
                }

                _context37.next = 5;
                return this.getSignatureHeader(originalUrl);

              case 5:
                signatureHeader = _context37.sent;
                host = endpoint.replace(/http(s?)/g, 'ws$1');
                url = "".concat(host).concat(originalUrl, "&signature=").concat(encodeURIComponent(signatureHeader['x-sig']));
                ws = new WebSocket(url);
                ws.addEventListener('message', function (messageEvent) {
                  var handleAsync = /*#__PURE__*/function () {
                    var _ref4 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee36() {
                      var data, sharedSecret;
                      return regeneratorRuntime.wrap(function _callee36$(_context36) {
                        while (1) {
                          switch (_context36.prev = _context36.next) {
                            case 0:
                              data = JSON.parse(messageEvent.data);

                              if (!(data.rpc.method === 'chat.message')) {
                                _context36.next = 19;
                                break;
                              }

                              _context36.next = 4;
                              return _this5.getChatSecret(data.rpc.params.chat_id);

                            case 4:
                              sharedSecret = _context36.sent;
                              _context36.t0 = _this5.eventEmitter;
                              _context36.t1 = data.rpc.params.chat_id;
                              _context36.t2 = data.rpc.params.message_id;
                              _context36.next = 10;
                              return _this5.decryptString(sharedSecret, base64.decode(data.rpc.params.message))["catch"](function (e) {
                                _this5.logger.error("[audius-sdk]: Error: Couldn't decrypt websocket chat message", data, e);

                                return GENERIC_MESSAGE_ERROR;
                              });

                            case 10:
                              _context36.t3 = _context36.sent;
                              _context36.t4 = data.metadata.userId;
                              _context36.t5 = data.metadata.timestamp;
                              _context36.t6 = [];
                              _context36.t7 = {
                                message_id: _context36.t2,
                                message: _context36.t3,
                                sender_user_id: _context36.t4,
                                created_at: _context36.t5,
                                reactions: _context36.t6
                              };
                              _context36.t8 = {
                                chatId: _context36.t1,
                                message: _context36.t7
                              };

                              _context36.t0.emit.call(_context36.t0, 'message', _context36.t8);

                              _context36.next = 20;
                              break;

                            case 19:
                              if (data.rpc.method === 'chat.react') {
                                _this5.eventEmitter.emit('reaction', {
                                  chatId: data.rpc.params.chat_id,
                                  messageId: data.rpc.params.message_id,
                                  reaction: {
                                    reaction: data.rpc.params.reaction,
                                    user_id: data.metadata.userId,
                                    created_at: data.metadata.timestamp
                                  }
                                });
                              }

                            case 20:
                            case "end":
                              return _context36.stop();
                          }
                        }
                      }, _callee36);
                    }));

                    return function handleAsync() {
                      return _ref4.apply(this, arguments);
                    };
                  }();

                  handleAsync();
                });
                ws.addEventListener('open', function () {
                  _this5.eventEmitter.emit('open');
                });
                ws.addEventListener('close', function () {
                  _this5.eventEmitter.emit('close');
                });
                ws.addEventListener('error', function (e) {
                  _this5.eventEmitter.emit('error', e);
                });
                return _context37.abrupt("return", ws);

              case 14:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function createWebsocket(_x45) {
        return _createWebsocket.apply(this, arguments);
      }

      return createWebsocket;
    }()
  }]);

  return ChatsApi;
}(BaseAPI$1);

/* tslint:disable */

/* eslint-disable */

/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var BASE_PATH = "/v1/full".replace(/\/+$/, "");
var Configuration = /*#__PURE__*/function () {
  function Configuration() {
    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck$1(this, Configuration);

    _defineProperty$4(this, "configuration", void 0);

    this.configuration = configuration;
  }

  _createClass$1(Configuration, [{
    key: "config",
    set: function set(configuration) {
      this.configuration = configuration;
    }
  }, {
    key: "basePath",
    get: function get() {
      return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }
  }, {
    key: "fetchApi",
    get: function get() {
      return this.configuration.fetchApi;
    }
  }, {
    key: "middleware",
    get: function get() {
      return this.configuration.middleware || [];
    }
  }, {
    key: "queryParamsStringify",
    get: function get() {
      return this.configuration.queryParamsStringify || querystring;
    }
  }, {
    key: "username",
    get: function get() {
      return this.configuration.username;
    }
  }, {
    key: "password",
    get: function get() {
      return this.configuration.password;
    }
  }, {
    key: "apiKey",
    get: function get() {
      var apiKey = this.configuration.apiKey;

      if (apiKey) {
        return typeof apiKey === 'function' ? apiKey : function () {
          return apiKey;
        };
      }

      return undefined;
    }
  }, {
    key: "accessToken",
    get: function get() {
      var accessToken = this.configuration.accessToken;

      if (accessToken) {
        return typeof accessToken === 'function' ? accessToken : /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", accessToken);

                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
      }

      return undefined;
    }
  }, {
    key: "headers",
    get: function get() {
      return this.configuration.headers;
    }
  }, {
    key: "credentials",
    get: function get() {
      return this.configuration.credentials;
    }
  }]);

  return Configuration;
}();
var DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */

var BaseAPI = /*#__PURE__*/function () {
  function BaseAPI() {
    var _this = this;

    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultConfig;

    _classCallCheck$1(this, BaseAPI);

    _defineProperty$4(this, "configuration", void 0);

    _defineProperty$4(this, "middleware", void 0);

    _defineProperty$4(this, "fetchApi", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url, init) {
        var fetchParams, _iterator, _step, _middleware, response, _iterator2, _step2, middleware, _iterator3, _step3, _middleware2;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                fetchParams = {
                  url: url,
                  init: init
                };
                _iterator = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 2;

                _iterator.s();

              case 4:
                if ((_step = _iterator.n()).done) {
                  _context2.next = 15;
                  break;
                }

                _middleware = _step.value;

                if (!_middleware.pre) {
                  _context2.next = 13;
                  break;
                }

                _context2.next = 9;
                return _middleware.pre(_objectSpread2({
                  fetch: _this.fetchApi
                }, fetchParams));

              case 9:
                _context2.t0 = _context2.sent;

                if (_context2.t0) {
                  _context2.next = 12;
                  break;
                }

                _context2.t0 = fetchParams;

              case 12:
                fetchParams = _context2.t0;

              case 13:
                _context2.next = 4;
                break;

              case 15:
                _context2.next = 20;
                break;

              case 17:
                _context2.prev = 17;
                _context2.t1 = _context2["catch"](2);

                _iterator.e(_context2.t1);

              case 20:
                _context2.prev = 20;

                _iterator.f();

                return _context2.finish(20);

              case 23:
                response = undefined;
                _context2.prev = 24;
                _context2.next = 27;
                return (_this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);

              case 27:
                response = _context2.sent;
                _context2.next = 60;
                break;

              case 30:
                _context2.prev = 30;
                _context2.t2 = _context2["catch"](24);
                _iterator2 = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 33;

                _iterator2.s();

              case 35:
                if ((_step2 = _iterator2.n()).done) {
                  _context2.next = 46;
                  break;
                }

                middleware = _step2.value;

                if (!middleware.onError) {
                  _context2.next = 44;
                  break;
                }

                _context2.next = 40;
                return middleware.onError({
                  fetch: _this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  error: _context2.t2,
                  response: response ? response.clone() : undefined
                });

              case 40:
                _context2.t3 = _context2.sent;

                if (_context2.t3) {
                  _context2.next = 43;
                  break;
                }

                _context2.t3 = response;

              case 43:
                response = _context2.t3;

              case 44:
                _context2.next = 35;
                break;

              case 46:
                _context2.next = 51;
                break;

              case 48:
                _context2.prev = 48;
                _context2.t4 = _context2["catch"](33);

                _iterator2.e(_context2.t4);

              case 51:
                _context2.prev = 51;

                _iterator2.f();

                return _context2.finish(51);

              case 54:
                if (!(response === undefined)) {
                  _context2.next = 60;
                  break;
                }

                if (!(_context2.t2 instanceof Error)) {
                  _context2.next = 59;
                  break;
                }

                throw new FetchError(_context2.t2, 'The request failed and the interceptors did not return an alternative response');

              case 59:
                throw _context2.t2;

              case 60:
                _iterator3 = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 61;

                _iterator3.s();

              case 63:
                if ((_step3 = _iterator3.n()).done) {
                  _context2.next = 74;
                  break;
                }

                _middleware2 = _step3.value;

                if (!_middleware2.post) {
                  _context2.next = 72;
                  break;
                }

                _context2.next = 68;
                return _middleware2.post({
                  fetch: _this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  response: response.clone()
                });

              case 68:
                _context2.t5 = _context2.sent;

                if (_context2.t5) {
                  _context2.next = 71;
                  break;
                }

                _context2.t5 = response;

              case 71:
                response = _context2.t5;

              case 72:
                _context2.next = 63;
                break;

              case 74:
                _context2.next = 79;
                break;

              case 76:
                _context2.prev = 76;
                _context2.t6 = _context2["catch"](61);

                _iterator3.e(_context2.t6);

              case 79:
                _context2.prev = 79;

                _iterator3.f();

                return _context2.finish(79);

              case 82:
                return _context2.abrupt("return", response);

              case 83:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[2, 17, 20, 23], [24, 30], [33, 48, 51, 54], [61, 76, 79, 82]]);
      }));

      return function (_x, _x2) {
        return _ref2.apply(this, arguments);
      };
    }());

    this.configuration = configuration;
    this.middleware = configuration.middleware;
  }
  /** @hidden */


  _createClass$1(BaseAPI, [{
    key: "withMiddleware",
    value: function withMiddleware() {
      var _next$middleware;

      var next = this.clone();
      next.middleware = (_next$middleware = next.middleware).concat.apply(_next$middleware, arguments);
      return next;
    }
    /** @hidden */

  }, {
    key: "withPreMiddleware",
    value: function withPreMiddleware() {
      for (var _len = arguments.length, preMiddlewares = new Array(_len), _key = 0; _key < _len; _key++) {
        preMiddlewares[_key] = arguments[_key];
      }

      var middlewares = preMiddlewares.map(function (pre) {
        return {
          pre: pre
        };
      });
      return this.withMiddleware.apply(this, _toConsumableArray(middlewares));
    }
    /** @hidden */

  }, {
    key: "withPostMiddleware",
    value: function withPostMiddleware() {
      for (var _len2 = arguments.length, postMiddlewares = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        postMiddlewares[_key2] = arguments[_key2];
      }

      var middlewares = postMiddlewares.map(function (post) {
        return {
          post: post
        };
      });
      return this.withMiddleware.apply(this, _toConsumableArray(middlewares));
    }
    /** @hidden */

  }, {
    key: "request",
    value: function () {
      var _request = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(context, initOverrides) {
        var _yield$this$createFet, url, init, response;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.createFetchParams(context, initOverrides);

              case 2:
                _yield$this$createFet = _context3.sent;
                url = _yield$this$createFet.url;
                init = _yield$this$createFet.init;
                _context3.next = 7;
                return this.fetchApi(url, init);

              case 7:
                response = _context3.sent;

                if (!(response && response.status >= 200 && response.status < 300)) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt("return", response);

              case 10:
                throw new ResponseError(response, 'Response returned an error code');

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function request(_x3, _x4) {
        return _request.apply(this, arguments);
      }

      return request;
    }()
  }, {
    key: "createFetchParams",
    value: function () {
      var _createFetchParams = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(context, initOverrides) {
        var url, headers, initOverrideFn, initParams, overriddenInit, init;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                url = this.configuration.basePath + context.path;

                if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                  // only add the querystring to the URL if there are query parameters.
                  // this is done to avoid urls ending with a "?" character which buggy webservers
                  // do not handle correctly sometimes.
                  url += '?' + this.configuration.queryParamsStringify(context.query);
                }

                headers = Object.assign({}, this.configuration.headers, context.headers);
                Object.keys(headers).forEach(function (key) {
                  return headers[key] === undefined ? delete headers[key] : {};
                });
                initOverrideFn = typeof initOverrides === "function" ? initOverrides : /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                  return regeneratorRuntime.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          return _context4.abrupt("return", initOverrides);

                        case 1:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                }));
                initParams = {
                  method: context.method,
                  headers: headers,
                  body: context.body,
                  credentials: this.configuration.credentials
                };
                _context5.t0 = _objectSpread2;
                _context5.t1 = _objectSpread2({}, initParams);
                _context5.next = 10;
                return initOverrideFn({
                  init: initParams,
                  context: context
                });

              case 10:
                _context5.t2 = _context5.sent;
                overriddenInit = (0, _context5.t0)(_context5.t1, _context5.t2);
                init = _objectSpread2(_objectSpread2({}, overriddenInit), {}, {
                  body: isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body) || isString(overriddenInit.body) ? overriddenInit.body : JSON.stringify(overriddenInit.body)
                });
                return _context5.abrupt("return", {
                  url: url,
                  init: init
                });

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function createFetchParams(_x5, _x6) {
        return _createFetchParams.apply(this, arguments);
      }

      return createFetchParams;
    }()
  }, {
    key: "clone",
    value:
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    function clone() {
      var constructor = this.constructor;
      var next = new constructor(this.configuration);
      next.middleware = this.middleware.slice();
      return next;
    }
  }]);

  return BaseAPI;
}();

function isBlob(value) {
  return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}

function isString(value) {
  return typeof value === 'string';
}

var ResponseError = /*#__PURE__*/function (_Error) {
  _inherits(ResponseError, _Error);

  var _super = _createSuper(ResponseError);

  function ResponseError(response, msg) {
    var _this2;

    _classCallCheck$1(this, ResponseError);

    _this2 = _super.call(this, msg);

    _defineProperty$4(_assertThisInitialized(_this2), "response", void 0);

    _defineProperty$4(_assertThisInitialized(_this2), "name", "ResponseError");

    _this2.response = response;
    return _this2;
  }

  return _createClass$1(ResponseError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var FetchError = /*#__PURE__*/function (_Error2) {
  _inherits(FetchError, _Error2);

  var _super2 = _createSuper(FetchError);

  function FetchError(cause, msg) {
    var _this3;

    _classCallCheck$1(this, FetchError);

    _this3 = _super2.call(this, msg);

    _defineProperty$4(_assertThisInitialized(_this3), "cause", void 0);

    _defineProperty$4(_assertThisInitialized(_this3), "name", "FetchError");

    _this3.cause = cause;
    return _this3;
  }

  return _createClass$1(FetchError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var RequiredError = /*#__PURE__*/function (_Error3) {
  _inherits(RequiredError, _Error3);

  var _super3 = _createSuper(RequiredError);

  function RequiredError(field, msg) {
    var _this4;

    _classCallCheck$1(this, RequiredError);

    _this4 = _super3.call(this, msg);

    _defineProperty$4(_assertThisInitialized(_this4), "field", void 0);

    _defineProperty$4(_assertThisInitialized(_this4), "name", "RequiredError");

    _this4.field = field;
    return _this4;
  }

  return _createClass$1(RequiredError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|"
};
function exists(json, key) {
  var value = json[key];
  return value !== null && value !== undefined;
}
function querystring(params) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return Object.keys(params).sort().map(function (key) {
    return querystringSingleKey(key, params[key], prefix);
  }).filter(function (part) {
    return part.length > 0;
  }).join('&');
}

function querystringSingleKey(key, value) {
  var keyPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);

  if (value instanceof Array) {
    var multiValue = value.map(function (singleValue) {
      return encodeURIComponent(String(singleValue));
    }).join("&".concat(encodeURIComponent(fullKey), "="));
    return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
  }

  if (value instanceof Set) {
    var valueAsArray = Array.from(value);
    return querystringSingleKey(key, valueAsArray, keyPrefix);
  }

  if (value instanceof Date) {
    return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
  }

  if (value instanceof Object) {
    return querystring(value, fullKey);
  }

  return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
}

function mapValues(data, fn) {
  return Object.keys(data).reduce(function (acc, key) {
    return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty$4({}, key, fn(data[key])));
  }, {});
}
function canConsumeForm(consumes) {
  var _iterator4 = _createForOfIteratorHelper(consumes),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var consume = _step4.value;

      if ('multipart/form-data' === consume.contentType) {
        return true;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return false;
}
var JSONApiResponse = /*#__PURE__*/function () {
  function JSONApiResponse(raw) {
    var transformer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (jsonValue) {
      return jsonValue;
    };

    _classCallCheck$1(this, JSONApiResponse);

    _defineProperty$4(this, "raw", void 0);

    _defineProperty$4(this, "transformer", void 0);

    this.raw = raw;
    this.transformer = transformer;
  }

  _createClass$1(JSONApiResponse, [{
    key: "value",
    value: function () {
      var _value = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.t0 = this;
                _context6.next = 3;
                return this.raw.json();

              case 3:
                _context6.t1 = _context6.sent;
                return _context6.abrupt("return", _context6.t0.transformer.call(_context6.t0, _context6.t1));

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function value() {
        return _value.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return JSONApiResponse;
}();
var VoidApiResponse = /*#__PURE__*/function () {
  function VoidApiResponse(raw) {
    _classCallCheck$1(this, VoidApiResponse);

    _defineProperty$4(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass$1(VoidApiResponse, [{
    key: "value",
    value: function () {
      var _value2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", undefined);

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function value() {
        return _value2.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return VoidApiResponse;
}();
var BlobApiResponse = /*#__PURE__*/function () {
  function BlobApiResponse(raw) {
    _classCallCheck$1(this, BlobApiResponse);

    _defineProperty$4(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass$1(BlobApiResponse, [{
    key: "value",
    value: function () {
      var _value3 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.raw.blob();

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function value() {
        return _value3.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return BlobApiResponse;
}();
var TextApiResponse = /*#__PURE__*/function () {
  function TextApiResponse(raw) {
    _classCallCheck$1(this, TextApiResponse);

    _defineProperty$4(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass$1(TextApiResponse, [{
    key: "value",
    value: function () {
      var _value4 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.raw.text();

              case 2:
                return _context9.abrupt("return", _context9.sent);

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function value() {
        return _value4.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return TextApiResponse;
}();

/* tslint:disable */
/**
 * Check if a given object implements the ActivityFull interface.
 */

function instanceOfActivityFull(value) {
  var isInstance = true;
  return isInstance;
}
function ActivityFullFromJSON(json) {
  return ActivityFullFromJSONTyped(json);
}
function ActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'timestamp': !exists(json, 'timestamp') ? undefined : json['timestamp'],
    'itemType': !exists(json, 'item_type') ? undefined : json['item_type'],
    'item': !exists(json, 'item') ? undefined : json['item']
  };
}
function ActivityFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': value.item
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Favorite interface.
 */

function instanceOfFavorite(value) {
  var isInstance = true;
  isInstance = isInstance && "favoriteItemId" in value;
  isInstance = isInstance && "favoriteType" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "createdAt" in value;
  return isInstance;
}
function FavoriteFromJSON(json) {
  return FavoriteFromJSONTyped(json);
}
function FavoriteFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'favoriteItemId': json['favorite_item_id'],
    'favoriteType': json['favorite_type'],
    'userId': json['user_id'],
    'createdAt': json['created_at']
  };
}
function FavoriteToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'favorite_item_id': value.favoriteItemId,
    'favorite_type': value.favoriteType,
    'user_id': value.userId,
    'created_at': value.createdAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistAddedTimestamp interface.
 */

function instanceOfPlaylistAddedTimestamp(value) {
  var isInstance = true;
  isInstance = isInstance && "metadataTimestamp" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "trackId" in value;
  return isInstance;
}
function PlaylistAddedTimestampFromJSON(json) {
  return PlaylistAddedTimestampFromJSONTyped(json);
}
function PlaylistAddedTimestampFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'metadataTimestamp': json['metadata_timestamp'],
    'timestamp': json['timestamp'],
    'trackId': json['track_id']
  };
}
function PlaylistAddedTimestampToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'metadata_timestamp': value.metadataTimestamp,
    'timestamp': value.timestamp,
    'track_id': value.trackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistArtwork interface.
 */

function instanceOfPlaylistArtwork(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistArtworkFromJSON(json) {
  return PlaylistArtworkFromJSONTyped(json);
}
function PlaylistArtworkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function PlaylistArtworkToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Repost interface.
 */

function instanceOfRepost(value) {
  var isInstance = true;
  isInstance = isInstance && "repostItemId" in value;
  isInstance = isInstance && "repostType" in value;
  isInstance = isInstance && "userId" in value;
  return isInstance;
}
function RepostFromJSON(json) {
  return RepostFromJSONTyped(json);
}
function RepostFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'repostItemId': json['repost_item_id'],
    'repostType': json['repost_type'],
    'userId': json['user_id']
  };
}
function RepostToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'repost_item_id': value.repostItemId,
    'repost_type': value.repostType,
    'user_id': value.userId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoverArt interface.
 */

function instanceOfCoverArt(value) {
  var isInstance = true;
  return isInstance;
}
function CoverArtFromJSON(json) {
  return CoverArtFromJSONTyped(json);
}
function CoverArtFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function CoverArtToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DownloadMetadata interface.
 */

function instanceOfDownloadMetadata(value) {
  var isInstance = true;
  isInstance = isInstance && "isDownloadable" in value;
  isInstance = isInstance && "requiresFollow" in value;
  return isInstance;
}
function DownloadMetadataFromJSON(json) {
  return DownloadMetadataFromJSONTyped(json);
}
function DownloadMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'cid': !exists(json, 'cid') ? undefined : json['cid'],
    'isDownloadable': json['is_downloadable'],
    'requiresFollow': json['requires_follow']
  };
}
function DownloadMetadataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'cid': value.cid,
    'is_downloadable': value.isDownloadable,
    'requires_follow': value.requiresFollow
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FieldVisibility interface.
 */

function instanceOfFieldVisibility(value) {
  var isInstance = true;
  return isInstance;
}
function FieldVisibilityFromJSON(json) {
  return FieldVisibilityFromJSONTyped(json);
}
function FieldVisibilityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'mood': !exists(json, 'mood') ? undefined : json['mood'],
    'tags': !exists(json, 'tags') ? undefined : json['tags'],
    'genre': !exists(json, 'genre') ? undefined : json['genre'],
    'share': !exists(json, 'share') ? undefined : json['share'],
    'playCount': !exists(json, 'play_count') ? undefined : json['play_count'],
    'remixes': !exists(json, 'remixes') ? undefined : json['remixes']
  };
}
function FieldVisibilityToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'mood': value.mood,
    'tags': value.tags,
    'genre': value.genre,
    'share': value.share,
    'play_count': value.playCount,
    'remixes': value.remixes
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoverPhoto interface.
 */

function instanceOfCoverPhoto(value) {
  var isInstance = true;
  return isInstance;
}
function CoverPhotoFromJSON(json) {
  return CoverPhotoFromJSONTyped(json);
}
function CoverPhotoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_640x': !exists(json, '640x') ? undefined : json['640x'],
    '_2000x': !exists(json, '2000x') ? undefined : json['2000x']
  };
}
function CoverPhotoToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '640x': value._640x,
    '2000x': value._2000x
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistLibrary interface.
 */

function instanceOfPlaylistLibrary(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistLibraryFromJSON(json) {
  return PlaylistLibraryFromJSONTyped(json);
}
function PlaylistLibraryFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'contents': !exists(json, 'contents') ? undefined : json['contents']
  };
}
function PlaylistLibraryToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'contents': value.contents
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ProfilePicture interface.
 */

function instanceOfProfilePicture(value) {
  var isInstance = true;
  return isInstance;
}
function ProfilePictureFromJSON(json) {
  return ProfilePictureFromJSONTyped(json);
}
function ProfilePictureFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function ProfilePictureToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserFull interface.
 */

function instanceOfUserFull(value) {
  var isInstance = true;
  isInstance = isInstance && "albumCount" in value;
  isInstance = isInstance && "followeeCount" in value;
  isInstance = isInstance && "followerCount" in value;
  isInstance = isInstance && "handle" in value;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isVerified" in value;
  isInstance = isInstance && "name" in value;
  isInstance = isInstance && "playlistCount" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "trackCount" in value;
  isInstance = isInstance && "isDeactivated" in value;
  isInstance = isInstance && "isAvailable" in value;
  isInstance = isInstance && "ercWallet" in value;
  isInstance = isInstance && "splWallet" in value;
  isInstance = isInstance && "supporterCount" in value;
  isInstance = isInstance && "supportingCount" in value;
  isInstance = isInstance && "totalAudioBalance" in value;
  isInstance = isInstance && "balance" in value;
  isInstance = isInstance && "associatedWalletsBalance" in value;
  isInstance = isInstance && "totalBalance" in value;
  isInstance = isInstance && "waudioBalance" in value;
  isInstance = isInstance && "associatedSolWalletsBalance" in value;
  isInstance = isInstance && "blocknumber" in value;
  isInstance = isInstance && "wallet" in value;
  isInstance = isInstance && "createdAt" in value;
  isInstance = isInstance && "isStorageV2" in value;
  isInstance = isInstance && "currentUserFolloweeFollowCount" in value;
  isInstance = isInstance && "doesCurrentUserFollow" in value;
  isInstance = isInstance && "handleLc" in value;
  isInstance = isInstance && "updatedAt" in value;
  isInstance = isInstance && "hasCollectibles" in value;
  isInstance = isInstance && "allowAiAttribution" in value;
  return isInstance;
}
function UserFullFromJSON(json) {
  return UserFullFromJSONTyped(json);
}
function UserFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'albumCount': json['album_count'],
    'artistPickTrackId': !exists(json, 'artist_pick_track_id') ? undefined : json['artist_pick_track_id'],
    'bio': !exists(json, 'bio') ? undefined : json['bio'],
    'coverPhoto': !exists(json, 'cover_photo') ? undefined : CoverPhotoFromJSON(json['cover_photo']),
    'followeeCount': json['followee_count'],
    'followerCount': json['follower_count'],
    'doesFollowCurrentUser': !exists(json, 'does_follow_current_user') ? undefined : json['does_follow_current_user'],
    'handle': json['handle'],
    'id': json['id'],
    'isVerified': json['is_verified'],
    'location': !exists(json, 'location') ? undefined : json['location'],
    'name': json['name'],
    'playlistCount': json['playlist_count'],
    'profilePicture': !exists(json, 'profile_picture') ? undefined : ProfilePictureFromJSON(json['profile_picture']),
    'repostCount': json['repost_count'],
    'trackCount': json['track_count'],
    'isDeactivated': json['is_deactivated'],
    'isAvailable': json['is_available'],
    'ercWallet': json['erc_wallet'],
    'splWallet': json['spl_wallet'],
    'supporterCount': json['supporter_count'],
    'supportingCount': json['supporting_count'],
    'totalAudioBalance': json['total_audio_balance'],
    'balance': json['balance'],
    'associatedWalletsBalance': json['associated_wallets_balance'],
    'totalBalance': json['total_balance'],
    'waudioBalance': json['waudio_balance'],
    'associatedSolWalletsBalance': json['associated_sol_wallets_balance'],
    'blocknumber': json['blocknumber'],
    'wallet': json['wallet'],
    'createdAt': json['created_at'],
    'isStorageV2': json['is_storage_v2'],
    'creatorNodeEndpoint': !exists(json, 'creator_node_endpoint') ? undefined : json['creator_node_endpoint'],
    'currentUserFolloweeFollowCount': json['current_user_followee_follow_count'],
    'doesCurrentUserFollow': json['does_current_user_follow'],
    'handleLc': json['handle_lc'],
    'updatedAt': json['updated_at'],
    'coverPhotoSizes': !exists(json, 'cover_photo_sizes') ? undefined : json['cover_photo_sizes'],
    'coverPhotoCids': !exists(json, 'cover_photo_cids') ? undefined : CoverPhotoFromJSON(json['cover_photo_cids']),
    'coverPhotoLegacy': !exists(json, 'cover_photo_legacy') ? undefined : json['cover_photo_legacy'],
    'profilePictureSizes': !exists(json, 'profile_picture_sizes') ? undefined : json['profile_picture_sizes'],
    'profilePictureCids': !exists(json, 'profile_picture_cids') ? undefined : ProfilePictureFromJSON(json['profile_picture_cids']),
    'profilePictureLegacy': !exists(json, 'profile_picture_legacy') ? undefined : json['profile_picture_legacy'],
    'metadataMultihash': !exists(json, 'metadata_multihash') ? undefined : json['metadata_multihash'],
    'hasCollectibles': json['has_collectibles'],
    'playlistLibrary': !exists(json, 'playlist_library') ? undefined : PlaylistLibraryFromJSON(json['playlist_library']),
    'allowAiAttribution': json['allow_ai_attribution']
  };
}
function UserFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'album_count': value.albumCount,
    'artist_pick_track_id': value.artistPickTrackId,
    'bio': value.bio,
    'cover_photo': CoverPhotoToJSON(value.coverPhoto),
    'followee_count': value.followeeCount,
    'follower_count': value.followerCount,
    'does_follow_current_user': value.doesFollowCurrentUser,
    'handle': value.handle,
    'id': value.id,
    'is_verified': value.isVerified,
    'location': value.location,
    'name': value.name,
    'playlist_count': value.playlistCount,
    'profile_picture': ProfilePictureToJSON(value.profilePicture),
    'repost_count': value.repostCount,
    'track_count': value.trackCount,
    'is_deactivated': value.isDeactivated,
    'is_available': value.isAvailable,
    'erc_wallet': value.ercWallet,
    'spl_wallet': value.splWallet,
    'supporter_count': value.supporterCount,
    'supporting_count': value.supportingCount,
    'total_audio_balance': value.totalAudioBalance,
    'balance': value.balance,
    'associated_wallets_balance': value.associatedWalletsBalance,
    'total_balance': value.totalBalance,
    'waudio_balance': value.waudioBalance,
    'associated_sol_wallets_balance': value.associatedSolWalletsBalance,
    'blocknumber': value.blocknumber,
    'wallet': value.wallet,
    'created_at': value.createdAt,
    'is_storage_v2': value.isStorageV2,
    'creator_node_endpoint': value.creatorNodeEndpoint,
    'current_user_followee_follow_count': value.currentUserFolloweeFollowCount,
    'does_current_user_follow': value.doesCurrentUserFollow,
    'handle_lc': value.handleLc,
    'updated_at': value.updatedAt,
    'cover_photo_sizes': value.coverPhotoSizes,
    'cover_photo_cids': CoverPhotoToJSON(value.coverPhotoCids),
    'cover_photo_legacy': value.coverPhotoLegacy,
    'profile_picture_sizes': value.profilePictureSizes,
    'profile_picture_cids': ProfilePictureToJSON(value.profilePictureCids),
    'profile_picture_legacy': value.profilePictureLegacy,
    'metadata_multihash': value.metadataMultihash,
    'has_collectibles': value.hasCollectibles,
    'playlist_library': PlaylistLibraryToJSON(value.playlistLibrary),
    'allow_ai_attribution': value.allowAiAttribution
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullRemix interface.
 */

function instanceOfFullRemix(value) {
  var isInstance = true;
  isInstance = isInstance && "parentTrackId" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "hasRemixAuthorReposted" in value;
  isInstance = isInstance && "hasRemixAuthorSaved" in value;
  return isInstance;
}
function FullRemixFromJSON(json) {
  return FullRemixFromJSONTyped(json);
}
function FullRemixFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'parentTrackId': json['parent_track_id'],
    'user': UserFullFromJSON(json['user']),
    'hasRemixAuthorReposted': json['has_remix_author_reposted'],
    'hasRemixAuthorSaved': json['has_remix_author_saved']
  };
}
function FullRemixToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'parent_track_id': value.parentTrackId,
    'user': UserFullToJSON(value.user),
    'has_remix_author_reposted': value.hasRemixAuthorReposted,
    'has_remix_author_saved': value.hasRemixAuthorSaved
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullRemixParent interface.
 */

function instanceOfFullRemixParent(value) {
  var isInstance = true;
  return isInstance;
}
function FullRemixParentFromJSON(json) {
  return FullRemixParentFromJSONTyped(json);
}
function FullRemixParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(FullRemixFromJSON)
  };
}
function FullRemixParentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(FullRemixToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PremiumContentSignature interface.
 */

function instanceOfPremiumContentSignature(value) {
  var isInstance = true;
  return isInstance;
}
function PremiumContentSignatureFromJSON(json) {
  return PremiumContentSignatureFromJSONTyped(json);
}
function PremiumContentSignatureFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists(json, 'data') ? undefined : json['data'],
    'signature': !exists(json, 'signature') ? undefined : json['signature']
  };
}
function PremiumContentSignatureToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data,
    'signature': value.signature
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the StemParent interface.
 */

function instanceOfStemParent(value) {
  var isInstance = true;
  isInstance = isInstance && "category" in value;
  isInstance = isInstance && "parentTrackId" in value;
  return isInstance;
}
function StemParentFromJSON(json) {
  return StemParentFromJSONTyped(json);
}
function StemParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'category': json['category'],
    'parentTrackId': json['parent_track_id']
  };
}
function StemParentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'category': value.category,
    'parent_track_id': value.parentTrackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackArtwork interface.
 */

function instanceOfTrackArtwork(value) {
  var isInstance = true;
  return isInstance;
}
function TrackArtworkFromJSON(json) {
  return TrackArtworkFromJSONTyped(json);
}
function TrackArtworkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function TrackArtworkToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackSegment interface.
 */

function instanceOfTrackSegment(value) {
  var isInstance = true;
  isInstance = isInstance && "duration" in value;
  isInstance = isInstance && "multihash" in value;
  return isInstance;
}
function TrackSegmentFromJSON(json) {
  return TrackSegmentFromJSONTyped(json);
}
function TrackSegmentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'duration': json['duration'],
    'multihash': json['multihash']
  };
}
function TrackSegmentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'duration': value.duration,
    'multihash': value.multihash
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackFull interface.
 */

function instanceOfTrackFull(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "title" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "duration" in value;
  isInstance = isInstance && "playCount" in value;
  isInstance = isInstance && "blocknumber" in value;
  isInstance = isInstance && "followeeReposts" in value;
  isInstance = isInstance && "hasCurrentUserReposted" in value;
  isInstance = isInstance && "isUnlisted" in value;
  isInstance = isInstance && "hasCurrentUserSaved" in value;
  isInstance = isInstance && "followeeFavorites" in value;
  isInstance = isInstance && "routeId" in value;
  isInstance = isInstance && "userId" in value;
  return isInstance;
}
function TrackFullFromJSON(json) {
  return TrackFullFromJSONTyped(json);
}
function TrackFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists(json, 'artwork') ? undefined : TrackArtworkFromJSON(json['artwork']),
    'description': !exists(json, 'description') ? undefined : json['description'],
    'genre': !exists(json, 'genre') ? undefined : json['genre'],
    'id': json['id'],
    'trackCid': !exists(json, 'track_cid') ? undefined : json['track_cid'],
    'previewCid': !exists(json, 'preview_cid') ? undefined : json['preview_cid'],
    'mood': !exists(json, 'mood') ? undefined : json['mood'],
    'releaseDate': !exists(json, 'release_date') ? undefined : json['release_date'],
    'remixOf': !exists(json, 'remix_of') ? undefined : FullRemixParentFromJSON(json['remix_of']),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'tags': !exists(json, 'tags') ? undefined : json['tags'],
    'title': json['title'],
    'user': UserFullFromJSON(json['user']),
    'duration': json['duration'],
    'downloadable': !exists(json, 'downloadable') ? undefined : json['downloadable'],
    'playCount': json['play_count'],
    'permalink': !exists(json, 'permalink') ? undefined : json['permalink'],
    'isStreamable': !exists(json, 'is_streamable') ? undefined : json['is_streamable'],
    'blocknumber': json['blocknumber'],
    'createDate': !exists(json, 'create_date') ? undefined : json['create_date'],
    'coverArtSizes': !exists(json, 'cover_art_sizes') ? undefined : json['cover_art_sizes'],
    'coverArtCids': !exists(json, 'cover_art_cids') ? undefined : CoverArtFromJSON(json['cover_art_cids']),
    'createdAt': !exists(json, 'created_at') ? undefined : json['created_at'],
    'creditsSplits': !exists(json, 'credits_splits') ? undefined : json['credits_splits'],
    'download': !exists(json, 'download') ? undefined : DownloadMetadataFromJSON(json['download']),
    'isrc': !exists(json, 'isrc') ? undefined : json['isrc'],
    'license': !exists(json, 'license') ? undefined : json['license'],
    'iswc': !exists(json, 'iswc') ? undefined : json['iswc'],
    'fieldVisibility': !exists(json, 'field_visibility') ? undefined : FieldVisibilityFromJSON(json['field_visibility']),
    'followeeReposts': json['followee_reposts'].map(RepostFromJSON),
    'hasCurrentUserReposted': json['has_current_user_reposted'],
    'isUnlisted': json['is_unlisted'],
    'hasCurrentUserSaved': json['has_current_user_saved'],
    'followeeFavorites': json['followee_favorites'].map(FavoriteFromJSON),
    'routeId': json['route_id'],
    'stemOf': !exists(json, 'stem_of') ? undefined : StemParentFromJSON(json['stem_of']),
    'trackSegments': !exists(json, 'track_segments') ? undefined : json['track_segments'].map(TrackSegmentFromJSON),
    'updatedAt': !exists(json, 'updated_at') ? undefined : json['updated_at'],
    'userId': json['user_id'],
    'isDelete': !exists(json, 'is_delete') ? undefined : json['is_delete'],
    'coverArt': !exists(json, 'cover_art') ? undefined : json['cover_art'],
    'isAvailable': !exists(json, 'is_available') ? undefined : json['is_available'],
    'isPremium': !exists(json, 'is_premium') ? undefined : json['is_premium'],
    'premiumConditions': !exists(json, 'premium_conditions') ? undefined : json['premium_conditions'],
    'premiumContentSignature': !exists(json, 'premium_content_signature') ? undefined : PremiumContentSignatureFromJSON(json['premium_content_signature']),
    'aiAttributionUserId': !exists(json, 'ai_attribution_user_id') ? undefined : json['ai_attribution_user_id'],
    'audioUploadId': !exists(json, 'audio_upload_id') ? undefined : json['audio_upload_id'],
    'previewStartSeconds': !exists(json, 'preview_start_seconds') ? undefined : json['preview_start_seconds']
  };
}
function TrackFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': TrackArtworkToJSON(value.artwork),
    'description': value.description,
    'genre': value.genre,
    'id': value.id,
    'track_cid': value.trackCid,
    'preview_cid': value.previewCid,
    'mood': value.mood,
    'release_date': value.releaseDate,
    'remix_of': FullRemixParentToJSON(value.remixOf),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'tags': value.tags,
    'title': value.title,
    'user': UserFullToJSON(value.user),
    'duration': value.duration,
    'downloadable': value.downloadable,
    'play_count': value.playCount,
    'permalink': value.permalink,
    'is_streamable': value.isStreamable,
    'blocknumber': value.blocknumber,
    'create_date': value.createDate,
    'cover_art_sizes': value.coverArtSizes,
    'cover_art_cids': CoverArtToJSON(value.coverArtCids),
    'created_at': value.createdAt,
    'credits_splits': value.creditsSplits,
    'download': DownloadMetadataToJSON(value.download),
    'isrc': value.isrc,
    'license': value.license,
    'iswc': value.iswc,
    'field_visibility': FieldVisibilityToJSON(value.fieldVisibility),
    'followee_reposts': value.followeeReposts.map(RepostToJSON),
    'has_current_user_reposted': value.hasCurrentUserReposted,
    'is_unlisted': value.isUnlisted,
    'has_current_user_saved': value.hasCurrentUserSaved,
    'followee_favorites': value.followeeFavorites.map(FavoriteToJSON),
    'route_id': value.routeId,
    'stem_of': StemParentToJSON(value.stemOf),
    'track_segments': value.trackSegments === undefined ? undefined : value.trackSegments.map(TrackSegmentToJSON),
    'updated_at': value.updatedAt,
    'user_id': value.userId,
    'is_delete': value.isDelete,
    'cover_art': value.coverArt,
    'is_available': value.isAvailable,
    'is_premium': value.isPremium,
    'premium_conditions': value.premiumConditions,
    'premium_content_signature': PremiumContentSignatureToJSON(value.premiumContentSignature),
    'ai_attribution_user_id': value.aiAttributionUserId,
    'audio_upload_id': value.audioUploadId,
    'preview_start_seconds': value.previewStartSeconds
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistFullWithoutTracks interface.
 */

function instanceOfPlaylistFullWithoutTracks(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isAlbum" in value;
  isInstance = isInstance && "isImageAutogenerated" in value;
  isInstance = isInstance && "playlistName" in value;
  isInstance = isInstance && "playlistContents" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "totalPlayCount" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "blocknumber" in value;
  isInstance = isInstance && "followeeReposts" in value;
  isInstance = isInstance && "followeeFavorites" in value;
  isInstance = isInstance && "hasCurrentUserReposted" in value;
  isInstance = isInstance && "hasCurrentUserSaved" in value;
  isInstance = isInstance && "isDelete" in value;
  isInstance = isInstance && "isPrivate" in value;
  isInstance = isInstance && "addedTimestamps" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "trackCount" in value;
  return isInstance;
}
function PlaylistFullWithoutTracksFromJSON(json) {
  return PlaylistFullWithoutTracksFromJSONTyped(json);
}
function PlaylistFullWithoutTracksFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists(json, 'artwork') ? undefined : PlaylistArtworkFromJSON(json['artwork']),
    'description': !exists(json, 'description') ? undefined : json['description'],
    'permalink': !exists(json, 'permalink') ? undefined : json['permalink'],
    'id': json['id'],
    'isAlbum': json['is_album'],
    'isImageAutogenerated': json['is_image_autogenerated'],
    'playlistName': json['playlist_name'],
    'playlistContents': json['playlist_contents'].map(PlaylistAddedTimestampFromJSON),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'totalPlayCount': json['total_play_count'],
    'user': UserFullFromJSON(json['user']),
    'blocknumber': json['blocknumber'],
    'createdAt': !exists(json, 'created_at') ? undefined : json['created_at'],
    'followeeReposts': json['followee_reposts'].map(RepostFromJSON),
    'followeeFavorites': json['followee_favorites'].map(FavoriteFromJSON),
    'hasCurrentUserReposted': json['has_current_user_reposted'],
    'hasCurrentUserSaved': json['has_current_user_saved'],
    'isDelete': json['is_delete'],
    'isPrivate': json['is_private'],
    'updatedAt': !exists(json, 'updated_at') ? undefined : json['updated_at'],
    'addedTimestamps': json['added_timestamps'].map(PlaylistAddedTimestampFromJSON),
    'userId': json['user_id'],
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(TrackFullFromJSON),
    'coverArt': !exists(json, 'cover_art') ? undefined : json['cover_art'],
    'coverArtSizes': !exists(json, 'cover_art_sizes') ? undefined : json['cover_art_sizes'],
    'coverArtCids': !exists(json, 'cover_art_cids') ? undefined : PlaylistArtworkFromJSON(json['cover_art_cids']),
    'trackCount': json['track_count']
  };
}
function PlaylistFullWithoutTracksToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': PlaylistArtworkToJSON(value.artwork),
    'description': value.description,
    'permalink': value.permalink,
    'id': value.id,
    'is_album': value.isAlbum,
    'is_image_autogenerated': value.isImageAutogenerated,
    'playlist_name': value.playlistName,
    'playlist_contents': value.playlistContents.map(PlaylistAddedTimestampToJSON),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'total_play_count': value.totalPlayCount,
    'user': UserFullToJSON(value.user),
    'blocknumber': value.blocknumber,
    'created_at': value.createdAt,
    'followee_reposts': value.followeeReposts.map(RepostToJSON),
    'followee_favorites': value.followeeFavorites.map(FavoriteToJSON),
    'has_current_user_reposted': value.hasCurrentUserReposted,
    'has_current_user_saved': value.hasCurrentUserSaved,
    'is_delete': value.isDelete,
    'is_private': value.isPrivate,
    'updated_at': value.updatedAt,
    'added_timestamps': value.addedTimestamps.map(PlaylistAddedTimestampToJSON),
    'user_id': value.userId,
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackFullToJSON),
    'cover_art': value.coverArt,
    'cover_art_sizes': value.coverArtSizes,
    'cover_art_cids': PlaylistArtworkToJSON(value.coverArtCids),
    'track_count': value.trackCount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CollectionActivityFull interface.
 */

function instanceOfCollectionActivityFull(value) {
  var isInstance = true;
  return isInstance;
}
function CollectionActivityFullFromJSON(json) {
  return CollectionActivityFullFromJSONTyped(json);
}
function CollectionActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'timestamp': !exists(json, 'timestamp') ? undefined : json['timestamp'],
    'itemType': !exists(json, 'item_type') ? undefined : json['item_type'],
    'item': !exists(json, 'item') ? undefined : PlaylistFullWithoutTracksFromJSON(json['item'])
  };
}
function CollectionActivityFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': PlaylistFullWithoutTracksToJSON(value.item)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the VersionMetadata interface.
 */

function instanceOfVersionMetadata(value) {
  var isInstance = true;
  isInstance = isInstance && "service" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function VersionMetadataFromJSON(json) {
  return VersionMetadataFromJSONTyped(json);
}
function VersionMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'service': json['service'],
    'version': json['version']
  };
}
function VersionMetadataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'service': value.service,
    'version': value.version
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CollectionLibraryResponseFull interface.
 */

function instanceOfCollectionLibraryResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function CollectionLibraryResponseFullFromJSON(json) {
  return CollectionLibraryResponseFullFromJSONTyped(json);
}
function CollectionLibraryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(CollectionActivityFullFromJSON)
  };
}
function CollectionLibraryResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(CollectionActivityFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowingResponse interface.
 */

function instanceOfFollowingResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FollowingResponseFromJSON(json) {
  return FollowingResponseFromJSONTyped(json);
}
function FollowingResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FollowingResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowingResponseFull interface.
 */

function instanceOfFollowingResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FollowingResponseFullFromJSON(json) {
  return FollowingResponseFullFromJSONTyped(json);
}
function FollowingResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FollowingResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserSubscribers interface.
 */

function instanceOfUserSubscribers(value) {
  var isInstance = true;
  isInstance = isInstance && "userId" in value;
  return isInstance;
}
function UserSubscribersFromJSON(json) {
  return UserSubscribersFromJSONTyped(json);
}
function UserSubscribersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': json['user_id'],
    'subscriberIds': !exists(json, 'subscriber_ids') ? undefined : json['subscriber_ids']
  };
}
function UserSubscribersToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'user_id': value.userId,
    'subscriber_ids': value.subscriberIds
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullBulkSubscribersResponse interface.
 */

function instanceOfFullBulkSubscribersResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullBulkSubscribersResponseFromJSON(json) {
  return FullBulkSubscribersResponseFromJSONTyped(json);
}
function FullBulkSubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserSubscribersFromJSON)
  };
}
function FullBulkSubscribersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserSubscribersToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullFollowersResponse interface.
 */

function instanceOfFullFollowersResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullFollowersResponseFromJSON(json) {
  return FullFollowersResponseFromJSONTyped(json);
}
function FullFollowersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullFollowersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullSupporter interface.
 */

function instanceOfFullSupporter(value) {
  var isInstance = true;
  isInstance = isInstance && "rank" in value;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "sender" in value;
  return isInstance;
}
function FullSupporterFromJSON(json) {
  return FullSupporterFromJSONTyped(json);
}
function FullSupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'sender': UserFullFromJSON(json['sender'])
  };
}
function FullSupporterToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'rank': value.rank,
    'amount': value.amount,
    'sender': UserFullToJSON(value.sender)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullGetSupporter interface.
 */

function instanceOfFullGetSupporter(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullGetSupporterFromJSON(json) {
  return FullGetSupporterFromJSONTyped(json);
}
function FullGetSupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : FullSupporterFromJSON(json['data'])
  };
}
function FullGetSupporterToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': FullSupporterToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullGetSupporters interface.
 */

function instanceOfFullGetSupporters(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullGetSupportersFromJSON(json) {
  return FullGetSupportersFromJSONTyped(json);
}
function FullGetSupportersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(FullSupporterFromJSON)
  };
}
function FullGetSupportersToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(FullSupporterToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullSupporting interface.
 */

function instanceOfFullSupporting(value) {
  var isInstance = true;
  isInstance = isInstance && "rank" in value;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "receiver" in value;
  return isInstance;
}
function FullSupportingFromJSON(json) {
  return FullSupportingFromJSONTyped(json);
}
function FullSupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'receiver': UserFullFromJSON(json['receiver'])
  };
}
function FullSupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'rank': value.rank,
    'amount': value.amount,
    'receiver': UserFullToJSON(value.receiver)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullGetSupporting interface.
 */

function instanceOfFullGetSupporting(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullGetSupportingFromJSON(json) {
  return FullGetSupportingFromJSONTyped(json);
}
function FullGetSupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : FullSupportingFromJSON(json['data'])
  };
}
function FullGetSupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': FullSupportingToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistFull interface.
 */

function instanceOfPlaylistFull(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isAlbum" in value;
  isInstance = isInstance && "isImageAutogenerated" in value;
  isInstance = isInstance && "playlistName" in value;
  isInstance = isInstance && "playlistContents" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "totalPlayCount" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "blocknumber" in value;
  isInstance = isInstance && "followeeReposts" in value;
  isInstance = isInstance && "followeeFavorites" in value;
  isInstance = isInstance && "hasCurrentUserReposted" in value;
  isInstance = isInstance && "hasCurrentUserSaved" in value;
  isInstance = isInstance && "isDelete" in value;
  isInstance = isInstance && "isPrivate" in value;
  isInstance = isInstance && "addedTimestamps" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "tracks" in value;
  isInstance = isInstance && "trackCount" in value;
  return isInstance;
}
function PlaylistFullFromJSON(json) {
  return PlaylistFullFromJSONTyped(json);
}
function PlaylistFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists(json, 'artwork') ? undefined : PlaylistArtworkFromJSON(json['artwork']),
    'description': !exists(json, 'description') ? undefined : json['description'],
    'permalink': !exists(json, 'permalink') ? undefined : json['permalink'],
    'id': json['id'],
    'isAlbum': json['is_album'],
    'isImageAutogenerated': json['is_image_autogenerated'],
    'playlistName': json['playlist_name'],
    'playlistContents': json['playlist_contents'].map(PlaylistAddedTimestampFromJSON),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'totalPlayCount': json['total_play_count'],
    'user': UserFullFromJSON(json['user']),
    'blocknumber': json['blocknumber'],
    'createdAt': !exists(json, 'created_at') ? undefined : json['created_at'],
    'followeeReposts': json['followee_reposts'].map(RepostFromJSON),
    'followeeFavorites': json['followee_favorites'].map(FavoriteFromJSON),
    'hasCurrentUserReposted': json['has_current_user_reposted'],
    'hasCurrentUserSaved': json['has_current_user_saved'],
    'isDelete': json['is_delete'],
    'isPrivate': json['is_private'],
    'updatedAt': !exists(json, 'updated_at') ? undefined : json['updated_at'],
    'addedTimestamps': json['added_timestamps'].map(PlaylistAddedTimestampFromJSON),
    'userId': json['user_id'],
    'tracks': json['tracks'].map(TrackFullFromJSON),
    'coverArt': !exists(json, 'cover_art') ? undefined : json['cover_art'],
    'coverArtSizes': !exists(json, 'cover_art_sizes') ? undefined : json['cover_art_sizes'],
    'coverArtCids': !exists(json, 'cover_art_cids') ? undefined : PlaylistArtworkFromJSON(json['cover_art_cids']),
    'trackCount': json['track_count']
  };
}
function PlaylistFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': PlaylistArtworkToJSON(value.artwork),
    'description': value.description,
    'permalink': value.permalink,
    'id': value.id,
    'is_album': value.isAlbum,
    'is_image_autogenerated': value.isImageAutogenerated,
    'playlist_name': value.playlistName,
    'playlist_contents': value.playlistContents.map(PlaylistAddedTimestampToJSON),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'total_play_count': value.totalPlayCount,
    'user': UserFullToJSON(value.user),
    'blocknumber': value.blocknumber,
    'created_at': value.createdAt,
    'followee_reposts': value.followeeReposts.map(RepostToJSON),
    'followee_favorites': value.followeeFavorites.map(FavoriteToJSON),
    'has_current_user_reposted': value.hasCurrentUserReposted,
    'has_current_user_saved': value.hasCurrentUserSaved,
    'is_delete': value.isDelete,
    'is_private': value.isPrivate,
    'updated_at': value.updatedAt,
    'added_timestamps': value.addedTimestamps.map(PlaylistAddedTimestampToJSON),
    'user_id': value.userId,
    'tracks': value.tracks.map(TrackFullToJSON),
    'cover_art': value.coverArt,
    'cover_art_sizes': value.coverArtSizes,
    'cover_art_cids': PlaylistArtworkToJSON(value.coverArtCids),
    'track_count': value.trackCount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullPlaylistResponse interface.
 */

function instanceOfFullPlaylistResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullPlaylistResponseFromJSON(json) {
  return FullPlaylistResponseFromJSONTyped(json);
}
function FullPlaylistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(PlaylistFullFromJSON)
  };
}
function FullPlaylistResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(PlaylistFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullPlaylistTracksResponse interface.
 */

function instanceOfFullPlaylistTracksResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullPlaylistTracksResponseFromJSON(json) {
  return FullPlaylistTracksResponseFromJSONTyped(json);
}
function FullPlaylistTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function FullPlaylistTracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullReposts interface.
 */

function instanceOfFullReposts(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullRepostsFromJSON(json) {
  return FullRepostsFromJSONTyped(json);
}
function FullRepostsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(ActivityFullFromJSON)
  };
}
function FullRepostsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(ActivityFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullSubscribersResponse interface.
 */

function instanceOfFullSubscribersResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullSubscribersResponseFromJSON(json) {
  return FullSubscribersResponseFromJSONTyped(json);
}
function FullSubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullSubscribersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SupporterReference interface.
 */

function instanceOfSupporterReference(value) {
  var isInstance = true;
  isInstance = isInstance && "userId" in value;
  return isInstance;
}
function SupporterReferenceFromJSON(json) {
  return SupporterReferenceFromJSONTyped(json);
}
function SupporterReferenceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': json['user_id']
  };
}
function SupporterReferenceToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'user_id': value.userId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTip interface.
 */

function instanceOfFullTip(value) {
  var isInstance = true;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "sender" in value;
  isInstance = isInstance && "receiver" in value;
  isInstance = isInstance && "createdAt" in value;
  isInstance = isInstance && "slot" in value;
  isInstance = isInstance && "followeeSupporters" in value;
  isInstance = isInstance && "txSignature" in value;
  return isInstance;
}
function FullTipFromJSON(json) {
  return FullTipFromJSONTyped(json);
}
function FullTipFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'amount': json['amount'],
    'sender': UserFullFromJSON(json['sender']),
    'receiver': UserFullFromJSON(json['receiver']),
    'createdAt': json['created_at'],
    'slot': json['slot'],
    'followeeSupporters': json['followee_supporters'].map(SupporterReferenceFromJSON),
    'txSignature': json['tx_signature']
  };
}
function FullTipToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'amount': value.amount,
    'sender': UserFullToJSON(value.sender),
    'receiver': UserFullToJSON(value.receiver),
    'created_at': value.createdAt,
    'slot': value.slot,
    'followee_supporters': value.followeeSupporters.map(SupporterReferenceToJSON),
    'tx_signature': value.txSignature
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTrackResponse interface.
 */

function instanceOfFullTrackResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullTrackResponseFromJSON(json) {
  return FullTrackResponseFromJSONTyped(json);
}
function FullTrackResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : TrackFullFromJSON(json['data'])
  };
}
function FullTrackResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': TrackFullToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTracks interface.
 */

function instanceOfFullTracks(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullTracksFromJSON(json) {
  return FullTracksFromJSONTyped(json);
}
function FullTracksFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function FullTracksToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTracksResponse interface.
 */

function instanceOfFullTracksResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullTracksResponseFromJSON(json) {
  return FullTracksResponseFromJSONTyped(json);
}
function FullTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function FullTracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTrendingPlaylistsResponse interface.
 */

function instanceOfFullTrendingPlaylistsResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullTrendingPlaylistsResponseFromJSON(json) {
  return FullTrendingPlaylistsResponseFromJSONTyped(json);
}
function FullTrendingPlaylistsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(PlaylistFullFromJSON)
  };
}
function FullTrendingPlaylistsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(PlaylistFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullUserResponse interface.
 */

function instanceOfFullUserResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullUserResponseFromJSON(json) {
  return FullUserResponseFromJSONTyped(json);
}
function FullUserResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullUserResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetTipsResponse interface.
 */

function instanceOfGetTipsResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function GetTipsResponseFromJSON(json) {
  return GetTipsResponseFromJSONTyped(json);
}
function GetTipsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(FullTipFromJSON)
  };
}
function GetTipsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(FullTipToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the HistoryResponseFull interface.
 */

function instanceOfHistoryResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function HistoryResponseFullFromJSON(json) {
  return HistoryResponseFullFromJSONTyped(json);
}
function HistoryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(ActivityFullFromJSON)
  };
}
function HistoryResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(ActivityFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RelatedArtistResponseFull interface.
 */

function instanceOfRelatedArtistResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function RelatedArtistResponseFullFromJSON(json) {
  return RelatedArtistResponseFullFromJSONTyped(json);
}
function RelatedArtistResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function RelatedArtistResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixesResponse interface.
 */

function instanceOfRemixesResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "count" in value;
  return isInstance;
}
function RemixesResponseFromJSON(json) {
  return RemixesResponseFromJSONTyped(json);
}
function RemixesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'count': json['count'],
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(TrackFullFromJSON)
  };
}
function RemixesResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'count': value.count,
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixesResponseFull interface.
 */

function instanceOfRemixesResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function RemixesResponseFullFromJSON(json) {
  return RemixesResponseFullFromJSONTyped(json);
}
function RemixesResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : RemixesResponseFromJSON(json['data'])
  };
}
function RemixesResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': RemixesResponseToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixingResponse interface.
 */

function instanceOfRemixingResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function RemixingResponseFromJSON(json) {
  return RemixingResponseFromJSONTyped(json);
}
function RemixingResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function RemixingResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SearchModel interface.
 */

function instanceOfSearchModel(value) {
  var isInstance = true;
  isInstance = isInstance && "users" in value;
  isInstance = isInstance && "tracks" in value;
  isInstance = isInstance && "playlists" in value;
  isInstance = isInstance && "albums" in value;
  return isInstance;
}
function SearchModelFromJSON(json) {
  return SearchModelFromJSONTyped(json);
}
function SearchModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'users': json['users'].map(UserFullFromJSON),
    'followedUsers': !exists(json, 'followed_users') ? undefined : json['followed_users'].map(UserFullFromJSON),
    'tracks': json['tracks'].map(TrackFullFromJSON),
    'savedTracks': !exists(json, 'saved_tracks') ? undefined : json['saved_tracks'].map(TrackFullFromJSON),
    'playlists': json['playlists'].map(PlaylistFullFromJSON),
    'savedPlaylists': !exists(json, 'saved_playlists') ? undefined : json['saved_playlists'].map(PlaylistFullFromJSON),
    'albums': json['albums'].map(PlaylistFullFromJSON),
    'savedAlbums': !exists(json, 'saved_albums') ? undefined : json['saved_albums'].map(PlaylistFullFromJSON)
  };
}
function SearchModelToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'users': value.users.map(UserFullToJSON),
    'followed_users': value.followedUsers === undefined ? undefined : value.followedUsers.map(UserFullToJSON),
    'tracks': value.tracks.map(TrackFullToJSON),
    'saved_tracks': value.savedTracks === undefined ? undefined : value.savedTracks.map(TrackFullToJSON),
    'playlists': value.playlists.map(PlaylistFullToJSON),
    'saved_playlists': value.savedPlaylists === undefined ? undefined : value.savedPlaylists.map(PlaylistFullToJSON),
    'albums': value.albums.map(PlaylistFullToJSON),
    'saved_albums': value.savedAlbums === undefined ? undefined : value.savedAlbums.map(PlaylistFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SearchAutocompleteResponse interface.
 */

function instanceOfSearchAutocompleteResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function SearchAutocompleteResponseFromJSON(json) {
  return SearchAutocompleteResponseFromJSONTyped(json);
}
function SearchAutocompleteResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : SearchModelFromJSON(json['data'])
  };
}
function SearchAutocompleteResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': SearchModelToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SearchFullResponse interface.
 */

function instanceOfSearchFullResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function SearchFullResponseFromJSON(json) {
  return SearchFullResponseFromJSONTyped(json);
}
function SearchFullResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : SearchModelFromJSON(json['data'])
  };
}
function SearchFullResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': SearchModelToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the StemFull interface.
 */

function instanceOfStemFull(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "parentId" in value;
  isInstance = isInstance && "category" in value;
  isInstance = isInstance && "cid" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "blocknumber" in value;
  return isInstance;
}
function StemFullFromJSON(json) {
  return StemFullFromJSONTyped(json);
}
function StemFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'id': json['id'],
    'parentId': json['parent_id'],
    'category': json['category'],
    'cid': json['cid'],
    'userId': json['user_id'],
    'blocknumber': json['blocknumber']
  };
}
function StemFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'id': value.id,
    'parent_id': value.parentId,
    'category': value.category,
    'cid': value.cid,
    'user_id': value.userId,
    'blocknumber': value.blocknumber
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the StemsResponse interface.
 */

function instanceOfStemsResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function StemsResponseFromJSON(json) {
  return StemsResponseFromJSONTyped(json);
}
function StemsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(StemFullFromJSON)
  };
}
function StemsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(StemFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TopGenreUsersResponseFull interface.
 */

function instanceOfTopGenreUsersResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TopGenreUsersResponseFullFromJSON(json) {
  return TopGenreUsersResponseFullFromJSONTyped(json);
}
function TopGenreUsersResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TopGenreUsersResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TopUsersResponseFull interface.
 */

function instanceOfTopUsersResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TopUsersResponseFullFromJSON(json) {
  return TopUsersResponseFullFromJSONTyped(json);
}
function TopUsersResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TopUsersResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackActivityFull interface.
 */

function instanceOfTrackActivityFull(value) {
  var isInstance = true;
  return isInstance;
}
function TrackActivityFullFromJSON(json) {
  return TrackActivityFullFromJSONTyped(json);
}
function TrackActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'timestamp': !exists(json, 'timestamp') ? undefined : json['timestamp'],
    'itemType': !exists(json, 'item_type') ? undefined : json['item_type'],
    'item': !exists(json, 'item') ? undefined : TrackFullFromJSON(json['item'])
  };
}
function TrackActivityFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': TrackFullToJSON(value.item)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackFavoritesResponseFull interface.
 */

function instanceOfTrackFavoritesResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TrackFavoritesResponseFullFromJSON(json) {
  return TrackFavoritesResponseFullFromJSONTyped(json);
}
function TrackFavoritesResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TrackFavoritesResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackId interface.
 */

function instanceOfTrackId(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  return isInstance;
}
function TrackIdFromJSON(json) {
  return TrackIdFromJSONTyped(json);
}
function TrackIdFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'id': json['id']
  };
}
function TrackIdToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'id': value.id
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackLibraryResponseFull interface.
 */

function instanceOfTrackLibraryResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TrackLibraryResponseFullFromJSON(json) {
  return TrackLibraryResponseFullFromJSONTyped(json);
}
function TrackLibraryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackActivityFullFromJSON)
  };
}
function TrackLibraryResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackActivityFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackRepostsResponseFull interface.
 */

function instanceOfTrackRepostsResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TrackRepostsResponseFullFromJSON(json) {
  return TrackRepostsResponseFullFromJSONTyped(json);
}
function TrackRepostsResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TrackRepostsResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TransactionDetails interface.
 */

function instanceOfTransactionDetails(value) {
  var isInstance = true;
  isInstance = isInstance && "transactionDate" in value;
  isInstance = isInstance && "transactionType" in value;
  isInstance = isInstance && "method" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "userBank" in value;
  isInstance = isInstance && "change" in value;
  isInstance = isInstance && "balance" in value;
  isInstance = isInstance && "metadata" in value;
  return isInstance;
}
function TransactionDetailsFromJSON(json) {
  return TransactionDetailsFromJSONTyped(json);
}
function TransactionDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'transactionDate': json['transaction_date'],
    'transactionType': json['transaction_type'],
    'method': json['method'],
    'signature': json['signature'],
    'userBank': json['user_bank'],
    'change': json['change'],
    'balance': json['balance'],
    'metadata': json['metadata']
  };
}
function TransactionDetailsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'transaction_date': value.transactionDate,
    'transaction_type': value.transactionType,
    'method': value.method,
    'signature': value.signature,
    'user_bank': value.userBank,
    'change': value.change,
    'balance': value.balance,
    'metadata': value.metadata
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TransactionHistoryCountResponse interface.
 */

function instanceOfTransactionHistoryCountResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TransactionHistoryCountResponseFromJSON(json) {
  return TransactionHistoryCountResponseFromJSONTyped(json);
}
function TransactionHistoryCountResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data']
  };
}
function TransactionHistoryCountResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TransactionHistoryResponse interface.
 */

function instanceOfTransactionHistoryResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TransactionHistoryResponseFromJSON(json) {
  return TransactionHistoryResponseFromJSONTyped(json);
}
function TransactionHistoryResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TransactionDetailsFromJSON)
  };
}
function TransactionHistoryResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TransactionDetailsToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingTimesIds interface.
 */

function instanceOfTrendingTimesIds(value) {
  var isInstance = true;
  return isInstance;
}
function TrendingTimesIdsFromJSON(json) {
  return TrendingTimesIdsFromJSONTyped(json);
}
function TrendingTimesIdsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'week': !exists(json, 'week') ? undefined : json['week'].map(TrackIdFromJSON),
    'month': !exists(json, 'month') ? undefined : json['month'].map(TrackIdFromJSON),
    'year': !exists(json, 'year') ? undefined : json['year'].map(TrackIdFromJSON)
  };
}
function TrendingTimesIdsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'week': value.week === undefined ? undefined : value.week.map(TrackIdToJSON),
    'month': value.month === undefined ? undefined : value.month.map(TrackIdToJSON),
    'year': value.year === undefined ? undefined : value.year.map(TrackIdToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingIdsResponse interface.
 */

function instanceOfTrendingIdsResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TrendingIdsResponseFromJSON(json) {
  return TrendingIdsResponseFromJSONTyped(json);
}
function TrendingIdsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists(json, 'data') ? undefined : TrendingTimesIdsFromJSON(json['data'])
  };
}
function TrendingIdsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': TrendingTimesIdsToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserReplicaSet interface.
 */

function instanceOfUserReplicaSet(value) {
  var isInstance = true;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "wallet" in value;
  return isInstance;
}
function UserReplicaSetFromJSON(json) {
  return UserReplicaSetFromJSONTyped(json);
}
function UserReplicaSetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': json['user_id'],
    'wallet': json['wallet'],
    'primary': !exists(json, 'primary') ? undefined : json['primary'],
    'secondary1': !exists(json, 'secondary1') ? undefined : json['secondary1'],
    'secondary2': !exists(json, 'secondary2') ? undefined : json['secondary2'],
    'primarySpID': !exists(json, 'primarySpID') ? undefined : json['primarySpID'],
    'secondary1SpID': !exists(json, 'secondary1SpID') ? undefined : json['secondary1SpID'],
    'secondary2SpID': !exists(json, 'secondary2SpID') ? undefined : json['secondary2SpID']
  };
}
function UserReplicaSetToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'user_id': value.userId,
    'wallet': value.wallet,
    'primary': value.primary,
    'secondary1': value.secondary1,
    'secondary2': value.secondary2,
    'primarySpID': value.primarySpID,
    'secondary1SpID': value.secondary1SpID,
    'secondary2SpID': value.secondary2SpID
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UsersByContentNode interface.
 */

function instanceOfUsersByContentNode(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function UsersByContentNodeFromJSON(json) {
  return UsersByContentNodeFromJSONTyped(json);
}
function UsersByContentNodeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : UserReplicaSetFromJSON(json['data'])
  };
}
function UsersByContentNodeToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': UserReplicaSetToJSON(value.data)
  };
}

/**
 *
 */

var PlaylistsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(PlaylistsApi, _runtime$BaseAPI);

  var _super = _createSuper(PlaylistsApi);

  function PlaylistsApi() {
    _classCallCheck$1(this, PlaylistsApi);

    return _super.apply(this, arguments);
  }

  _createClass$1(PlaylistsApi, [{
    key: "getPlaylistRaw",
    value:
    /** @hidden
     * Get a playlist by ID
     */
    function () {
      var _getPlaylistRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylist.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context.next = 7;
                return this.request({
                  path: "/playlists/{playlist_id}".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullPlaylistResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getPlaylistRaw(_x, _x2) {
        return _getPlaylistRaw.apply(this, arguments);
      }

      return getPlaylistRaw;
    }()
    /**
     * Get a playlist by ID
     */

  }, {
    key: "getPlaylist",
    value: function () {
      var _getPlaylist = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getPlaylistRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getPlaylist(_x3, _x4) {
        return _getPlaylist.apply(this, arguments);
      }

      return getPlaylist;
    }()
    /** @hidden
     * Get a playlist by handle and slug
     */

  }, {
    key: "getPlaylistByHandleAndSlugRaw",
    value: function () {
      var _getPlaylistByHandleAndSlugRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getPlaylistByHandleAndSlug.');

              case 2:
                if (!(params.slug === null || params.slug === undefined)) {
                  _context3.next = 4;
                  break;
                }

                throw new RequiredError('slug', 'Required parameter params.slug was null or undefined when calling getPlaylistByHandleAndSlug.');

              case 4:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context3.next = 9;
                return this.request({
                  path: "/playlists/by_permalink/{handle}/{slug}".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))).replace("{".concat("slug", "}"), encodeURIComponent(String(params.slug))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullPlaylistResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getPlaylistByHandleAndSlugRaw(_x5, _x6) {
        return _getPlaylistByHandleAndSlugRaw.apply(this, arguments);
      }

      return getPlaylistByHandleAndSlugRaw;
    }()
    /**
     * Get a playlist by handle and slug
     */

  }, {
    key: "getPlaylistByHandleAndSlug",
    value: function () {
      var _getPlaylistByHandleAndSlug = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getPlaylistByHandleAndSlugRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getPlaylistByHandleAndSlug(_x7, _x8) {
        return _getPlaylistByHandleAndSlug.apply(this, arguments);
      }

      return getPlaylistByHandleAndSlug;
    }()
    /** @hidden
     * Fetch tracks within a playlist.
     */

  }, {
    key: "getPlaylistTracksRaw",
    value: function () {
      var _getPlaylistTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context5.next = 2;
                  break;
                }

                throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylistTracks.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context5.next = 6;
                return this.request({
                  path: "/playlists/{playlist_id}/tracks".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullPlaylistTracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getPlaylistTracksRaw(_x9, _x10) {
        return _getPlaylistTracksRaw.apply(this, arguments);
      }

      return getPlaylistTracksRaw;
    }()
    /**
     * Fetch tracks within a playlist.
     */

  }, {
    key: "getPlaylistTracks",
    value: function () {
      var _getPlaylistTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getPlaylistTracksRaw(params, initOverrides);

              case 2:
                response = _context6.sent;
                _context6.next = 5;
                return response.value();

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getPlaylistTracks(_x11, _x12) {
        return _getPlaylistTracks.apply(this, arguments);
      }

      return getPlaylistTracks;
    }()
    /** @hidden
     * Returns trending playlists for a time period
     */

  }, {
    key: "getTrendingPlaylistsRaw",
    value: function () {
      var _getTrendingPlaylistsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context7.next = 8;
                return this.request({
                  path: "/playlists/trending",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTrendingPlaylistsResponseFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getTrendingPlaylistsRaw(_x13, _x14) {
        return _getTrendingPlaylistsRaw.apply(this, arguments);
      }

      return getTrendingPlaylistsRaw;
    }()
    /**
     * Returns trending playlists for a time period
     */

  }, {
    key: "getTrendingPlaylists",
    value: function () {
      var _getTrendingPlaylists = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var params,
            initOverrides,
            response,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                params = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};
                initOverrides = _args8.length > 1 ? _args8[1] : undefined;
                _context8.next = 4;
                return this.getTrendingPlaylistsRaw(params, initOverrides);

              case 4:
                response = _context8.sent;
                _context8.next = 7;
                return response.value();

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getTrendingPlaylists() {
        return _getTrendingPlaylists.apply(this, arguments);
      }

      return getTrendingPlaylists;
    }()
    /** @hidden
     * Returns trending playlists for a time period based on the given trending version
     */

  }, {
    key: "getTrendingPlaylistsWithVersionRaw",
    value: function () {
      var _getTrendingPlaylistsWithVersionRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getTrendingPlaylistsWithVersion.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context9.next = 10;
                return this.request({
                  path: "/playlists/trending/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 10:
                response = _context9.sent;
                return _context9.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTrendingPlaylistsResponseFromJSON(jsonValue);
                }));

              case 12:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getTrendingPlaylistsWithVersionRaw(_x15, _x16) {
        return _getTrendingPlaylistsWithVersionRaw.apply(this, arguments);
      }

      return getTrendingPlaylistsWithVersionRaw;
    }()
    /**
     * Returns trending playlists for a time period based on the given trending version
     */

  }, {
    key: "getTrendingPlaylistsWithVersion",
    value: function () {
      var _getTrendingPlaylistsWithVersion = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getTrendingPlaylistsWithVersionRaw(params, initOverrides);

              case 2:
                response = _context10.sent;
                _context10.next = 5;
                return response.value();

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getTrendingPlaylistsWithVersion(_x17, _x18) {
        return _getTrendingPlaylistsWithVersion.apply(this, arguments);
      }

      return getTrendingPlaylistsWithVersion;
    }()
    /** @hidden
     * Get users that favorited a playlist
     */

  }, {
    key: "getUsersFromPlaylistFavoritesRaw",
    value: function () {
      var _getUsersFromPlaylistFavoritesRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context11.next = 2;
                  break;
                }

                throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getUsersFromPlaylistFavorites.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context11.next = 9;
                return this.request({
                  path: "/playlists/{playlist_id}/favorites".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context11.sent;
                return _context11.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FollowingResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getUsersFromPlaylistFavoritesRaw(_x19, _x20) {
        return _getUsersFromPlaylistFavoritesRaw.apply(this, arguments);
      }

      return getUsersFromPlaylistFavoritesRaw;
    }()
    /**
     * Get users that favorited a playlist
     */

  }, {
    key: "getUsersFromPlaylistFavorites",
    value: function () {
      var _getUsersFromPlaylistFavorites = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getUsersFromPlaylistFavoritesRaw(params, initOverrides);

              case 2:
                response = _context12.sent;
                _context12.next = 5;
                return response.value();

              case 5:
                return _context12.abrupt("return", _context12.sent);

              case 6:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getUsersFromPlaylistFavorites(_x21, _x22) {
        return _getUsersFromPlaylistFavorites.apply(this, arguments);
      }

      return getUsersFromPlaylistFavorites;
    }()
    /** @hidden
     * Get users that reposted a playlist
     */

  }, {
    key: "getUsersFromPlaylistRepostsRaw",
    value: function () {
      var _getUsersFromPlaylistRepostsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context13.next = 2;
                  break;
                }

                throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getUsersFromPlaylistReposts.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context13.next = 9;
                return this.request({
                  path: "/playlists/{playlist_id}/reposts".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context13.sent;
                return _context13.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FollowingResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getUsersFromPlaylistRepostsRaw(_x23, _x24) {
        return _getUsersFromPlaylistRepostsRaw.apply(this, arguments);
      }

      return getUsersFromPlaylistRepostsRaw;
    }()
    /**
     * Get users that reposted a playlist
     */

  }, {
    key: "getUsersFromPlaylistReposts",
    value: function () {
      var _getUsersFromPlaylistReposts = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getUsersFromPlaylistRepostsRaw(params, initOverrides);

              case 2:
                response = _context14.sent;
                _context14.next = 5;
                return response.value();

              case 5:
                return _context14.abrupt("return", _context14.sent);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getUsersFromPlaylistReposts(_x25, _x26) {
        return _getUsersFromPlaylistReposts.apply(this, arguments);
      }

      return getUsersFromPlaylistReposts;
    }()
  }]);

  return PlaylistsApi;
}(BaseAPI);
/**
 * @export
 */

var GetTrendingPlaylistsTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetTrendingPlaylistsWithVersionTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};

/**
 *
 */

var ReactionsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(ReactionsApi, _runtime$BaseAPI);

  var _super = _createSuper(ReactionsApi);

  function ReactionsApi() {
    _classCallCheck$1(this, ReactionsApi);

    return _super.apply(this, arguments);
  }

  _createClass$1(ReactionsApi, [{
    key: "bulkGetReactionsRaw",
    value:
    /** @hidden
     * Gets reactions by reacted_to_id and type
     */
    function () {
      var _bulkGetReactionsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.reactedToIds === null || params.reactedToIds === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('reactedToIds', 'Required parameter params.reactedToIds was null or undefined when calling bulkGetReactions.');

              case 2:
                queryParameters = {};

                if (params.type !== undefined) {
                  queryParameters['type'] = params.type;
                }

                if (params.reactedToIds) {
                  queryParameters['reacted_to_ids'] = params.reactedToIds.join(COLLECTION_FORMATS["csv"]);
                }

                headerParameters = {};
                _context.next = 8;
                return this.request({
                  path: "/reactions",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context.sent;
                return _context.abrupt("return", new VoidApiResponse(response));

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function bulkGetReactionsRaw(_x, _x2) {
        return _bulkGetReactionsRaw.apply(this, arguments);
      }

      return bulkGetReactionsRaw;
    }()
    /**
     * Gets reactions by reacted_to_id and type
     */

  }, {
    key: "bulkGetReactions",
    value: function () {
      var _bulkGetReactions = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.bulkGetReactionsRaw(params, initOverrides);

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function bulkGetReactions(_x3, _x4) {
        return _bulkGetReactions.apply(this, arguments);
      }

      return bulkGetReactions;
    }()
  }]);

  return ReactionsApi;
}(BaseAPI);

/**
 *
 */

var SearchApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(SearchApi, _runtime$BaseAPI);

  var _super = _createSuper(SearchApi);

  function SearchApi() {
    _classCallCheck$1(this, SearchApi);

    return _super.apply(this, arguments);
  }

  _createClass$1(SearchApi, [{
    key: "searchRaw",
    value:
    /** @hidden
     * Get Users/Tracks/Playlists/Albums that best match the search query
     */
    function () {
      var _searchRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('query', 'Required parameter params.query was null or undefined when calling search.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.kind !== undefined) {
                  queryParameters['kind'] = params.kind;
                }

                headerParameters = {};
                _context.next = 11;
                return this.request({
                  path: "/search/full",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return SearchFullResponseFromJSON(jsonValue);
                }));

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function searchRaw(_x, _x2) {
        return _searchRaw.apply(this, arguments);
      }

      return searchRaw;
    }()
    /**
     * Get Users/Tracks/Playlists/Albums that best match the search query
     */

  }, {
    key: "search",
    value: function () {
      var _search = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.searchRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function search(_x3, _x4) {
        return _search.apply(this, arguments);
      }

      return search;
    }()
    /** @hidden
     * Same as search but optimized for quicker response at the cost of some entity information.
     * Get Users/Tracks/Playlists/Albums that best match the search query
     */

  }, {
    key: "searchAutocompleteRaw",
    value: function () {
      var _searchAutocompleteRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError('query', 'Required parameter params.query was null or undefined when calling searchAutocomplete.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.kind !== undefined) {
                  queryParameters['kind'] = params.kind;
                }

                headerParameters = {};
                _context3.next = 11;
                return this.request({
                  path: "/search/autocomplete",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return SearchAutocompleteResponseFromJSON(jsonValue);
                }));

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function searchAutocompleteRaw(_x5, _x6) {
        return _searchAutocompleteRaw.apply(this, arguments);
      }

      return searchAutocompleteRaw;
    }()
    /**
     * Same as search but optimized for quicker response at the cost of some entity information.
     * Get Users/Tracks/Playlists/Albums that best match the search query
     */

  }, {
    key: "searchAutocomplete",
    value: function () {
      var _searchAutocomplete = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.searchAutocompleteRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function searchAutocomplete(_x7, _x8) {
        return _searchAutocomplete.apply(this, arguments);
      }

      return searchAutocomplete;
    }()
  }]);

  return SearchApi;
}(BaseAPI);
/**
 * @export
 */

var SearchKindEnum = {
  All: 'all',
  Users: 'users',
  Tracks: 'tracks',
  Playlists: 'playlists',
  Albums: 'albums'
};
/**
 * @export
 */

var SearchAutocompleteKindEnum = {
  All: 'all',
  Users: 'users',
  Tracks: 'tracks',
  Playlists: 'playlists',
  Albums: 'albums'
};

/**
 *
 */

var TipsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TipsApi, _runtime$BaseAPI);

  var _super = _createSuper(TipsApi);

  function TipsApi() {
    _classCallCheck$1(this, TipsApi);

    return _super.apply(this, arguments);
  }

  _createClass$1(TipsApi, [{
    key: "getTipsRaw",
    value:
    /** @hidden
     * Gets the most recent tips on the network
     */
    function () {
      var _getTipsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.receiverMinFollowers !== undefined) {
                  queryParameters['receiver_min_followers'] = params.receiverMinFollowers;
                }

                if (params.receiverIsVerified !== undefined) {
                  queryParameters['receiver_is_verified'] = params.receiverIsVerified;
                }

                if (params.currentUserFollows !== undefined) {
                  queryParameters['current_user_follows'] = params.currentUserFollows;
                }

                if (params.uniqueBy !== undefined) {
                  queryParameters['unique_by'] = params.uniqueBy;
                }

                if (params.minSlot !== undefined) {
                  queryParameters['min_slot'] = params.minSlot;
                }

                if (params.maxSlot !== undefined) {
                  queryParameters['max_slot'] = params.maxSlot;
                }

                if (params.txSignatures) {
                  queryParameters['tx_signatures'] = params.txSignatures.join(COLLECTION_FORMATS["csv"]);
                }

                headerParameters = {};
                _context.next = 14;
                return this.request({
                  path: "/tips",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return GetTipsResponseFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getTipsRaw(_x, _x2) {
        return _getTipsRaw.apply(this, arguments);
      }

      return getTipsRaw;
    }()
    /**
     * Gets the most recent tips on the network
     */

  }, {
    key: "getTips",
    value: function () {
      var _getTips = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var params,
            initOverrides,
            response,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                params = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                initOverrides = _args2.length > 1 ? _args2[1] : undefined;
                _context2.next = 4;
                return this.getTipsRaw(params, initOverrides);

              case 4:
                response = _context2.sent;
                _context2.next = 7;
                return response.value();

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getTips() {
        return _getTips.apply(this, arguments);
      }

      return getTips;
    }()
  }]);

  return TipsApi;
}(BaseAPI);
/**
 * @export
 */

var GetTipsCurrentUserFollowsEnum = {
  Sender: 'sender',
  Receiver: 'receiver',
  SenderOrReceiver: 'sender_or_receiver'
};
/**
 * @export
 */

var GetTipsUniqueByEnum = {
  Sender: 'sender',
  Receiver: 'receiver'
};

/**
 *
 */

var TracksApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TracksApi, _runtime$BaseAPI);

  var _super = _createSuper(TracksApi);

  function TracksApi() {
    _classCallCheck$1(this, TracksApi);

    return _super.apply(this, arguments);
  }

  _createClass$1(TracksApi, [{
    key: "bestNewReleasesRaw",
    value:
    /** @hidden
     * Gets the tracks found on the \"Best New Releases\" smart playlist
     */
    function () {
      var _bestNewReleasesRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                queryParameters = {};
                headerParameters = {};
                _context.next = 4;
                return this.request({
                  path: "/tracks/best_new_releases",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 4:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function bestNewReleasesRaw(_x) {
        return _bestNewReleasesRaw.apply(this, arguments);
      }

      return bestNewReleasesRaw;
    }()
    /**
     * Gets the tracks found on the \"Best New Releases\" smart playlist
     */

  }, {
    key: "bestNewReleases",
    value: function () {
      var _bestNewReleases = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.bestNewReleasesRaw(initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function bestNewReleases(_x2) {
        return _bestNewReleases.apply(this, arguments);
      }

      return bestNewReleases;
    }()
    /** @hidden
     * Gets a list of tracks using their IDs or permalinks
     */

  }, {
    key: "getBulkTracksRaw",
    value: function () {
      var _getBulkTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.permalink) {
                  queryParameters['permalink'] = params.permalink;
                }

                if (params.id) {
                  queryParameters['id'] = params.id;
                }

                headerParameters = {};
                _context3.next = 7;
                return this.request({
                  path: "/tracks",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getBulkTracksRaw(_x3, _x4) {
        return _getBulkTracksRaw.apply(this, arguments);
      }

      return getBulkTracksRaw;
    }()
    /**
     * Gets a list of tracks using their IDs or permalinks
     */

  }, {
    key: "getBulkTracks",
    value: function () {
      var _getBulkTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var params,
            initOverrides,
            response,
            _args4 = arguments;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                params = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
                initOverrides = _args4.length > 1 ? _args4[1] : undefined;
                _context4.next = 4;
                return this.getBulkTracksRaw(params, initOverrides);

              case 4:
                response = _context4.sent;
                _context4.next = 7;
                return response.value();

              case 7:
                return _context4.abrupt("return", _context4.sent);

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getBulkTracks() {
        return _getBulkTracks.apply(this, arguments);
      }

      return getBulkTracks;
    }()
    /** @hidden
     * Gets random tracks found on the \"Feeling Lucky\" smart playlist
     */

  }, {
    key: "getFeelingLuckyTracksRaw",
    value: function () {
      var _getFeelingLuckyTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.withUsers !== undefined) {
                  queryParameters['with_users'] = params.withUsers;
                }

                if (params.minFollowers !== undefined) {
                  queryParameters['min_followers'] = params.minFollowers;
                }

                headerParameters = {};
                _context5.next = 8;
                return this.request({
                  path: "/tracks/feeling_lucky",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getFeelingLuckyTracksRaw(_x5, _x6) {
        return _getFeelingLuckyTracksRaw.apply(this, arguments);
      }

      return getFeelingLuckyTracksRaw;
    }()
    /**
     * Gets random tracks found on the \"Feeling Lucky\" smart playlist
     */

  }, {
    key: "getFeelingLuckyTracks",
    value: function () {
      var _getFeelingLuckyTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var params,
            initOverrides,
            response,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                params = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
                initOverrides = _args6.length > 1 ? _args6[1] : undefined;
                _context6.next = 4;
                return this.getFeelingLuckyTracksRaw(params, initOverrides);

              case 4:
                response = _context6.sent;
                _context6.next = 7;
                return response.value();

              case 7:
                return _context6.abrupt("return", _context6.sent);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getFeelingLuckyTracks() {
        return _getFeelingLuckyTracks.apply(this, arguments);
      }

      return getFeelingLuckyTracks;
    }()
    /** @hidden
     * Gets the tracks found on the \"Most Loved\" smart playlist
     */

  }, {
    key: "getMostLovedTracksRaw",
    value: function () {
      var _getMostLovedTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.withUsers !== undefined) {
                  queryParameters['with_users'] = params.withUsers;
                }

                headerParameters = {};
                _context7.next = 7;
                return this.request({
                  path: "/tracks/most_loved",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getMostLovedTracksRaw(_x7, _x8) {
        return _getMostLovedTracksRaw.apply(this, arguments);
      }

      return getMostLovedTracksRaw;
    }()
    /**
     * Gets the tracks found on the \"Most Loved\" smart playlist
     */

  }, {
    key: "getMostLovedTracks",
    value: function () {
      var _getMostLovedTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var params,
            initOverrides,
            response,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                params = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};
                initOverrides = _args8.length > 1 ? _args8[1] : undefined;
                _context8.next = 4;
                return this.getMostLovedTracksRaw(params, initOverrides);

              case 4:
                response = _context8.sent;
                _context8.next = 7;
                return response.value();

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getMostLovedTracks() {
        return _getMostLovedTracks.apply(this, arguments);
      }

      return getMostLovedTracks;
    }()
    /** @hidden
     * Gets premium track signatures for passed in premium track ids
     */

  }, {
    key: "getPremiumTrackSignaturesRaw",
    value: function () {
      var _getPremiumTrackSignaturesRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.userId === null || params.userId === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError('userId', 'Required parameter params.userId was null or undefined when calling getPremiumTrackSignatures.');

              case 2:
                queryParameters = {};

                if (params.trackIds) {
                  queryParameters['track_ids'] = params.trackIds;
                }

                if (params.tokenIds) {
                  queryParameters['token_ids'] = params.tokenIds;
                }

                headerParameters = {};
                _context9.next = 8;
                return this.request({
                  path: "/tracks/{user_id}/nft-gated-signatures".replace("{".concat("user_id", "}"), encodeURIComponent(String(params.userId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context9.sent;
                return _context9.abrupt("return", new VoidApiResponse(response));

              case 10:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getPremiumTrackSignaturesRaw(_x9, _x10) {
        return _getPremiumTrackSignaturesRaw.apply(this, arguments);
      }

      return getPremiumTrackSignaturesRaw;
    }()
    /**
     * Gets premium track signatures for passed in premium track ids
     */

  }, {
    key: "getPremiumTrackSignatures",
    value: function () {
      var _getPremiumTrackSignatures = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getPremiumTrackSignaturesRaw(params, initOverrides);

              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getPremiumTrackSignatures(_x11, _x12) {
        return _getPremiumTrackSignatures.apply(this, arguments);
      }

      return getPremiumTrackSignatures;
    }()
    /** @hidden
     * Get recommended tracks
     */

  }, {
    key: "getRecommendedTracksRaw",
    value: function () {
      var _getRecommendedTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                queryParameters = {};

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                if (params.exclusionList) {
                  queryParameters['exclusion_list'] = params.exclusionList;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context11.next = 9;
                return this.request({
                  path: "/tracks/recommended",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context11.sent;
                return _context11.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getRecommendedTracksRaw(_x13, _x14) {
        return _getRecommendedTracksRaw.apply(this, arguments);
      }

      return getRecommendedTracksRaw;
    }()
    /**
     * Get recommended tracks
     */

  }, {
    key: "getRecommendedTracks",
    value: function () {
      var _getRecommendedTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var params,
            initOverrides,
            response,
            _args12 = arguments;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                params = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : {};
                initOverrides = _args12.length > 1 ? _args12[1] : undefined;
                _context12.next = 4;
                return this.getRecommendedTracksRaw(params, initOverrides);

              case 4:
                response = _context12.sent;
                _context12.next = 7;
                return response.value();

              case 7:
                return _context12.abrupt("return", _context12.sent);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getRecommendedTracks() {
        return _getRecommendedTracks.apply(this, arguments);
      }

      return getRecommendedTracks;
    }()
    /** @hidden
     * Get recommended tracks using the given trending strategy version
     */

  }, {
    key: "getRecommendedTracksWithVersionRaw",
    value: function () {
      var _getRecommendedTracksWithVersionRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context13.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getRecommendedTracksWithVersion.');

              case 2:
                queryParameters = {};

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                if (params.exclusionList) {
                  queryParameters['exclusion_list'] = params.exclusionList;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context13.next = 11;
                return this.request({
                  path: "/tracks/recommended/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context13.sent;
                return _context13.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 13:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getRecommendedTracksWithVersionRaw(_x15, _x16) {
        return _getRecommendedTracksWithVersionRaw.apply(this, arguments);
      }

      return getRecommendedTracksWithVersionRaw;
    }()
    /**
     * Get recommended tracks using the given trending strategy version
     */

  }, {
    key: "getRecommendedTracksWithVersion",
    value: function () {
      var _getRecommendedTracksWithVersion = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getRecommendedTracksWithVersionRaw(params, initOverrides);

              case 2:
                response = _context14.sent;
                _context14.next = 5;
                return response.value();

              case 5:
                return _context14.abrupt("return", _context14.sent);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getRecommendedTracksWithVersion(_x17, _x18) {
        return _getRecommendedTracksWithVersion.apply(this, arguments);
      }

      return getRecommendedTracksWithVersion;
    }()
    /** @hidden
     * Gets a list of tracks that have stems available for remixing
     */

  }, {
    key: "getRemixableTracksRaw",
    value: function () {
      var _getRemixableTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                queryParameters = {};

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.withUsers !== undefined) {
                  queryParameters['with_users'] = params.withUsers;
                }

                headerParameters = {};
                _context15.next = 7;
                return this.request({
                  path: "/tracks/remixables",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context15.sent;
                return _context15.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTrackResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getRemixableTracksRaw(_x19, _x20) {
        return _getRemixableTracksRaw.apply(this, arguments);
      }

      return getRemixableTracksRaw;
    }()
    /**
     * Gets a list of tracks that have stems available for remixing
     */

  }, {
    key: "getRemixableTracks",
    value: function () {
      var _getRemixableTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
        var params,
            initOverrides,
            response,
            _args16 = arguments;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                params = _args16.length > 0 && _args16[0] !== undefined ? _args16[0] : {};
                initOverrides = _args16.length > 1 ? _args16[1] : undefined;
                _context16.next = 4;
                return this.getRemixableTracksRaw(params, initOverrides);

              case 4:
                response = _context16.sent;
                _context16.next = 7;
                return response.value();

              case 7:
                return _context16.abrupt("return", _context16.sent);

              case 8:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getRemixableTracks() {
        return _getRemixableTracks.apply(this, arguments);
      }

      return getRemixableTracks;
    }()
    /** @hidden
     * Gets a track by ID. If `show_unlisted` is true, then `handle` and `url_title` are required.
     */

  }, {
    key: "getTrackRaw",
    value: function () {
      var _getTrackRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context17.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrack.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.handle !== undefined) {
                  queryParameters['handle'] = params.handle;
                }

                if (params.urlTitle !== undefined) {
                  queryParameters['url_title'] = params.urlTitle;
                }

                if (params.showUnlisted !== undefined) {
                  queryParameters['show_unlisted'] = params.showUnlisted;
                }

                headerParameters = {};
                _context17.next = 10;
                return this.request({
                  path: "/tracks/{track_id}".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 10:
                response = _context17.sent;
                return _context17.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTrackResponseFromJSON(jsonValue);
                }));

              case 12:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getTrackRaw(_x21, _x22) {
        return _getTrackRaw.apply(this, arguments);
      }

      return getTrackRaw;
    }()
    /**
     * Gets a track by ID. If `show_unlisted` is true, then `handle` and `url_title` are required.
     */

  }, {
    key: "getTrack",
    value: function () {
      var _getTrack = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.getTrackRaw(params, initOverrides);

              case 2:
                response = _context18.sent;
                _context18.next = 5;
                return response.value();

              case 5:
                return _context18.abrupt("return", _context18.sent);

              case 6:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getTrack(_x23, _x24) {
        return _getTrack.apply(this, arguments);
      }

      return getTrack;
    }()
    /** @hidden
     * Gets all the tracks that the given track remixes
     */

  }, {
    key: "getTrackRemixParentsRaw",
    value: function () {
      var _getTrackRemixParentsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context19.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackRemixParents.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context19.next = 9;
                return this.request({
                  path: "/tracks/{track_id}/remixing".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context19.sent;
                return _context19.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return RemixingResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getTrackRemixParentsRaw(_x25, _x26) {
        return _getTrackRemixParentsRaw.apply(this, arguments);
      }

      return getTrackRemixParentsRaw;
    }()
    /**
     * Gets all the tracks that the given track remixes
     */

  }, {
    key: "getTrackRemixParents",
    value: function () {
      var _getTrackRemixParents = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getTrackRemixParentsRaw(params, initOverrides);

              case 2:
                response = _context20.sent;
                _context20.next = 5;
                return response.value();

              case 5:
                return _context20.abrupt("return", _context20.sent);

              case 6:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getTrackRemixParents(_x27, _x28) {
        return _getTrackRemixParents.apply(this, arguments);
      }

      return getTrackRemixParents;
    }()
    /** @hidden
     * Get all tracks that remix the given track
     */

  }, {
    key: "getTrackRemixesRaw",
    value: function () {
      var _getTrackRemixesRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context21.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackRemixes.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context21.next = 9;
                return this.request({
                  path: "/tracks/{track_id}/remixes".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context21.sent;
                return _context21.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return RemixesResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getTrackRemixesRaw(_x29, _x30) {
        return _getTrackRemixesRaw.apply(this, arguments);
      }

      return getTrackRemixesRaw;
    }()
    /**
     * Get all tracks that remix the given track
     */

  }, {
    key: "getTrackRemixes",
    value: function () {
      var _getTrackRemixes = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getTrackRemixesRaw(params, initOverrides);

              case 2:
                response = _context22.sent;
                _context22.next = 5;
                return response.value();

              case 5:
                return _context22.abrupt("return", _context22.sent);

              case 6:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getTrackRemixes(_x31, _x32) {
        return _getTrackRemixes.apply(this, arguments);
      }

      return getTrackRemixes;
    }()
    /** @hidden
     * Get the remixable stems of a track
     */

  }, {
    key: "getTrackStemsRaw",
    value: function () {
      var _getTrackStemsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context23.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackStems.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context23.next = 6;
                return this.request({
                  path: "/tracks/{track_id}/stems".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context23.sent;
                return _context23.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return StemsResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getTrackStemsRaw(_x33, _x34) {
        return _getTrackStemsRaw.apply(this, arguments);
      }

      return getTrackStemsRaw;
    }()
    /**
     * Get the remixable stems of a track
     */

  }, {
    key: "getTrackStems",
    value: function () {
      var _getTrackStems = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.getTrackStemsRaw(params, initOverrides);

              case 2:
                response = _context24.sent;
                _context24.next = 5;
                return response.value();

              case 5:
                return _context24.abrupt("return", _context24.sent);

              case 6:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getTrackStems(_x35, _x36) {
        return _getTrackStems.apply(this, arguments);
      }

      return getTrackStems;
    }()
    /** @hidden
     * Gets the track IDs of the top trending tracks on Audius
     */

  }, {
    key: "getTrendingTrackIDsRaw",
    value: function () {
      var _getTrendingTrackIDsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                queryParameters = {};

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                headerParameters = {};
                _context25.next = 5;
                return this.request({
                  path: "/tracks/trending/ids",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 5:
                response = _context25.sent;
                return _context25.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrendingIdsResponseFromJSON(jsonValue);
                }));

              case 7:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getTrendingTrackIDsRaw(_x37, _x38) {
        return _getTrendingTrackIDsRaw.apply(this, arguments);
      }

      return getTrendingTrackIDsRaw;
    }()
    /**
     * Gets the track IDs of the top trending tracks on Audius
     */

  }, {
    key: "getTrendingTrackIDs",
    value: function () {
      var _getTrendingTrackIDs = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee26() {
        var params,
            initOverrides,
            response,
            _args26 = arguments;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                params = _args26.length > 0 && _args26[0] !== undefined ? _args26[0] : {};
                initOverrides = _args26.length > 1 ? _args26[1] : undefined;
                _context26.next = 4;
                return this.getTrendingTrackIDsRaw(params, initOverrides);

              case 4:
                response = _context26.sent;
                _context26.next = 7;
                return response.value();

              case 7:
                return _context26.abrupt("return", _context26.sent);

              case 8:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function getTrendingTrackIDs() {
        return _getTrendingTrackIDs.apply(this, arguments);
      }

      return getTrendingTrackIDs;
    }()
    /** @hidden
     * Gets the top 100 trending (most popular) tracks on Audius
     */

  }, {
    key: "getTrendingTracksRaw",
    value: function () {
      var _getTrendingTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context27.next = 9;
                return this.request({
                  path: "/tracks/trending",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context27.sent;
                return _context27.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getTrendingTracksRaw(_x39, _x40) {
        return _getTrendingTracksRaw.apply(this, arguments);
      }

      return getTrendingTracksRaw;
    }()
    /**
     * Gets the top 100 trending (most popular) tracks on Audius
     */

  }, {
    key: "getTrendingTracks",
    value: function () {
      var _getTrendingTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee28() {
        var params,
            initOverrides,
            response,
            _args28 = arguments;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                params = _args28.length > 0 && _args28[0] !== undefined ? _args28[0] : {};
                initOverrides = _args28.length > 1 ? _args28[1] : undefined;
                _context28.next = 4;
                return this.getTrendingTracksRaw(params, initOverrides);

              case 4:
                response = _context28.sent;
                _context28.next = 7;
                return response.value();

              case 7:
                return _context28.abrupt("return", _context28.sent);

              case 8:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getTrendingTracks() {
        return _getTrendingTracks.apply(this, arguments);
      }

      return getTrendingTracks;
    }()
    /** @hidden
     * Gets the track IDs of the top trending tracks on Audius based on the given trending strategy version
     */

  }, {
    key: "getTrendingTracksIDsWithVersionRaw",
    value: function () {
      var _getTrendingTracksIDsWithVersionRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context29.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getTrendingTracksIDsWithVersion.');

              case 2:
                queryParameters = {};

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                headerParameters = {};
                _context29.next = 7;
                return this.request({
                  path: "/tracks/trending/ids/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context29.sent;
                return _context29.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrendingIdsResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getTrendingTracksIDsWithVersionRaw(_x41, _x42) {
        return _getTrendingTracksIDsWithVersionRaw.apply(this, arguments);
      }

      return getTrendingTracksIDsWithVersionRaw;
    }()
    /**
     * Gets the track IDs of the top trending tracks on Audius based on the given trending strategy version
     */

  }, {
    key: "getTrendingTracksIDsWithVersion",
    value: function () {
      var _getTrendingTracksIDsWithVersion = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this.getTrendingTracksIDsWithVersionRaw(params, initOverrides);

              case 2:
                response = _context30.sent;
                _context30.next = 5;
                return response.value();

              case 5:
                return _context30.abrupt("return", _context30.sent);

              case 6:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getTrendingTracksIDsWithVersion(_x43, _x44) {
        return _getTrendingTracksIDsWithVersion.apply(this, arguments);
      }

      return getTrendingTracksIDsWithVersion;
    }()
    /** @hidden
     * Gets the top 100 trending (most popular tracks on Audius using a given trending strategy version
     */

  }, {
    key: "getTrendingTracksWithVersionRaw",
    value: function () {
      var _getTrendingTracksWithVersionRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context31.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getTrendingTracksWithVersion.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context31.next = 11;
                return this.request({
                  path: "/tracks/trending/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context31.sent;
                return _context31.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 13:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getTrendingTracksWithVersionRaw(_x45, _x46) {
        return _getTrendingTracksWithVersionRaw.apply(this, arguments);
      }

      return getTrendingTracksWithVersionRaw;
    }()
    /**
     * Gets the top 100 trending (most popular tracks on Audius using a given trending strategy version
     */

  }, {
    key: "getTrendingTracksWithVersion",
    value: function () {
      var _getTrendingTracksWithVersion = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.getTrendingTracksWithVersionRaw(params, initOverrides);

              case 2:
                response = _context32.sent;
                _context32.next = 5;
                return response.value();

              case 5:
                return _context32.abrupt("return", _context32.sent);

              case 6:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getTrendingTracksWithVersion(_x47, _x48) {
        return _getTrendingTracksWithVersion.apply(this, arguments);
      }

      return getTrendingTracksWithVersion;
    }()
    /** @hidden
     * Gets the tracks found on the \"Under the Radar\" smart playlist
     */

  }, {
    key: "getUnderTheRadarTracksRaw",
    value: function () {
      var _getUnderTheRadarTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.filter !== undefined) {
                  queryParameters['filter'] = params.filter;
                }

                if (params.tracksOnly !== undefined) {
                  queryParameters['tracks_only'] = params.tracksOnly;
                }

                if (params.withUsers !== undefined) {
                  queryParameters['with_users'] = params.withUsers;
                }

                headerParameters = {};
                _context33.next = 10;
                return this.request({
                  path: "/tracks/under_the_radar",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 10:
                response = _context33.sent;
                return _context33.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 12:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getUnderTheRadarTracksRaw(_x49, _x50) {
        return _getUnderTheRadarTracksRaw.apply(this, arguments);
      }

      return getUnderTheRadarTracksRaw;
    }()
    /**
     * Gets the tracks found on the \"Under the Radar\" smart playlist
     */

  }, {
    key: "getUnderTheRadarTracks",
    value: function () {
      var _getUnderTheRadarTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee34() {
        var params,
            initOverrides,
            response,
            _args34 = arguments;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                params = _args34.length > 0 && _args34[0] !== undefined ? _args34[0] : {};
                initOverrides = _args34.length > 1 ? _args34[1] : undefined;
                _context34.next = 4;
                return this.getUnderTheRadarTracksRaw(params, initOverrides);

              case 4:
                response = _context34.sent;
                _context34.next = 7;
                return response.value();

              case 7:
                return _context34.abrupt("return", _context34.sent);

              case 8:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function getUnderTheRadarTracks() {
        return _getUnderTheRadarTracks.apply(this, arguments);
      }

      return getUnderTheRadarTracks;
    }()
    /** @hidden
     * Gets the top 100 trending underground tracks on Audius
     */

  }, {
    key: "getUndergroundTrendingTracksRaw",
    value: function () {
      var _getUndergroundTrendingTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context35.next = 7;
                return this.request({
                  path: "/tracks/trending/underground",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context35.sent;
                return _context35.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function getUndergroundTrendingTracksRaw(_x51, _x52) {
        return _getUndergroundTrendingTracksRaw.apply(this, arguments);
      }

      return getUndergroundTrendingTracksRaw;
    }()
    /**
     * Gets the top 100 trending underground tracks on Audius
     */

  }, {
    key: "getUndergroundTrendingTracks",
    value: function () {
      var _getUndergroundTrendingTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee36() {
        var params,
            initOverrides,
            response,
            _args36 = arguments;
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                params = _args36.length > 0 && _args36[0] !== undefined ? _args36[0] : {};
                initOverrides = _args36.length > 1 ? _args36[1] : undefined;
                _context36.next = 4;
                return this.getUndergroundTrendingTracksRaw(params, initOverrides);

              case 4:
                response = _context36.sent;
                _context36.next = 7;
                return response.value();

              case 7:
                return _context36.abrupt("return", _context36.sent);

              case 8:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function getUndergroundTrendingTracks() {
        return _getUndergroundTrendingTracks.apply(this, arguments);
      }

      return getUndergroundTrendingTracks;
    }()
    /** @hidden
     * Gets the top 100 trending underground tracks on Audius using a given trending strategy version
     */

  }, {
    key: "getUndergroundTrendingTracksWithVersionRaw",
    value: function () {
      var _getUndergroundTrendingTracksWithVersionRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context37.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getUndergroundTrendingTracksWithVersion.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context37.next = 9;
                return this.request({
                  path: "/tracks/trending/underground/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context37.sent;
                return _context37.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function getUndergroundTrendingTracksWithVersionRaw(_x53, _x54) {
        return _getUndergroundTrendingTracksWithVersionRaw.apply(this, arguments);
      }

      return getUndergroundTrendingTracksWithVersionRaw;
    }()
    /**
     * Gets the top 100 trending underground tracks on Audius using a given trending strategy version
     */

  }, {
    key: "getUndergroundTrendingTracksWithVersion",
    value: function () {
      var _getUndergroundTrendingTracksWithVersion = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                _context38.next = 2;
                return this.getUndergroundTrendingTracksWithVersionRaw(params, initOverrides);

              case 2:
                response = _context38.sent;
                _context38.next = 5;
                return response.value();

              case 5:
                return _context38.abrupt("return", _context38.sent);

              case 6:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function getUndergroundTrendingTracksWithVersion(_x55, _x56) {
        return _getUndergroundTrendingTracksWithVersion.apply(this, arguments);
      }

      return getUndergroundTrendingTracksWithVersion;
    }()
    /** @hidden
     * Get users that favorited a track
     */

  }, {
    key: "getUsersFromFavoritesRaw",
    value: function () {
      var _getUsersFromFavoritesRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context39.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getUsersFromFavorites.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context39.next = 9;
                return this.request({
                  path: "/tracks/{track_id}/favorites".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context39.sent;
                return _context39.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrackFavoritesResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));

      function getUsersFromFavoritesRaw(_x57, _x58) {
        return _getUsersFromFavoritesRaw.apply(this, arguments);
      }

      return getUsersFromFavoritesRaw;
    }()
    /**
     * Get users that favorited a track
     */

  }, {
    key: "getUsersFromFavorites",
    value: function () {
      var _getUsersFromFavorites = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee40(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                _context40.next = 2;
                return this.getUsersFromFavoritesRaw(params, initOverrides);

              case 2:
                response = _context40.sent;
                _context40.next = 5;
                return response.value();

              case 5:
                return _context40.abrupt("return", _context40.sent);

              case 6:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));

      function getUsersFromFavorites(_x59, _x60) {
        return _getUsersFromFavorites.apply(this, arguments);
      }

      return getUsersFromFavorites;
    }()
    /** @hidden
     * Get the users that reposted a track
     */

  }, {
    key: "getUsersFromRepostsRaw",
    value: function () {
      var _getUsersFromRepostsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee41(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context41.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getUsersFromReposts.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context41.next = 9;
                return this.request({
                  path: "/tracks/{track_id}/reposts".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context41.sent;
                return _context41.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrackRepostsResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this);
      }));

      function getUsersFromRepostsRaw(_x61, _x62) {
        return _getUsersFromRepostsRaw.apply(this, arguments);
      }

      return getUsersFromRepostsRaw;
    }()
    /**
     * Get the users that reposted a track
     */

  }, {
    key: "getUsersFromReposts",
    value: function () {
      var _getUsersFromReposts = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee42(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                _context42.next = 2;
                return this.getUsersFromRepostsRaw(params, initOverrides);

              case 2:
                response = _context42.sent;
                _context42.next = 5;
                return response.value();

              case 5:
                return _context42.abrupt("return", _context42.sent);

              case 6:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this);
      }));

      function getUsersFromReposts(_x63, _x64) {
        return _getUsersFromReposts.apply(this, arguments);
      }

      return getUsersFromReposts;
    }()
  }]);

  return TracksApi;
}(BaseAPI);
/**
 * @export
 */

var GetRecommendedTracksTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetRecommendedTracksWithVersionTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetTrendingTracksTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetTrendingTracksWithVersionTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetUnderTheRadarTracksFilterEnum = {
  All: 'all',
  Repost: 'repost',
  Original: 'original'
};

/**
 *
 */

var TransactionsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TransactionsApi, _runtime$BaseAPI);

  var _super = _createSuper(TransactionsApi);

  function TransactionsApi() {
    _classCallCheck$1(this, TransactionsApi);

    return _super.apply(this, arguments);
  }

  _createClass$1(TransactionsApi, [{
    key: "getAudioTransactionHistoryRaw",
    value:
    /** @hidden
     * Gets the user\'s $AUDIO transaction history within the App
     */
    function () {
      var _getAudioTransactionHistoryRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getAudioTransactionHistory.');

              case 2:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getAudioTransactionHistory.');

              case 4:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context.next = 14;
                return this.request({
                  path: "/transactions",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TransactionHistoryResponseFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAudioTransactionHistoryRaw(_x, _x2) {
        return _getAudioTransactionHistoryRaw.apply(this, arguments);
      }

      return getAudioTransactionHistoryRaw;
    }()
    /**
     * Gets the user\'s $AUDIO transaction history within the App
     */

  }, {
    key: "getAudioTransactionHistory",
    value: function () {
      var _getAudioTransactionHistory = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getAudioTransactionHistoryRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getAudioTransactionHistory(_x3, _x4) {
        return _getAudioTransactionHistory.apply(this, arguments);
      }

      return getAudioTransactionHistory;
    }()
    /** @hidden
     * Gets the count of the user\'s $AUDIO transaction history within the App
     */

  }, {
    key: "getAudioTransactionHistoryCountRaw",
    value: function () {
      var _getAudioTransactionHistoryCountRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getAudioTransactionHistoryCount.');

              case 2:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context3.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getAudioTransactionHistoryCount.');

              case 4:
                queryParameters = {};
                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context3.next = 10;
                return this.request({
                  path: "/transactions/count",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 10:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TransactionHistoryCountResponseFromJSON(jsonValue);
                }));

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getAudioTransactionHistoryCountRaw(_x5, _x6) {
        return _getAudioTransactionHistoryCountRaw.apply(this, arguments);
      }

      return getAudioTransactionHistoryCountRaw;
    }()
    /**
     * Gets the count of the user\'s $AUDIO transaction history within the App
     */

  }, {
    key: "getAudioTransactionHistoryCount",
    value: function () {
      var _getAudioTransactionHistoryCount = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getAudioTransactionHistoryCountRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAudioTransactionHistoryCount(_x7, _x8) {
        return _getAudioTransactionHistoryCount.apply(this, arguments);
      }

      return getAudioTransactionHistoryCount;
    }()
  }]);

  return TransactionsApi;
}(BaseAPI);
/**
 * @export
 */

var GetAudioTransactionHistorySortMethodEnum = {
  Date: 'date',
  TransactionType: 'transaction_type'
};
/**
 * @export
 */

var GetAudioTransactionHistorySortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};

/**
 *
 */

var UsersApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(UsersApi, _runtime$BaseAPI);

  var _super = _createSuper(UsersApi);

  function UsersApi() {
    _classCallCheck$1(this, UsersApi);

    return _super.apply(this, arguments);
  }

  _createClass$1(UsersApi, [{
    key: "bulkGetSubscribersRaw",
    value:
    /** @hidden
     * All users that subscribe to the provided users
     */
    function () {
      var _bulkGetSubscribersRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.ids === null || params.ids === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('ids', 'Required parameter params.ids was null or undefined when calling bulkGetSubscribers.');

              case 2:
                queryParameters = {};

                if (params.ids) {
                  queryParameters['ids'] = params.ids.join(COLLECTION_FORMATS["csv"]);
                }

                headerParameters = {};
                _context.next = 7;
                return this.request({
                  path: "/users/subscribers",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullBulkSubscribersResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function bulkGetSubscribersRaw(_x, _x2) {
        return _bulkGetSubscribersRaw.apply(this, arguments);
      }

      return bulkGetSubscribersRaw;
    }()
    /**
     * All users that subscribe to the provided users
     */

  }, {
    key: "bulkGetSubscribers",
    value: function () {
      var _bulkGetSubscribers = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.bulkGetSubscribersRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function bulkGetSubscribers(_x3, _x4) {
        return _bulkGetSubscribers.apply(this, arguments);
      }

      return bulkGetSubscribers;
    }()
    /** @hidden
     * Get all users that subscribe to the users listed in the JSON request
     */

  }, {
    key: "bulkGetSubscribersViaJSONRequestRaw",
    value: function () {
      var _bulkGetSubscribersViaJSONRequestRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.ids === null || params.ids === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError('ids', 'Required parameter params.ids was null or undefined when calling bulkGetSubscribersViaJSONRequest.');

              case 2:
                queryParameters = {};

                if (params.ids) {
                  queryParameters['ids'] = params.ids.join(COLLECTION_FORMATS["csv"]);
                }

                headerParameters = {};
                _context3.next = 7;
                return this.request({
                  path: "/users/subscribers",
                  method: 'POST',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullBulkSubscribersResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function bulkGetSubscribersViaJSONRequestRaw(_x5, _x6) {
        return _bulkGetSubscribersViaJSONRequestRaw.apply(this, arguments);
      }

      return bulkGetSubscribersViaJSONRequestRaw;
    }()
    /**
     * Get all users that subscribe to the users listed in the JSON request
     */

  }, {
    key: "bulkGetSubscribersViaJSONRequest",
    value: function () {
      var _bulkGetSubscribersViaJSONRequest = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.bulkGetSubscribersViaJSONRequestRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function bulkGetSubscribersViaJSONRequest(_x7, _x8) {
        return _bulkGetSubscribersViaJSONRequest.apply(this, arguments);
      }

      return bulkGetSubscribersViaJSONRequest;
    }()
    /** @hidden
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */

  }, {
    key: "getAIAttributedTracksByUserHandleRaw",
    value: function () {
      var _getAIAttributedTracksByUserHandleRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context5.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getAIAttributedTracksByUserHandle.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context5.next = 14;
                return this.request({
                  path: "/users/handle/{handle}/tracks/ai_attributed".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getAIAttributedTracksByUserHandleRaw(_x9, _x10) {
        return _getAIAttributedTracksByUserHandleRaw.apply(this, arguments);
      }

      return getAIAttributedTracksByUserHandleRaw;
    }()
    /**
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */

  }, {
    key: "getAIAttributedTracksByUserHandle",
    value: function () {
      var _getAIAttributedTracksByUserHandle = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getAIAttributedTracksByUserHandleRaw(params, initOverrides);

              case 2:
                response = _context6.sent;
                _context6.next = 5;
                return response.value();

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getAIAttributedTracksByUserHandle(_x11, _x12) {
        return _getAIAttributedTracksByUserHandle.apply(this, arguments);
      }

      return getAIAttributedTracksByUserHandle;
    }()
    /** @hidden
     * Gets a user\'s favorite tracks
     */

  }, {
    key: "getFavoritesRaw",
    value: function () {
      var _getFavoritesRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context7.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getFavorites.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};
                _context7.next = 12;
                return this.request({
                  path: "/users/{id}/favorites/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 12:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrackLibraryResponseFullFromJSON(jsonValue);
                }));

              case 14:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getFavoritesRaw(_x13, _x14) {
        return _getFavoritesRaw.apply(this, arguments);
      }

      return getFavoritesRaw;
    }()
    /**
     * Gets a user\'s favorite tracks
     */

  }, {
    key: "getFavorites",
    value: function () {
      var _getFavorites = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getFavoritesRaw(params, initOverrides);

              case 2:
                response = _context8.sent;
                _context8.next = 5;
                return response.value();

              case 5:
                return _context8.abrupt("return", _context8.sent);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getFavorites(_x15, _x16) {
        return _getFavorites.apply(this, arguments);
      }

      return getFavorites;
    }()
    /** @hidden
     * All users that follow the provided user
     */

  }, {
    key: "getFollowersRaw",
    value: function () {
      var _getFollowersRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getFollowers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context9.next = 9;
                return this.request({
                  path: "/users/{id}/followers".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context9.sent;
                return _context9.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullFollowersResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getFollowersRaw(_x17, _x18) {
        return _getFollowersRaw.apply(this, arguments);
      }

      return getFollowersRaw;
    }()
    /**
     * All users that follow the provided user
     */

  }, {
    key: "getFollowers",
    value: function () {
      var _getFollowers = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getFollowersRaw(params, initOverrides);

              case 2:
                response = _context10.sent;
                _context10.next = 5;
                return response.value();

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getFollowers(_x19, _x20) {
        return _getFollowers.apply(this, arguments);
      }

      return getFollowers;
    }()
    /** @hidden
     * All users that the provided user follows
     */

  }, {
    key: "getFollowingRaw",
    value: function () {
      var _getFollowingRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context11.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getFollowing.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context11.next = 9;
                return this.request({
                  path: "/users/{id}/following".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context11.sent;
                return _context11.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FollowingResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getFollowingRaw(_x21, _x22) {
        return _getFollowingRaw.apply(this, arguments);
      }

      return getFollowingRaw;
    }()
    /**
     * All users that the provided user follows
     */

  }, {
    key: "getFollowing",
    value: function () {
      var _getFollowing = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getFollowingRaw(params, initOverrides);

              case 2:
                response = _context12.sent;
                _context12.next = 5;
                return response.value();

              case 5:
                return _context12.abrupt("return", _context12.sent);

              case 6:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getFollowing(_x23, _x24) {
        return _getFollowing.apply(this, arguments);
      }

      return getFollowing;
    }()
    /** @hidden
     * Gets the purchases the user has made
     */

  }, {
    key: "getPurchasesRaw",
    value: function () {
      var _getPurchasesRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context13.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getPurchases.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};
                _context13.next = 11;
                return this.request({
                  path: "/users/{id}/purchases".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context13.sent;
                return _context13.abrupt("return", new VoidApiResponse(response));

              case 13:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getPurchasesRaw(_x25, _x26) {
        return _getPurchasesRaw.apply(this, arguments);
      }

      return getPurchasesRaw;
    }()
    /**
     * Gets the purchases the user has made
     */

  }, {
    key: "getPurchases",
    value: function () {
      var _getPurchases = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getPurchasesRaw(params, initOverrides);

              case 2:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getPurchases(_x27, _x28) {
        return _getPurchases.apply(this, arguments);
      }

      return getPurchases;
    }()
    /** @hidden
     * Gets a list of users that might be of interest to followers of this user.
     */

  }, {
    key: "getRelatedUsersRaw",
    value: function () {
      var _getRelatedUsersRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context15.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getRelatedUsers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context15.next = 9;
                return this.request({
                  path: "/users/{id}/related".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context15.sent;
                return _context15.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return RelatedArtistResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getRelatedUsersRaw(_x29, _x30) {
        return _getRelatedUsersRaw.apply(this, arguments);
      }

      return getRelatedUsersRaw;
    }()
    /**
     * Gets a list of users that might be of interest to followers of this user.
     */

  }, {
    key: "getRelatedUsers",
    value: function () {
      var _getRelatedUsers = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.getRelatedUsersRaw(params, initOverrides);

              case 2:
                response = _context16.sent;
                _context16.next = 5;
                return response.value();

              case 5:
                return _context16.abrupt("return", _context16.sent);

              case 6:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getRelatedUsers(_x31, _x32) {
        return _getRelatedUsers.apply(this, arguments);
      }

      return getRelatedUsers;
    }()
    /** @hidden
     * Gets the given user\'s reposts
     */

  }, {
    key: "getRepostsRaw",
    value: function () {
      var _getRepostsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context17.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getReposts.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context17.next = 9;
                return this.request({
                  path: "/users/{id}/reposts".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context17.sent;
                return _context17.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullRepostsFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getRepostsRaw(_x33, _x34) {
        return _getRepostsRaw.apply(this, arguments);
      }

      return getRepostsRaw;
    }()
    /**
     * Gets the given user\'s reposts
     */

  }, {
    key: "getReposts",
    value: function () {
      var _getReposts = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.getRepostsRaw(params, initOverrides);

              case 2:
                response = _context18.sent;
                _context18.next = 5;
                return response.value();

              case 5:
                return _context18.abrupt("return", _context18.sent);

              case 6:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getReposts(_x35, _x36) {
        return _getReposts.apply(this, arguments);
      }

      return getReposts;
    }()
    /** @hidden
     * Gets the user\'s reposts by the user handle
     */

  }, {
    key: "getRepostsByHandleRaw",
    value: function () {
      var _getRepostsByHandleRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context19.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getRepostsByHandle.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context19.next = 9;
                return this.request({
                  path: "/users/handle/{handle}/reposts".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context19.sent;
                return _context19.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullRepostsFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getRepostsByHandleRaw(_x37, _x38) {
        return _getRepostsByHandleRaw.apply(this, arguments);
      }

      return getRepostsByHandleRaw;
    }()
    /**
     * Gets the user\'s reposts by the user handle
     */

  }, {
    key: "getRepostsByHandle",
    value: function () {
      var _getRepostsByHandle = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getRepostsByHandleRaw(params, initOverrides);

              case 2:
                response = _context20.sent;
                _context20.next = 5;
                return response.value();

              case 5:
                return _context20.abrupt("return", _context20.sent);

              case 6:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getRepostsByHandle(_x39, _x40) {
        return _getRepostsByHandle.apply(this, arguments);
      }

      return getRepostsByHandle;
    }()
    /** @hidden
     * Gets the sales the user has made
     */

  }, {
    key: "getSalesRaw",
    value: function () {
      var _getSalesRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context21.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSales.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};
                _context21.next = 11;
                return this.request({
                  path: "/users/{id}/sales".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context21.sent;
                return _context21.abrupt("return", new VoidApiResponse(response));

              case 13:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getSalesRaw(_x41, _x42) {
        return _getSalesRaw.apply(this, arguments);
      }

      return getSalesRaw;
    }()
    /**
     * Gets the sales the user has made
     */

  }, {
    key: "getSales",
    value: function () {
      var _getSales = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getSalesRaw(params, initOverrides);

              case 2:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getSales(_x43, _x44) {
        return _getSales.apply(this, arguments);
      }

      return getSales;
    }()
    /** @hidden
     * All users that subscribe to the provided user
     */

  }, {
    key: "getSubscribersRaw",
    value: function () {
      var _getSubscribersRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context23.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSubscribers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context23.next = 9;
                return this.request({
                  path: "/users/{id}/subscribers".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context23.sent;
                return _context23.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullSubscribersResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getSubscribersRaw(_x45, _x46) {
        return _getSubscribersRaw.apply(this, arguments);
      }

      return getSubscribersRaw;
    }()
    /**
     * All users that subscribe to the provided user
     */

  }, {
    key: "getSubscribers",
    value: function () {
      var _getSubscribers = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.getSubscribersRaw(params, initOverrides);

              case 2:
                response = _context24.sent;
                _context24.next = 5;
                return response.value();

              case 5:
                return _context24.abrupt("return", _context24.sent);

              case 6:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getSubscribers(_x47, _x48) {
        return _getSubscribers.apply(this, arguments);
      }

      return getSubscribers;
    }()
    /** @hidden
     * Gets the specified supporter of the given user
     */

  }, {
    key: "getSupporterRaw",
    value: function () {
      var _getSupporterRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context25.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupporter.');

              case 2:
                if (!(params.supporterUserId === null || params.supporterUserId === undefined)) {
                  _context25.next = 4;
                  break;
                }

                throw new RequiredError('supporterUserId', 'Required parameter params.supporterUserId was null or undefined when calling getSupporter.');

              case 4:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context25.next = 9;
                return this.request({
                  path: "/users/{id}/supporters/{supporter_user_id}".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))).replace("{".concat("supporter_user_id", "}"), encodeURIComponent(String(params.supporterUserId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context25.sent;
                return _context25.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullGetSupporterFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getSupporterRaw(_x49, _x50) {
        return _getSupporterRaw.apply(this, arguments);
      }

      return getSupporterRaw;
    }()
    /**
     * Gets the specified supporter of the given user
     */

  }, {
    key: "getSupporter",
    value: function () {
      var _getSupporter = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.getSupporterRaw(params, initOverrides);

              case 2:
                response = _context26.sent;
                _context26.next = 5;
                return response.value();

              case 5:
                return _context26.abrupt("return", _context26.sent);

              case 6:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function getSupporter(_x51, _x52) {
        return _getSupporter.apply(this, arguments);
      }

      return getSupporter;
    }()
    /** @hidden
     * Gets the supporters of the given user
     */

  }, {
    key: "getSupportersRaw",
    value: function () {
      var _getSupportersRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context27.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupporters.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context27.next = 9;
                return this.request({
                  path: "/users/{id}/supporters".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context27.sent;
                return _context27.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullGetSupportersFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getSupportersRaw(_x53, _x54) {
        return _getSupportersRaw.apply(this, arguments);
      }

      return getSupportersRaw;
    }()
    /**
     * Gets the supporters of the given user
     */

  }, {
    key: "getSupporters",
    value: function () {
      var _getSupporters = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.getSupportersRaw(params, initOverrides);

              case 2:
                response = _context28.sent;
                _context28.next = 5;
                return response.value();

              case 5:
                return _context28.abrupt("return", _context28.sent);

              case 6:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getSupporters(_x55, _x56) {
        return _getSupporters.apply(this, arguments);
      }

      return getSupporters;
    }()
    /** @hidden
     * Gets the support from the given user to the supported user
     */

  }, {
    key: "getSupportingRaw",
    value: function () {
      var _getSupportingRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context29.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupporting.');

              case 2:
                if (!(params.supportedUserId === null || params.supportedUserId === undefined)) {
                  _context29.next = 4;
                  break;
                }

                throw new RequiredError('supportedUserId', 'Required parameter params.supportedUserId was null or undefined when calling getSupporting.');

              case 4:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context29.next = 9;
                return this.request({
                  path: "/users/{id}/supporting/{supported_user_id}".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))).replace("{".concat("supported_user_id", "}"), encodeURIComponent(String(params.supportedUserId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context29.sent;
                return _context29.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullGetSupportingFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getSupportingRaw(_x57, _x58) {
        return _getSupportingRaw.apply(this, arguments);
      }

      return getSupportingRaw;
    }()
    /**
     * Gets the support from the given user to the supported user
     */

  }, {
    key: "getSupporting",
    value: function () {
      var _getSupporting = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this.getSupportingRaw(params, initOverrides);

              case 2:
                response = _context30.sent;
                _context30.next = 5;
                return response.value();

              case 5:
                return _context30.abrupt("return", _context30.sent);

              case 6:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getSupporting(_x59, _x60) {
        return _getSupporting.apply(this, arguments);
      }

      return getSupporting;
    }()
    /** @hidden
     * Gets the users that the given user supports
     */

  }, {
    key: "getSupportingsRaw",
    value: function () {
      var _getSupportingsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context31.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupportings.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context31.next = 9;
                return this.request({
                  path: "/users/{id}/supporting".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context31.sent;
                return _context31.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullGetSupportingFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getSupportingsRaw(_x61, _x62) {
        return _getSupportingsRaw.apply(this, arguments);
      }

      return getSupportingsRaw;
    }()
    /**
     * Gets the users that the given user supports
     */

  }, {
    key: "getSupportings",
    value: function () {
      var _getSupportings = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.getSupportingsRaw(params, initOverrides);

              case 2:
                response = _context32.sent;
                _context32.next = 5;
                return response.value();

              case 5:
                return _context32.abrupt("return", _context32.sent);

              case 6:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getSupportings(_x63, _x64) {
        return _getSupportings.apply(this, arguments);
      }

      return getSupportings;
    }()
    /** @hidden
     * Get the Top Users having at least one track by follower count
     */

  }, {
    key: "getTopUsersRaw",
    value: function () {
      var _getTopUsersRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context33.next = 7;
                return this.request({
                  path: "/users/top",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context33.sent;
                return _context33.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TopUsersResponseFullFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getTopUsersRaw(_x65, _x66) {
        return _getTopUsersRaw.apply(this, arguments);
      }

      return getTopUsersRaw;
    }()
    /**
     * Get the Top Users having at least one track by follower count
     */

  }, {
    key: "getTopUsers",
    value: function () {
      var _getTopUsers = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee34() {
        var params,
            initOverrides,
            response,
            _args34 = arguments;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                params = _args34.length > 0 && _args34[0] !== undefined ? _args34[0] : {};
                initOverrides = _args34.length > 1 ? _args34[1] : undefined;
                _context34.next = 4;
                return this.getTopUsersRaw(params, initOverrides);

              case 4:
                response = _context34.sent;
                _context34.next = 7;
                return response.value();

              case 7:
                return _context34.abrupt("return", _context34.sent);

              case 8:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function getTopUsers() {
        return _getTopUsers.apply(this, arguments);
      }

      return getTopUsers;
    }()
    /** @hidden
     * Get the Top Users for a Given Genre
     */

  }, {
    key: "getTopUsersInGenreRaw",
    value: function () {
      var _getTopUsersInGenreRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.genre) {
                  queryParameters['genre'] = params.genre;
                }

                headerParameters = {};
                _context35.next = 7;
                return this.request({
                  path: "/users/genre/top",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context35.sent;
                return _context35.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TopGenreUsersResponseFullFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function getTopUsersInGenreRaw(_x67, _x68) {
        return _getTopUsersInGenreRaw.apply(this, arguments);
      }

      return getTopUsersInGenreRaw;
    }()
    /**
     * Get the Top Users for a Given Genre
     */

  }, {
    key: "getTopUsersInGenre",
    value: function () {
      var _getTopUsersInGenre = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee36() {
        var params,
            initOverrides,
            response,
            _args36 = arguments;
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                params = _args36.length > 0 && _args36[0] !== undefined ? _args36[0] : {};
                initOverrides = _args36.length > 1 ? _args36[1] : undefined;
                _context36.next = 4;
                return this.getTopUsersInGenreRaw(params, initOverrides);

              case 4:
                response = _context36.sent;
                _context36.next = 7;
                return response.value();

              case 7:
                return _context36.abrupt("return", _context36.sent);

              case 8:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function getTopUsersInGenre() {
        return _getTopUsersInGenre.apply(this, arguments);
      }

      return getTopUsersInGenre;
    }()
    /** @hidden
     * Gets the tracks created by a user using their user ID
     */

  }, {
    key: "getTracksByUserRaw",
    value: function () {
      var _getTracksByUserRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context37.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getTracksByUser.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context37.next = 14;
                return this.request({
                  path: "/users/{id}/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context37.sent;
                return _context37.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function getTracksByUserRaw(_x69, _x70) {
        return _getTracksByUserRaw.apply(this, arguments);
      }

      return getTracksByUserRaw;
    }()
    /**
     * Gets the tracks created by a user using their user ID
     */

  }, {
    key: "getTracksByUser",
    value: function () {
      var _getTracksByUser = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                _context38.next = 2;
                return this.getTracksByUserRaw(params, initOverrides);

              case 2:
                response = _context38.sent;
                _context38.next = 5;
                return response.value();

              case 5:
                return _context38.abrupt("return", _context38.sent);

              case 6:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function getTracksByUser(_x71, _x72) {
        return _getTracksByUser.apply(this, arguments);
      }

      return getTracksByUser;
    }()
    /** @hidden
     * Gets the tracks created by a user using the user\'s handle
     */

  }, {
    key: "getTracksByUserHandleRaw",
    value: function () {
      var _getTracksByUserHandleRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context39.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getTracksByUserHandle.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context39.next = 14;
                return this.request({
                  path: "/users/handle/{handle}/tracks".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context39.sent;
                return _context39.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));

      function getTracksByUserHandleRaw(_x73, _x74) {
        return _getTracksByUserHandleRaw.apply(this, arguments);
      }

      return getTracksByUserHandleRaw;
    }()
    /**
     * Gets the tracks created by a user using the user\'s handle
     */

  }, {
    key: "getTracksByUserHandle",
    value: function () {
      var _getTracksByUserHandle = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee40(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                _context40.next = 2;
                return this.getTracksByUserHandleRaw(params, initOverrides);

              case 2:
                response = _context40.sent;
                _context40.next = 5;
                return response.value();

              case 5:
                return _context40.abrupt("return", _context40.sent);

              case 6:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));

      function getTracksByUserHandle(_x75, _x76) {
        return _getTracksByUserHandle.apply(this, arguments);
      }

      return getTracksByUserHandle;
    }()
    /** @hidden
     * Gets a single user by their user ID
     */

  }, {
    key: "getUserRaw",
    value: function () {
      var _getUserRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee41(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context41.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUser.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context41.next = 7;
                return this.request({
                  path: "/users/{id}".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context41.sent;
                return _context41.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullUserResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this);
      }));

      function getUserRaw(_x77, _x78) {
        return _getUserRaw.apply(this, arguments);
      }

      return getUserRaw;
    }()
    /**
     * Gets a single user by their user ID
     */

  }, {
    key: "getUser",
    value: function () {
      var _getUser = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee42(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                _context42.next = 2;
                return this.getUserRaw(params, initOverrides);

              case 2:
                response = _context42.sent;
                _context42.next = 5;
                return response.value();

              case 5:
                return _context42.abrupt("return", _context42.sent);

              case 6:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this);
      }));

      function getUser(_x79, _x80) {
        return _getUser.apply(this, arguments);
      }

      return getUser;
    }()
    /** @hidden
     * Gets a single user by their handle
     */

  }, {
    key: "getUserByHandleRaw",
    value: function () {
      var _getUserByHandleRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee43(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee43$(_context43) {
          while (1) {
            switch (_context43.prev = _context43.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context43.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getUserByHandle.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context43.next = 7;
                return this.request({
                  path: "/users/handle/{handle}".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context43.sent;
                return _context43.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullUserResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context43.stop();
            }
          }
        }, _callee43, this);
      }));

      function getUserByHandleRaw(_x81, _x82) {
        return _getUserByHandleRaw.apply(this, arguments);
      }

      return getUserByHandleRaw;
    }()
    /**
     * Gets a single user by their handle
     */

  }, {
    key: "getUserByHandle",
    value: function () {
      var _getUserByHandle = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee44(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee44$(_context44) {
          while (1) {
            switch (_context44.prev = _context44.next) {
              case 0:
                _context44.next = 2;
                return this.getUserByHandleRaw(params, initOverrides);

              case 2:
                response = _context44.sent;
                _context44.next = 5;
                return response.value();

              case 5:
                return _context44.abrupt("return", _context44.sent);

              case 6:
              case "end":
                return _context44.stop();
            }
          }
        }, _callee44, this);
      }));

      function getUserByHandle(_x83, _x84) {
        return _getUserByHandle.apply(this, arguments);
      }

      return getUserByHandle;
    }()
    /** @hidden
     * Gets a user\'s saved/reposted/purchased/all albums
     * Fetch a user\'s full library playlists
     */

  }, {
    key: "getUserLibraryAlbumsRaw",
    value: function () {
      var _getUserLibraryAlbumsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee45(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee45$(_context45) {
          while (1) {
            switch (_context45.prev = _context45.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context45.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserLibraryAlbums.');

              case 2:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context45.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getUserLibraryAlbums.');

              case 4:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context45.next = 6;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getUserLibraryAlbums.');

              case 6:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.type !== undefined) {
                  queryParameters['type'] = params.type;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context45.next = 19;
                return this.request({
                  path: "/users/{id}/library/albums".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 19:
                response = _context45.sent;
                return _context45.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return CollectionLibraryResponseFullFromJSON(jsonValue);
                }));

              case 21:
              case "end":
                return _context45.stop();
            }
          }
        }, _callee45, this);
      }));

      function getUserLibraryAlbumsRaw(_x85, _x86) {
        return _getUserLibraryAlbumsRaw.apply(this, arguments);
      }

      return getUserLibraryAlbumsRaw;
    }()
    /**
     * Gets a user\'s saved/reposted/purchased/all albums
     * Fetch a user\'s full library playlists
     */

  }, {
    key: "getUserLibraryAlbums",
    value: function () {
      var _getUserLibraryAlbums = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee46(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee46$(_context46) {
          while (1) {
            switch (_context46.prev = _context46.next) {
              case 0:
                _context46.next = 2;
                return this.getUserLibraryAlbumsRaw(params, initOverrides);

              case 2:
                response = _context46.sent;
                _context46.next = 5;
                return response.value();

              case 5:
                return _context46.abrupt("return", _context46.sent);

              case 6:
              case "end":
                return _context46.stop();
            }
          }
        }, _callee46, this);
      }));

      function getUserLibraryAlbums(_x87, _x88) {
        return _getUserLibraryAlbums.apply(this, arguments);
      }

      return getUserLibraryAlbums;
    }()
    /** @hidden
     * Gets a user\'s saved/reposted/purchased/all playlists
     * Fetch a user\'s full library playlists
     */

  }, {
    key: "getUserLibraryPlaylistsRaw",
    value: function () {
      var _getUserLibraryPlaylistsRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee47(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee47$(_context47) {
          while (1) {
            switch (_context47.prev = _context47.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context47.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserLibraryPlaylists.');

              case 2:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context47.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getUserLibraryPlaylists.');

              case 4:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context47.next = 6;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getUserLibraryPlaylists.');

              case 6:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.type !== undefined) {
                  queryParameters['type'] = params.type;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context47.next = 19;
                return this.request({
                  path: "/users/{id}/library/playlists".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 19:
                response = _context47.sent;
                return _context47.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return CollectionLibraryResponseFullFromJSON(jsonValue);
                }));

              case 21:
              case "end":
                return _context47.stop();
            }
          }
        }, _callee47, this);
      }));

      function getUserLibraryPlaylistsRaw(_x89, _x90) {
        return _getUserLibraryPlaylistsRaw.apply(this, arguments);
      }

      return getUserLibraryPlaylistsRaw;
    }()
    /**
     * Gets a user\'s saved/reposted/purchased/all playlists
     * Fetch a user\'s full library playlists
     */

  }, {
    key: "getUserLibraryPlaylists",
    value: function () {
      var _getUserLibraryPlaylists = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee48(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee48$(_context48) {
          while (1) {
            switch (_context48.prev = _context48.next) {
              case 0:
                _context48.next = 2;
                return this.getUserLibraryPlaylistsRaw(params, initOverrides);

              case 2:
                response = _context48.sent;
                _context48.next = 5;
                return response.value();

              case 5:
                return _context48.abrupt("return", _context48.sent);

              case 6:
              case "end":
                return _context48.stop();
            }
          }
        }, _callee48, this);
      }));

      function getUserLibraryPlaylists(_x91, _x92) {
        return _getUserLibraryPlaylists.apply(this, arguments);
      }

      return getUserLibraryPlaylists;
    }()
    /** @hidden
     * Gets a user\'s saved/reposted/purchased/all tracks
     * Fetch a user\'s full library tracks
     */

  }, {
    key: "getUserLibraryTracksRaw",
    value: function () {
      var _getUserLibraryTracksRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee49(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee49$(_context49) {
          while (1) {
            switch (_context49.prev = _context49.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context49.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserLibraryTracks.');

              case 2:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context49.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getUserLibraryTracks.');

              case 4:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context49.next = 6;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getUserLibraryTracks.');

              case 6:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.type !== undefined) {
                  queryParameters['type'] = params.type;
                }

                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context49.next = 19;
                return this.request({
                  path: "/users/{id}/library/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 19:
                response = _context49.sent;
                return _context49.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrackLibraryResponseFullFromJSON(jsonValue);
                }));

              case 21:
              case "end":
                return _context49.stop();
            }
          }
        }, _callee49, this);
      }));

      function getUserLibraryTracksRaw(_x93, _x94) {
        return _getUserLibraryTracksRaw.apply(this, arguments);
      }

      return getUserLibraryTracksRaw;
    }()
    /**
     * Gets a user\'s saved/reposted/purchased/all tracks
     * Fetch a user\'s full library tracks
     */

  }, {
    key: "getUserLibraryTracks",
    value: function () {
      var _getUserLibraryTracks = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee50(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee50$(_context50) {
          while (1) {
            switch (_context50.prev = _context50.next) {
              case 0:
                _context50.next = 2;
                return this.getUserLibraryTracksRaw(params, initOverrides);

              case 2:
                response = _context50.sent;
                _context50.next = 5;
                return response.value();

              case 5:
                return _context50.abrupt("return", _context50.sent);

              case 6:
              case "end":
                return _context50.stop();
            }
          }
        }, _callee50, this);
      }));

      function getUserLibraryTracks(_x95, _x96) {
        return _getUserLibraryTracks.apply(this, arguments);
      }

      return getUserLibraryTracks;
    }()
    /** @hidden
     * Gets the user\'s replica set
     */

  }, {
    key: "getUserReplicaSetRaw",
    value: function () {
      var _getUserReplicaSetRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee51(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee51$(_context51) {
          while (1) {
            switch (_context51.prev = _context51.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context51.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserReplicaSet.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context51.next = 7;
                return this.request({
                  path: "/users/{id}/replica_set".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context51.sent;
                return _context51.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return UsersByContentNodeFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context51.stop();
            }
          }
        }, _callee51, this);
      }));

      function getUserReplicaSetRaw(_x97, _x98) {
        return _getUserReplicaSetRaw.apply(this, arguments);
      }

      return getUserReplicaSetRaw;
    }()
    /**
     * Gets the user\'s replica set
     */

  }, {
    key: "getUserReplicaSet",
    value: function () {
      var _getUserReplicaSet = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee52(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee52$(_context52) {
          while (1) {
            switch (_context52.prev = _context52.next) {
              case 0:
                _context52.next = 2;
                return this.getUserReplicaSetRaw(params, initOverrides);

              case 2:
                response = _context52.sent;
                _context52.next = 5;
                return response.value();

              case 5:
                return _context52.abrupt("return", _context52.sent);

              case 6:
              case "end":
                return _context52.stop();
            }
          }
        }, _callee52, this);
      }));

      function getUserReplicaSet(_x99, _x100) {
        return _getUserReplicaSet.apply(this, arguments);
      }

      return getUserReplicaSet;
    }()
    /** @hidden
     * Get the tracks the user recently listened to.
     */

  }, {
    key: "getUsersTrackHistoryRaw",
    value: function () {
      var _getUsersTrackHistoryRaw = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee53(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee53$(_context53) {
          while (1) {
            switch (_context53.prev = _context53.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context53.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUsersTrackHistory.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};
                _context53.next = 12;
                return this.request({
                  path: "/users/{id}/history/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 12:
                response = _context53.sent;
                return _context53.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return HistoryResponseFullFromJSON(jsonValue);
                }));

              case 14:
              case "end":
                return _context53.stop();
            }
          }
        }, _callee53, this);
      }));

      function getUsersTrackHistoryRaw(_x101, _x102) {
        return _getUsersTrackHistoryRaw.apply(this, arguments);
      }

      return getUsersTrackHistoryRaw;
    }()
    /**
     * Get the tracks the user recently listened to.
     */

  }, {
    key: "getUsersTrackHistory",
    value: function () {
      var _getUsersTrackHistory = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee54(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee54$(_context54) {
          while (1) {
            switch (_context54.prev = _context54.next) {
              case 0:
                _context54.next = 2;
                return this.getUsersTrackHistoryRaw(params, initOverrides);

              case 2:
                response = _context54.sent;
                _context54.next = 5;
                return response.value();

              case 5:
                return _context54.abrupt("return", _context54.sent);

              case 6:
              case "end":
                return _context54.stop();
            }
          }
        }, _callee54, this);
      }));

      function getUsersTrackHistory(_x103, _x104) {
        return _getUsersTrackHistory.apply(this, arguments);
      }

      return getUsersTrackHistory;
    }()
  }]);

  return UsersApi;
}(BaseAPI);
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortEnum = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleFilterTracksEnum = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */

var GetFavoritesSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetFavoritesSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetPurchasesSortMethodEnum = {
  ContentTitle: 'content_title',
  ArtistName: 'artist_name',
  Date: 'date'
};
/**
 * @export
 */

var GetPurchasesSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetSalesSortMethodEnum = {
  ContentTitle: 'content_title',
  ArtistName: 'artist_name',
  Date: 'date'
};
/**
 * @export
 */

var GetSalesSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetTracksByUserSortEnum = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetTracksByUserSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetTracksByUserSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetTracksByUserFilterTracksEnum = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */

var GetTracksByUserHandleSortEnum = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetTracksByUserHandleSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetTracksByUserHandleSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetTracksByUserHandleFilterTracksEnum = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */

var GetUserLibraryAlbumsSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetUserLibraryAlbumsTypeEnum = {
  All: 'all',
  Repost: 'repost',
  Favorite: 'favorite',
  Purchase: 'purchase'
};
/**
 * @export
 */

var GetUserLibraryAlbumsSortMethodEnum = {
  AddedDate: 'added_date',
  Reposts: 'reposts',
  Saves: 'saves'
};
/**
 * @export
 */

var GetUserLibraryPlaylistsSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetUserLibraryPlaylistsTypeEnum = {
  All: 'all',
  Repost: 'repost',
  Favorite: 'favorite',
  Purchase: 'purchase'
};
/**
 * @export
 */

var GetUserLibraryPlaylistsSortMethodEnum = {
  AddedDate: 'added_date',
  Reposts: 'reposts',
  Saves: 'saves'
};
/**
 * @export
 */

var GetUserLibraryTracksSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetUserLibraryTracksSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetUserLibraryTracksTypeEnum = {
  All: 'all',
  Repost: 'repost',
  Favorite: 'favorite',
  Purchase: 'purchase'
};
/**
 * @export
 */

var GetUsersTrackHistorySortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetUsersTrackHistorySortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};

/* tslint:disable */

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BASE_PATH: BASE_PATH,
  Configuration: Configuration,
  DefaultConfig: DefaultConfig,
  BaseAPI: BaseAPI,
  ResponseError: ResponseError,
  FetchError: FetchError,
  RequiredError: RequiredError,
  COLLECTION_FORMATS: COLLECTION_FORMATS,
  exists: exists,
  querystring: querystring,
  mapValues: mapValues,
  canConsumeForm: canConsumeForm,
  JSONApiResponse: JSONApiResponse,
  VoidApiResponse: VoidApiResponse,
  BlobApiResponse: BlobApiResponse,
  TextApiResponse: TextApiResponse,
  PlaylistsApi: PlaylistsApi,
  GetTrendingPlaylistsTimeEnum: GetTrendingPlaylistsTimeEnum,
  GetTrendingPlaylistsWithVersionTimeEnum: GetTrendingPlaylistsWithVersionTimeEnum,
  ReactionsApi: ReactionsApi,
  SearchApi: SearchApi,
  SearchKindEnum: SearchKindEnum,
  SearchAutocompleteKindEnum: SearchAutocompleteKindEnum,
  TipsApi: TipsApi,
  GetTipsCurrentUserFollowsEnum: GetTipsCurrentUserFollowsEnum,
  GetTipsUniqueByEnum: GetTipsUniqueByEnum,
  TracksApi: TracksApi,
  GetRecommendedTracksTimeEnum: GetRecommendedTracksTimeEnum,
  GetRecommendedTracksWithVersionTimeEnum: GetRecommendedTracksWithVersionTimeEnum,
  GetTrendingTracksTimeEnum: GetTrendingTracksTimeEnum,
  GetTrendingTracksWithVersionTimeEnum: GetTrendingTracksWithVersionTimeEnum,
  GetUnderTheRadarTracksFilterEnum: GetUnderTheRadarTracksFilterEnum,
  TransactionsApi: TransactionsApi,
  GetAudioTransactionHistorySortMethodEnum: GetAudioTransactionHistorySortMethodEnum,
  GetAudioTransactionHistorySortDirectionEnum: GetAudioTransactionHistorySortDirectionEnum,
  UsersApi: UsersApi,
  GetAIAttributedTracksByUserHandleSortEnum: GetAIAttributedTracksByUserHandleSortEnum,
  GetAIAttributedTracksByUserHandleSortMethodEnum: GetAIAttributedTracksByUserHandleSortMethodEnum,
  GetAIAttributedTracksByUserHandleSortDirectionEnum: GetAIAttributedTracksByUserHandleSortDirectionEnum,
  GetAIAttributedTracksByUserHandleFilterTracksEnum: GetAIAttributedTracksByUserHandleFilterTracksEnum,
  GetFavoritesSortMethodEnum: GetFavoritesSortMethodEnum,
  GetFavoritesSortDirectionEnum: GetFavoritesSortDirectionEnum,
  GetPurchasesSortMethodEnum: GetPurchasesSortMethodEnum,
  GetPurchasesSortDirectionEnum: GetPurchasesSortDirectionEnum,
  GetSalesSortMethodEnum: GetSalesSortMethodEnum,
  GetSalesSortDirectionEnum: GetSalesSortDirectionEnum,
  GetTracksByUserSortEnum: GetTracksByUserSortEnum,
  GetTracksByUserSortMethodEnum: GetTracksByUserSortMethodEnum,
  GetTracksByUserSortDirectionEnum: GetTracksByUserSortDirectionEnum,
  GetTracksByUserFilterTracksEnum: GetTracksByUserFilterTracksEnum,
  GetTracksByUserHandleSortEnum: GetTracksByUserHandleSortEnum,
  GetTracksByUserHandleSortMethodEnum: GetTracksByUserHandleSortMethodEnum,
  GetTracksByUserHandleSortDirectionEnum: GetTracksByUserHandleSortDirectionEnum,
  GetTracksByUserHandleFilterTracksEnum: GetTracksByUserHandleFilterTracksEnum,
  GetUserLibraryAlbumsSortDirectionEnum: GetUserLibraryAlbumsSortDirectionEnum,
  GetUserLibraryAlbumsTypeEnum: GetUserLibraryAlbumsTypeEnum,
  GetUserLibraryAlbumsSortMethodEnum: GetUserLibraryAlbumsSortMethodEnum,
  GetUserLibraryPlaylistsSortDirectionEnum: GetUserLibraryPlaylistsSortDirectionEnum,
  GetUserLibraryPlaylistsTypeEnum: GetUserLibraryPlaylistsTypeEnum,
  GetUserLibraryPlaylistsSortMethodEnum: GetUserLibraryPlaylistsSortMethodEnum,
  GetUserLibraryTracksSortMethodEnum: GetUserLibraryTracksSortMethodEnum,
  GetUserLibraryTracksSortDirectionEnum: GetUserLibraryTracksSortDirectionEnum,
  GetUserLibraryTracksTypeEnum: GetUserLibraryTracksTypeEnum,
  GetUsersTrackHistorySortMethodEnum: GetUsersTrackHistorySortMethodEnum,
  GetUsersTrackHistorySortDirectionEnum: GetUsersTrackHistorySortDirectionEnum,
  instanceOfActivityFull: instanceOfActivityFull,
  ActivityFullFromJSON: ActivityFullFromJSON,
  ActivityFullFromJSONTyped: ActivityFullFromJSONTyped,
  ActivityFullToJSON: ActivityFullToJSON,
  instanceOfCollectionActivityFull: instanceOfCollectionActivityFull,
  CollectionActivityFullFromJSON: CollectionActivityFullFromJSON,
  CollectionActivityFullFromJSONTyped: CollectionActivityFullFromJSONTyped,
  CollectionActivityFullToJSON: CollectionActivityFullToJSON,
  instanceOfCollectionLibraryResponseFull: instanceOfCollectionLibraryResponseFull,
  CollectionLibraryResponseFullFromJSON: CollectionLibraryResponseFullFromJSON,
  CollectionLibraryResponseFullFromJSONTyped: CollectionLibraryResponseFullFromJSONTyped,
  CollectionLibraryResponseFullToJSON: CollectionLibraryResponseFullToJSON,
  instanceOfCoverArt: instanceOfCoverArt,
  CoverArtFromJSON: CoverArtFromJSON,
  CoverArtFromJSONTyped: CoverArtFromJSONTyped,
  CoverArtToJSON: CoverArtToJSON,
  instanceOfCoverPhoto: instanceOfCoverPhoto,
  CoverPhotoFromJSON: CoverPhotoFromJSON,
  CoverPhotoFromJSONTyped: CoverPhotoFromJSONTyped,
  CoverPhotoToJSON: CoverPhotoToJSON,
  instanceOfDownloadMetadata: instanceOfDownloadMetadata,
  DownloadMetadataFromJSON: DownloadMetadataFromJSON,
  DownloadMetadataFromJSONTyped: DownloadMetadataFromJSONTyped,
  DownloadMetadataToJSON: DownloadMetadataToJSON,
  instanceOfFavorite: instanceOfFavorite,
  FavoriteFromJSON: FavoriteFromJSON,
  FavoriteFromJSONTyped: FavoriteFromJSONTyped,
  FavoriteToJSON: FavoriteToJSON,
  instanceOfFieldVisibility: instanceOfFieldVisibility,
  FieldVisibilityFromJSON: FieldVisibilityFromJSON,
  FieldVisibilityFromJSONTyped: FieldVisibilityFromJSONTyped,
  FieldVisibilityToJSON: FieldVisibilityToJSON,
  instanceOfFollowingResponse: instanceOfFollowingResponse,
  FollowingResponseFromJSON: FollowingResponseFromJSON,
  FollowingResponseFromJSONTyped: FollowingResponseFromJSONTyped,
  FollowingResponseToJSON: FollowingResponseToJSON,
  instanceOfFollowingResponseFull: instanceOfFollowingResponseFull,
  FollowingResponseFullFromJSON: FollowingResponseFullFromJSON,
  FollowingResponseFullFromJSONTyped: FollowingResponseFullFromJSONTyped,
  FollowingResponseFullToJSON: FollowingResponseFullToJSON,
  instanceOfFullBulkSubscribersResponse: instanceOfFullBulkSubscribersResponse,
  FullBulkSubscribersResponseFromJSON: FullBulkSubscribersResponseFromJSON,
  FullBulkSubscribersResponseFromJSONTyped: FullBulkSubscribersResponseFromJSONTyped,
  FullBulkSubscribersResponseToJSON: FullBulkSubscribersResponseToJSON,
  instanceOfFullFollowersResponse: instanceOfFullFollowersResponse,
  FullFollowersResponseFromJSON: FullFollowersResponseFromJSON,
  FullFollowersResponseFromJSONTyped: FullFollowersResponseFromJSONTyped,
  FullFollowersResponseToJSON: FullFollowersResponseToJSON,
  instanceOfFullGetSupporter: instanceOfFullGetSupporter,
  FullGetSupporterFromJSON: FullGetSupporterFromJSON,
  FullGetSupporterFromJSONTyped: FullGetSupporterFromJSONTyped,
  FullGetSupporterToJSON: FullGetSupporterToJSON,
  instanceOfFullGetSupporters: instanceOfFullGetSupporters,
  FullGetSupportersFromJSON: FullGetSupportersFromJSON,
  FullGetSupportersFromJSONTyped: FullGetSupportersFromJSONTyped,
  FullGetSupportersToJSON: FullGetSupportersToJSON,
  instanceOfFullGetSupporting: instanceOfFullGetSupporting,
  FullGetSupportingFromJSON: FullGetSupportingFromJSON,
  FullGetSupportingFromJSONTyped: FullGetSupportingFromJSONTyped,
  FullGetSupportingToJSON: FullGetSupportingToJSON,
  instanceOfFullPlaylistResponse: instanceOfFullPlaylistResponse,
  FullPlaylistResponseFromJSON: FullPlaylistResponseFromJSON,
  FullPlaylistResponseFromJSONTyped: FullPlaylistResponseFromJSONTyped,
  FullPlaylistResponseToJSON: FullPlaylistResponseToJSON,
  instanceOfFullPlaylistTracksResponse: instanceOfFullPlaylistTracksResponse,
  FullPlaylistTracksResponseFromJSON: FullPlaylistTracksResponseFromJSON,
  FullPlaylistTracksResponseFromJSONTyped: FullPlaylistTracksResponseFromJSONTyped,
  FullPlaylistTracksResponseToJSON: FullPlaylistTracksResponseToJSON,
  instanceOfFullRemix: instanceOfFullRemix,
  FullRemixFromJSON: FullRemixFromJSON,
  FullRemixFromJSONTyped: FullRemixFromJSONTyped,
  FullRemixToJSON: FullRemixToJSON,
  instanceOfFullRemixParent: instanceOfFullRemixParent,
  FullRemixParentFromJSON: FullRemixParentFromJSON,
  FullRemixParentFromJSONTyped: FullRemixParentFromJSONTyped,
  FullRemixParentToJSON: FullRemixParentToJSON,
  instanceOfFullReposts: instanceOfFullReposts,
  FullRepostsFromJSON: FullRepostsFromJSON,
  FullRepostsFromJSONTyped: FullRepostsFromJSONTyped,
  FullRepostsToJSON: FullRepostsToJSON,
  instanceOfFullSubscribersResponse: instanceOfFullSubscribersResponse,
  FullSubscribersResponseFromJSON: FullSubscribersResponseFromJSON,
  FullSubscribersResponseFromJSONTyped: FullSubscribersResponseFromJSONTyped,
  FullSubscribersResponseToJSON: FullSubscribersResponseToJSON,
  instanceOfFullSupporter: instanceOfFullSupporter,
  FullSupporterFromJSON: FullSupporterFromJSON,
  FullSupporterFromJSONTyped: FullSupporterFromJSONTyped,
  FullSupporterToJSON: FullSupporterToJSON,
  instanceOfFullSupporting: instanceOfFullSupporting,
  FullSupportingFromJSON: FullSupportingFromJSON,
  FullSupportingFromJSONTyped: FullSupportingFromJSONTyped,
  FullSupportingToJSON: FullSupportingToJSON,
  instanceOfFullTip: instanceOfFullTip,
  FullTipFromJSON: FullTipFromJSON,
  FullTipFromJSONTyped: FullTipFromJSONTyped,
  FullTipToJSON: FullTipToJSON,
  instanceOfFullTrackResponse: instanceOfFullTrackResponse,
  FullTrackResponseFromJSON: FullTrackResponseFromJSON,
  FullTrackResponseFromJSONTyped: FullTrackResponseFromJSONTyped,
  FullTrackResponseToJSON: FullTrackResponseToJSON,
  instanceOfFullTracks: instanceOfFullTracks,
  FullTracksFromJSON: FullTracksFromJSON,
  FullTracksFromJSONTyped: FullTracksFromJSONTyped,
  FullTracksToJSON: FullTracksToJSON,
  instanceOfFullTracksResponse: instanceOfFullTracksResponse,
  FullTracksResponseFromJSON: FullTracksResponseFromJSON,
  FullTracksResponseFromJSONTyped: FullTracksResponseFromJSONTyped,
  FullTracksResponseToJSON: FullTracksResponseToJSON,
  instanceOfFullTrendingPlaylistsResponse: instanceOfFullTrendingPlaylistsResponse,
  FullTrendingPlaylistsResponseFromJSON: FullTrendingPlaylistsResponseFromJSON,
  FullTrendingPlaylistsResponseFromJSONTyped: FullTrendingPlaylistsResponseFromJSONTyped,
  FullTrendingPlaylistsResponseToJSON: FullTrendingPlaylistsResponseToJSON,
  instanceOfFullUserResponse: instanceOfFullUserResponse,
  FullUserResponseFromJSON: FullUserResponseFromJSON,
  FullUserResponseFromJSONTyped: FullUserResponseFromJSONTyped,
  FullUserResponseToJSON: FullUserResponseToJSON,
  instanceOfGetTipsResponse: instanceOfGetTipsResponse,
  GetTipsResponseFromJSON: GetTipsResponseFromJSON,
  GetTipsResponseFromJSONTyped: GetTipsResponseFromJSONTyped,
  GetTipsResponseToJSON: GetTipsResponseToJSON,
  instanceOfHistoryResponseFull: instanceOfHistoryResponseFull,
  HistoryResponseFullFromJSON: HistoryResponseFullFromJSON,
  HistoryResponseFullFromJSONTyped: HistoryResponseFullFromJSONTyped,
  HistoryResponseFullToJSON: HistoryResponseFullToJSON,
  instanceOfPlaylistAddedTimestamp: instanceOfPlaylistAddedTimestamp,
  PlaylistAddedTimestampFromJSON: PlaylistAddedTimestampFromJSON,
  PlaylistAddedTimestampFromJSONTyped: PlaylistAddedTimestampFromJSONTyped,
  PlaylistAddedTimestampToJSON: PlaylistAddedTimestampToJSON,
  instanceOfPlaylistArtwork: instanceOfPlaylistArtwork,
  PlaylistArtworkFromJSON: PlaylistArtworkFromJSON,
  PlaylistArtworkFromJSONTyped: PlaylistArtworkFromJSONTyped,
  PlaylistArtworkToJSON: PlaylistArtworkToJSON,
  instanceOfPlaylistFull: instanceOfPlaylistFull,
  PlaylistFullFromJSON: PlaylistFullFromJSON,
  PlaylistFullFromJSONTyped: PlaylistFullFromJSONTyped,
  PlaylistFullToJSON: PlaylistFullToJSON,
  instanceOfPlaylistFullWithoutTracks: instanceOfPlaylistFullWithoutTracks,
  PlaylistFullWithoutTracksFromJSON: PlaylistFullWithoutTracksFromJSON,
  PlaylistFullWithoutTracksFromJSONTyped: PlaylistFullWithoutTracksFromJSONTyped,
  PlaylistFullWithoutTracksToJSON: PlaylistFullWithoutTracksToJSON,
  instanceOfPlaylistLibrary: instanceOfPlaylistLibrary,
  PlaylistLibraryFromJSON: PlaylistLibraryFromJSON,
  PlaylistLibraryFromJSONTyped: PlaylistLibraryFromJSONTyped,
  PlaylistLibraryToJSON: PlaylistLibraryToJSON,
  instanceOfPremiumContentSignature: instanceOfPremiumContentSignature,
  PremiumContentSignatureFromJSON: PremiumContentSignatureFromJSON,
  PremiumContentSignatureFromJSONTyped: PremiumContentSignatureFromJSONTyped,
  PremiumContentSignatureToJSON: PremiumContentSignatureToJSON,
  instanceOfProfilePicture: instanceOfProfilePicture,
  ProfilePictureFromJSON: ProfilePictureFromJSON,
  ProfilePictureFromJSONTyped: ProfilePictureFromJSONTyped,
  ProfilePictureToJSON: ProfilePictureToJSON,
  instanceOfRelatedArtistResponseFull: instanceOfRelatedArtistResponseFull,
  RelatedArtistResponseFullFromJSON: RelatedArtistResponseFullFromJSON,
  RelatedArtistResponseFullFromJSONTyped: RelatedArtistResponseFullFromJSONTyped,
  RelatedArtistResponseFullToJSON: RelatedArtistResponseFullToJSON,
  instanceOfRemixesResponse: instanceOfRemixesResponse,
  RemixesResponseFromJSON: RemixesResponseFromJSON,
  RemixesResponseFromJSONTyped: RemixesResponseFromJSONTyped,
  RemixesResponseToJSON: RemixesResponseToJSON,
  instanceOfRemixesResponseFull: instanceOfRemixesResponseFull,
  RemixesResponseFullFromJSON: RemixesResponseFullFromJSON,
  RemixesResponseFullFromJSONTyped: RemixesResponseFullFromJSONTyped,
  RemixesResponseFullToJSON: RemixesResponseFullToJSON,
  instanceOfRemixingResponse: instanceOfRemixingResponse,
  RemixingResponseFromJSON: RemixingResponseFromJSON,
  RemixingResponseFromJSONTyped: RemixingResponseFromJSONTyped,
  RemixingResponseToJSON: RemixingResponseToJSON,
  instanceOfRepost: instanceOfRepost,
  RepostFromJSON: RepostFromJSON,
  RepostFromJSONTyped: RepostFromJSONTyped,
  RepostToJSON: RepostToJSON,
  instanceOfSearchAutocompleteResponse: instanceOfSearchAutocompleteResponse,
  SearchAutocompleteResponseFromJSON: SearchAutocompleteResponseFromJSON,
  SearchAutocompleteResponseFromJSONTyped: SearchAutocompleteResponseFromJSONTyped,
  SearchAutocompleteResponseToJSON: SearchAutocompleteResponseToJSON,
  instanceOfSearchFullResponse: instanceOfSearchFullResponse,
  SearchFullResponseFromJSON: SearchFullResponseFromJSON,
  SearchFullResponseFromJSONTyped: SearchFullResponseFromJSONTyped,
  SearchFullResponseToJSON: SearchFullResponseToJSON,
  instanceOfSearchModel: instanceOfSearchModel,
  SearchModelFromJSON: SearchModelFromJSON,
  SearchModelFromJSONTyped: SearchModelFromJSONTyped,
  SearchModelToJSON: SearchModelToJSON,
  instanceOfStemFull: instanceOfStemFull,
  StemFullFromJSON: StemFullFromJSON,
  StemFullFromJSONTyped: StemFullFromJSONTyped,
  StemFullToJSON: StemFullToJSON,
  instanceOfStemParent: instanceOfStemParent,
  StemParentFromJSON: StemParentFromJSON,
  StemParentFromJSONTyped: StemParentFromJSONTyped,
  StemParentToJSON: StemParentToJSON,
  instanceOfStemsResponse: instanceOfStemsResponse,
  StemsResponseFromJSON: StemsResponseFromJSON,
  StemsResponseFromJSONTyped: StemsResponseFromJSONTyped,
  StemsResponseToJSON: StemsResponseToJSON,
  instanceOfSupporterReference: instanceOfSupporterReference,
  SupporterReferenceFromJSON: SupporterReferenceFromJSON,
  SupporterReferenceFromJSONTyped: SupporterReferenceFromJSONTyped,
  SupporterReferenceToJSON: SupporterReferenceToJSON,
  instanceOfTopGenreUsersResponseFull: instanceOfTopGenreUsersResponseFull,
  TopGenreUsersResponseFullFromJSON: TopGenreUsersResponseFullFromJSON,
  TopGenreUsersResponseFullFromJSONTyped: TopGenreUsersResponseFullFromJSONTyped,
  TopGenreUsersResponseFullToJSON: TopGenreUsersResponseFullToJSON,
  instanceOfTopUsersResponseFull: instanceOfTopUsersResponseFull,
  TopUsersResponseFullFromJSON: TopUsersResponseFullFromJSON,
  TopUsersResponseFullFromJSONTyped: TopUsersResponseFullFromJSONTyped,
  TopUsersResponseFullToJSON: TopUsersResponseFullToJSON,
  instanceOfTrackActivityFull: instanceOfTrackActivityFull,
  TrackActivityFullFromJSON: TrackActivityFullFromJSON,
  TrackActivityFullFromJSONTyped: TrackActivityFullFromJSONTyped,
  TrackActivityFullToJSON: TrackActivityFullToJSON,
  instanceOfTrackArtwork: instanceOfTrackArtwork,
  TrackArtworkFromJSON: TrackArtworkFromJSON,
  TrackArtworkFromJSONTyped: TrackArtworkFromJSONTyped,
  TrackArtworkToJSON: TrackArtworkToJSON,
  instanceOfTrackFavoritesResponseFull: instanceOfTrackFavoritesResponseFull,
  TrackFavoritesResponseFullFromJSON: TrackFavoritesResponseFullFromJSON,
  TrackFavoritesResponseFullFromJSONTyped: TrackFavoritesResponseFullFromJSONTyped,
  TrackFavoritesResponseFullToJSON: TrackFavoritesResponseFullToJSON,
  instanceOfTrackFull: instanceOfTrackFull,
  TrackFullFromJSON: TrackFullFromJSON,
  TrackFullFromJSONTyped: TrackFullFromJSONTyped,
  TrackFullToJSON: TrackFullToJSON,
  instanceOfTrackId: instanceOfTrackId,
  TrackIdFromJSON: TrackIdFromJSON,
  TrackIdFromJSONTyped: TrackIdFromJSONTyped,
  TrackIdToJSON: TrackIdToJSON,
  instanceOfTrackLibraryResponseFull: instanceOfTrackLibraryResponseFull,
  TrackLibraryResponseFullFromJSON: TrackLibraryResponseFullFromJSON,
  TrackLibraryResponseFullFromJSONTyped: TrackLibraryResponseFullFromJSONTyped,
  TrackLibraryResponseFullToJSON: TrackLibraryResponseFullToJSON,
  instanceOfTrackRepostsResponseFull: instanceOfTrackRepostsResponseFull,
  TrackRepostsResponseFullFromJSON: TrackRepostsResponseFullFromJSON,
  TrackRepostsResponseFullFromJSONTyped: TrackRepostsResponseFullFromJSONTyped,
  TrackRepostsResponseFullToJSON: TrackRepostsResponseFullToJSON,
  instanceOfTrackSegment: instanceOfTrackSegment,
  TrackSegmentFromJSON: TrackSegmentFromJSON,
  TrackSegmentFromJSONTyped: TrackSegmentFromJSONTyped,
  TrackSegmentToJSON: TrackSegmentToJSON,
  instanceOfTransactionDetails: instanceOfTransactionDetails,
  TransactionDetailsFromJSON: TransactionDetailsFromJSON,
  TransactionDetailsFromJSONTyped: TransactionDetailsFromJSONTyped,
  TransactionDetailsToJSON: TransactionDetailsToJSON,
  instanceOfTransactionHistoryCountResponse: instanceOfTransactionHistoryCountResponse,
  TransactionHistoryCountResponseFromJSON: TransactionHistoryCountResponseFromJSON,
  TransactionHistoryCountResponseFromJSONTyped: TransactionHistoryCountResponseFromJSONTyped,
  TransactionHistoryCountResponseToJSON: TransactionHistoryCountResponseToJSON,
  instanceOfTransactionHistoryResponse: instanceOfTransactionHistoryResponse,
  TransactionHistoryResponseFromJSON: TransactionHistoryResponseFromJSON,
  TransactionHistoryResponseFromJSONTyped: TransactionHistoryResponseFromJSONTyped,
  TransactionHistoryResponseToJSON: TransactionHistoryResponseToJSON,
  instanceOfTrendingIdsResponse: instanceOfTrendingIdsResponse,
  TrendingIdsResponseFromJSON: TrendingIdsResponseFromJSON,
  TrendingIdsResponseFromJSONTyped: TrendingIdsResponseFromJSONTyped,
  TrendingIdsResponseToJSON: TrendingIdsResponseToJSON,
  instanceOfTrendingTimesIds: instanceOfTrendingTimesIds,
  TrendingTimesIdsFromJSON: TrendingTimesIdsFromJSON,
  TrendingTimesIdsFromJSONTyped: TrendingTimesIdsFromJSONTyped,
  TrendingTimesIdsToJSON: TrendingTimesIdsToJSON,
  instanceOfUserFull: instanceOfUserFull,
  UserFullFromJSON: UserFullFromJSON,
  UserFullFromJSONTyped: UserFullFromJSONTyped,
  UserFullToJSON: UserFullToJSON,
  instanceOfUserReplicaSet: instanceOfUserReplicaSet,
  UserReplicaSetFromJSON: UserReplicaSetFromJSON,
  UserReplicaSetFromJSONTyped: UserReplicaSetFromJSONTyped,
  UserReplicaSetToJSON: UserReplicaSetToJSON,
  instanceOfUserSubscribers: instanceOfUserSubscribers,
  UserSubscribersFromJSON: UserSubscribersFromJSON,
  UserSubscribersFromJSONTyped: UserSubscribersFromJSONTyped,
  UserSubscribersToJSON: UserSubscribersToJSON,
  instanceOfUsersByContentNode: instanceOfUsersByContentNode,
  UsersByContentNodeFromJSON: UsersByContentNodeFromJSON,
  UsersByContentNodeFromJSONTyped: UsersByContentNodeFromJSONTyped,
  UsersByContentNodeToJSON: UsersByContentNodeToJSON,
  instanceOfVersionMetadata: instanceOfVersionMetadata,
  VersionMetadataFromJSON: VersionMetadataFromJSON,
  VersionMetadataFromJSONTyped: VersionMetadataFromJSONTyped,
  VersionMetadataToJSON: VersionMetadataToJSON
});

var appName;
/**
 * Appends the configured app_name to the query string for tracking API usage
 * @param options the middleware options
 * @param {string} options.appName the name of the app using the SDK
 */

var addAppNameMiddleware = function addAppNameMiddleware(_ref) {
  var providedAppName = _ref.appName,
      services = _ref.services;
  appName = providedAppName;
  return {
    pre: function () {
      var _pre = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(context) {
        var _appName, _context$init;

        var _yield$developerApps$, middleware, apiClientConfig, developerApps;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (appName) {
                  _context.next = 21;
                  break;
                }

                middleware = [services.discoveryNodeSelector.createMiddleware()];
                apiClientConfig = new Configuration$1({
                  fetchApi: fetch$1,
                  middleware: middleware
                });
                developerApps = new DeveloperAppsApi(apiClientConfig, services.entityManager, services.auth);
                _context.t1 = developerApps;
                _context.next = 7;
                return services.auth.getAddress();

              case 7:
                _context.t2 = _context.sent;
                _context.t3 = {
                  address: _context.t2
                };
                _context.next = 11;
                return _context.t1.getDeveloperApp.call(_context.t1, _context.t3);

              case 11:
                _context.t4 = _yield$developerApps$ = _context.sent.data;
                _context.t0 = _context.t4 === null;

                if (_context.t0) {
                  _context.next = 15;
                  break;
                }

                _context.t0 = _yield$developerApps$ === void 0;

              case 15:
                if (!_context.t0) {
                  _context.next = 19;
                  break;
                }

                _context.t5 = void 0;
                _context.next = 20;
                break;

              case 19:
                _context.t5 = _yield$developerApps$.name;

              case 20:
                appName = _context.t5;

              case 21:
                return _context.abrupt("return", {
                  url: context.url + (context.url.includes('?') ? '&' : '?') + querystring$1({
                    app_name: (_appName = appName) !== null && _appName !== void 0 ? _appName : ''
                  }),
                  init: (_context$init = context.init) !== null && _context$init !== void 0 ? _context$init : {}
                });

              case 22:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function pre(_x) {
        return _pre.apply(this, arguments);
      }

      return pre;
    }()
  };
};

var DECISION_TREE_STATE;

(function (DECISION_TREE_STATE) {
  DECISION_TREE_STATE["CHECK_SHORT_CIRCUIT"] = "Check Short Circuit";
  DECISION_TREE_STATE["GET_ALL_SERVICES"] = "Get All Services";
  DECISION_TREE_STATE["FILTER_TO_WHITELIST"] = "Filter To Whitelist";
  DECISION_TREE_STATE["FILTER_FROM_BLACKLIST"] = "Filter From Blacklist";
  DECISION_TREE_STATE["FILTER_OUT_KNOWN_UNHEALTHY"] = "Filter Out Known Unhealthy";
  DECISION_TREE_STATE["GET_SELECTION_ROUND"] = "Get Selection Round";
  DECISION_TREE_STATE["NO_SERVICES_LEFT_TO_TRY"] = "No Services Left To Try";
  DECISION_TREE_STATE["SELECTED_FROM_BACKUP"] = "Selected From Backup";
  DECISION_TREE_STATE["FAILED_AND_RESETTING"] = "Failed Everything -- Resetting";
  DECISION_TREE_STATE["ROUND_FAILED_RETRY"] = "Round Failed Retry";
  DECISION_TREE_STATE["MADE_A_SELECTION"] = "Made A Selection";
  DECISION_TREE_STATE["RACED_AND_FOUND_BEST"] = "Raced And Found Best";
})(DECISION_TREE_STATE || (DECISION_TREE_STATE = {}));

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */

function baseClamp$2(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }

    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }

  return number;
}

var _baseClamp = baseClamp$2;

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */

function copyArray$2(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

var _copyArray = copyArray$2;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeRandom = Math.random;
/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */

function baseRandom$1(lower, upper) {
  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}

var _baseRandom = baseRandom$1;

var baseRandom = _baseRandom;
/**
 * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @param {number} [size=array.length] The size of `array`.
 * @returns {Array} Returns `array`.
 */

function shuffleSelf$2(array, size) {
  var index = -1,
      length = array.length,
      lastIndex = length - 1;
  size = size === undefined ? length : size;

  while (++index < size) {
    var rand = baseRandom(index, lastIndex),
        value = array[rand];
    array[rand] = array[index];
    array[index] = value;
  }

  array.length = size;
  return array;
}

var _shuffleSelf = shuffleSelf$2;

var baseClamp$1 = _baseClamp,
    copyArray$1 = _copyArray,
    shuffleSelf$1 = _shuffleSelf;
/**
 * A specialized version of `_.sampleSize` for arrays.
 *
 * @private
 * @param {Array} array The array to sample.
 * @param {number} n The number of elements to sample.
 * @returns {Array} Returns the random elements.
 */

function arraySampleSize$1(array, n) {
  return shuffleSelf$1(copyArray$1(array), baseClamp$1(n, 0, array.length));
}

var _arraySampleSize = arraySampleSize$1;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

function arrayMap$1(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

var _arrayMap = arrayMap$1;

var arrayMap = _arrayMap;
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */

function baseValues$1(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

var _baseValues = baseValues$1;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */

function baseTimes$1(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

var _baseTimes = baseTimes$1;

var freeGlobal$1 = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;

var freeGlobal = _freeGlobal;
/** Detect free variable `self`. */

var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root$4 = freeGlobal || freeSelf || Function('return this')();
var _root = root$4;

var root$3 = _root;
/** Built-in value references. */

var _Symbol2 = root$3.Symbol;
var _Symbol$2 = _Symbol2;

var _Symbol$1 = _Symbol$2;
/** Used for built-in method references. */

var objectProto$b = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString$1 = objectProto$b.toString;
/** Built-in value references. */

var symToStringTag$1 = _Symbol$1 ? _Symbol$1.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag$1(value) {
  var isOwn = hasOwnProperty$9.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }

  return result;
}

var _getRawTag = getRawTag$1;

/** Used for built-in method references. */
var objectProto$a = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto$a.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString$1(value) {
  return nativeObjectToString.call(value);
}

var _objectToString = objectToString$1;

var _Symbol = _Symbol$2,
    getRawTag = _getRawTag,
    objectToString = _objectToString;
/** `Object#toString` result references. */

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag$5(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

var _baseGetTag = baseGetTag$5;

function isObjectLike$6(value) {
  return value != null && _typeof(value) == 'object';
}

var isObjectLike_1 = isObjectLike$6;

var baseGetTag$4 = _baseGetTag,
    isObjectLike$5 = isObjectLike_1;
/** `Object#toString` result references. */

var argsTag$1 = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments$1(value) {
  return isObjectLike$5(value) && baseGetTag$4(value) == argsTag$1;
}

var _baseIsArguments = baseIsArguments$1;

var baseIsArguments = _baseIsArguments,
    isObjectLike$4 = isObjectLike_1;
/** Used for built-in method references. */

var objectProto$9 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto$9.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments$3 = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike$4(value) && hasOwnProperty$8.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
var isArguments_1 = isArguments$3;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$4 = Array.isArray;
var isArray_1 = isArray$4;

var isBuffer$2 = {exports: {}};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */

function stubFalse() {
  return false;
}

var stubFalse_1 = stubFalse;

(function (module, exports) {
  var root = _root,
      stubFalse = stubFalse_1;
  /** Detect free variable `exports`. */

  var freeExports = exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Built-in value references. */

  var Buffer = moduleExports ? root.Buffer : undefined;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */

  var isBuffer = nativeIsBuffer || stubFalse;
  module.exports = isBuffer;
})(isBuffer$2, isBuffer$2.exports);

var MAX_SAFE_INTEGER$1 = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex$2(value, length) {
  var type = _typeof(value);

  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

var _isIndex = isIndex$2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength$2(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

var isLength_1 = isLength$2;

var baseGetTag$3 = _baseGetTag,
    isLength$1 = isLength_1,
    isObjectLike$3 = isObjectLike_1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag$1 = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray$1(value) {
  return isObjectLike$3(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$3(value)];
}

var _baseIsTypedArray = baseIsTypedArray$1;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */

function baseUnary$1(func) {
  return function (value) {
    return func(value);
  };
}

var _baseUnary = baseUnary$1;

var _nodeUtil = {exports: {}};

(function (module, exports) {
  var freeGlobal = _freeGlobal;
  /** Detect free variable `exports`. */

  var freeExports = exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Detect free variable `process` from Node.js. */

  var freeProcess = moduleExports && freeGlobal.process;
  /** Used to access faster Node.js helpers. */

  var nodeUtil = function () {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      } // Legacy `process.binding('util')` for Node.js < 10.


      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();

  module.exports = nodeUtil;
})(_nodeUtil, _nodeUtil.exports);

var baseIsTypedArray = _baseIsTypedArray,
    baseUnary = _baseUnary,
    nodeUtil = _nodeUtil.exports;
/* Node.js helper references. */

var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;

var baseTimes = _baseTimes,
    isArguments$2 = isArguments_1,
    isArray$3 = isArray_1,
    isBuffer$1 = isBuffer$2.exports,
    isIndex$1 = _isIndex,
    isTypedArray$1 = isTypedArray_1;
/** Used for built-in method references. */

var objectProto$8 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$3(value),
      isArg = !isArr && isArguments$2(value),
      isBuff = !isArr && !isArg && isBuffer$1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex$1(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

var _arrayLikeKeys = arrayLikeKeys$2;

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype$3(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$7;
  return value === proto;
}

var _isPrototype = isPrototype$3;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */

function overArg$2(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

var _overArg = overArg$2;

var overArg$1 = _overArg;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;

var isPrototype$2 = _isPrototype,
    nativeKeys = _nativeKeys;
/** Used for built-in method references. */

var objectProto$6 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys$1(object) {
  if (!isPrototype$2(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty$6.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

var _baseKeys = baseKeys$1;

function isObject$8(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject$8;

var baseGetTag$2 = _baseGetTag,
    isObject$7 = isObject_1;
/** `Object#toString` result references. */

var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction$3(value) {
  if (!isObject$7(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag$2(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

var isFunction_1 = isFunction$3;

var isFunction$2 = isFunction_1,
    isLength = isLength_1;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike$4(value) {
  return value != null && isLength(value.length) && !isFunction$2(value);
}

var isArrayLike_1 = isArrayLike$4;

var arrayLikeKeys$1 = _arrayLikeKeys,
    baseKeys = _baseKeys,
    isArrayLike$3 = isArrayLike_1;
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */

function keys$1(object) {
  return isArrayLike$3(object) ? arrayLikeKeys$1(object) : baseKeys(object);
}

var keys_1 = keys$1;

var baseValues = _baseValues,
    keys = keys_1;
/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */

function values$1(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

var values_1 = values$1;

var baseClamp = _baseClamp,
    shuffleSelf = _shuffleSelf,
    values = values_1;
/**
 * The base implementation of `_.sampleSize` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to sample.
 * @param {number} n The number of elements to sample.
 * @returns {Array} Returns the random elements.
 */

function baseSampleSize$1(collection, n) {
  var array = values(collection);
  return shuffleSelf(array, baseClamp(n, 0, array.length));
}

var _baseSampleSize = baseSampleSize$1;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */

function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}

var eq_1 = eq$4;

var eq$3 = eq_1,
    isArrayLike$2 = isArrayLike_1,
    isIndex = _isIndex,
    isObject$6 = isObject_1;
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */

function isIterateeCall$2(value, index, object) {
  if (!isObject$6(object)) {
    return false;
  }

  var type = _typeof(index);

  if (type == 'number' ? isArrayLike$2(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq$3(object[index], value);
  }

  return false;
}

var _isIterateeCall = isIterateeCall$2;

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */

function trimmedEndIndex$1(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}

  return index;
}

var _trimmedEndIndex = trimmedEndIndex$1;

var trimmedEndIndex = _trimmedEndIndex;
/** Used to match leading whitespace. */

var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */

function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
}

var _baseTrim = baseTrim$1;

var baseGetTag$1 = _baseGetTag,
    isObjectLike$2 = isObjectLike_1;
/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol$1(value) {
  return _typeof(value) == 'symbol' || isObjectLike$2(value) && baseGetTag$1(value) == symbolTag;
}

var isSymbol_1 = isSymbol$1;

var baseTrim = _baseTrim,
    isObject$5 = isObject_1,
    isSymbol = isSymbol_1;
/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */

function toNumber$1(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject$5(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject$5(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

var toNumber_1 = toNumber$1;

var toNumber = toNumber_1;
/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */

function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }

  value = toNumber(value);

  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }

  return value === value ? value : 0;
}

var toFinite_1 = toFinite$1;

var toFinite = toFinite_1;
/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */

function toInteger$1(value) {
  var result = toFinite(value),
      remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}

var toInteger_1 = toInteger$1;

var arraySampleSize = _arraySampleSize,
    baseSampleSize = _baseSampleSize,
    isArray$2 = isArray_1,
    isIterateeCall$1 = _isIterateeCall,
    toInteger = toInteger_1;
/**
 * Gets `n` random elements at unique keys from `collection` up to the
 * size of `collection`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to sample.
 * @param {number} [n=1] The number of elements to sample.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the random elements.
 * @example
 *
 * _.sampleSize([1, 2, 3], 2);
 * // => [3, 1]
 *
 * _.sampleSize([1, 2, 3], 4);
 * // => [2, 3, 1]
 */

function sampleSize(collection, n, guard) {
  if (guard ? isIterateeCall$1(collection, n, guard) : n === undefined) {
    n = 1;
  } else {
    n = toInteger(n);
  }

  var func = isArray$2(collection) ? arraySampleSize : baseSampleSize;
  return func(collection, n);
}

var sampleSize_1 = sampleSize;

var HealthCheckStatus;

(function (HealthCheckStatus) {
  HealthCheckStatus["UNHEALTHY"] = "unhealthy";
  HealthCheckStatus["BEHIND"] = "behind";
  HealthCheckStatus["HEALTHY"] = "healthy";
})(HealthCheckStatus || (HealthCheckStatus = {}));

var servicesConfig$2 = {
  "minVersion": "0.0.0",
  "discoveryNodes": ["http://audius-protocol-discovery-provider-1"],
  "storageNodes": [{
    "delegateOwnerWallet": "0x0D38e653eC28bdea5A2296fD5940aaB2D0B8875c",
    "endpoint": "http://audius-protocol-creator-node-1"
  }],
  "entityManagerContractAddress": "0x254dffcd3277C0b1660F6d42EFbB754edaBAbC2B",
  "web3ProviderUrl": "http://audius-protocol-poa-ganache-1",
  "identityServiceUrl": "http://audius-protocol-identity-service-1"
};

var servicesConfig$1 = {
  "minVersion": "0.3.83",
  "discoveryNodes": ["https://discoveryprovider2.staging.audius.co", "https://discoveryprovider3.staging.audius.co", "https://discoveryprovider.staging.audius.co", "https://discoveryprovider5.staging.audius.co"],
  "storageNodes": [{
    "endpoint": "https://usermetadata.staging.audius.co",
    "delegateOwnerWallet": "0x671ddce7B4E676C9467F87e4031a917b5D6f75F0"
  }, {
    "endpoint": "https://creatornode5.staging.audius.co",
    "delegateOwnerWallet": "0xDC2BDF1F23381CA2eC9e9c70D4FD96CD8645D090"
  }, {
    "endpoint": "https://creatornode6.staging.audius.co",
    "delegateOwnerWallet": "0x68039d001D87E7A5E6B06fe0825EA7871C1Cd6C2"
  }, {
    "endpoint": "https://creatornode7.staging.audius.co",
    "delegateOwnerWallet": "0x1F8e7aF58086992Ef4c4fc0371446974BBbC0D9F"
  }, {
    "endpoint": "https://creatornode8.staging.audius.co",
    "delegateOwnerWallet": "0x8fcFA10Bd3808570987dbb5B1EF4AB74400FbfDA"
  }, {
    "endpoint": "https://creatornode9.staging.audius.co",
    "delegateOwnerWallet": "0x140eD283b33be2145ed7d9d15f1fE7bF1E0B2Ac3"
  }, {
    "endpoint": "https://creatornode10.staging.audius.co",
    "delegateOwnerWallet": "0xf7C96916bd37Ad76D4EEDd6536B81c29706C8056"
  }, {
    "endpoint": "https://creatornode11.staging.audius.co",
    "delegateOwnerWallet": "0x4c88d2c0f4c4586b41621aD6e98882ae904B98f6"
  }],
  "web3ProviderUrl": "https://poa-gateway.staging.audius.co",
  "entityManagerContractAddress": "0x1Cd8a543596D499B9b6E7a6eC15ECd2B7857Fd64",
  "identityServiceUrl": "https://identityservice.staging.audius.co"
};

var servicesConfig = {
  "minVersion": "0.3.85",
  "discoveryNodes": ["https://audius-metadata-1.figment.io", "https://audius-metadata-2.figment.io", "https://audius-discovery-1.altego.net", "https://audius-disco.ams-x01.nl.supercache.org", "https://dn-jpn.audius.metadata.fyi", "https://discoveryprovider3.audius.co", "https://discoveryprovider2.audius.co", "https://discoveryprovider.audius.co", "https://audius-metadata-3.figment.io", "https://audius-metadata-4.figment.io", "https://dn1.monophonic.digital", "https://dn-usa.audius.metadata.fyi", "https://discovery-us-01.audius.openplayer.org", "https://dn2.monophonic.digital", "https://audius-discovery-2.altego.net", "https://dn1.nodeoperator.io", "https://audius-disco.dfw-x02.us.supercache.org", "https://audius-discovery-3.altego.net", "https://dn1.matterlightblooming.xyz", "https://audius-dp.singapore.creatorseed.com", "https://discovery.grassfed.network", "https://audius-discovery-1.cultur3stake.com", "https://audius-discovery-3.cultur3stake.com", "https://audius-discovery-4.cultur3stake.com", "https://audius-discovery-5.cultur3stake.com", "https://audius-discovery-7.cultur3stake.com", "https://audius-discovery-8.cultur3stake.com", "https://audius-discovery-9.cultur3stake.com", "https://audius-discovery-10.cultur3stake.com", "https://discovery-au-02.audius.openplayer.org", "https://disc-lon01.audius.hashbeam.com", "https://audius-dp.amsterdam.creatorseed.com", "https://blockdaemon-audius-discovery-01.bdnodes.net", "https://blockdaemon-audius-discovery-02.bdnodes.net", "https://blockdaemon-audius-discovery-03.bdnodes.net", "https://blockdaemon-audius-discovery-04.bdnodes.net", "https://blockdaemon-audius-discovery-05.bdnodes.net", "https://blockdaemon-audius-discovery-06.bdnodes.net", "https://blockdaemon-audius-discovery-07.bdnodes.net", "https://blockchange-audius-discovery-01.bdnodes.net", "https://blockchange-audius-discovery-02.bdnodes.net", "https://blockchange-audius-discovery-03.bdnodes.net", "https://audius-discovery-11.cultur3stake.com", "https://audius-discovery-12.cultur3stake.com", "https://audius-discovery-13.cultur3stake.com", "https://audius-discovery-14.cultur3stake.com", "https://audius-discovery-16.cultur3stake.com", "https://audius-discovery-18.cultur3stake.com", "https://audius-discovery-17.cultur3stake.com", "https://audius-discovery-15.cultur3stake.com", "https://audius-discovery-6.cultur3stake.com", "https://audius-discovery-2.cultur3stake.com", "https://blockdaemon-audius-discovery-08.bdnodes.net", "https://audius-metadata-5.figment.io", "https://dn1.stuffisup.com", "https://audius-discovery-1.theblueprint.xyz", "https://audius-discovery-2.theblueprint.xyz", "https://audius-discovery-3.theblueprint.xyz", "https://audius-discovery-4.theblueprint.xyz", "https://audius.w3coins.io"],
  "storageNodes": [{
    "endpoint": "https://creatornode.audius.co",
    "delegateOwnerWallet": "0xc8d0C29B6d540295e8fc8ac72456F2f4D41088c8"
  }, {
    "endpoint": "https://creatornode2.audius.co",
    "delegateOwnerWallet": "0xf686647E3737d595C60c6DE2f5F90463542FE439"
  }, {
    "endpoint": "https://creatornode3.audius.co",
    "delegateOwnerWallet": "0x0C32BE6328578E99b6F06E0e7A6B385EB8FC13d1"
  }, {
    "endpoint": "https://content-node.audius.co",
    "delegateOwnerWallet": "0xC892c75Fa17e8b641a4843D0aa620792857d217A"
  }, {
    "endpoint": "https://audius-content-1.figment.io",
    "delegateOwnerWallet": "0xBfdE9a7DD3620CB6428463E9A9e9932B4d10fdc5"
  }, {
    "endpoint": "https://creatornode.audius.prod-us-west-2.staked.cloud",
    "delegateOwnerWallet": "0x675086B880260D217963cF14F503272AEb44b2E9"
  }, {
    "endpoint": "https://audius-content-2.figment.io",
    "delegateOwnerWallet": "0x6444212FFc23a4CcF7460f8Fe6D0e6074db59036"
  }, {
    "endpoint": "https://audius-content-3.figment.io",
    "delegateOwnerWallet": "0xECEDCaABecb40ef4bE733BA47FaD612aeA1F396F"
  }, {
    "endpoint": "https://audius-content-4.figment.io",
    "delegateOwnerWallet": "0x08fEF3884Db16E2E6211272cdC9Eee68E8b63b09"
  }, {
    "endpoint": "https://audius-content-5.figment.io",
    "delegateOwnerWallet": "0x10fF8197f2e94eF880d940D2414E0A14983c3bFE"
  }, {
    "endpoint": "https://creatornode.audius1.prod-us-west-2.staked.cloud",
    "delegateOwnerWallet": "0xC23Ee959E0B22a9B0F5dF18D7e7875cA4B6c4236"
  }, {
    "endpoint": "https://creatornode.audius2.prod-us-west-2.staked.cloud",
    "delegateOwnerWallet": "0x51a5575dc04c1f5f2e39390d090aaf78554F5f7B"
  }, {
    "endpoint": "https://creatornode.audius3.prod-us-west-2.staked.cloud",
    "delegateOwnerWallet": "0xe0b56BAe2276E016d3DB314Dd7374e596B0457ac"
  }, {
    "endpoint": "https://audius-content-6.figment.io",
    "delegateOwnerWallet": "0x68a4Bd6b4177ffB025AF9844cBE4Fe31348AEE1D"
  }, {
    "endpoint": "https://audius-content-7.figment.io",
    "delegateOwnerWallet": "0xf45a6DBf3ce0201F4012a19b1fB04D4f05B53a37"
  }, {
    "endpoint": "https://audius-content-8.figment.io",
    "delegateOwnerWallet": "0x9708Fb04DeA029212126255B311a21F1F884cCB4"
  }, {
    "endpoint": "https://usermetadata.audius.co",
    "delegateOwnerWallet": "0xD7E6Fe145874E6c2648F012379699c694b183A2c"
  }, {
    "endpoint": "https://audius-content-9.figment.io",
    "delegateOwnerWallet": "0x7c34c9709ed69513D55dF2020e799DA44fC52E6e"
  }, {
    "endpoint": "https://audius-content-10.figment.io",
    "delegateOwnerWallet": "0xff753331CEa586DD5B23bd21222a3c902909F2dd"
  }, {
    "endpoint": "https://audius-content-11.figment.io",
    "delegateOwnerWallet": "0xC9721F892BcC8822eb34237E875BE93904f11073"
  }, {
    "endpoint": "https://audius.prod.capturealpha.io",
    "delegateOwnerWallet": "0x0A5AEA27A7fB95b51056Df6AaD7fe7E9116eC9B4"
  }, {
    "endpoint": "https://content.grassfed.network",
    "delegateOwnerWallet": "0x33Ab85445c8A2690B9488e9fB5E6A9849d3a18d3"
  }, {
    "endpoint": "https://blockdaemon-audius-content-01.bdnodes.net",
    "delegateOwnerWallet": "0x807C0fba7405aeb8b6a37A974df6259C6aB9bB1e"
  }, {
    "endpoint": "https://audius-content-1.cultur3stake.com",
    "delegateOwnerWallet": "0xCEb6a23d6132Cfe329b3c8E3c45f9DDc28A62Bd4"
  }, {
    "endpoint": "https://audius-content-2.cultur3stake.com",
    "delegateOwnerWallet": "0x2e9e7A4e35C3136fB651a0dBF8f91c9f5C27BBf7"
  }, {
    "endpoint": "https://audius-content-3.cultur3stake.com",
    "delegateOwnerWallet": "0x742da6cAc2782FeA961bB7B9150a048F5167D1e1"
  }, {
    "endpoint": "https://audius-content-4.cultur3stake.com",
    "delegateOwnerWallet": "0xcbb0cE7481685587b0988195Ff0cD6AA1A701657"
  }, {
    "endpoint": "https://audius-content-5.cultur3stake.com",
    "delegateOwnerWallet": "0xFec4708155277D35d568aD6Ca322262577683584"
  }, {
    "endpoint": "https://audius-content-6.cultur3stake.com",
    "delegateOwnerWallet": "0x3Db0E61591063310eEd22fd57E6f7F1ab2Bb538E"
  }, {
    "endpoint": "https://audius-content-7.cultur3stake.com",
    "delegateOwnerWallet": "0xE6C00e7E8d582fD2856718a5439f1aeEB68e27E5"
  }, {
    "endpoint": "https://blockdaemon-audius-content-02.bdnodes.net",
    "delegateOwnerWallet": "0x4Ad694B3fC34b3cC245aF6AA7B43C52ddD0d7AAE"
  }, {
    "endpoint": "https://blockdaemon-audius-content-03.bdnodes.net",
    "delegateOwnerWallet": "0x8ea81225013719950E968DE0602c4Eca458fA9f4"
  }, {
    "endpoint": "https://blockdaemon-audius-content-04.bdnodes.net",
    "delegateOwnerWallet": "0xcfFA8ACF0b04d9278eEE13928be264b2E9aaab97"
  }, {
    "endpoint": "https://blockdaemon-audius-content-05.bdnodes.net",
    "delegateOwnerWallet": "0xB4Ff0cab630FB05a7fcEfec9E979a968b8f4fE55"
  }, {
    "endpoint": "https://blockdaemon-audius-content-06.bdnodes.net",
    "delegateOwnerWallet": "0x7449da7d1548C11c481b87667EC9b2A8F20C13A0"
  }, {
    "endpoint": "https://blockdaemon-audius-content-07.bdnodes.net",
    "delegateOwnerWallet": "0x00B1CA1A34257860f66e742eF163Ad30bF42d075"
  }, {
    "endpoint": "https://blockdaemon-audius-content-08.bdnodes.net",
    "delegateOwnerWallet": "0x16650eDB44C720ea627d5a59ff0b4f74c37fe419"
  }, {
    "endpoint": "https://blockdaemon-audius-content-09.bdnodes.net",
    "delegateOwnerWallet": "0xD5Cfcf4149c683516239fc653D5a470F3F4A606D"
  }, {
    "endpoint": "https://audius-content-8.cultur3stake.com",
    "delegateOwnerWallet": "0xff432F81D0eb77DA5973Cf55e24A897882fdd3E6"
  }, {
    "endpoint": "https://blockchange-audius-content-01.bdnodes.net",
    "delegateOwnerWallet": "0x8464c88502925a0076c381962F8B70b6EC892861"
  }, {
    "endpoint": "https://blockchange-audius-content-02.bdnodes.net",
    "delegateOwnerWallet": "0x5e0D0BeDC11F0B512457f6f707A35703b1447Fb5"
  }, {
    "endpoint": "https://blockchange-audius-content-03.bdnodes.net",
    "delegateOwnerWallet": "0xe3F1c416c3919bB2ffD78F1e38b9E81E8c80815F"
  }, {
    "endpoint": "https://audius-content-9.cultur3stake.com",
    "delegateOwnerWallet": "0xB6f506557B2e9026743FeA6157e52F204D26690F"
  }, {
    "endpoint": "https://audius-content-10.cultur3stake.com",
    "delegateOwnerWallet": "0x2AF4598D3CF95D8e76987c02BC8A8D71F58d49d5"
  }, {
    "endpoint": "https://audius-content-11.cultur3stake.com",
    "delegateOwnerWallet": "0xB2684Cca5281d2bA6D9Ce66Cca215635FF2Ba466"
  }, {
    "endpoint": "https://audius-content-12.cultur3stake.com",
    "delegateOwnerWallet": "0x28924C99822eA08bFCeDdE3a411308633948b349"
  }, {
    "endpoint": "https://audius-content-13.cultur3stake.com",
    "delegateOwnerWallet": "0xcb23908aa0dCDef762ebEaA38391D8fFC69E6e8F"
  }, {
    "endpoint": "https://audius-content-14.cultur3stake.com",
    "delegateOwnerWallet": "0xCbDa351492e52fdb2f0E7FBc440cA2047738b71C"
  }, {
    "endpoint": "https://audius-content-15.cultur3stake.com",
    "delegateOwnerWallet": "0x2fE2652296c40BB22D33C6379558Bf63A25b4f9a"
  }, {
    "endpoint": "https://audius-content-16.cultur3stake.com",
    "delegateOwnerWallet": "0x47367ED3Db5D9691d866cb09545DE7cccD571579"
  }, {
    "endpoint": "https://audius-content-17.cultur3stake.com",
    "delegateOwnerWallet": "0xb472c555Ab9eA1D33543383d6d1F8885c97eF83A"
  }, {
    "endpoint": "https://audius-content-18.cultur3stake.com",
    "delegateOwnerWallet": "0x4F62C17Dc54E58289354847974E1F246c8EAcf11"
  }, {
    "endpoint": "https://audius-content-12.figment.io",
    "delegateOwnerWallet": "0x780641e157621621658F118375dc1B36Ea514d46"
  }, {
    "endpoint": "https://cn0.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0xf9b373E223b73473C59034072263f52aEF60133B"
  }, {
    "endpoint": "https://cn1.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0x9b0D01bd7F01BD6916Ba139743Ce9C524B9375Dd"
  }, {
    "endpoint": "https://cn2.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0xf6e297203c0086dc229DAE17F5b61a15F42A1A00"
  }, {
    "endpoint": "https://cn3.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0x24C4b2cb6eC4c87a03F66723d8750dbe98Fa3e4f"
  }, {
    "endpoint": "https://audius-content-13.figment.io",
    "delegateOwnerWallet": "0x33a2da466B14990E0124383204b06F9196f62d8e"
  }, {
    "endpoint": "https://audius-content-14.figment.io",
    "delegateOwnerWallet": "0x817c513C1B702eA0BdD4F8C1204C60372f715006"
  }, {
    "endpoint": "https://cn4.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0x69e749266C59757dA81F8C659Be6B07ce5Bac6C9"
  }, {
    "endpoint": "https://audius-content-1.jollyworld.xyz",
    "delegateOwnerWallet": "0x125A9f40CFB329266ef415b9510D4E716Dba8Da6"
  }, {
    "endpoint": "https://audius-creator-1.theblueprint.xyz",
    "delegateOwnerWallet": "0x0E0aF7035581C615d07372be16D99A9B64E5B2e9"
  }, {
    "endpoint": "https://audius-creator-2.theblueprint.xyz",
    "delegateOwnerWallet": "0x3D0dD2Cd46c2658d228769f4a394662946A28987"
  }, {
    "endpoint": "https://audius-creator-3.theblueprint.xyz",
    "delegateOwnerWallet": "0x292B0d5987a7DE879909C48a54f0853C211da5f3"
  }, {
    "endpoint": "https://audius-creator-4.theblueprint.xyz",
    "delegateOwnerWallet": "0xA815f8108C2772D24D7DCB866c861148f043224D"
  }, {
    "endpoint": "https://audius-creator-5.theblueprint.xyz",
    "delegateOwnerWallet": "0x65Fe5BEf65A0E0b0520d6beE7767ea6Da7f792f6"
  }, {
    "endpoint": "https://audius-creator-6.theblueprint.xyz",
    "delegateOwnerWallet": "0x19B026B0f0Dbf619DBf8C4Efb0190308ace56366"
  }, {
    "endpoint": "https://creatornode.audius8.prod-eks-ap-northeast-1.staked.cloud",
    "delegateOwnerWallet": "0xc69F344FCDbc9D747559c968562f682ABfBa442C"
  }],
  "web3ProviderUrl": "https://poa-gateway.audius.co",
  "entityManagerContractAddress": "0x1Cd8a543596D499B9b6E7a6eC15ECd2B7857Fd64",
  "identityServiceUrl": "https://identityservice.audius.co"
};

var DEFAULT_LOG_LEVEL = 'warn';
var DEFAULT_LOG_PREFIX = '[audius-sdk]';
var logLevels = ['debug', 'info', 'warn', 'error'];
var Logger = /*#__PURE__*/function () {
  function Logger(config) {
    var _config$logLevel, _config$logPrefix;

    _classCallCheck$1(this, Logger);

    _defineProperty$4(this, "logLevel", void 0);

    _defineProperty$4(this, "logPrefix", '[audius-sdk]');

    this.logLevel = (_config$logLevel = config === null || config === void 0 ? void 0 : config.logLevel) !== null && _config$logLevel !== void 0 ? _config$logLevel : DEFAULT_LOG_LEVEL;
    this.logPrefix = (_config$logPrefix = config === null || config === void 0 ? void 0 : config.logPrefix) !== null && _config$logPrefix !== void 0 ? _config$logPrefix : DEFAULT_LOG_PREFIX;
  }

  _createClass$1(Logger, [{
    key: "createPrefixedLogger",
    value: function createPrefixedLogger(logPrefix) {
      return new Logger({
        logLevel: this.logLevel,
        logPrefix: "".concat(this.logPrefix).concat(logPrefix)
      });
    }
  }, {
    key: "debug",
    value: function debug() {
      var _console;

      if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('debug')) {
        return;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_console = console).debug.apply(_console, [this.logPrefix].concat(args));
    }
  }, {
    key: "info",
    value: function info() {
      var _console2;

      if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('info')) {
        return;
      }

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      (_console2 = console).info.apply(_console2, [this.logPrefix].concat(args));
    }
  }, {
    key: "warn",
    value: function warn() {
      var _console3;

      if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('warn')) {
        return;
      }

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      (_console3 = console).warn.apply(_console3, [this.logPrefix].concat(args));
    }
  }, {
    key: "error",
    value: function error() {
      var _console4;

      if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('error')) {
        return;
      }

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      (_console4 = console).error.apply(_console4, [this.logPrefix].concat(args));
    }
  }]);

  return Logger;
}();

/**
 * The name of the service for Discovery Node
 */

var DISCOVERY_SERVICE_NAME = 'discovery-node';
var defaultDiscoveryNodeSelectorConfig = {
  initialSelectedNode: null,
  blocklist: null,
  allowlist: null,
  maxConcurrentRequests: 6,
  requestTimeout: 30000,
  unhealthyTTL: 3600000,
  backupsTTL: 120000,
  healthCheckThresholds: {
    minVersion: servicesConfig.minVersion,
    maxSlotDiffPlays: null,
    maxBlockDiff: 15
  },
  bootstrapServices: servicesConfig.discoveryNodes,
  logger: new Logger()
};

var isFullFlaskResponse = function isFullFlaskResponse(data) {
  return data.version !== undefined;
};
var isCommsResponse = function isCommsResponse(data) {
  return data.health !== undefined;
};

var isIndexerHealthy = function isIndexerHealthy(_ref) {
  var data = _ref.data,
      maxBlockDiff = _ref.maxBlockDiff;
  return data.block_difference === undefined || data.block_difference === null || data.block_difference <= maxBlockDiff;
};

var isApiIndexerHealthy = function isApiIndexerHealthy(_ref2) {
  var data = _ref2.data,
      maxBlockDiff = _ref2.maxBlockDiff;
  return data.latest_chain_block === null || data.latest_indexed_block === null || data.latest_chain_block === undefined || data.latest_indexed_block === undefined || data.latest_chain_block - data.latest_indexed_block <= maxBlockDiff;
};

var isSolanaIndexerHealthy = function isSolanaIndexerHealthy(_ref3) {
  var _data$plays, _data$rewards_manager, _data$spl_audio_info, _data$user_bank, _data$plays2, _data$plays2$tx_info, _data$plays3, _data$plays3$tx_info;

  var data = _ref3.data,
      maxSlotDiffPlays = _ref3.maxSlotDiffPlays;
  return !((_data$plays = data.plays) !== null && _data$plays !== void 0 && _data$plays.is_unhealthy) && !((_data$rewards_manager = data.rewards_manager) !== null && _data$rewards_manager !== void 0 && _data$rewards_manager.is_unhealthy) && !((_data$spl_audio_info = data.spl_audio_info) !== null && _data$spl_audio_info !== void 0 && _data$spl_audio_info.is_unhealthy) && !((_data$user_bank = data.user_bank) !== null && _data$user_bank !== void 0 && _data$user_bank.is_unhealthy) && (!((_data$plays2 = data.plays) !== null && _data$plays2 !== void 0 && (_data$plays2$tx_info = _data$plays2.tx_info) !== null && _data$plays2$tx_info !== void 0 && _data$plays2$tx_info.slot_diff) || maxSlotDiffPlays === null || ((_data$plays3 = data.plays) === null || _data$plays3 === void 0 ? void 0 : (_data$plays3$tx_info = _data$plays3.tx_info) === null || _data$plays3$tx_info === void 0 ? void 0 : _data$plays3$tx_info.slot_diff) <= maxSlotDiffPlays);
};

var isApiSolanaIndexerHealthy = function isApiSolanaIndexerHealthy(_ref4) {
  var data = _ref4.data,
      maxSlotDiffPlays = _ref4.maxSlotDiffPlays;
  return !maxSlotDiffPlays || !data.latest_chain_slot_plays || !data.latest_indexed_slot_plays || data.latest_chain_slot_plays - data.latest_indexed_slot_plays <= maxSlotDiffPlays;
}; // const isApiCommsHealthy = ({ data }: { data: CommsResponse }) => {
//   return data.health?.is_healthy
// }


var parseApiHealthStatusReason = function parseApiHealthStatusReason(_ref5) {
  var data = _ref5.data,
      _ref5$healthCheckThre = _ref5.healthCheckThresholds,
      minVersion = _ref5$healthCheckThre.minVersion,
      maxBlockDiff = _ref5$healthCheckThre.maxBlockDiff,
      maxSlotDiffPlays = _ref5$healthCheckThre.maxSlotDiffPlays;

  if (isFullFlaskResponse(data)) {
    var _data$version;

    if (((_data$version = data.version) === null || _data$version === void 0 ? void 0 : _data$version.service) !== DISCOVERY_SERVICE_NAME) {
      return {
        health: HealthCheckStatus.UNHEALTHY,
        reason: 'name'
      };
    }

    if (minVersion) {
      if (!data.version.version) {
        return {
          health: HealthCheckStatus.UNHEALTHY,
          reason: 'version'
        };
      }

      if (semver.lt(data.version.version, minVersion)) {
        return {
          health: HealthCheckStatus.BEHIND,
          reason: 'version'
        };
      }
    }

    if (!isApiIndexerHealthy({
      data: data,
      maxBlockDiff: maxBlockDiff
    })) {
      return {
        health: HealthCheckStatus.BEHIND,
        reason: 'block diff'
      };
    }

    if (!isApiSolanaIndexerHealthy({
      data: data,
      maxSlotDiffPlays: maxSlotDiffPlays
    })) {
      return {
        health: HealthCheckStatus.BEHIND,
        reason: 'slot diff'
      };
    }
  } else if (isCommsResponse(data)) ;

  return {
    health: HealthCheckStatus.HEALTHY
  };
};

var getHealthCheckData = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(endpoint, fetchOptions) {
    var healthCheckURL, data, comms, response, json;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            healthCheckURL = "".concat(endpoint, "/health_check");
            data = null;
            comms = null;
            _context.next = 5;
            return fetch$1(healthCheckURL, fetchOptions);

          case 5:
            response = _context.sent;

            if (response.ok) {
              _context.next = 8;
              break;
            }

            throw new Error(response.statusText);

          case 8:
            _context.next = 10;
            return response.json();

          case 10:
            json = _context.sent;
            data = json.data;
            comms = json.comms;

            if (data) {
              _context.next = 15;
              break;
            }

            throw new Error('data');

          case 15:
            if (comms) {
              _context.next = 17;
              break;
            }

            throw new Error('comms');

          case 17:
            return _context.abrupt("return", {
              data: data,
              comms: comms
            });

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getHealthCheckData(_x, _x2) {
    return _ref6.apply(this, arguments);
  };
}();

var parseHealthStatusReason = function parseHealthStatusReason(_ref7) {
  var data = _ref7.data,
      comms = _ref7.comms,
      _ref7$healthCheckThre = _ref7.healthCheckThresholds,
      minVersion = _ref7$healthCheckThre.minVersion,
      maxBlockDiff = _ref7$healthCheckThre.maxBlockDiff,
      maxSlotDiffPlays = _ref7$healthCheckThre.maxSlotDiffPlays;

  if (data === null) {
    return {
      health: HealthCheckStatus.UNHEALTHY,
      reason: 'data'
    };
  }

  if (data.service !== DISCOVERY_SERVICE_NAME) {
    return {
      health: HealthCheckStatus.UNHEALTHY,
      reason: 'name'
    };
  }

  if (!(comms !== null && comms !== void 0 && comms.healthy)) {
    return {
      health: HealthCheckStatus.UNHEALTHY,
      reason: 'comms'
    };
  }

  if (minVersion) {
    if (!data.version) {
      return {
        health: HealthCheckStatus.UNHEALTHY,
        reason: 'version'
      };
    }

    if (semver.lt(data.version, minVersion)) {
      return {
        health: HealthCheckStatus.BEHIND,
        reason: 'version'
      };
    }
  }

  if (!isIndexerHealthy({
    data: data,
    maxBlockDiff: maxBlockDiff
  })) {
    return {
      health: HealthCheckStatus.BEHIND,
      reason: 'block diff'
    };
  }

  if (!isSolanaIndexerHealthy({
    data: data,
    maxSlotDiffPlays: maxSlotDiffPlays
  })) {
    return {
      health: HealthCheckStatus.BEHIND,
      reason: 'slot diff'
    };
  }

  return {
    health: HealthCheckStatus.HEALTHY
  };
};
var getDiscoveryNodeHealthCheck = /*#__PURE__*/function () {
  var _ref9 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref8) {
    var endpoint, healthCheckThresholds, fetchOptions, timeoutMs, timeoutPromises, timeoutPromise, _yield$Promise$race, data, comms, reason;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            endpoint = _ref8.endpoint, healthCheckThresholds = _ref8.healthCheckThresholds, fetchOptions = _ref8.fetchOptions, timeoutMs = _ref8.timeoutMs;
            timeoutPromises = [];

            if (timeoutMs !== undefined) {
              timeoutPromise = new Promise(function (_resolve, reject) {
                return setTimeout(function () {
                  return reject(new Error('timeout'));
                }, timeoutMs);
              });
              timeoutPromises.push(timeoutPromise);
            }

            _context2.prev = 3;
            _context2.next = 6;
            return Promise.race([getHealthCheckData(endpoint, fetchOptions)].concat(timeoutPromises));

          case 6:
            _yield$Promise$race = _context2.sent;
            data = _yield$Promise$race.data;
            comms = _yield$Promise$race.comms;
            reason = parseHealthStatusReason({
              data: data,
              comms: comms,
              healthCheckThresholds: healthCheckThresholds
            });
            return _context2.abrupt("return", _objectSpread2(_objectSpread2({}, reason), {}, {
              data: data
            }));

          case 13:
            _context2.prev = 13;
            _context2.t0 = _context2["catch"](3);
            return _context2.abrupt("return", {
              health: HealthCheckStatus.UNHEALTHY,
              reason: _context2.t0 === null || _context2.t0 === void 0 ? void 0 : _context2.t0.message,
              data: null
            });

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 13]]);
  }));

  return function getDiscoveryNodeHealthCheck(_x3) {
    return _ref9.apply(this, arguments);
  };
}();

/**
 * Polyfill for Promise.any
 * Adapted from Sergio Tskhovrebov's implementation:
 * https://dev.to/sinxwal/looking-for-promise-any-let-s-quickly-implement-a-polyfill-for-it-1kga
 */
var promiseAny = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(iterable) {
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!Promise.any) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt("return", Promise.any(iterable));

          case 2:
            _context4.next = 4;
            return Promise.all(_toConsumableArray(iterable).map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(promise) {
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return new Promise(function (resolve, reject) {
                          Promise.resolve(promise).then(reject, resolve);
                        });

                      case 2:
                        return _context.abrupt("return", _context.sent);

                      case 3:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x2) {
                return _ref2.apply(this, arguments);
              };
            }())).then( /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(errors) {
                return regeneratorRuntime.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return Promise.reject(errors);

                      case 2:
                        return _context2.abrupt("return", _context2.sent);

                      case 3:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));

              return function (_x3) {
                return _ref3.apply(this, arguments);
              };
            }(), /*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(value) {
                return regeneratorRuntime.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.next = 2;
                        return Promise.resolve(value);

                      case 2:
                        return _context3.abrupt("return", _context3.sent);

                      case 3:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function (_x4) {
                return _ref4.apply(this, arguments);
              };
            }());

          case 4:
            return _context4.abrupt("return", _context4.sent);

          case 5:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function promiseAny(_x) {
    return _ref.apply(this, arguments);
  };
}();

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */

function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}

var _listCacheClear = listCacheClear$1;

var eq$2 = eq_1;
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function assocIndexOf$4(array, key) {
  var length = array.length;

  while (length--) {
    if (eq$2(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

var _assocIndexOf = assocIndexOf$4;

var assocIndexOf$3 = _assocIndexOf;
/** Used for built-in method references. */

var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete$1(key) {
  var data = this.__data__,
      index = assocIndexOf$3(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

var _listCacheDelete = listCacheDelete$1;

var assocIndexOf$2 = _assocIndexOf;
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function listCacheGet$1(key) {
  var data = this.__data__,
      index = assocIndexOf$2(data, key);
  return index < 0 ? undefined : data[index][1];
}

var _listCacheGet = listCacheGet$1;

var assocIndexOf$1 = _assocIndexOf;
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}

var _listCacheHas = listCacheHas$1;

var assocIndexOf = _assocIndexOf;
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */

function listCacheSet$1(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

var _listCacheSet = listCacheSet$1;

var listCacheClear = _listCacheClear,
    listCacheDelete = _listCacheDelete,
    listCacheGet = _listCacheGet,
    listCacheHas = _listCacheHas,
    listCacheSet = _listCacheSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache$4(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype['delete'] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;

var ListCache$3 = _ListCache;
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */

function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}

var _stackClear = stackClear$1;

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function stackDelete$1(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

var _stackDelete = stackDelete$1;

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function stackGet$1(key) {
  return this.__data__.get(key);
}

var _stackGet = stackGet$1;

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function stackHas$1(key) {
  return this.__data__.has(key);
}

var _stackHas = stackHas$1;

var root$2 = _root;
/** Used to detect overreaching core-js shims. */

var coreJsData$1 = root$2['__core-js_shared__'];
var _coreJsData = coreJsData$1;

var coreJsData = _coreJsData;
/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

var _isMasked = isMasked$1;

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$2 = funcProto$2.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

var _toSource = toSource$1;

var isFunction$1 = isFunction_1,
    isMasked = _isMasked,
    isObject$4 = isObject_1,
    toSource = _toSource;
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto$1 = Function.prototype,
    objectProto$5 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$1 = funcProto$1.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$5).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative$1(value) {
  if (!isObject$4(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

var _baseIsNative = baseIsNative$1;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

function getValue$1(object, key) {
  return object == null ? undefined : object[key];
}

var _getValue = getValue$1;

var baseIsNative = _baseIsNative,
    getValue = _getValue;
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */

function getNative$3(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

var _getNative = getNative$3;

var getNative$2 = _getNative,
    root$1 = _root;
/* Built-in method references that are verified to be native. */

var Map$3 = getNative$2(root$1, 'Map');
var _Map = Map$3;

var getNative$1 = _getNative;
/* Built-in method references that are verified to be native. */

var nativeCreate$4 = getNative$1(Object, 'create');
var _nativeCreate = nativeCreate$4;

var nativeCreate$3 = _nativeCreate;
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */

function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}

var _hashClear = hashClear$1;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var _hashDelete = hashDelete$1;

var nativeCreate$2 = _nativeCreate;
/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto$4 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet$1(key) {
  var data = this.__data__;

  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }

  return hasOwnProperty$4.call(data, key) ? data[key] : undefined;
}

var _hashGet = hashGet$1;

var nativeCreate$1 = _nativeCreate;
/** Used for built-in method references. */

var objectProto$3 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$3.call(data, key);
}

var _hashHas = hashHas$1;

var nativeCreate = _nativeCreate;
/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

var _hashSet = hashSet$1;

var hashClear = _hashClear,
    hashDelete = _hashDelete,
    hashGet = _hashGet,
    hashHas = _hashHas,
    hashSet = _hashSet;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash$1(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash$1.prototype.clear = hashClear;
Hash$1.prototype['delete'] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;

var Hash = _Hash,
    ListCache$2 = _ListCache,
    Map$2 = _Map;
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */

function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map$2 || ListCache$2)(),
    'string': new Hash()
  };
}

var _mapCacheClear = mapCacheClear$1;

function isKeyable$1(value) {
  var type = _typeof(value);

  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

var _isKeyable = isKeyable$1;

var isKeyable = _isKeyable;
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */

function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

var _getMapData = getMapData$4;

var getMapData$3 = _getMapData;
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

var _mapCacheDelete = mapCacheDelete$1;

var getMapData$2 = _getMapData;
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}

var _mapCacheGet = mapCacheGet$1;

var getMapData$1 = _getMapData;
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}

var _mapCacheHas = mapCacheHas$1;

var getMapData = _getMapData;
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */

function mapCacheSet$1(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

var _mapCacheSet = mapCacheSet$1;

var mapCacheClear = _mapCacheClear,
    mapCacheDelete = _mapCacheDelete,
    mapCacheGet = _mapCacheGet,
    mapCacheHas = _mapCacheHas,
    mapCacheSet = _mapCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache$1(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache$1.prototype.clear = mapCacheClear;
MapCache$1.prototype['delete'] = mapCacheDelete;
MapCache$1.prototype.get = mapCacheGet;
MapCache$1.prototype.has = mapCacheHas;
MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1;

var ListCache$1 = _ListCache,
    Map$1 = _Map,
    MapCache = _MapCache;
/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet$1(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache$1) {
    var pairs = data.__data__;

    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

var _stackSet = stackSet$1;

var ListCache = _ListCache,
    stackClear = _stackClear,
    stackDelete = _stackDelete,
    stackGet = _stackGet,
    stackHas = _stackHas,
    stackSet = _stackSet;
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Stack$1(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack$1.prototype.clear = stackClear;
Stack$1.prototype['delete'] = stackDelete;
Stack$1.prototype.get = stackGet;
Stack$1.prototype.has = stackHas;
Stack$1.prototype.set = stackSet;
var _Stack = Stack$1;

var getNative = _getNative;

var defineProperty$2 = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

var _defineProperty = defineProperty$2;

var defineProperty$1 = _defineProperty;
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function baseAssignValue$3(object, key, value) {
  if (key == '__proto__' && defineProperty$1) {
    defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

var _baseAssignValue = baseAssignValue$3;

var baseAssignValue$2 = _baseAssignValue,
    eq$1 = eq_1;
/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignMergeValue$2(object, key, value) {
  if (value !== undefined && !eq$1(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}

var _assignMergeValue = assignMergeValue$2;

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

function createBaseFor$1(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

var _createBaseFor = createBaseFor$1;

var createBaseFor = _createBaseFor;
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */

var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;

var _cloneBuffer = {exports: {}};

(function (module, exports) {
  var root = _root;
  /** Detect free variable `exports`. */

  var freeExports = exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Built-in value references. */

  var Buffer = moduleExports ? root.Buffer : undefined,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */

  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }

    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }

  module.exports = cloneBuffer;
})(_cloneBuffer, _cloneBuffer.exports);

var root = _root;
/** Built-in value references. */

var Uint8Array$2 = root.Uint8Array;
var _Uint8Array = Uint8Array$2;

var Uint8Array$1 = _Uint8Array;
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */

function cloneArrayBuffer$1(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}

var _cloneArrayBuffer = cloneArrayBuffer$1;

var cloneArrayBuffer = _cloneArrayBuffer;
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */

function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

var _cloneTypedArray = cloneTypedArray$1;

var isObject$3 = isObject_1;
/** Built-in value references. */

var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate$1 = function () {
  function object() {}

  return function (proto) {
    if (!isObject$3(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

var _baseCreate = baseCreate$1;

var overArg = _overArg;
/** Built-in value references. */

var getPrototype$2 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$2;

var baseCreate = _baseCreate,
    getPrototype$1 = _getPrototype,
    isPrototype$1 = _isPrototype;
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneObject$1(object) {
  return typeof object.constructor == 'function' && !isPrototype$1(object) ? baseCreate(getPrototype$1(object)) : {};
}

var _initCloneObject = initCloneObject$1;

var isArrayLike$1 = isArrayLike_1,
    isObjectLike$1 = isObjectLike_1;
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */

function isArrayLikeObject$1(value) {
  return isObjectLike$1(value) && isArrayLike$1(value);
}

var isArrayLikeObject_1 = isArrayLikeObject$1;

var baseGetTag = _baseGetTag,
    getPrototype = _getPrototype,
    isObjectLike = isObjectLike_1;
/** `Object#toString` result references. */

var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto$2 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject$1(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty$2.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

var isPlainObject_1 = isPlainObject$1;

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

function safeGet$2(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

var _safeGet = safeGet$2;

var baseAssignValue$1 = _baseAssignValue,
    eq = eq_1;
/** Used for built-in method references. */

var objectProto$1 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue$1(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty$1.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue$1(object, key, value);
  }
}

var _assignValue = assignValue$1;

var assignValue = _assignValue,
    baseAssignValue = _baseAssignValue;
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */

function copyObject$1(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

var _copyObject = copyObject$1;

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function nativeKeysIn$1(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

var _nativeKeysIn = nativeKeysIn$1;

var isObject$2 = isObject_1,
    isPrototype = _isPrototype,
    nativeKeysIn = _nativeKeysIn;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn$1(object) {
  if (!isObject$2(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

var _baseKeysIn = baseKeysIn$1;

var arrayLikeKeys = _arrayLikeKeys,
    baseKeysIn = _baseKeysIn,
    isArrayLike = isArrayLike_1;
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */

function keysIn$2(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

var keysIn_1 = keysIn$2;

var copyObject = _copyObject,
    keysIn$1 = keysIn_1;
/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */

function toPlainObject$1(value) {
  return copyObject(value, keysIn$1(value));
}

var toPlainObject_1 = toPlainObject$1;

var assignMergeValue$1 = _assignMergeValue,
    cloneBuffer = _cloneBuffer.exports,
    cloneTypedArray = _cloneTypedArray,
    copyArray = _copyArray,
    initCloneObject = _initCloneObject,
    isArguments$1 = isArguments_1,
    isArray$1 = isArray_1,
    isArrayLikeObject = isArrayLikeObject_1,
    isBuffer = isBuffer$2.exports,
    isFunction = isFunction_1,
    isObject$1 = isObject_1,
    isPlainObject = isPlainObject_1,
    isTypedArray = isTypedArray_1,
    safeGet$1 = _safeGet,
    toPlainObject = toPlainObject_1;
/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key),
      srcValue = safeGet$1(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray$1(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray$1(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;

      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$1(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue$1(object, key, newValue);
}

var _baseMergeDeep = baseMergeDeep$1;

var Stack = _Stack,
    assignMergeValue = _assignMergeValue,
    baseFor = _baseFor,
    baseMergeDeep = _baseMergeDeep,
    isObject = isObject_1,
    keysIn = keysIn_1,
    safeGet = _safeGet;
/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    stack || (stack = new Stack());

    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

var _baseMerge = baseMerge$1;

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */

function identity$2(value) {
  return value;
}

var identity_1 = identity$2;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */

function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

var _apply = apply$1;

var apply = _apply;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest$1(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

var _overRest = overRest$1;

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */

function constant$1(value) {
  return function () {
    return value;
  };
}

var constant_1 = constant$1;

var constant = constant_1,
    defineProperty = _defineProperty,
    identity$1 = identity_1;
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var baseSetToString$1 = !defineProperty ? identity$1 : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
var _baseSetToString = baseSetToString$1;

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut$1(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

var _shortOut = shortOut$1;

var baseSetToString = _baseSetToString,
    shortOut = _shortOut;
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var setToString$1 = shortOut(baseSetToString);
var _setToString = setToString$1;

var identity = identity_1,
    overRest = _overRest,
    setToString = _setToString;
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */

function baseRest$1(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

var _baseRest = baseRest$1;

var baseRest = _baseRest,
    isIterateeCall = _isIterateeCall;
/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */

function createAssigner$1(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

var _createAssigner = createAssigner$1;

var baseMerge = _baseMerge,
    createAssigner = _createAssigner;
/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */

var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});
var mergeWith_1 = mergeWith;

/**
 * Gets the config with any undefined properties replaced by the defaults
 * @param config the config
 * @param defaults the defaults
 * @returns the merged config with defaults
 */

var mergeConfigWithDefaults = function mergeConfigWithDefaults(config, defaults) {
  return mergeWith_1({}, defaults, config, function (_a, b) {
    if (Array.isArray(b)) {
      return b;
    }

    return undefined;
  });
};

var getPathFromUrl = function getPathFromUrl(url) {
  var pathRegex = /^([a-z]+:\/\/)?(?:www\.)?([^/]+)?(.*)$/;
  var match = url.match(pathRegex);

  if (match !== null && match !== void 0 && match[3]) {
    var path = match[3];
    return path;
  } else {
    throw new Error("Invalid URL, couldn't get path.");
  }
};

var DiscoveryNodeSelector = /*#__PURE__*/function () {
  function DiscoveryNodeSelector(config) {
    var _this$config$allowlis, _this$config$blocklis;

    _classCallCheck$1(this, DiscoveryNodeSelector);

    _defineProperty$4(this, "services", void 0);

    _defineProperty$4(this, "selectedNode", void 0);

    _defineProperty$4(this, "config", void 0);

    _defineProperty$4(this, "_isBehind", void 0);

    _defineProperty$4(this, "unhealthyServices", void 0);

    _defineProperty$4(this, "backupServices", void 0);

    _defineProperty$4(this, "unhealthyCleanupTimeout", null);

    _defineProperty$4(this, "backupCleanupTimeout", null);

    _defineProperty$4(this, "reselectLock", false);

    _defineProperty$4(this, "eventEmitter", void 0);

    _defineProperty$4(this, "addEventListener", void 0);

    _defineProperty$4(this, "removeEventListener", void 0);

    _defineProperty$4(this, "logger", void 0);

    this.config = mergeConfigWithDefaults(config, defaultDiscoveryNodeSelectorConfig);
    this.services = this.config.bootstrapServices;
    this._isBehind = false;
    this.unhealthyServices = new Set([]);
    this.backupServices = {};
    this.selectedNode = this.config.initialSelectedNode && (!this.config.allowlist || (_this$config$allowlis = this.config.allowlist) !== null && _this$config$allowlis !== void 0 && _this$config$allowlis.has(this.config.initialSelectedNode)) && !((_this$config$blocklis = this.config.blocklist) !== null && _this$config$blocklis !== void 0 && _this$config$blocklis.has(this.config.initialSelectedNode)) ? this.config.initialSelectedNode : null;
    this.eventEmitter = new EventEmitter$1(); // Potentially need many event listeners for discovery reselection (to prevent race condition)

    this.eventEmitter.setMaxListeners(1000);
    this.addEventListener = this.eventEmitter.addListener.bind(this.eventEmitter);
    this.removeEventListener = this.eventEmitter.removeListener.bind(this.eventEmitter);
    this.logger = this.config.logger.createPrefixedLogger('[discovery-node-selector]');
  }
  /**
   * Updates the config.
   * Note that setting the initial node or bootstrap nodes here does nothing as the service is already initialized.
   * Will force reselections if health check thresholds change (as that might cause the current node to be considered unhealthy)
   * or if the selected node is excluded per allow/blocklists
   */


  _createClass$1(DiscoveryNodeSelector, [{
    key: "isBehind",
    get:
    /**
     * List of services to select from
     */

    /**
     * Currently selected discovery node
     */

    /**
     * Configuration passed in by consumer (with defaults)
     */

    /**
     * Whether or not we are using a backup, meaning we were
     * unable to select a discovery node that was up-to-date and healthy.
     * Clients may want to consider blocking writes as service may be degraded
     */
    function get() {
      return this._isBehind;
    },
    set: function set(isBehind) {
      if (isBehind && !this._isBehind) {
        this.logger.warn('using behind discovery node', this.selectedNode);
      } else if (!isBehind && this._isBehind) {
        this.logger.info('discovery node no longer behind', this.selectedNode);
      }

      this._isBehind = isBehind;
    }
    /**
     * During selection, services that fail health check will be put in this list
     * so that we try different nodes on new rounds of selection
     */

  }, {
    key: "updateConfig",
    value: function updateConfig(config) {
      this.config = mergeConfigWithDefaults(config, this.config);

      if (this.selectedNode) {
        var _config$blocklist;

        if (config.healthCheckThresholds) {
          this.selectedNode = null;
        } else if (config.allowlist && !config.allowlist.has(this.selectedNode)) {
          this.selectedNode = null;
        } else if ((_config$blocklist = config.blocklist) !== null && _config$blocklist !== void 0 && _config$blocklist.has(this.selectedNode)) {
          this.selectedNode = null;
        }
      }
    }
    /**
     * Returns a middleware that reselects if the current discovery node is behind
     * @returns the middleware
     */

  }, {
    key: "createMiddleware",
    value: function createMiddleware() {
      var _this = this;

      return {
        pre: function () {
          var _pre = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(context) {
            var url, endpoint;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    url = context.url;

                    if (url.startsWith('http')) {
                      _context.next = 6;
                      break;
                    }

                    _context.next = 4;
                    return _this.getSelectedEndpoint();

                  case 4:
                    endpoint = _context.sent;
                    url = "".concat(endpoint).concat(context.url);

                  case 6:
                    return _context.abrupt("return", {
                      url: url,
                      init: context.init
                    });

                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function pre(_x) {
            return _pre.apply(this, arguments);
          }

          return pre;
        }(),
        post: function () {
          var _post = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(context) {
            var response, endpoint, _data$latest_chain_bl, _data$latest_indexed_, _data$version$version, _data$version, responseClone, data, _parseApiHealthStatus, health, reason, blockDiff, version;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    response = context.response;
                    _context2.next = 3;
                    return _this.getSelectedEndpoint();

                  case 3:
                    endpoint = _context2.sent;

                    if (endpoint) {
                      _context2.next = 9;
                      break;
                    }

                    _context2.next = 7;
                    return _this.select(endpoint);

                  case 7:
                    _context2.next = 24;
                    break;

                  case 9:
                    if (!response.ok) {
                      _context2.next = 21;
                      break;
                    }

                    // Even when successful, copy response to read JSON body to
                    // check for signs the DN is unhealthy and reselect if necessary.
                    // This will get the client to pick new discovery providers
                    // if the selected one falls behind, even if requests are succeeding
                    responseClone = response.clone();
                    _context2.next = 13;
                    return responseClone.json();

                  case 13:
                    data = _context2.sent;
                    _parseApiHealthStatus = parseApiHealthStatusReason({
                      data: data,
                      healthCheckThresholds: _this.config.healthCheckThresholds
                    }), health = _parseApiHealthStatus.health, reason = _parseApiHealthStatus.reason;
                    blockDiff = isFullFlaskResponse(data) ? ((_data$latest_chain_bl = data.latest_chain_block) !== null && _data$latest_chain_bl !== void 0 ? _data$latest_chain_bl : 0) - ((_data$latest_indexed_ = data.latest_indexed_block) !== null && _data$latest_indexed_ !== void 0 ? _data$latest_indexed_ : 0) : 0;
                    version = isFullFlaskResponse(data) ? (_data$version$version = (_data$version = data.version) === null || _data$version === void 0 ? void 0 : _data$version.version) !== null && _data$version$version !== void 0 ? _data$version$version : '' : '';
                    _context2.next = 19;
                    return _this.reselectIfNecessary({
                      endpoint: endpoint,
                      health: health,
                      reason: reason,
                      data: {
                        block_difference: blockDiff,
                        version: version
                      }
                    });

                  case 19:
                    _context2.next = 24;
                    break;

                  case 21:
                    _context2.next = 23;
                    return _this.reselectAndRetry({
                      context: context,
                      endpoint: endpoint
                    });

                  case 23:
                    return _context2.abrupt("return", _context2.sent);

                  case 24:
                    return _context2.abrupt("return", response);

                  case 25:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function post(_x2) {
            return _post.apply(this, arguments);
          }

          return post;
        }(),
        onError: function () {
          var _onError = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(context) {
            var endpoint, response;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return _this.getSelectedEndpoint();

                  case 2:
                    endpoint = _context3.sent;
                    response = context.response;

                    if (endpoint) {
                      _context3.next = 9;
                      break;
                    }

                    _context3.next = 7;
                    return _this.select(endpoint);

                  case 7:
                    _context3.next = 12;
                    break;

                  case 9:
                    _context3.next = 11;
                    return _this.reselectAndRetry({
                      context: context,
                      endpoint: endpoint
                    });

                  case 11:
                    return _context3.abrupt("return", _context3.sent);

                  case 12:
                    return _context3.abrupt("return", response);

                  case 13:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));

          function onError(_x3) {
            return _onError.apply(this, arguments);
          }

          return onError;
        }()
      };
    }
    /**
     * Selects a discovery node or returns the existing selection
     * @returns a discovery node endpoint
     */

  }, {
    key: "getSelectedEndpoint",
    value: function () {
      var _getSelectedEndpoint = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(this.selectedNode !== null)) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return", this.selectedNode);

              case 2:
                _context4.next = 4;
                return this.select(null);

              case 4:
                return _context4.abrupt("return", _context4.sent);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getSelectedEndpoint() {
        return _getSelectedEndpoint.apply(this, arguments);
      }

      return getSelectedEndpoint;
    }()
    /**
     * Gets the list of services
     */

  }, {
    key: "getServices",
    value: function getServices() {
      return this.services;
    }
    /**
     * Finds a healthy discovery node
     * @returns a healthy discovery node endpoint
     */

  }, {
    key: "select",
    value: function () {
      var _select = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(prevSelectedNode) {
        var _this2 = this;

        var decisionTree, services, selectedService, attemptedServicesCount, filteredServices, backup, round;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.reselectLock) {
                  _context5.next = 3;
                  break;
                }

                _context5.next = 3;
                return new Promise(function (resolve) {
                  _this2.eventEmitter.once('reselectAttemptComplete', function () {
                    resolve();
                  });
                });

              case 3:
                if (!(prevSelectedNode !== this.selectedNode && this.selectedNode != null)) {
                  _context5.next = 5;
                  break;
                }

                return _context5.abrupt("return", this.selectedNode);

              case 5:
                this.reselectLock = true;
                _context5.prev = 6;
                this.logger.debug('Selecting new discovery node...');
                decisionTree = []; // Get all the services we have

                services = _toConsumableArray(this.services);
                decisionTree.push({
                  stage: DECISION_TREE_STATE.GET_ALL_SERVICES,
                  val: services
                }); // If a whitelist is provided, filter down to it

                if (this.config.allowlist) {
                  services = services.filter(function (s) {
                    var _this2$config$allowli;

                    return (_this2$config$allowli = _this2.config.allowlist) === null || _this2$config$allowli === void 0 ? void 0 : _this2$config$allowli.has(s);
                  });
                  decisionTree.push({
                    stage: DECISION_TREE_STATE.FILTER_TO_WHITELIST,
                    val: services
                  });
                } // if a blacklist is provided, filter out services in the list


                if (this.config.blocklist) {
                  services = services.filter(function (s) {
                    var _this2$config$blockli;

                    return !((_this2$config$blockli = _this2.config.blocklist) !== null && _this2$config$blockli !== void 0 && _this2$config$blockli.has(s));
                  });
                  decisionTree.push({
                    stage: DECISION_TREE_STATE.FILTER_FROM_BLACKLIST,
                    val: services
                  });
                }

                selectedService = null;
                attemptedServicesCount = 0; // Loop until a healthy node is found, batching health_check requests by maxConcurrentRequests

              case 15:
                if (!(selectedService === null)) {
                  _context5.next = 44;
                  break;
                }

                // Filter out anything we know is already unhealthy
                filteredServices = services.filter(function (s) {
                  return !_this2.unhealthyServices.has(s);
                });
                decisionTree.push({
                  stage: DECISION_TREE_STATE.FILTER_OUT_KNOWN_UNHEALTHY,
                  val: filteredServices
                }); // If there are no services left to try, either pick a backup or return null

                if (!(filteredServices.length === 0)) {
                  _context5.next = 35;
                  break;
                }

                decisionTree.push({
                  stage: DECISION_TREE_STATE.NO_SERVICES_LEFT_TO_TRY
                });

                if (!(Object.keys(this.backupServices).length > 0)) {
                  _context5.next = 30;
                  break;
                }

                _context5.next = 23;
                return this.selectFromBackups();

              case 23:
                backup = _context5.sent;
                decisionTree.push({
                  stage: DECISION_TREE_STATE.SELECTED_FROM_BACKUP,
                  val: backup
                });
                this.selectedNode = backup;
                this.isBehind = true;
                return _context5.abrupt("return", backup);

              case 30:
                // Nothing could be found that was healthy.
                // Reset everything we know so that we might try again.
                this.unhealthyServices = new Set([]);
                this.backupServices = {};
                decisionTree.push({
                  stage: DECISION_TREE_STATE.FAILED_AND_RESETTING
                });
                this.logger.error('Failed to select discovery node', decisionTree);
                return _context5.abrupt("return", null);

              case 35:
                // Randomly sample a "round" to test
                round = sampleSize_1(filteredServices, this.config.maxConcurrentRequests);
                decisionTree.push({
                  stage: DECISION_TREE_STATE.GET_SELECTION_ROUND,
                  val: round
                }); // Race this "round" of services to find the quickest healthy node

                _context5.next = 39;
                return this.anyHealthyEndpoint(round);

              case 39:
                selectedService = _context5.sent;
                attemptedServicesCount += round.length; // Retry if none were found

                if (!selectedService) {
                  decisionTree.push({
                    stage: DECISION_TREE_STATE.ROUND_FAILED_RETRY
                  });
                  this.logger.debug('No healthy services found. Attempting another round...', {
                    attemptedServicesCount: attemptedServicesCount
                  });
                }

                _context5.next = 15;
                break;

              case 44:
                // Trigger a cleanup event for all of the unhealthy and backup services,
                // so they can get retried in the future
                this.triggerCleanup();
                decisionTree.push({
                  stage: DECISION_TREE_STATE.MADE_A_SELECTION,
                  val: selectedService
                }); // If we made it this far, we found the best service! (of the rounds we tried)

                if (selectedService) {
                  this.selectedNode = selectedService;
                  this.eventEmitter.emit('change', selectedService);
                }

                this.logger.info("Selected discprov ".concat(selectedService), decisionTree, {
                  attemptedServicesCount: attemptedServicesCount
                });
                this.isBehind = false;
                return _context5.abrupt("return", this.selectedNode);

              case 50:
                _context5.prev = 50;
                this.reselectLock = false;
                this.eventEmitter.emit('reselectAttemptComplete');
                return _context5.finish(50);

              case 54:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[6,, 50, 54]]);
      }));

      function select(_x4) {
        return _select.apply(this, arguments);
      }

      return select;
    }()
    /**
     * Checks to see if any of the endpoints are healthy, returning the first one that is.
     * Cancels the remaining promises.
     * Uses the configured timeout.
     * Any unhealthy or behind services found are placed into the unhealthy and backup lists respectively
     *
     * @param endpoints the endpoints to race
     * @returns the fastest healthy endpoint or null if none are healthy
     */

  }, {
    key: "anyHealthyEndpoint",
    value: function () {
      var _anyHealthyEndpoint = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(endpoints) {
        var _this3 = this;

        var abortController, requestPromises;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                abortController = new AbortController();
                requestPromises = endpoints.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(endpoint) {
                    var _yield$getDiscoveryNo, health, data, reason, _data$network;

                    return regeneratorRuntime.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.next = 2;
                            return getDiscoveryNodeHealthCheck({
                              endpoint: endpoint,
                              fetchOptions: {
                                signal: abortController.signal
                              },
                              timeoutMs: _this3.config.requestTimeout,
                              healthCheckThresholds: _this3.config.healthCheckThresholds
                            });

                          case 2:
                            _yield$getDiscoveryNo = _context6.sent;
                            health = _yield$getDiscoveryNo.health;
                            data = _yield$getDiscoveryNo.data;
                            reason = _yield$getDiscoveryNo.reason;

                            if (!(health !== HealthCheckStatus.HEALTHY)) {
                              _context6.next = 11;
                              break;
                            }

                            if (reason !== null && reason !== void 0 && reason.toLowerCase().includes('aborted')) {
                              // Ignore aborted requests
                              _this3.logger.debug('health_check', endpoint, health, reason);
                            } else if (health === HealthCheckStatus.UNHEALTHY) {
                              _this3.unhealthyServices.add(endpoint);

                              _this3.logger.debug('health_check', endpoint, health, reason);
                            } else if (health === HealthCheckStatus.BEHIND) {
                              _this3.unhealthyServices.add(endpoint);

                              if (data) {
                                _this3.backupServices[endpoint] = {
                                  endpoint: endpoint,
                                  block_difference: data.block_difference,
                                  version: data.version
                                };
                              }

                              _this3.logger.debug('health_check', endpoint, health, reason);
                            }

                            throw new Error("".concat(endpoint, " ").concat(health, ": ").concat(reason));

                          case 11:
                            // We're healthy!
                            _this3.logger.debug('health_check', endpoint, health); // Cancel any existing requests from other promises


                            abortController.abort(); // Refresh service list with the healthy list from DN

                            if (data !== null && data !== void 0 && (_data$network = data.network) !== null && _data$network !== void 0 && _data$network.discovery_nodes && data.network.discovery_nodes.length > 0) {
                              _this3.services = data.network.discovery_nodes;
                            } else {
                              _this3.logger.warn("Couldn't load new service list from healthy service", endpoint);
                            }

                            return _context6.abrupt("return", endpoint);

                          case 15:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6);
                  }));

                  return function (_x6) {
                    return _ref.apply(this, arguments);
                  };
                }());
                _context7.prev = 2;
                _context7.next = 5;
                return promiseAny(requestPromises);

              case 5:
                return _context7.abrupt("return", _context7.sent);

              case 8:
                _context7.prev = 8;
                _context7.t0 = _context7["catch"](2);
                this.logger.error('No healthy nodes', _context7.t0);
                return _context7.abrupt("return", null);

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[2, 8]]);
      }));

      function anyHealthyEndpoint(_x5) {
        return _anyHealthyEndpoint.apply(this, arguments);
      }

      return anyHealthyEndpoint;
    }()
    /**
     * Checks the given endpoint's health check and reselects if necessary.
     * @param endpoint the endpoint to health_check
     * @returns a new discovery node if reselect was necessary, or the existing endpoint if reselect unnecessary
     */

  }, {
    key: "reselectIfNecessary",
    value: function () {
      var _reselectIfNecessary = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(_ref2) {
        var endpoint, health, reason, data;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                endpoint = _ref2.endpoint, health = _ref2.health, reason = _ref2.reason, data = _ref2.data;

                if (!(health === HealthCheckStatus.HEALTHY)) {
                  _context8.next = 6;
                  break;
                }

                this.isBehind = false;
                return _context8.abrupt("return", endpoint);

              case 6:
                if (!(this.isBehind && HealthCheckStatus.BEHIND)) {
                  _context8.next = 10;
                  break;
                }

                return _context8.abrupt("return", endpoint);

              case 10:
                if (health === HealthCheckStatus.UNHEALTHY || !data) {
                  this.unhealthyServices.add(endpoint);
                } else if (health === HealthCheckStatus.BEHIND) {
                  this.backupServices[endpoint] = {
                    endpoint: endpoint,
                    block_difference: data.block_difference,
                    version: data.version
                  };
                }

                this.logger.warn('api_health_check failed, reselecting', endpoint, health, reason);
                _context8.next = 14;
                return this.select(endpoint);

              case 14:
                return _context8.abrupt("return", _context8.sent);

              case 15:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function reselectIfNecessary(_x7) {
        return _reselectIfNecessary.apply(this, arguments);
      }

      return reselectIfNecessary;
    }()
    /**
     * Sets (or resets) a setTimeout to reset the backup and unhealthy service lists
     */

  }, {
    key: "triggerCleanup",
    value: function triggerCleanup() {
      var _this4 = this;

      if (this.unhealthyCleanupTimeout) {
        clearTimeout(this.unhealthyCleanupTimeout);
      }

      if (this.backupCleanupTimeout) {
        clearTimeout(this.backupCleanupTimeout);
      }

      this.unhealthyCleanupTimeout = setTimeout(function () {
        _this4.unhealthyServices = new Set([]);
      }, this.config.unhealthyTTL);
      this.backupCleanupTimeout = setTimeout(function () {
        _this4.backupServices = {};
      }, this.config.backupsTTL);
    }
    /**
     * First try to get a node that's got a healthy blockdiff, but a behind version.
     * If that fails, get the node with the lowest blockdiff on the most up to date version
     */

  }, {
    key: "selectFromBackups",
    value: function () {
      var _selectFromBackups = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var _this5 = this,
            _goodBlockdiffBadVers;

        var sortedBackups, goodBlockdiffBadVersion, nextBest;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                sortedBackups = Object.values(this.backupServices).sort(function (a, b) {
                  var versionSort = semver.rcompare(a.version, b.version);

                  if (versionSort === 0) {
                    return a.block_difference - b.block_difference;
                  }

                  return versionSort;
                });
                goodBlockdiffBadVersion = sortedBackups.find(function (s) {
                  return s.block_difference <= _this5.config.healthCheckThresholds.maxBlockDiff;
                });
                nextBest = sortedBackups[0];

                if (!(!goodBlockdiffBadVersion && nextBest)) {
                  _context9.next = 5;
                  break;
                }

                return _context9.abrupt("return", nextBest.endpoint);

              case 5:
                return _context9.abrupt("return", (_goodBlockdiffBadVers = goodBlockdiffBadVersion === null || goodBlockdiffBadVersion === void 0 ? void 0 : goodBlockdiffBadVersion.endpoint) !== null && _goodBlockdiffBadVers !== void 0 ? _goodBlockdiffBadVers : null);

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function selectFromBackups() {
        return _selectFromBackups.apply(this, arguments);
      }

      return selectFromBackups;
    }()
  }, {
    key: "reselectAndRetry",
    value: function () {
      var _reselectAndRetry = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(_ref3) {
        var _data$block_differenc, _data$version2;

        var context, endpoint, _yield$getDiscoveryNo2, health, data, reason, newEndpoint, path;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                context = _ref3.context, endpoint = _ref3.endpoint;
                // On request failure, check health_check and reselect if unhealthy
                this.logger.warn('request failed', endpoint, context);
                _context10.next = 4;
                return getDiscoveryNodeHealthCheck({
                  endpoint: endpoint,
                  healthCheckThresholds: this.config.healthCheckThresholds
                });

              case 4:
                _yield$getDiscoveryNo2 = _context10.sent;
                health = _yield$getDiscoveryNo2.health;
                data = _yield$getDiscoveryNo2.data;
                reason = _yield$getDiscoveryNo2.reason;
                _context10.next = 10;
                return this.reselectIfNecessary({
                  endpoint: endpoint,
                  health: health,
                  reason: reason,
                  data: {
                    block_difference: (_data$block_differenc = data === null || data === void 0 ? void 0 : data.block_difference) !== null && _data$block_differenc !== void 0 ? _data$block_differenc : 0,
                    version: (_data$version2 = data === null || data === void 0 ? void 0 : data.version) !== null && _data$version2 !== void 0 ? _data$version2 : ''
                  }
                });

              case 10:
                newEndpoint = _context10.sent;

                if (!(newEndpoint && newEndpoint !== endpoint)) {
                  _context10.next = 22;
                  break;
                }

                _context10.prev = 12;
                path = getPathFromUrl(context.url); // Retry once on new endpoint

                _context10.next = 16;
                return context.fetch("".concat(newEndpoint).concat(path), context.init);

              case 16:
                return _context10.abrupt("return", _context10.sent);

              case 19:
                _context10.prev = 19;
                _context10.t0 = _context10["catch"](12);
                this.logger.error('Retry on new node failed', newEndpoint);

              case 22:
                return _context10.abrupt("return", undefined);

              case 23:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[12, 19]]);
      }));

      function reselectAndRetry(_x8) {
        return _reselectAndRetry.apply(this, arguments);
      }

      return reselectAndRetry;
    }()
  }]);

  return DiscoveryNodeSelector;
}();

var Web3;

if (typeof window !== 'undefined' && window && window.Web3) {
  Web3 = window.Web3;
} else {
  Web3 = require$$0$2;
}

var LibsWeb3 = Web3;

var getSendMethod = function getSendMethod(provider) {
  if ('sendAsync' in provider) {
    return provider.sendAsync;
  }

  return provider.send;
};
/**
 * web3 consumes a provider object on initialization
 * ref: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3/types/index.d.ts#L31
 * which references: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3-core/types/index.d.ts#L436
 * MultiProvider implements HttpProvider which can be consumed by web3
 * ref for HttpProvider: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3-providers-http/types/index.d.ts#L46-L66
 */


var MultiProvider = /*#__PURE__*/function (_Web3$providers$HttpP) {
  _inherits(MultiProvider, _Web3$providers$HttpP);

  var _super = _createSuper(MultiProvider);

  /**
   * Creates a MultiProvider
   * @param {Array<string | Provider> | string} - The providers to use.
   */
  function MultiProvider(providers) {
    var _web3ProviderInstance;

    var _this;

    _classCallCheck$1(this, MultiProvider);

    var web3Providers;

    if (typeof providers === 'string') {
      web3Providers = providers.split(',');
    } else if (!Array.isArray(providers)) {
      web3Providers = [providers];
    } else {
      web3Providers = providers;
    } // The below line ensures that we support different types of providers i.e. comma separated strings, an array of strings or an array of providers.


    var web3ProviderInstances = web3Providers.map(function (provider) {
      return new LibsWeb3(provider).eth.currentProvider;
    });
    _this = _super.call(this, (_web3ProviderInstance = web3ProviderInstances[0]) === null || _web3ProviderInstance === void 0 ? void 0 : _web3ProviderInstance.host);

    _defineProperty$4(_assertThisInitialized(_this), "providers", void 0);

    if (!web3ProviderInstances.every(getSendMethod)) {
      throw new Error('Some providers do not have a send method to use.');
    }

    _this.providers = web3ProviderInstances; // We replace HttpProvider.send with a custom function that supports fallback providers.

    _this.send = util$2.callbackify(_this._send.bind(_assertThisInitialized(_this))); // web3 only supports callback functions and not async

    return _this;
  }
  /**
   * @method _send
   * @param {Object} payload
   */


  _createClass$1(MultiProvider, [{
    key: "_send",
    value: function () {
      var _send2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(payload) {
        var _iterator, _step, provider, send, result;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _iterator = _createForOfIteratorHelper(shuffle(this.providers));
                _context.prev = 1;

                _iterator.s();

              case 3:
                if ((_step = _iterator.n()).done) {
                  _context.next = 18;
                  break;
                }

                provider = _step.value;
                _context.prev = 5;
                send = util$2.promisify(getSendMethod(provider).bind(provider));
                _context.next = 9;
                return send(payload);

              case 9:
                result = _context.sent;
                return _context.abrupt("return", result);

              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](5);
                console.log(_context.t0);

              case 16:
                _context.next = 3;
                break;

              case 18:
                _context.next = 23;
                break;

              case 20:
                _context.prev = 20;
                _context.t1 = _context["catch"](1);

                _iterator.e(_context.t1);

              case 23:
                _context.prev = 23;

                _iterator.f();

                return _context.finish(23);

              case 26:
                throw new Error('All requests failed');

              case 27:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 20, 23, 26], [5, 13]]);
      }));

      function _send(_x) {
        return _send2.apply(this, arguments);
      }

      return _send;
    }()
  }]);

  return MultiProvider;
}(LibsWeb3.providers.HttpProvider);

var uuid = function uuid() {
  // https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/873856#873856
  var s = [];
  var hexDigits = '0123456789abcdef';

  for (var i = 0; i < 36; i++) {
    s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
  }

  s[14] = '4'; // bits 12-15 of the time_hi_and_version field to 0010

  s[19] = hexDigits.substr(s[19] | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01

  s[8] = s[13] = s[18] = s[23] = '-';
  var uuid = s.join('');
  return uuid;
};

var fs = {};

var encode_1 = encode$2;
var MSB = 128,
    REST = 127,
    MSBALL = ~REST,
    INT = Math.pow(2, 31);

function encode$2(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;

  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }

  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }

  out[offset] = num | 0;
  encode$2.bytes = offset - oldOffset + 1;
  return out;
}

var decode$3 = read;
var MSB$1 = 128,
    REST$1 = 127;

function read(buf, offset) {
  var res = 0,
      offset = offset || 0,
      shift = 0,
      counter = offset,
      b,
      l = buf.length;

  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError('Could not decode varint');
    }

    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);

  read.bytes = counter - offset;
  return res;
}

var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);

var length = function length(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};

var varint = {
  encode: encode_1,
  decode: decode$3,
  encodingLength: length
};
var _brrp_varint = varint;

var decode$2 = function decode(data) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var code = _brrp_varint.decode(data, offset);
  return [code, _brrp_varint.decode.bytes];
};
var encodeTo = function encodeTo(_int, target) {
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  _brrp_varint.encode(_int, target, offset);
  return target;
};
var encodingLength = function encodingLength(_int2) {
  return _brrp_varint.encodingLength(_int2);
};

var equals$1 = function equals(aa, bb) {
  if (aa === bb) return true;

  if (aa.byteLength !== bb.byteLength) {
    return false;
  }

  for (var ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }

  return true;
};

var coerce = function coerce(o) {
  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o;
  if (o instanceof ArrayBuffer) return new Uint8Array(o);

  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }

  throw new Error('Unknown type, must be binary type');
};

var create = function create(code, digest) {
  var size = digest.byteLength;
  var sizeOffset = encodingLength(code);
  var digestOffset = sizeOffset + encodingLength(size);
  var bytes = new Uint8Array(digestOffset + size);
  encodeTo(code, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest(code, size, digest, bytes);
};
var decode$1 = function decode(multihash) {
  var bytes = coerce(multihash);

  var _varint$decode = decode$2(bytes),
      _varint$decode2 = _slicedToArray(_varint$decode, 2),
      code = _varint$decode2[0],
      sizeOffset = _varint$decode2[1];

  var _varint$decode3 = decode$2(bytes.subarray(sizeOffset)),
      _varint$decode4 = _slicedToArray(_varint$decode3, 2),
      size = _varint$decode4[0],
      digestOffset = _varint$decode4[1];

  var digest = bytes.subarray(sizeOffset + digestOffset);

  if (digest.byteLength !== size) {
    throw new Error('Incorrect length');
  }

  return new Digest(code, size, digest, bytes);
};
var equals = function equals(a, b) {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && equals$1(a.bytes, b.bytes);
  }
};
var Digest = /*#__PURE__*/_createClass$1(function Digest(code, size, digest, bytes) {
  _classCallCheck$1(this, Digest);

  this.code = code;
  this.size = size;
  this.digest = digest;
  this.bytes = bytes;
});

function base(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError('Alphabet too long');
  }

  var BASE_MAP = new Uint8Array(256);

  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }

  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);

    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + ' is ambiguous');
    }

    BASE_MAP[xc] = i;
  }

  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);

  function encode(source) {
    if (source instanceof Uint8Array) ;else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }

    if (!(source instanceof Uint8Array)) {
      throw new TypeError('Expected Uint8Array');
    }

    if (source.length === 0) {
      return '';
    }

    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;

    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }

    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);

    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i = 0;

      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }

      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }

      length = i;
      pbegin++;
    }

    var it2 = size - length;

    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }

    var str = LEADER.repeat(zeroes);

    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }

    return str;
  }

  function decodeUnsafe(source) {
    if (typeof source !== 'string') {
      throw new TypeError('Expected String');
    }

    if (source.length === 0) {
      return new Uint8Array();
    }

    var psz = 0;

    if (source[psz] === ' ') {
      return;
    }

    var zeroes = 0;
    var length = 0;

    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }

    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);

    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];

      if (carry === 255) {
        return;
      }

      var i = 0;

      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }

      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }

      length = i;
      psz++;
    }

    if (source[psz] === ' ') {
      return;
    }

    var it4 = size - length;

    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }

    var vch = new Uint8Array(zeroes + (size - it4));
    var j = zeroes;

    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }

    return vch;
  }

  function decode(string) {
    var buffer = decodeUnsafe(string);

    if (buffer) {
      return buffer;
    }

    throw new Error("Non-".concat(name, " character"));
  }

  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  };
}

var src$2 = base;
var _brrp__multiformats_scope_baseX = src$2;

var Encoder = /*#__PURE__*/function () {
  function Encoder(name, prefix, baseEncode) {
    _classCallCheck$1(this, Encoder);

    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }

  _createClass$1(Encoder, [{
    key: "encode",
    value: function encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return "".concat(this.prefix).concat(this.baseEncode(bytes));
      } else {
        throw Error('Unknown type, must be binary type');
      }
    }
  }]);

  return Encoder;
}();

var Decoder = /*#__PURE__*/function () {
  function Decoder(name, prefix, baseDecode) {
    _classCallCheck$1(this, Decoder);

    this.name = name;
    this.prefix = prefix;

    if (prefix.codePointAt(0) === undefined) {
      throw new Error('Invalid prefix character');
    }

    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }

  _createClass$1(Decoder, [{
    key: "decode",
    value: function decode(text) {
      if (typeof text === 'string') {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error("Unable to decode multibase string ".concat(JSON.stringify(text), ", ").concat(this.name, " decoder only supports inputs prefixed with ").concat(this.prefix));
        }

        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error('Can only multibase decode strings');
      }
    }
  }, {
    key: "or",
    value: function or(decoder) {
      return _or(this, decoder);
    }
  }]);

  return Decoder;
}();

var ComposedDecoder = /*#__PURE__*/function () {
  function ComposedDecoder(decoders) {
    _classCallCheck$1(this, ComposedDecoder);

    this.decoders = decoders;
  }

  _createClass$1(ComposedDecoder, [{
    key: "or",
    value: function or(decoder) {
      return _or(this, decoder);
    }
  }, {
    key: "decode",
    value: function decode(input) {
      var prefix = input[0];
      var decoder = this.decoders[prefix];

      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(input), ", only inputs prefixed with ").concat(Object.keys(this.decoders), " are supported"));
      }
    }
  }]);

  return ComposedDecoder;
}();

var _or = function _or(left, right) {
  return new ComposedDecoder(_objectSpread2(_objectSpread2({}, left.decoders || _defineProperty$4({}, left.prefix, left)), right.decoders || _defineProperty$4({}, right.prefix, right)));
};
var Codec = /*#__PURE__*/function () {
  function Codec(name, prefix, baseEncode, baseDecode) {
    _classCallCheck$1(this, Codec);

    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix, baseEncode);
    this.decoder = new Decoder(name, prefix, baseDecode);
  }

  _createClass$1(Codec, [{
    key: "encode",
    value: function encode(input) {
      return this.encoder.encode(input);
    }
  }, {
    key: "decode",
    value: function decode(input) {
      return this.decoder.decode(input);
    }
  }]);

  return Codec;
}();
var from$1 = function from(_ref3) {
  var name = _ref3.name,
      prefix = _ref3.prefix,
      encode = _ref3.encode,
      decode = _ref3.decode;
  return new Codec(name, prefix, encode, decode);
};
var baseX = function baseX(_ref4) {
  var prefix = _ref4.prefix,
      name = _ref4.name,
      alphabet = _ref4.alphabet;

  var _basex = _brrp__multiformats_scope_baseX(alphabet, name),
      encode = _basex.encode,
      _decode = _basex.decode;

  return from$1({
    prefix: prefix,
    name: name,
    encode: encode,
    decode: function decode(text) {
      return coerce(_decode(text));
    }
  });
};

var _decode2 = function decode(string, alphabet, bitsPerChar, name) {
  var codes = {};

  for (var i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i;
  }

  var end = string.length;

  while (string[end - 1] === '=') {
    --end;
  }

  var out = new Uint8Array(end * bitsPerChar / 8 | 0);
  var bits = 0;
  var buffer = 0;
  var written = 0;

  for (var _i = 0; _i < end; ++_i) {
    var value = codes[string[_i]];

    if (value === undefined) {
      throw new SyntaxError("Non-".concat(name, " character"));
    }

    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;

    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }

  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError('Unexpected end of data');
  }

  return out;
};

var _encode = function encode(data, alphabet, bitsPerChar) {
  var pad = alphabet[alphabet.length - 1] === '=';
  var mask = (1 << bitsPerChar) - 1;
  var out = '';
  var bits = 0;
  var buffer = 0;

  for (var i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;

    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet[mask & buffer >> bits];
    }
  }

  if (bits) {
    out += alphabet[mask & buffer << bitsPerChar - bits];
  }

  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += '=';
    }
  }

  return out;
};

var rfc4648 = function rfc4648(_ref5) {
  var name = _ref5.name,
      prefix = _ref5.prefix,
      bitsPerChar = _ref5.bitsPerChar,
      alphabet = _ref5.alphabet;
  return from$1({
    prefix: prefix,
    name: name,
    encode: function encode(input) {
      return _encode(input, alphabet, bitsPerChar);
    },
    decode: function decode(input) {
      return _decode2(input, alphabet, bitsPerChar, name);
    }
  });
};

var base58btc = baseX({
  name: 'base58btc',
  prefix: 'z',
  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
});
baseX({
  name: 'base58flickr',
  prefix: 'Z',
  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
});

var base32 = rfc4648({
  prefix: 'b',
  name: 'base32',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'B',
  name: 'base32upper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'c',
  name: 'base32pad',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'C',
  name: 'base32padupper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'v',
  name: 'base32hex',
  alphabet: '0123456789abcdefghijklmnopqrstuv',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'V',
  name: 'base32hexupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
  bitsPerChar: 5
});
rfc4648({
  prefix: 't',
  name: 'base32hexpad',
  alphabet: '0123456789abcdefghijklmnopqrstuv=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'T',
  name: 'base32hexpadupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'h',
  name: 'base32z',
  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
  bitsPerChar: 5
});

var CID = /*#__PURE__*/function (_Symbol$toStringTag, _Symbol$for) {
  function CID(version, code, multihash, bytes) {
    _classCallCheck$1(this, CID);

    this.code = code;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }

  _createClass$1(CID, [{
    key: "toV0",
    value: function toV0() {
      switch (this.version) {
        case 0:
          {
            return this;
          }

        default:
          {
            var code = this.code,
                multihash = this.multihash;

            if (code !== DAG_PB_CODE) {
              throw new Error('Cannot convert a non dag-pb CID to CIDv0');
            }

            if (multihash.code !== SHA_256_CODE) {
              throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
            }

            return CID.createV0(multihash);
          }
      }
    }
  }, {
    key: "toV1",
    value: function toV1() {
      switch (this.version) {
        case 0:
          {
            var _this$multihash = this.multihash,
                code = _this$multihash.code,
                digest = _this$multihash.digest;
            var multihash = create(code, digest);
            return CID.createV1(this.code, multihash);
          }

        case 1:
          {
            return this;
          }

        default:
          {
            throw Error("Can not convert CID version ".concat(this.version, " to version 0. This is a bug please report"));
          }
      }
    }
  }, {
    key: "equals",
    value: function equals$1(other) {
      return other && this.code === other.code && this.version === other.version && equals(this.multihash, other.multihash);
    }
  }, {
    key: "toString",
    value: function toString(base) {
      var bytes = this.bytes,
          version = this.version,
          _baseCache = this._baseCache;

      switch (version) {
        case 0:
          return toStringV0(bytes, _baseCache, base || base58btc.encoder);

        default:
          return toStringV1(bytes, _baseCache, base || base32.encoder);
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        code: this.code,
        version: this.version,
        hash: this.multihash.bytes
      };
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return 'CID';
    }
  }, {
    key: _Symbol$for,
    value: function value() {
      return 'CID(' + this.toString() + ')';
    }
  }, {
    key: "toBaseEncodedString",
    get: function get() {
      throw new Error('Deprecated, use .toString()');
    }
  }, {
    key: "codec",
    get: function get() {
      throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
  }, {
    key: "buffer",
    get: function get() {
      throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');
    }
  }, {
    key: "multibaseName",
    get: function get() {
      throw new Error('"multibaseName" property is deprecated');
    }
  }, {
    key: "prefix",
    get: function get() {
      throw new Error('"prefix" property is deprecated');
    }
  }], [{
    key: "isCID",
    value: function isCID(value) {
      deprecate(/^0\.0/, IS_CID_DEPRECATION);
      return !!(value && (value[cidSymbol] || value.asCID === value));
    }
  }, {
    key: "asCID",
    value: function asCID(value) {
      if (value instanceof CID) {
        return value;
      } else if (value != null && value.asCID === value) {
        var _version = value.version,
            code = value.code,
            multihash = value.multihash,
            bytes = value.bytes;
        return new CID(_version, code, multihash, bytes || encodeCID(_version, code, multihash.bytes));
      } else if (value != null && value[cidSymbol] === true) {
        var _version2 = value.version,
            _multihash = value.multihash,
            _code = value.code;
        var digest = decode$1(_multihash);
        return CID.create(_version2, _code, digest);
      } else {
        return null;
      }
    }
  }, {
    key: "create",
    value: function create(version, code, digest) {
      if (typeof code !== 'number') {
        throw new Error('String codecs are no longer supported');
      }

      switch (version) {
        case 0:
          {
            if (code !== DAG_PB_CODE) {
              throw new Error("Version 0 CID must use dag-pb (code: ".concat(DAG_PB_CODE, ") block encoding"));
            } else {
              return new CID(version, code, digest, digest.bytes);
            }
          }

        case 1:
          {
            var bytes = encodeCID(version, code, digest.bytes);
            return new CID(version, code, digest, bytes);
          }

        default:
          {
            throw new Error('Invalid version');
          }
      }
    }
  }, {
    key: "createV0",
    value: function createV0(digest) {
      return CID.create(0, DAG_PB_CODE, digest);
    }
  }, {
    key: "createV1",
    value: function createV1(code, digest) {
      return CID.create(1, code, digest);
    }
  }, {
    key: "decode",
    value: function decode(bytes) {
      var _CID$decodeFirst = CID.decodeFirst(bytes),
          _CID$decodeFirst2 = _slicedToArray(_CID$decodeFirst, 2),
          cid = _CID$decodeFirst2[0],
          remainder = _CID$decodeFirst2[1];

      if (remainder.length) {
        throw new Error('Incorrect length');
      }

      return cid;
    }
  }, {
    key: "decodeFirst",
    value: function decodeFirst(bytes) {
      var specs = CID.inspectBytes(bytes);
      var prefixSize = specs.size - specs.multihashSize;
      var multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));

      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error('Incorrect length');
      }

      var digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      var digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      var cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
      return [cid, bytes.subarray(specs.size)];
    }
  }, {
    key: "inspectBytes",
    value: function inspectBytes(initialBytes) {
      var offset = 0;

      var next = function next() {
        var _varint$decode = decode$2(initialBytes.subarray(offset)),
            _varint$decode2 = _slicedToArray(_varint$decode, 2),
            i = _varint$decode2[0],
            length = _varint$decode2[1];

        offset += length;
        return i;
      };

      var version = next();
      var codec = DAG_PB_CODE;

      if (version === 18) {
        version = 0;
        offset = 0;
      } else if (version === 1) {
        codec = next();
      }

      if (version !== 0 && version !== 1) {
        throw new RangeError("Invalid CID version ".concat(version));
      }

      var prefixSize = offset;
      var multihashCode = next();
      var digestSize = next();
      var size = offset + digestSize;
      var multihashSize = size - prefixSize;
      return {
        version: version,
        codec: codec,
        multihashCode: multihashCode,
        digestSize: digestSize,
        multihashSize: multihashSize,
        size: size
      };
    }
  }, {
    key: "parse",
    value: function parse(source, base) {
      var _parseCIDtoBytes = parseCIDtoBytes(source, base),
          _parseCIDtoBytes2 = _slicedToArray(_parseCIDtoBytes, 2),
          prefix = _parseCIDtoBytes2[0],
          bytes = _parseCIDtoBytes2[1];

      var cid = CID.decode(bytes);

      cid._baseCache.set(prefix, source);

      return cid;
    }
  }]);

  return CID;
}(Symbol.toStringTag, Symbol["for"]('nodejs.util.inspect.custom'));

var parseCIDtoBytes = function parseCIDtoBytes(source, base) {
  switch (source[0]) {
    case 'Q':
      {
        var decoder = base || base58btc;
        return [base58btc.prefix, decoder.decode("".concat(base58btc.prefix).concat(source))];
      }

    case base58btc.prefix:
      {
        var _decoder = base || base58btc;

        return [base58btc.prefix, _decoder.decode(source)];
      }

    case base32.prefix:
      {
        var _decoder2 = base || base32;

        return [base32.prefix, _decoder2.decode(source)];
      }

    default:
      {
        if (base == null) {
          throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');
        }

        return [source[0], base.decode(source)];
      }
  }
};

var toStringV0 = function toStringV0(bytes, cache, base) {
  var prefix = base.prefix;

  if (prefix !== base58btc.prefix) {
    throw Error("Cannot string encode V0 in ".concat(base.name, " encoding"));
  }

  var cid = cache.get(prefix);

  if (cid == null) {
    var _cid = base.encode(bytes).slice(1);

    cache.set(prefix, _cid);
    return _cid;
  } else {
    return cid;
  }
};

var toStringV1 = function toStringV1(bytes, cache, base) {
  var prefix = base.prefix;
  var cid = cache.get(prefix);

  if (cid == null) {
    var _cid2 = base.encode(bytes);

    cache.set(prefix, _cid2);
    return _cid2;
  } else {
    return cid;
  }
};

var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;

var encodeCID = function encodeCID(version, code, multihash) {
  var codeOffset = encodingLength(version);
  var hashOffset = codeOffset + encodingLength(code);
  var bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version, bytes, 0);
  encodeTo(code, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};

var cidSymbol = Symbol["for"]('@ipld/js-cid/CID');
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version = '0.0.0-dev';

var deprecate = function deprecate(range, message) {
  if (range.test(version)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};

var IS_CID_DEPRECATION = "CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n";

var textEncoder = new TextEncoder();
new TextDecoder();
var code = 512;
var encode$1 = function encode(node) {
  return textEncoder.encode(JSON.stringify(node));
};

var crypto = {};

var _polyfillNode_crypto = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': crypto
});

var from = function from(_ref) {
  var name = _ref.name,
      code = _ref.code,
      encode = _ref.encode;
  return new Hasher(name, code, encode);
};
var Hasher = /*#__PURE__*/function () {
  function Hasher(name, code, encode) {
    _classCallCheck$1(this, Hasher);

    this.name = name;
    this.code = code;
    this.encode = encode;
  }

  _createClass$1(Hasher, [{
    key: "digest",
    value: function digest(input) {
      var _this = this;

      if (input instanceof Uint8Array) {
        var result = this.encode(input);
        return result instanceof Uint8Array ? create(this.code, result) : result.then(function (digest) {
          return create(_this.code, digest);
        });
      } else {
        throw Error('Unknown type, must be binary type');
      }
    }
  }]);

  return Hasher;
}();

var sha256 = from({
  name: 'sha2-256',
  code: 18,
  encode: function encode(input) {
    return coerce(crypto.createHash('sha256').update(input).digest());
  }
});
from({
  name: 'sha2-512',
  code: 19,
  encode: function encode(input) {
    return coerce(crypto.createHash('sha512').update(input).digest());
  }
});

var block = {
  get: function () {
    var _get = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key, _options) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              throw new Error("unexpected block API get for ".concat(key));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function get(_x, _x2) {
      return _get.apply(this, arguments);
    }

    return get;
  }(),
  put: function () {
    var _put = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_key, _val, _options) {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              throw new Error('unexpected block API put');

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function put(_x3, _x4, _x5) {
      return _put.apply(this, arguments);
    }

    return put;
  }(),
  open: function () {
    var _open = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function open() {
      return _open.apply(this, arguments);
    }

    return open;
  }(),
  close: function () {
    var _close = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function close() {
      return _close.apply(this, arguments);
    }

    return close;
  }(),
  has: function () {
    var _has = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_key, _options) {
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    function has(_x6, _x7) {
      return _has.apply(this, arguments);
    }

    return has;
  }(),
  "delete": function () {
    var _delete2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_key, _options) {
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    function _delete(_x8, _x9) {
      return _delete2.apply(this, arguments);
    }

    return _delete;
  }(),
  putMany: function putMany(_source, _options) {
    throw new Error('Function not implemented.');
  },
  getMany: function getMany(_source, _options) {
    throw new Error('Function not implemented.');
  },
  deleteMany: function deleteMany(_source, _options) {
    throw new Error('Function not implemented.');
  },
  batch: function batch() {
    throw new Error('Function not implemented.');
  },
  query: function query(_query, _options) {
    throw new Error('Function not implemented.');
  },
  queryKeys: function queryKeys(_query, _options) {
    throw new Error('Function not implemented.');
  }
};
var fileHasher = {
  convertNanosToMillis: function convertNanosToMillis(nanoSeconds) {
    return nanoSeconds / BigInt(1000000);
  },

  /**
   * Used to initalize the only hash fns. See Alan Shaw's reference code for more context.
   */
  initImageHasher: function initImageHasher(content, options) {
    options = options || {};
    options.onlyHash = true;
    options.cidVersion = 0;
    return {
      options: options,
      content: content
    };
  },

  /**
   * Used to iniitalize the only hash fns. See Alan Shaw's reference code for more context.
   */
  initNonImageHasher: function initNonImageHasher(content, options) {
    options = options || {};
    options.onlyHash = true;
    options.cidVersion = 0;
    return {
      options: options,
      content: content
    };
  },

  /**
   * Convert content to a buffer; used in `generateNonImageCid()`.
   * @param {ReadStream|Buffer|string} content if string, should be file path
   * @param {Object} logger
   * @returns buffer version of content
   */
  convertToBuffer: function convertToBuffer(content, logger) {
    return _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
      var buffer, fsReadFile, errMsg;
      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!Buffer.isBuffer(content)) {
                _context7.next = 2;
                break;
              }

              return _context7.abrupt("return", content);

            case 2:
              _context7.prev = 2;

              if (!(content instanceof Stream$2.Readable)) {
                _context7.next = 8;
                break;
              }

              _context7.next = 6;
              return new Promise(function (resolve, reject) {
                content.on('data', function (chunk) {
                  return buffer.push(chunk);
                });
                content.on('end', function () {
                  return resolve(Buffer.concat(buffer));
                });
                content.on('error', function (err) {
                  return reject(err);
                });
              });

            case 6:
              _context7.next = 12;
              break;

            case 8:
              fsReadFile = util$2.promisify(fs.readFile);
              _context7.next = 11;
              return fsReadFile(content);

            case 11:
              buffer = _context7.sent;

            case 12:
              _context7.next = 19;
              break;

            case 14:
              _context7.prev = 14;
              _context7.t0 = _context7["catch"](2);
              errMsg = "[fileHasher - convertToBuffer()] Could not convert content into buffer: ".concat(_context7.t0.toString());
              logger.error(errMsg);
              throw new Error(errMsg);

            case 19:
              return _context7.abrupt("return", buffer);

            case 20:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, null, [[2, 14]]);
    }))();
  },

  /**
   * Custom fn to generate the content-hashing logic
   * @param content a buffer of the content
   * @param options options for importer
   * @returns the V0 CID from content addressing logic
   */
  hashNonImages: function hashNonImages(content) {
    var _arguments = arguments;
    return _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
      var options, _fileHasher$initNonIm, lastCid, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, cid;

      return regeneratorRuntime.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              options = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};
              _fileHasher$initNonIm = fileHasher.initNonImageHasher(content, options);
              options = _fileHasher$initNonIm.options;
              content = _fileHasher$initNonIm.content;
              lastCid = '';
              _iteratorAbruptCompletion = false;
              _didIteratorError = false;
              _context8.prev = 8;
              _iterator = _asyncIterator(importer([{
                content: content
              }], block, options));

            case 10:
              _context8.next = 12;
              return _iterator.next();

            case 12:
              if (!(_iteratorAbruptCompletion = !(_step = _context8.sent).done)) {
                _context8.next = 18;
                break;
              }

              cid = _step.value.cid;
              lastCid = "".concat(cid);

            case 15:
              _iteratorAbruptCompletion = false;
              _context8.next = 10;
              break;

            case 18:
              _context8.next = 24;
              break;

            case 20:
              _context8.prev = 20;
              _context8.t0 = _context8["catch"](8);
              _didIteratorError = true;
              _iteratorError = _context8.t0;

            case 24:
              _context8.prev = 24;
              _context8.prev = 25;

              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                _context8.next = 29;
                break;
              }

              _context8.next = 29;
              return _iterator["return"]();

            case 29:
              _context8.prev = 29;

              if (!_didIteratorError) {
                _context8.next = 32;
                break;
              }

              throw _iteratorError;

            case 32:
              return _context8.finish(29);

            case 33:
              return _context8.finish(24);

            case 34:
              return _context8.abrupt("return", lastCid);

            case 35:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, null, [[8, 20, 24, 34], [25,, 29, 33]]);
    }))();
  },

  /**
   * Custom fn to generate the content-hashing logic
   * @param content an Object[] with the structure [{ path: string, content: buffer }, ...]
   * @param options options for importer
   * @returns an Object[] with the structure [{path: <string>, cid: <string>, size: <number>}]
   *
   * Example with adding a profile picture:
   * [
      {
        "cid": "QmSRyKvnXwoxPZ9UxqxXPR8NXjcPYBEf1qbNrXyo5USqLL",
        "path": "blob/150x150.jpg",
        "size": 3091
      },
      {
        "cid": "QmQQMV9TXxRmDKafZiRvMVkqUNtUu9WGAfukUBS1yCk2ht",
        "path": "blob/480x480.jpg",
        "size": 20743
      },
      {
        "cid": "Qmd8cDdDGcWVaLEoJPVFtkKhYMqvHXZTvXcisYjubFxv1F",
        "path": "blob/1000x1000.jpg",
        "size": 72621
      },
      {
        "cid": "QmaYCPUH8G14yxetsMgW5J5tpTqPaTp3HMd3EAyffZKSvm",
        "path": "blob/original.jpg",
        "size": 185844
      },
      {
        "cid": "QmW8FUFhvaxv1MZmVcUcmR7Tg9WZhGf8xDNBesT9XepwrK",
        "path": "blob",
        "size": 282525
      }
    ]
  */
  hashImages: function hashImages(content) {
    var _arguments2 = arguments;
    return _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
      var options, _fileHasher$initImage, result, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, file;

      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              options = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};
              _fileHasher$initImage = fileHasher.initImageHasher(content, options);
              options = _fileHasher$initImage.options;
              content = _fileHasher$initImage.content;
              result = [];
              _iteratorAbruptCompletion2 = false;
              _didIteratorError2 = false;
              _context9.prev = 8;
              _iterator2 = _asyncIterator(importer(content, block, options));

            case 10:
              _context9.next = 12;
              return _iterator2.next();

            case 12:
              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context9.sent).done)) {
                _context9.next = 18;
                break;
              }

              file = _step2.value;
              result.push({
                path: file.path,
                cid: "".concat(file.cid),
                size: file.size
              });

            case 15:
              _iteratorAbruptCompletion2 = false;
              _context9.next = 10;
              break;

            case 18:
              _context9.next = 24;
              break;

            case 20:
              _context9.prev = 20;
              _context9.t0 = _context9["catch"](8);
              _didIteratorError2 = true;
              _iteratorError2 = _context9.t0;

            case 24:
              _context9.prev = 24;
              _context9.prev = 25;

              if (!(_iteratorAbruptCompletion2 && _iterator2["return"] != null)) {
                _context9.next = 29;
                break;
              }

              _context9.next = 29;
              return _iterator2["return"]();

            case 29:
              _context9.prev = 29;

              if (!_didIteratorError2) {
                _context9.next = 32;
                break;
              }

              throw _iteratorError2;

            case 32:
              return _context9.finish(29);

            case 33:
              return _context9.finish(24);

            case 34:
              return _context9.abrupt("return", result);

            case 35:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, null, [[8, 20, 24, 34], [25,, 29, 33]]);
    }))();
  },

  /**
   * Generates CID V0 (46-char string starting with "Qm") for a non-image file (track segment, track transcode, metadata)
   * @param {Buffer|ReadStream|string} content a single Buffer, a ReadStream, or path to an existing file
   * @param {Object?} logger
   * @returns {string} only hash response cid
   */
  generateNonImageCid: function generateNonImageCid(content) {
    var _arguments3 = arguments;
    return _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
      var logger, buffer;
      return regeneratorRuntime.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              logger = _arguments3.length > 1 && _arguments3[1] !== undefined ? _arguments3[1] : console;
              _context10.next = 3;
              return fileHasher.convertToBuffer(content, logger);

            case 3:
              buffer = _context10.sent;
              _context10.next = 6;
              return fileHasher.hashNonImages(buffer);

            case 6:
              return _context10.abrupt("return", _context10.sent);

            case 7:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }))();
  },

  /**
   * Generates CID V1 for a JSON metadata object (NOT the string of the metadata - must be an object).
   * CID<T, 512, SHA_256, 1> represents CID with json codec (512) and sha256 hash using CID V1.
   * Call toString() on the result to get the CID V1 string.
   */
  generateMetadataCidV1: function generateMetadataCidV1(metadata) {
    return _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
      var bytes, hash;
      return regeneratorRuntime.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              bytes = encode$1(metadata);
              _context11.next = 3;
              return sha256.digest(bytes);

            case 3:
              hash = _context11.sent;
              return _context11.abrupt("return", CID.create(1, code, hash));

            case 5:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }))();
  },

  /**
   * Wrapper that generates multihashes for image files
   * @param {Object[]} content an Object[] with the structure [{ path: string, content: buffer }, ...]
   * @param {Object?} logger
   * @returns {HashedImage[]} only hash responses with the structure [{path: <string>, cid: <string>, size: <number>}]
   */
  generateImageCids: function generateImageCids(content) {
    return _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {

      return regeneratorRuntime.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 3;
              return fileHasher.hashImages(content);

            case 3:
              return _context12.abrupt("return", _context12.sent);

            case 4:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }))();
  }
};

var HASH_SALT = 'azowernasdfoia';
var MIN_LENGTH = 5;
var hashids = new Hashids(HASH_SALT, MIN_LENGTH);
var ZeroAddress = '0x0000000000000000000000000000000000000000'; // eslint-disable-next-line @typescript-eslint/no-extraneous-class -- this should just be esm

var Utils = /*#__PURE__*/function () {
  function Utils() {
    _classCallCheck$1(this, Utils);
  }

  _createClass$1(Utils, null, [{
    key: "utf8ToHex",
    value: function utf8ToHex(utf8Str) {
      return LibsWeb3.utils.utf8ToHex(utf8Str);
    }
  }, {
    key: "padRight",
    value: function padRight(hexStr, size) {
      return LibsWeb3.utils.padRight(hexStr, size);
    }
  }, {
    key: "hexToUtf8",
    value: function hexToUtf8(hexStr) {
      return LibsWeb3.utils.hexToUtf8(hexStr);
    }
  }, {
    key: "keccak256",
    value: function keccak256(utf8Str) {
      return LibsWeb3.utils.keccak256(utf8Str);
    }
  }, {
    key: "isBN",
    value: function isBN(number) {
      return LibsWeb3.utils.isBN(number);
    }
  }, {
    key: "toBN",
    value: function toBN(number, base) {
      return new LibsWeb3.utils.BN(number, base);
    }
  }, {
    key: "BN",
    value: function BN() {
      return LibsWeb3.utils.BN;
    }
  }, {
    key: "checkStrLen",
    value: function checkStrLen(str, maxLen) {
      var minLen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

      if (str === undefined || str === null || str.length > maxLen || str.length < minLen) {
        throw new Error("String '".concat(str, "' must be between ").concat(minLen, "-").concat(maxLen, " characters"));
      }
    }
  }, {
    key: "wait",
    value: function () {
      var _wait = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(milliseconds) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, milliseconds);
                });

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function wait(_x) {
        return _wait.apply(this, arguments);
      }

      return wait;
    }() // Regular expression to check if endpoint is a FQDN. https://regex101.com/r/kIowvx/2

  }, {
    key: "isFQDN",
    value: function isFQDN(url) {
      var FQDN = /(?:^|[ \t])((https?:\/\/)?(?:localhost|[\w-]+(?:\.[\w-]+)+)(:\d+)?(\/\S*)?)/gm;
      return FQDN.test(url);
    }
  }, {
    key: "isHttps",
    value: function isHttps(url) {
      var https = /^https:\/\//;
      return https.test(url);
    } // Function to check if the endpont/health_check returns JSON object [ {'healthy':true} ]

  }, {
    key: "isHealthy",
    value: function () {
      var _isHealthy = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url) {
        var _yield$axios$get, body;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return axios.get(url + '/health_check');

              case 3:
                _yield$axios$get = _context2.sent;
                body = _yield$axios$get.data;
                return _context2.abrupt("return", body.data.healthy);

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](0);
                return _context2.abrupt("return", false);

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[0, 8]]);
      }));

      function isHealthy(_x2) {
        return _isHealthy.apply(this, arguments);
      }

      return isHealthy;
    }()
  }, {
    key: "formatOptionalMultihash",
    value: function formatOptionalMultihash(multihash) {
      if (multihash) {
        return this.decodeMultihash(multihash).digest;
      } else {
        return this.utf8ToHex('');
      }
    }
  }, {
    key: "decodeMultihash",
    value: function decodeMultihash(multihash) {
      var base16Multihash = bs58.decode(multihash);
      return {
        digest: "0x".concat(base16Multihash.slice(2).toString('hex')),
        hashFn: parseInt(base16Multihash[0]),
        size: parseInt(base16Multihash[1])
      };
    }
    /**
     * Given a digest value (written on chain, obtained through AudiusABIDecoder.decodeMethod),
     * convert back to a IFPS CIDv0
     * @param multihashDigest digest value from decodeMultihash
     * @returns String CID value
     */

  }, {
    key: "encodeMultihash",
    value: function encodeMultihash(multihashDigest) {
      // the 1220 is from reconstructing the hashFn and size with digest, the opposite of decodeMultihash
      // since IPFS CIDv0 has a fixed hashFn and size, the first two values are always 12 and 20
      // concat them together with digest and encode back to base58
      var digestStr = "1220".concat(multihashDigest.replace('0x', '')); // convert digestStr from hex to base 58

      return bs58.encode(Buffer.from(digestStr, 'hex'));
    }
  }, {
    key: "parseDataFromResponse",
    value: function parseDataFromResponse(response) {
      if (!response || !response.data) return null;
      var obj = response.data; // adapted from https://github.com/jashkenas/underscore/blob/master/underscore.js _.isEmpty function

      if (obj == null) return null;
      if ((Array.isArray(obj) || typeof obj === 'string') && obj.length === 0) return null;
      if (Object.keys(obj).length === 0) return null;
      return obj;
    }
  }, {
    key: "configureWeb3",
    value: function () {
      var _configureWeb = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(web3Provider, chainNetworkId) {
        var requiresAccount,
            web3Instance,
            networkId,
            accounts,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                requiresAccount = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : true;
                // Initializing web3 with a HttpProvider wrapper for multiple providers
                // ref: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3/types/index.d.ts#L31.
                web3Instance = new LibsWeb3(new MultiProvider(web3Provider));
                _context3.prev = 2;
                _context3.next = 5;
                return web3Instance.eth.net.getId();

              case 5:
                networkId = _context3.sent;

                if (!(chainNetworkId && networkId.toString() !== chainNetworkId)) {
                  _context3.next = 8;
                  break;
                }

                return _context3.abrupt("return", false);

              case 8:
                if (!requiresAccount) {
                  _context3.next = 14;
                  break;
                }

                _context3.next = 11;
                return web3Instance.eth.getAccounts();

              case 11:
                accounts = _context3.sent;

                if (!(!accounts || accounts.length < 1)) {
                  _context3.next = 14;
                  break;
                }

                return _context3.abrupt("return", false);

              case 14:
                _context3.next = 19;
                break;

              case 16:
                _context3.prev = 16;
                _context3.t0 = _context3["catch"](2);
                return _context3.abrupt("return", false);

              case 19:
                return _context3.abrupt("return", web3Instance);

              case 20:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[2, 16]]);
      }));

      function configureWeb3(_x3, _x4) {
        return _configureWeb.apply(this, arguments);
      }

      return configureWeb3;
    }()
  }, {
    key: "zeroAddress",
    get: function get() {
      return ZeroAddress;
    }
  }, {
    key: "isZeroAddress",
    value: function isZeroAddress(address) {
      return address === Utils.zeroAddress;
    }
  }, {
    key: "makeUuid",
    value: function makeUuid() {
      return uuid();
    }
    /**
     * Decodes a string id into an int. Returns null if an invalid ID.
     */

  }, {
    key: "decodeHashId",
    value: function decodeHashId(id) {
      try {
        var ids = hashids.decode(id);
        if (!ids.length) return null;
        var num = Number(ids[0]);
        if (isNaN(num)) return null;
        return num;
      } catch (e) {
        console.error("Failed to decode ".concat(id), e);
        return null;
      }
    }
    /**
     * Encodes an int to a string based hashid
     */

  }, {
    key: "encodeHashId",
    value: function encodeHashId(id) {
      try {
        if (id === null) return null;
        var encodedId = hashids.encode(id);
        return encodedId;
      } catch (e) {
        console.error("Failed to encode ".concat(id), e);
        return null;
      }
    }
    /**
     * If `promise` responds before `timeoutMs`,
     * this function returns its response; else rejects with `timeoutMessage`
     */

  }, {
    key: "racePromiseWithTimeout",
    value: function () {
      var _racePromiseWithTimeout = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(promise, timeoutMs, timeoutMessage) {
        var timeoutPromise;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                // eslint-disable-next-line promise/param-names
                timeoutPromise = new Promise(function (_promise, reject) {
                  setTimeout(function () {
                    return reject(new Error(timeoutMessage));
                  }, timeoutMs);
                });
                _context4.next = 3;
                return Promise.race([promise, timeoutPromise]);

              case 3:
                return _context4.abrupt("return", _context4.sent);

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function racePromiseWithTimeout(_x5, _x6, _x7) {
        return _racePromiseWithTimeout.apply(this, arguments);
      }

      return racePromiseWithTimeout;
    }()
  }, {
    key: "getRandomInt",
    value: function getRandomInt(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min) + min);
    }
  }]);

  return Utils;
}();

_defineProperty$4(Utils, "fileHasher", fileHasher);

function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var hasOwn = Object.prototype.hasOwnProperty;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};
var pSlice = Array.prototype.slice;
var _functionsHaveNames;
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== 'undefined') {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = (function () {
    return function foo() {}.name === 'foo';
  }());
}
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (buffer.isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global$1.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

function assert$1(value, message) {
  if (!value) fail(value, true, message, '==', ok);
}

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util$2.isFunction(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert$1.AssertionError = AssertionError;
function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
}

// assert.AssertionError instanceof Error
util$2.inherits(AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames() || !util$2.isFunction(something)) {
    return util$2.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert$1.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', ok);
}
assert$1.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);
assert$1.equal = equal;
function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', equal);
}

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);
assert$1.notEqual = notEqual;
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', notEqual);
  }
}

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);
assert$1.deepEqual = deepEqual;
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', deepEqual);
  }
}
assert$1.deepStrictEqual = deepStrictEqual;
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
  }
}

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (buffer.isBuffer(actual) && buffer.isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util$2.isDate(actual) && util$2.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util$2.isRegExp(actual) && util$2.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (buffer.isBuffer(actual) !== buffer.isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util$2.isPrimitive(a) || util$2.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);
assert$1.notDeepEqual = notDeepEqual;
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', notDeepEqual);
  }
}

assert$1.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);
assert$1.strictEqual = strictEqual;
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', strictEqual);
  }
}

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
assert$1.notStrictEqual = notStrictEqual;
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', notStrictEqual);
  }
}

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util$2.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);
assert$1.throws = throws;
function throws(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
}

// EXTENSION! This is annoying to write outside this module.
assert$1.doesNotThrow = doesNotThrow;
function doesNotThrow(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
}

assert$1.ifError = ifError;
function ifError(err) {
  if (err) throw err;
}

var _polyfillNode_assert = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': assert$1,
  AssertionError: AssertionError,
  fail: fail,
  ok: ok,
  assert: ok,
  equal: equal,
  notEqual: notEqual,
  deepEqual: deepEqual,
  deepStrictEqual: deepStrictEqual,
  notDeepEqual: notDeepEqual,
  notDeepStrictEqual: notDeepStrictEqual,
  strictEqual: strictEqual,
  notStrictEqual: notStrictEqual,
  throws: throws,
  doesNotThrow: doesNotThrow,
  ifError: ifError
});

new LibsWeb3(); // From https://github.com/AudiusProject/sig/blob/main/node/index.js

var dist$3 = {};

var constants$1 = {};

var externals = {};

var dist$2 = {};

var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(dist$2, "__esModule", {
  value: true
});
dist$2.getLength = dist$2.decode = dist$2.encode = void 0;

var bn_js_1$1 = __importDefault$3(require$$0$5);
/**
 * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
 * This function takes in a data, convert it to buffer if not, and a length for recursion
 * @param input - will be converted to buffer
 * @returns returns buffer of encoded data
 **/


function encode(input) {
  if (Array.isArray(input)) {
    var output = [];

    for (var i = 0; i < input.length; i++) {
      output.push(encode(input[i]));
    }

    var buf = Buffer$6.concat(output);
    return Buffer$6.concat([encodeLength(buf.length, 192), buf]);
  } else {
    var inputBuf = toBuffer(input);
    return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : Buffer$6.concat([encodeLength(inputBuf.length, 128), inputBuf]);
  }
}

dist$2.encode = encode;
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 * @param base The base to parse the integer into
 */

function safeParseInt(v, base) {
  if (v[0] === '0' && v[1] === '0') {
    throw new Error('invalid RLP: extra zeros');
  }

  return parseInt(v, base);
}

function encodeLength(len, offset) {
  if (len < 56) {
    return Buffer$6.from([len + offset]);
  } else {
    var hexLength = intToHex$1(len);
    var lLength = hexLength.length / 2;
    var firstByte = intToHex$1(offset + 55 + lLength);
    return Buffer$6.from(firstByte + hexLength, 'hex');
  }
}

function decode(input) {
  var stream = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!input || input.length === 0) {
    return Buffer$6.from([]);
  }

  var inputBuffer = toBuffer(input);

  var decoded = _decode(inputBuffer);

  if (stream) {
    return decoded;
  }

  if (decoded.remainder.length !== 0) {
    throw new Error('invalid remainder');
  }

  return decoded.data;
}

dist$2.decode = decode;
/**
 * Get the length of the RLP input
 * @param input
 * @returns The length of the input or an empty Buffer if no input
 */

function getLength(input) {
  if (!input || input.length === 0) {
    return Buffer$6.from([]);
  }

  var inputBuffer = toBuffer(input);
  var firstByte = inputBuffer[0];

  if (firstByte <= 0x7f) {
    return inputBuffer.length;
  } else if (firstByte <= 0xb7) {
    return firstByte - 0x7f;
  } else if (firstByte <= 0xbf) {
    return firstByte - 0xb6;
  } else if (firstByte <= 0xf7) {
    // a list between  0-55 bytes long
    return firstByte - 0xbf;
  } else {
    // a list  over 55 bytes long
    var llength = firstByte - 0xf6;
    var length = safeParseInt(inputBuffer.slice(1, llength).toString('hex'), 16);
    return llength + length;
  }
}

dist$2.getLength = getLength;
/** Decode an input with RLP */

function _decode(input) {
  var length, llength, data, innerRemainder, d;
  var decoded = [];
  var firstByte = input[0];

  if (firstByte <= 0x7f) {
    // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
    return {
      data: input.slice(0, 1),
      remainder: input.slice(1)
    };
  } else if (firstByte <= 0xb7) {
    // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
    // The range of the first byte is [0x80, 0xb7]
    length = firstByte - 0x7f; // set 0x80 null to 0

    if (firstByte === 0x80) {
      data = Buffer$6.from([]);
    } else {
      data = input.slice(1, length);
    }

    if (length === 2 && data[0] < 0x80) {
      throw new Error('invalid rlp encoding: byte must be less 0x80');
    }

    return {
      data: data,
      remainder: input.slice(length)
    };
  } else if (firstByte <= 0xbf) {
    // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
    // followed by the length, followed by the string
    llength = firstByte - 0xb6;

    if (input.length - 1 < llength) {
      throw new Error('invalid RLP: not enough bytes for string length');
    }

    length = safeParseInt(input.slice(1, llength).toString('hex'), 16);

    if (length <= 55) {
      throw new Error('invalid RLP: expected string length to be greater than 55');
    }

    data = input.slice(llength, length + llength);

    if (data.length < length) {
      throw new Error('invalid RLP: not enough bytes for string');
    }

    return {
      data: data,
      remainder: input.slice(length + llength)
    };
  } else if (firstByte <= 0xf7) {
    // a list between  0-55 bytes long
    length = firstByte - 0xbf;
    innerRemainder = input.slice(1, length);

    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }

    return {
      data: decoded,
      remainder: input.slice(length)
    };
  } else {
    // a list  over 55 bytes long
    llength = firstByte - 0xf6;
    length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
    var totalLength = llength + length;

    if (totalLength > input.length) {
      throw new Error('invalid rlp: total length is larger than the data');
    }

    innerRemainder = input.slice(llength, totalLength);

    if (innerRemainder.length === 0) {
      throw new Error('invalid rlp, List has a invalid length');
    }

    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }

    return {
      data: decoded,
      remainder: input.slice(totalLength)
    };
  }
}
/** Check if a string is prefixed by 0x */


function isHexPrefixed$3(str) {
  return str.slice(0, 2) === '0x';
}
/** Removes 0x from a given String */


function stripHexPrefix$2(str) {
  if (typeof str !== 'string') {
    return str;
  }

  return isHexPrefixed$3(str) ? str.slice(2) : str;
}
/** Transform an integer into its hexadecimal value */


function intToHex$1(integer) {
  if (integer < 0) {
    throw new Error('Invalid integer as argument, must be unsigned!');
  }

  var hex = integer.toString(16);
  return hex.length % 2 ? "0".concat(hex) : hex;
}
/** Pad a string to be even */


function padToEven$2(a) {
  return a.length % 2 ? "0".concat(a) : a;
}
/** Transform an integer into a Buffer */


function intToBuffer$1(integer) {
  var hex = intToHex$1(integer);
  return Buffer$6.from(hex, 'hex');
}
/** Transform anything into a Buffer */


function toBuffer(v) {
  if (!Buffer$6.isBuffer(v)) {
    if (typeof v === 'string') {
      if (isHexPrefixed$3(v)) {
        return Buffer$6.from(padToEven$2(stripHexPrefix$2(v)), 'hex');
      } else {
        return Buffer$6.from(v);
      }
    } else if (typeof v === 'number' || typeof v === 'bigint') {
      if (!v) {
        return Buffer$6.from([]);
      } else {
        return intToBuffer$1(v);
      }
    } else if (v === null || v === undefined) {
      return Buffer$6.from([]);
    } else if (v instanceof Uint8Array) {
      return Buffer$6.from(v);
    } else if (bn_js_1$1["default"].isBN(v)) {
      // converts a BN to a Buffer
      return Buffer$6.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }

  return v;
}

/**
 * Re-exports commonly used modules:
 * * Exports [`BN`](https://github.com/indutny/bn.js), [`rlp`](https://github.com/ethereumjs/rlp).
 * @packageDocumentation
 */


var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(externals, "__esModule", {
  value: true
});
externals.rlp = externals.BN = void 0;

var bn_js_1 = __importDefault$2(require$$0$5);

externals.BN = bn_js_1["default"];

var rlp$1 = __importStar(dist$2);

externals.rlp = rlp$1;

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;
  var buffer_1 = buffer;
  var externals_1 = externals;
  /**
   * 2^64-1
   */

  exports.MAX_UINT64 = new externals_1.BN('ffffffffffffffff', 16);
  /**
   * The max integer that the evm can handle (2^256-1)
   */

  exports.MAX_INTEGER = new externals_1.BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);
  /**
   * 2^256
   */

  exports.TWO_POW256 = new externals_1.BN('10000000000000000000000000000000000000000000000000000000000000000', 16);
  /**
   * Keccak-256 hash of null
   */

  exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
  /**
   * Keccak-256 hash of null
   */

  exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, 'hex');
  /**
   * Keccak-256 of an RLP of an empty array
   */

  exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
  /**
   * Keccak-256 of an RLP of an empty array
   */

  exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
  /**
   * Keccak-256 hash of the RLP of null
   */

  exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
  /**
   * Keccak-256 hash of the RLP of null
   */

  exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, 'hex');
})(constants$1);

var account$1 = {};

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_assert);

var secp256k1$2 = {};

var random = {};

var require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_crypto);

var randombytes$1 = require$$0.randomBytes;

Object.defineProperty(random, "__esModule", {
  value: true
});
var randombytes = randombytes$1;

function getRandomBytes(bytes) {
  return new Promise(function (resolve, reject) {
    randombytes(bytes, function (err, resp) {
      if (err) {
        reject(err);
        return;
      }

      resolve(resp);
    });
  });
}

random.getRandomBytes = getRandomBytes;

function getRandomBytesSync(bytes) {
  return randombytes(bytes);
}

random.getRandomBytesSync = getRandomBytesSync;

(function (exports) {

  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  function __export(m) {
    for (var p in m) {
      if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
  }

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var secp256k1_1 = require$$0$6;
  var random_1 = random;
  var SECP256K1_PRIVATE_KEY_SIZE = 32;

  function createPrivateKey() {
    return __awaiter(this, void 0, void 0, function () {
      var pk;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];

          case 1:
            pk = _a.sent();

            if (secp256k1_1.privateKeyVerify(pk)) {
              return [2
              /*return*/
              , pk];
            }

            return [3
            /*break*/
            , 0];

          case 2:
            return [2
            /*return*/
            ];
        }
      });
    });
  }

  exports.createPrivateKey = createPrivateKey;

  function createPrivateKeySync() {
    while (true) {
      var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);

      if (secp256k1_1.privateKeyVerify(pk)) {
        return pk;
      }
    }
  }

  exports.createPrivateKeySync = createPrivateKeySync;

  __export(require$$0$6);
})(secp256k1$2);

var internal = {};

/*
The MIT License

Copyright (c) 2016 Nick Dodson. nickdodson.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE
 */


Object.defineProperty(internal, "__esModule", {
  value: true
});
internal.isHexString = internal.getKeys = internal.fromAscii = internal.fromUtf8 = internal.toAscii = internal.arrayContainsArray = internal.getBinarySize = internal.padToEven = internal.stripHexPrefix = internal.isHexPrefixed = void 0;
/**
 * Returns a `Boolean` on whether or not the a `String` starts with '0x'
 * @param str the string input value
 * @return a boolean if it is or is not hex prefixed
 * @throws if the str input is not a string
 */

function isHexPrefixed$2(str) {
  if (typeof str !== 'string') {
    throw new Error("[isHexPrefixed] input must be type 'string', received type ".concat(_typeof(str)));
  }

  return str[0] === '0' && str[1] === 'x';
}

internal.isHexPrefixed = isHexPrefixed$2;
/**
 * Removes '0x' from a given `String` if present
 * @param str the string value
 * @returns the string without 0x prefix
 */

var stripHexPrefix$1 = function stripHexPrefix(str) {
  if (typeof str !== 'string') throw new Error("[stripHexPrefix] input must be type 'string', received ".concat(_typeof(str)));
  return isHexPrefixed$2(str) ? str.slice(2) : str;
};

internal.stripHexPrefix = stripHexPrefix$1;
/**
 * Pads a `String` to have an even length
 * @param value
 * @return output
 */

function padToEven$1(value) {
  var a = value;

  if (typeof a !== 'string') {
    throw new Error("[padToEven] value must be type 'string', received ".concat(_typeof(a)));
  }

  if (a.length % 2) a = "0".concat(a);
  return a;
}

internal.padToEven = padToEven$1;
/**
 * Get the binary size of a string
 * @param str
 * @returns the number of bytes contained within the string
 */

function getBinarySize$1(str) {
  if (typeof str !== 'string') {
    throw new Error("[getBinarySize] method requires input type 'string', recieved ".concat(_typeof(str)));
  }

  return Buffer$6.byteLength(str, 'utf8');
}

internal.getBinarySize = getBinarySize$1;
/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param superset
 * @param subset
 *
 */

function arrayContainsArray$1(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error("[arrayContainsArray] method requires input 'superset' to be an array, got type '".concat(_typeof(superset), "'"));
  }

  if (Array.isArray(subset) !== true) {
    throw new Error("[arrayContainsArray] method requires input 'subset' to be an array, got type '".concat(_typeof(subset), "'"));
  }

  return subset[some ? 'some' : 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

internal.arrayContainsArray = arrayContainsArray$1;
/**
 * Should be called to get ascii from its hex representation
 *
 * @param string in hex
 * @returns ascii string representation of hex value
 */

function toAscii$1(hex) {
  var str = '';
  var i = 0;
  var l = hex.length;
  if (hex.substring(0, 2) === '0x') i = 2;

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

internal.toAscii = toAscii$1;
/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @param string
 * @param optional padding
 * @returns hex representation of input string
 */

function fromUtf8$1(stringValue) {
  var str = Buffer$6.from(stringValue, 'utf8');
  return "0x".concat(padToEven$1(str.toString('hex')).replace(/^0+|0+$/g, ''));
}

internal.fromUtf8 = fromUtf8$1;
/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @param  string
 * @param  optional padding
 * @returns  hex representation of input string
 */

function fromAscii$1(stringValue) {
  var hex = '';

  for (var i = 0; i < stringValue.length; i++) {
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? "0".concat(n) : n;
  }

  return "0x".concat(hex);
}

internal.fromAscii = fromAscii$1;
/**
 * Returns the keys from an array of objects.
 * @example
 * ```js
 * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']
 *````
 * @param  params
 * @param  key
 * @param  allowEmpty
 * @returns output just a simple array of output keys
 */

function getKeys$1(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error("[getKeys] method expects input 'params' to be an array, got ".concat(_typeof(params)));
  }

  if (typeof key !== 'string') {
    throw new Error("[getKeys] method expects input 'key' to be type 'string', got ".concat(_typeof(params)));
  }

  var result = [];

  for (var i = 0; i < params.length; i++) {
    var value = params[i][key];

    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error("invalid abi - expected type 'string', received ".concat(_typeof(value)));
    }

    result.push(value);
  }

  return result;
}

internal.getKeys = getKeys$1;
/**
 * Is the string a hex string.
 *
 * @param  value
 * @param  length
 * @returns  output the string is a hex string
 */

function isHexString$1(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;
  if (length && value.length !== 2 + 2 * length) return false;
  return true;
}

internal.isHexString = isHexString$1;

var bytes$1 = {};

var helpers = {};

Object.defineProperty(helpers, "__esModule", {
  value: true
});
helpers.assertIsString = helpers.assertIsArray = helpers.assertIsBuffer = helpers.assertIsHexString = void 0;
var internal_1$1 = internal;
/**
 * Throws if a string is not hex prefixed
 * @param {string} input string to check hex prefix of
 */

var assertIsHexString = function assertIsHexString(input) {
  if (!(0, internal_1$1.isHexString)(input)) {
    var msg = "This method only supports 0x-prefixed hex strings but input was: ".concat(input);
    throw new Error(msg);
  }
};

helpers.assertIsHexString = assertIsHexString;
/**
 * Throws if input is not a buffer
 * @param {Buffer} input value to check
 */

var assertIsBuffer = function assertIsBuffer(input) {
  if (!Buffer$6.isBuffer(input)) {
    var msg = "This method only supports Buffer but input was: ".concat(input);
    throw new Error(msg);
  }
};

helpers.assertIsBuffer = assertIsBuffer;
/**
 * Throws if input is not an array
 * @param {number[]} input value to check
 */

var assertIsArray = function assertIsArray(input) {
  if (!Array.isArray(input)) {
    var msg = "This method only supports number arrays but input was: ".concat(input);
    throw new Error(msg);
  }
};

helpers.assertIsArray = assertIsArray;
/**
 * Throws if input is not a string
 * @param {string} input value to check
 */

var assertIsString = function assertIsString(input) {
  if (typeof input !== 'string') {
    var msg = "This method only supports strings but input was: ".concat(input);
    throw new Error(msg);
  }
};

helpers.assertIsString = assertIsString;

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;
  var externals_1 = externals;
  var internal_1 = internal;
  var helpers_1 = helpers;
  /**
   * Converts a `Number` into a hex `String`
   * @param {Number} i
   * @return {String}
   */

  var intToHex = function intToHex(i) {
    if (!Number.isSafeInteger(i) || i < 0) {
      throw new Error("Received an invalid integer type: ".concat(i));
    }

    return "0x".concat(i.toString(16));
  };

  exports.intToHex = intToHex;
  /**
   * Converts an `Number` to a `Buffer`
   * @param {Number} i
   * @return {Buffer}
   */

  var intToBuffer = function intToBuffer(i) {
    var hex = (0, exports.intToHex)(i);
    return Buffer$6.from((0, internal_1.padToEven)(hex.slice(2)), 'hex');
  };

  exports.intToBuffer = intToBuffer;
  /**
   * Returns a buffer filled with 0s.
   * @param bytes the number of bytes the buffer should be
   */

  var zeros = function zeros(bytes) {
    return Buffer$6.allocUnsafe(bytes).fill(0);
  };

  exports.zeros = zeros;
  /**
   * Pads a `Buffer` with zeros till it has `length` bytes.
   * Truncates the beginning or end of input if its length exceeds `length`.
   * @param msg the value to pad (Buffer)
   * @param length the number of bytes the output should be
   * @param right whether to start padding form the left or right
   * @return (Buffer)
   */

  var setLength = function setLength(msg, length, right) {
    var buf = (0, exports.zeros)(length);

    if (right) {
      if (msg.length < length) {
        msg.copy(buf);
        return buf;
      }

      return msg.slice(0, length);
    } else {
      if (msg.length < length) {
        msg.copy(buf, length - msg.length);
        return buf;
      }

      return msg.slice(-length);
    }
  };
  /**
   * Left Pads a `Buffer` with leading zeros till it has `length` bytes.
   * Or it truncates the beginning if it exceeds.
   * @param msg the value to pad (Buffer)
   * @param length the number of bytes the output should be
   * @return (Buffer)
   */


  var setLengthLeft = function setLengthLeft(msg, length) {
    (0, helpers_1.assertIsBuffer)(msg);
    return setLength(msg, length, false);
  };

  exports.setLengthLeft = setLengthLeft;
  /**
   * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.
   * it truncates the end if it exceeds.
   * @param msg the value to pad (Buffer)
   * @param length the number of bytes the output should be
   * @return (Buffer)
   */

  var setLengthRight = function setLengthRight(msg, length) {
    (0, helpers_1.assertIsBuffer)(msg);
    return setLength(msg, length, true);
  };

  exports.setLengthRight = setLengthRight;
  /**
   * Trims leading zeros from a `Buffer`, `String` or `Number[]`.
   * @param a (Buffer|Array|String)
   * @return (Buffer|Array|String)
   */

  var stripZeros = function stripZeros(a) {
    var first = a[0];

    while (a.length > 0 && first.toString() === '0') {
      a = a.slice(1);
      first = a[0];
    }

    return a;
  };
  /**
   * Trims leading zeros from a `Buffer`.
   * @param a (Buffer)
   * @return (Buffer)
   */


  var unpadBuffer = function unpadBuffer(a) {
    (0, helpers_1.assertIsBuffer)(a);
    return stripZeros(a);
  };

  exports.unpadBuffer = unpadBuffer;
  /**
   * Trims leading zeros from an `Array` (of numbers).
   * @param a (number[])
   * @return (number[])
   */

  var unpadArray = function unpadArray(a) {
    (0, helpers_1.assertIsArray)(a);
    return stripZeros(a);
  };

  exports.unpadArray = unpadArray;
  /**
   * Trims leading zeros from a hex-prefixed `String`.
   * @param a (String)
   * @return (String)
   */

  var unpadHexString = function unpadHexString(a) {
    (0, helpers_1.assertIsHexString)(a);
    a = (0, internal_1.stripHexPrefix)(a);
    return stripZeros(a);
  };

  exports.unpadHexString = unpadHexString;
  /**
   * Attempts to turn a value into a `Buffer`.
   * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BN` and other objects
   * with a `toArray()` or `toBuffer()` method.
   * @param v the value
   */

  var toBuffer = function toBuffer(v) {
    if (v === null || v === undefined) {
      return Buffer$6.allocUnsafe(0);
    }

    if (Buffer$6.isBuffer(v)) {
      return Buffer$6.from(v);
    }

    if (Array.isArray(v) || v instanceof Uint8Array) {
      return Buffer$6.from(v);
    }

    if (typeof v === 'string') {
      if (!(0, internal_1.isHexString)(v)) {
        throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ".concat(v));
      }

      return Buffer$6.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), 'hex');
    }

    if (typeof v === 'number') {
      return (0, exports.intToBuffer)(v);
    }

    if (externals_1.BN.isBN(v)) {
      if (v.isNeg()) {
        throw new Error("Cannot convert negative BN to buffer. Given: ".concat(v));
      }

      return v.toArrayLike(Buffer$6);
    }

    if (v.toArray) {
      // converts a BN to a Buffer
      return Buffer$6.from(v.toArray());
    }

    if (v.toBuffer) {
      return Buffer$6.from(v.toBuffer());
    }

    throw new Error('invalid type');
  };

  exports.toBuffer = toBuffer;
  /**
   * Converts a `Buffer` to a `Number`.
   * @param buf `Buffer` object to convert
   * @throws If the input number exceeds 53 bits.
   */

  var bufferToInt = function bufferToInt(buf) {
    return new externals_1.BN((0, exports.toBuffer)(buf)).toNumber();
  };

  exports.bufferToInt = bufferToInt;
  /**
   * Converts a `Buffer` into a `0x`-prefixed hex `String`.
   * @param buf `Buffer` object to convert
   */

  var bufferToHex = function bufferToHex(buf) {
    buf = (0, exports.toBuffer)(buf);
    return '0x' + buf.toString('hex');
  };

  exports.bufferToHex = bufferToHex;
  /**
   * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
   * @param num Signed integer value
   */

  var fromSigned = function fromSigned(num) {
    return new externals_1.BN(num).fromTwos(256);
  };

  exports.fromSigned = fromSigned;
  /**
   * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
   * @param num
   */

  var toUnsigned = function toUnsigned(num) {
    return Buffer$6.from(num.toTwos(256).toArray());
  };

  exports.toUnsigned = toUnsigned;
  /**
   * Adds "0x" to a given `String` if it does not already start with "0x".
   */

  var addHexPrefix = function addHexPrefix(str) {
    if (typeof str !== 'string') {
      return str;
    }

    return (0, internal_1.isHexPrefixed)(str) ? str : '0x' + str;
  };

  exports.addHexPrefix = addHexPrefix;
  /**
   * Returns the utf8 string representation from a hex string.
   *
   * Examples:
   *
   * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'
   * Input 2: '657468657265756d'
   * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'
   *
   * Output (all 3 input variants): 'ethereum'
   *
   * Note that this method is not intended to be used with hex strings
   * representing quantities in both big endian or little endian notation.
   *
   * @param string Hex string, should be `0x` prefixed
   * @return Utf8 string
   */

  var toUtf8 = function toUtf8(hex) {
    var zerosRegexp = /^(00)+|(00)+$/g;
    hex = (0, internal_1.stripHexPrefix)(hex);

    if (hex.length % 2 !== 0) {
      throw new Error('Invalid non-even hex string input for toUtf8() provided');
    }

    var bufferVal = Buffer$6.from(hex.replace(zerosRegexp, ''), 'hex');
    return bufferVal.toString('utf8');
  };

  exports.toUtf8 = toUtf8;
  /**
   * Converts a `Buffer` or `Array` to JSON.
   * @param ba (Buffer|Array)
   * @return (Array|String|null)
   */

  var baToJSON = function baToJSON(ba) {
    if (Buffer$6.isBuffer(ba)) {
      return "0x".concat(ba.toString('hex'));
    } else if (ba instanceof Array) {
      var array = [];

      for (var i = 0; i < ba.length; i++) {
        array.push((0, exports.baToJSON)(ba[i]));
      }

      return array;
    }
  };

  exports.baToJSON = baToJSON;
  /**
   * Checks provided Buffers for leading zeroes and throws if found.
   *
   * Examples:
   *
   * Valid values: 0x1, 0x, 0x01, 0x1234
   * Invalid values: 0x0, 0x00, 0x001, 0x0001
   *
   * Note: This method is useful for validating that RLP encoded integers comply with the rule that all
   * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes
   * @param values An object containing string keys and Buffer values
   * @throws if any provided value is found to have leading zero bytes
   */

  var validateNoLeadingZeroes = function validateNoLeadingZeroes(values) {
    for (var _i = 0, _Object$entries = Object.entries(values); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          k = _Object$entries$_i[0],
          v = _Object$entries$_i[1];

      if (v !== undefined && v.length > 0 && v[0] === 0) {
        throw new Error("".concat(k, " cannot have leading zeroes, received: ").concat(v.toString('hex')));
      }
    }
  };

  exports.validateNoLeadingZeroes = validateNoLeadingZeroes;

  function arrToBufArr(arr) {
    if (!Array.isArray(arr)) {
      return Buffer$6.from(arr);
    }

    return arr.map(function (a) {
      return arrToBufArr(a);
    });
  }

  exports.arrToBufArr = arrToBufArr;

  function bufArrToArr(arr) {
    if (!Array.isArray(arr)) {
      return Uint8Array.from(arr !== null && arr !== void 0 ? arr : []);
    }

    return arr.map(function (a) {
      return bufArrToArr(a);
    });
  }

  exports.bufArrToArr = bufArrToArr;
})(bytes$1);

var hash$1 = {};

var keccak$3 = {};

var hashUtils = {};

Object.defineProperty(hashUtils, "__esModule", {
  value: true
});

function createHashFunction(hashConstructor) {
  return function (msg) {
    var hash = hashConstructor();
    hash.update(msg);
    return Buffer$6.from(hash.digest());
  };
}

hashUtils.createHashFunction = createHashFunction;

var keccak$2 = {exports: {}};

var Transform$1 = readable.exports.Transform;

var keccak$1 = function keccak(KeccakState) {
  return /*#__PURE__*/function (_Transform) {
    _inherits(Keccak, _Transform);

    var _super = _createSuper(Keccak);

    function Keccak(rate, capacity, delimitedSuffix, hashBitLength, options) {
      var _this;

      _classCallCheck$1(this, Keccak);

      _this = _super.call(this, options);
      _this._rate = rate;
      _this._capacity = capacity;
      _this._delimitedSuffix = delimitedSuffix;
      _this._hashBitLength = hashBitLength;
      _this._options = options;
      _this._state = new KeccakState();

      _this._state.initialize(rate, capacity);

      _this._finalized = false;
      return _this;
    }

    _createClass$1(Keccak, [{
      key: "_transform",
      value: function _transform(chunk, encoding, callback) {
        var error = null;

        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }

        callback(error);
      }
    }, {
      key: "_flush",
      value: function _flush(callback) {
        var error = null;

        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }

        callback(error);
      }
    }, {
      key: "update",
      value: function update(data, encoding) {
        if (!Buffer$6.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer');
        if (this._finalized) throw new Error('Digest already called');
        if (!Buffer$6.isBuffer(data)) data = Buffer$6.from(data, encoding);

        this._state.absorb(data);

        return this;
      }
    }, {
      key: "digest",
      value: function digest(encoding) {
        if (this._finalized) throw new Error('Digest already called');
        this._finalized = true;
        if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix);

        var digest = this._state.squeeze(this._hashBitLength / 8);

        if (encoding !== undefined) digest = digest.toString(encoding);

        this._resetState();

        return digest;
      } // remove result from memory

    }, {
      key: "_resetState",
      value: function _resetState() {
        this._state.initialize(this._rate, this._capacity);

        return this;
      } // because sometimes we need hash right now and little later

    }, {
      key: "_clone",
      value: function _clone() {
        var clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);

        this._state.copy(clone._state);

        clone._finalized = this._finalized;
        return clone;
      }
    }]);

    return Keccak;
  }(Transform$1);
};

var Transform = readable.exports.Transform;

var shake = function shake(KeccakState) {
  return /*#__PURE__*/function (_Transform) {
    _inherits(Shake, _Transform);

    var _super = _createSuper(Shake);

    function Shake(rate, capacity, delimitedSuffix, options) {
      var _this;

      _classCallCheck$1(this, Shake);

      _this = _super.call(this, options);
      _this._rate = rate;
      _this._capacity = capacity;
      _this._delimitedSuffix = delimitedSuffix;
      _this._options = options;
      _this._state = new KeccakState();

      _this._state.initialize(rate, capacity);

      _this._finalized = false;
      return _this;
    }

    _createClass$1(Shake, [{
      key: "_transform",
      value: function _transform(chunk, encoding, callback) {
        var error = null;

        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }

        callback(error);
      }
    }, {
      key: "_flush",
      value: function _flush() {}
    }, {
      key: "_read",
      value: function _read(size) {
        this.push(this.squeeze(size));
      }
    }, {
      key: "update",
      value: function update(data, encoding) {
        if (!Buffer$6.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer');
        if (this._finalized) throw new Error('Squeeze already called');
        if (!Buffer$6.isBuffer(data)) data = Buffer$6.from(data, encoding);

        this._state.absorb(data);

        return this;
      }
    }, {
      key: "squeeze",
      value: function squeeze(dataByteLength, encoding) {
        if (!this._finalized) {
          this._finalized = true;

          this._state.absorbLastFewBits(this._delimitedSuffix);
        }

        var data = this._state.squeeze(dataByteLength);

        if (encoding !== undefined) data = data.toString(encoding);
        return data;
      }
    }, {
      key: "_resetState",
      value: function _resetState() {
        this._state.initialize(this._rate, this._capacity);

        return this;
      }
    }, {
      key: "_clone",
      value: function _clone() {
        var clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);

        this._state.copy(clone._state);

        clone._finalized = this._finalized;
        return clone;
      }
    }]);

    return Shake;
  }(Transform);
};

var createKeccak = keccak$1;
var createShake = shake;

var api = function api(KeccakState) {
  var Keccak = createKeccak(KeccakState);
  var Shake = createShake(KeccakState);
  return function (algorithm, options) {
    var hash = typeof algorithm === 'string' ? algorithm.toLowerCase() : algorithm;

    switch (hash) {
      case 'keccak224':
        return new Keccak(1152, 448, null, 224, options);

      case 'keccak256':
        return new Keccak(1088, 512, null, 256, options);

      case 'keccak384':
        return new Keccak(832, 768, null, 384, options);

      case 'keccak512':
        return new Keccak(576, 1024, null, 512, options);

      case 'sha3-224':
        return new Keccak(1152, 448, 0x06, 224, options);

      case 'sha3-256':
        return new Keccak(1088, 512, 0x06, 256, options);

      case 'sha3-384':
        return new Keccak(832, 768, 0x06, 384, options);

      case 'sha3-512':
        return new Keccak(576, 1024, 0x06, 512, options);

      case 'shake128':
        return new Shake(1344, 256, 0x1f, options);

      case 'shake256':
        return new Shake(1088, 512, 0x1f, options);

      default:
        throw new Error('Invald algorithm: ' + algorithm);
    }
  };
};

var keccakStateUnroll = {};

var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];

keccakStateUnroll.p1600 = function (s) {
  for (var round = 0; round < 24; ++round) {
    // theta
    var lo0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
    var hi0 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
    var lo1 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
    var hi1 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
    var lo2 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
    var hi2 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
    var lo3 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
    var hi3 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
    var lo4 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
    var hi4 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
    var lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
    var hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
    var t1slo0 = s[0] ^ lo;
    var t1shi0 = s[1] ^ hi;
    var t1slo5 = s[10] ^ lo;
    var t1shi5 = s[11] ^ hi;
    var t1slo10 = s[20] ^ lo;
    var t1shi10 = s[21] ^ hi;
    var t1slo15 = s[30] ^ lo;
    var t1shi15 = s[31] ^ hi;
    var t1slo20 = s[40] ^ lo;
    var t1shi20 = s[41] ^ hi;
    lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
    hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
    var t1slo1 = s[2] ^ lo;
    var t1shi1 = s[3] ^ hi;
    var t1slo6 = s[12] ^ lo;
    var t1shi6 = s[13] ^ hi;
    var t1slo11 = s[22] ^ lo;
    var t1shi11 = s[23] ^ hi;
    var t1slo16 = s[32] ^ lo;
    var t1shi16 = s[33] ^ hi;
    var t1slo21 = s[42] ^ lo;
    var t1shi21 = s[43] ^ hi;
    lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
    hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
    var t1slo2 = s[4] ^ lo;
    var t1shi2 = s[5] ^ hi;
    var t1slo7 = s[14] ^ lo;
    var t1shi7 = s[15] ^ hi;
    var t1slo12 = s[24] ^ lo;
    var t1shi12 = s[25] ^ hi;
    var t1slo17 = s[34] ^ lo;
    var t1shi17 = s[35] ^ hi;
    var t1slo22 = s[44] ^ lo;
    var t1shi22 = s[45] ^ hi;
    lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
    hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
    var t1slo3 = s[6] ^ lo;
    var t1shi3 = s[7] ^ hi;
    var t1slo8 = s[16] ^ lo;
    var t1shi8 = s[17] ^ hi;
    var t1slo13 = s[26] ^ lo;
    var t1shi13 = s[27] ^ hi;
    var t1slo18 = s[36] ^ lo;
    var t1shi18 = s[37] ^ hi;
    var t1slo23 = s[46] ^ lo;
    var t1shi23 = s[47] ^ hi;
    lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
    hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
    var t1slo4 = s[8] ^ lo;
    var t1shi4 = s[9] ^ hi;
    var t1slo9 = s[18] ^ lo;
    var t1shi9 = s[19] ^ hi;
    var t1slo14 = s[28] ^ lo;
    var t1shi14 = s[29] ^ hi;
    var t1slo19 = s[38] ^ lo;
    var t1shi19 = s[39] ^ hi;
    var t1slo24 = s[48] ^ lo;
    var t1shi24 = s[49] ^ hi; // rho & pi

    var t2slo0 = t1slo0;
    var t2shi0 = t1shi0;
    var t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
    var t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
    var t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
    var t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
    var t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
    var t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
    var t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
    var t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
    var t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
    var t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
    var t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
    var t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
    var t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
    var t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
    var t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
    var t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
    var t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
    var t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
    var t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
    var t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
    var t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
    var t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
    var t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
    var t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
    var t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
    var t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
    var t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
    var t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
    var t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
    var t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
    var t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
    var t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
    var t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
    var t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
    var t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
    var t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
    var t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
    var t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
    var t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
    var t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
    var t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
    var t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
    var t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
    var t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
    var t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
    var t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
    var t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
    var t2shi4 = t1shi24 << 14 | t1slo24 >>> 18; // chi

    s[0] = t2slo0 ^ ~t2slo1 & t2slo2;
    s[1] = t2shi0 ^ ~t2shi1 & t2shi2;
    s[10] = t2slo5 ^ ~t2slo6 & t2slo7;
    s[11] = t2shi5 ^ ~t2shi6 & t2shi7;
    s[20] = t2slo10 ^ ~t2slo11 & t2slo12;
    s[21] = t2shi10 ^ ~t2shi11 & t2shi12;
    s[30] = t2slo15 ^ ~t2slo16 & t2slo17;
    s[31] = t2shi15 ^ ~t2shi16 & t2shi17;
    s[40] = t2slo20 ^ ~t2slo21 & t2slo22;
    s[41] = t2shi20 ^ ~t2shi21 & t2shi22;
    s[2] = t2slo1 ^ ~t2slo2 & t2slo3;
    s[3] = t2shi1 ^ ~t2shi2 & t2shi3;
    s[12] = t2slo6 ^ ~t2slo7 & t2slo8;
    s[13] = t2shi6 ^ ~t2shi7 & t2shi8;
    s[22] = t2slo11 ^ ~t2slo12 & t2slo13;
    s[23] = t2shi11 ^ ~t2shi12 & t2shi13;
    s[32] = t2slo16 ^ ~t2slo17 & t2slo18;
    s[33] = t2shi16 ^ ~t2shi17 & t2shi18;
    s[42] = t2slo21 ^ ~t2slo22 & t2slo23;
    s[43] = t2shi21 ^ ~t2shi22 & t2shi23;
    s[4] = t2slo2 ^ ~t2slo3 & t2slo4;
    s[5] = t2shi2 ^ ~t2shi3 & t2shi4;
    s[14] = t2slo7 ^ ~t2slo8 & t2slo9;
    s[15] = t2shi7 ^ ~t2shi8 & t2shi9;
    s[24] = t2slo12 ^ ~t2slo13 & t2slo14;
    s[25] = t2shi12 ^ ~t2shi13 & t2shi14;
    s[34] = t2slo17 ^ ~t2slo18 & t2slo19;
    s[35] = t2shi17 ^ ~t2shi18 & t2shi19;
    s[44] = t2slo22 ^ ~t2slo23 & t2slo24;
    s[45] = t2shi22 ^ ~t2shi23 & t2shi24;
    s[6] = t2slo3 ^ ~t2slo4 & t2slo0;
    s[7] = t2shi3 ^ ~t2shi4 & t2shi0;
    s[16] = t2slo8 ^ ~t2slo9 & t2slo5;
    s[17] = t2shi8 ^ ~t2shi9 & t2shi5;
    s[26] = t2slo13 ^ ~t2slo14 & t2slo10;
    s[27] = t2shi13 ^ ~t2shi14 & t2shi10;
    s[36] = t2slo18 ^ ~t2slo19 & t2slo15;
    s[37] = t2shi18 ^ ~t2shi19 & t2shi15;
    s[46] = t2slo23 ^ ~t2slo24 & t2slo20;
    s[47] = t2shi23 ^ ~t2shi24 & t2shi20;
    s[8] = t2slo4 ^ ~t2slo0 & t2slo1;
    s[9] = t2shi4 ^ ~t2shi0 & t2shi1;
    s[18] = t2slo9 ^ ~t2slo5 & t2slo6;
    s[19] = t2shi9 ^ ~t2shi5 & t2shi6;
    s[28] = t2slo14 ^ ~t2slo10 & t2slo11;
    s[29] = t2shi14 ^ ~t2shi10 & t2shi11;
    s[38] = t2slo19 ^ ~t2slo15 & t2slo16;
    s[39] = t2shi19 ^ ~t2shi15 & t2shi16;
    s[48] = t2slo24 ^ ~t2slo20 & t2slo21;
    s[49] = t2shi24 ^ ~t2shi20 & t2shi21; // iota

    s[0] ^= P1600_ROUND_CONSTANTS[round * 2];
    s[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
  }
};

var keccakState = keccakStateUnroll;

function Keccak() {
  // much faster than `new Array(50)`
  this.state = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  this.blockSize = null;
  this.count = 0;
  this.squeezing = false;
}

Keccak.prototype.initialize = function (rate, capacity) {
  for (var i = 0; i < 50; ++i) {
    this.state[i] = 0;
  }

  this.blockSize = rate / 8;
  this.count = 0;
  this.squeezing = false;
};

Keccak.prototype.absorb = function (data) {
  for (var i = 0; i < data.length; ++i) {
    this.state[~~(this.count / 4)] ^= data[i] << 8 * (this.count % 4);
    this.count += 1;

    if (this.count === this.blockSize) {
      keccakState.p1600(this.state);
      this.count = 0;
    }
  }
};

Keccak.prototype.absorbLastFewBits = function (bits) {
  this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
  if ((bits & 0x80) !== 0 && this.count === this.blockSize - 1) keccakState.p1600(this.state);
  this.state[~~((this.blockSize - 1) / 4)] ^= 0x80 << 8 * ((this.blockSize - 1) % 4);
  keccakState.p1600(this.state);
  this.count = 0;
  this.squeezing = true;
};

Keccak.prototype.squeeze = function (length) {
  if (!this.squeezing) this.absorbLastFewBits(0x01);
  var output = Buffer$6.alloc(length);

  for (var i = 0; i < length; ++i) {
    output[i] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 0xff;
    this.count += 1;

    if (this.count === this.blockSize) {
      keccakState.p1600(this.state);
      this.count = 0;
    }
  }

  return output;
};

Keccak.prototype.copy = function (dest) {
  for (var i = 0; i < 50; ++i) {
    dest.state[i] = this.state[i];
  }

  dest.blockSize = this.blockSize;
  dest.count = this.count;
  dest.squeezing = this.squeezing;
};

var keccak = Keccak;

var js = api(keccak);

try {
  keccak$2.exports = require('./bindings');
} catch (err) {
  keccak$2.exports = js;
}

Object.defineProperty(keccak$3, "__esModule", {
  value: true
});
var hash_utils_1 = hashUtils;
var createKeccakHash = keccak$2.exports;
keccak$3.keccak224 = hash_utils_1.createHashFunction(function () {
  return createKeccakHash("keccak224");
});
keccak$3.keccak256 = hash_utils_1.createHashFunction(function () {
  return createKeccakHash("keccak256");
});
keccak$3.keccak384 = hash_utils_1.createHashFunction(function () {
  return createKeccakHash("keccak384");
});
keccak$3.keccak512 = hash_utils_1.createHashFunction(function () {
  return createKeccakHash("keccak512");
});

var createHash = require$$0.createHash;

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.rlphash = exports.ripemd160FromArray = exports.ripemd160FromString = exports.ripemd160 = exports.sha256FromArray = exports.sha256FromString = exports.sha256 = exports.keccakFromArray = exports.keccakFromHexString = exports.keccakFromString = exports.keccak256 = exports.keccak = void 0;
  var keccak_1 = keccak$3;
  var createHash$1 = createHash;
  var externals_1 = externals;
  var bytes_1 = bytes$1;
  var helpers_1 = helpers;
  /**
   * Creates Keccak hash of a Buffer input
   * @param a The input data (Buffer)
   * @param bits (number = 256) The Keccak width
   */

  var keccak = function keccak(a) {
    var bits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 256;
    (0, helpers_1.assertIsBuffer)(a);

    switch (bits) {
      case 224:
        {
          return (0, keccak_1.keccak224)(a);
        }

      case 256:
        {
          return (0, keccak_1.keccak256)(a);
        }

      case 384:
        {
          return (0, keccak_1.keccak384)(a);
        }

      case 512:
        {
          return (0, keccak_1.keccak512)(a);
        }

      default:
        {
          throw new Error("Invald algorithm: keccak".concat(bits));
        }
    }
  };

  exports.keccak = keccak;
  /**
   * Creates Keccak-256 hash of the input, alias for keccak(a, 256).
   * @param a The input data (Buffer)
   */

  var keccak256 = function keccak256(a) {
    return (0, exports.keccak)(a);
  };

  exports.keccak256 = keccak256;
  /**
   * Creates Keccak hash of a utf-8 string input
   * @param a The input data (String)
   * @param bits (number = 256) The Keccak width
   */

  var keccakFromString = function keccakFromString(a) {
    var bits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 256;
    (0, helpers_1.assertIsString)(a);
    var buf = Buffer$6.from(a, 'utf8');
    return (0, exports.keccak)(buf, bits);
  };

  exports.keccakFromString = keccakFromString;
  /**
   * Creates Keccak hash of an 0x-prefixed string input
   * @param a The input data (String)
   * @param bits (number = 256) The Keccak width
   */

  var keccakFromHexString = function keccakFromHexString(a) {
    var bits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 256;
    (0, helpers_1.assertIsHexString)(a);
    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);
  };

  exports.keccakFromHexString = keccakFromHexString;
  /**
   * Creates Keccak hash of a number array input
   * @param a The input data (number[])
   * @param bits (number = 256) The Keccak width
   */

  var keccakFromArray = function keccakFromArray(a) {
    var bits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 256;
    (0, helpers_1.assertIsArray)(a);
    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);
  };

  exports.keccakFromArray = keccakFromArray;
  /**
   * Creates SHA256 hash of an input.
   * @param  a The input data (Buffer|Array|String)
   */

  var _sha256 = function _sha256(a) {
    a = (0, bytes_1.toBuffer)(a);
    return createHash$1('sha256').update(a).digest();
  };
  /**
   * Creates SHA256 hash of a Buffer input.
   * @param a The input data (Buffer)
   */


  var sha256 = function sha256(a) {
    (0, helpers_1.assertIsBuffer)(a);
    return _sha256(a);
  };

  exports.sha256 = sha256;
  /**
   * Creates SHA256 hash of a string input.
   * @param a The input data (string)
   */

  var sha256FromString = function sha256FromString(a) {
    (0, helpers_1.assertIsString)(a);
    return _sha256(a);
  };

  exports.sha256FromString = sha256FromString;
  /**
   * Creates SHA256 hash of a number[] input.
   * @param a The input data (number[])
   */

  var sha256FromArray = function sha256FromArray(a) {
    (0, helpers_1.assertIsArray)(a);
    return _sha256(a);
  };

  exports.sha256FromArray = sha256FromArray;
  /**
   * Creates RIPEMD160 hash of the input.
   * @param a The input data (Buffer|Array|String|Number)
   * @param padded Whether it should be padded to 256 bits or not
   */

  var _ripemd160 = function _ripemd160(a, padded) {
    a = (0, bytes_1.toBuffer)(a);
    var hash = createHash$1('rmd160').update(a).digest();

    if (padded === true) {
      return (0, bytes_1.setLengthLeft)(hash, 32);
    } else {
      return hash;
    }
  };
  /**
   * Creates RIPEMD160 hash of a Buffer input.
   * @param a The input data (Buffer)
   * @param padded Whether it should be padded to 256 bits or not
   */


  var ripemd160 = function ripemd160(a, padded) {
    (0, helpers_1.assertIsBuffer)(a);
    return _ripemd160(a, padded);
  };

  exports.ripemd160 = ripemd160;
  /**
   * Creates RIPEMD160 hash of a string input.
   * @param a The input data (String)
   * @param padded Whether it should be padded to 256 bits or not
   */

  var ripemd160FromString = function ripemd160FromString(a, padded) {
    (0, helpers_1.assertIsString)(a);
    return _ripemd160(a, padded);
  };

  exports.ripemd160FromString = ripemd160FromString;
  /**
   * Creates RIPEMD160 hash of a number[] input.
   * @param a The input data (number[])
   * @param padded Whether it should be padded to 256 bits or not
   */

  var ripemd160FromArray = function ripemd160FromArray(a, padded) {
    (0, helpers_1.assertIsArray)(a);
    return _ripemd160(a, padded);
  };

  exports.ripemd160FromArray = ripemd160FromArray;
  /**
   * Creates SHA-3 hash of the RLP encoded version of the input.
   * @param a The input data
   */

  var rlphash = function rlphash(a) {
    return (0, exports.keccak)(externals_1.rlp.encode(a));
  };

  exports.rlphash = rlphash;
})(hash$1);

var types = {};

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;
  var externals_1 = externals;
  var internal_1 = internal;
  var bytes_1 = bytes$1;
  /**
   * Convert BN to 0x-prefixed hex string.
   */

  function bnToHex(value) {
    return "0x".concat(value.toString(16));
  }

  exports.bnToHex = bnToHex;
  /**
   * Convert value from BN to an unpadded Buffer
   * (useful for RLP transport)
   * @param value value to convert
   */

  function bnToUnpaddedBuffer(value) {
    // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`
    // for compatibility with browserify and similar tools
    return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer$6));
  }

  exports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;
  /**
   * Deprecated alias for {@link bnToUnpaddedBuffer}
   * @deprecated
   */

  function bnToRlp(value) {
    return bnToUnpaddedBuffer(value);
  }

  exports.bnToRlp = bnToRlp;
  /**
   * Type output options
   */

  var TypeOutput;

  (function (TypeOutput) {
    TypeOutput[TypeOutput["Number"] = 0] = "Number";
    TypeOutput[TypeOutput["BN"] = 1] = "BN";
    TypeOutput[TypeOutput["Buffer"] = 2] = "Buffer";
    TypeOutput[TypeOutput["PrefixedHexString"] = 3] = "PrefixedHexString";
  })(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));

  function toType(input, outputType) {
    if (input === null) {
      return null;
    }

    if (input === undefined) {
      return undefined;
    }

    if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {
      throw new Error("A string must be provided with a 0x-prefix, given: ".concat(input));
    } else if (typeof input === 'number' && !Number.isSafeInteger(input)) {
      throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');
    }

    var output = (0, bytes_1.toBuffer)(input);

    if (outputType === TypeOutput.Buffer) {
      return output;
    } else if (outputType === TypeOutput.BN) {
      return new externals_1.BN(output);
    } else if (outputType === TypeOutput.Number) {
      var bn = new externals_1.BN(output);
      var max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());

      if (bn.gt(max)) {
        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');
      }

      return bn.toNumber();
    } else {
      // outputType === TypeOutput.PrefixedHexString
      return "0x".concat(output.toString('hex'));
    }
  }

  exports.toType = toType;
})(types);

(function (exports) {

  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;

  var assert_1 = __importDefault(require$$0$1);

  var externals_1 = externals;
  var secp256k1_1 = secp256k1$2;
  var internal_1 = internal;
  var constants_1 = constants$1;
  var bytes_1 = bytes$1;
  var hash_1 = hash$1;
  var helpers_1 = helpers;
  var types_1 = types;

  var Account = /*#__PURE__*/function () {
    /**
     * This constructor assigns and validates the values.
     * Use the static factory methods to assist in creating an Account from varying data types.
     */
    function Account() {
      var nonce = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new externals_1.BN(0);
      var balance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new externals_1.BN(0);
      var stateRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : constants_1.KECCAK256_RLP;
      var codeHash = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.KECCAK256_NULL;

      _classCallCheck$1(this, Account);

      this.nonce = nonce;
      this.balance = balance;
      this.stateRoot = stateRoot;
      this.codeHash = codeHash;

      this._validate();
    }

    _createClass$1(Account, [{
      key: "_validate",
      value: function _validate() {
        if (this.nonce.lt(new externals_1.BN(0))) {
          throw new Error('nonce must be greater than zero');
        }

        if (this.balance.lt(new externals_1.BN(0))) {
          throw new Error('balance must be greater than zero');
        }

        if (this.stateRoot.length !== 32) {
          throw new Error('stateRoot must have a length of 32');
        }

        if (this.codeHash.length !== 32) {
          throw new Error('codeHash must have a length of 32');
        }
      }
      /**
       * Returns a Buffer Array of the raw Buffers for the account, in order.
       */

    }, {
      key: "raw",
      value: function raw() {
        return [(0, types_1.bnToUnpaddedBuffer)(this.nonce), (0, types_1.bnToUnpaddedBuffer)(this.balance), this.stateRoot, this.codeHash];
      }
      /**
       * Returns the RLP serialization of the account as a `Buffer`.
       */

    }, {
      key: "serialize",
      value: function serialize() {
        return externals_1.rlp.encode(this.raw());
      }
      /**
       * Returns a `Boolean` determining if the account is a contract.
       */

    }, {
      key: "isContract",
      value: function isContract() {
        return !this.codeHash.equals(constants_1.KECCAK256_NULL);
      }
      /**
       * Returns a `Boolean` determining if the account is empty complying to the definition of
       * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
       * "An account is considered empty when it has no code and zero nonce and zero balance."
       */

    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);
      }
    }], [{
      key: "fromAccountData",
      value: function fromAccountData(accountData) {
        var nonce = accountData.nonce,
            balance = accountData.balance,
            stateRoot = accountData.stateRoot,
            codeHash = accountData.codeHash;
        return new Account(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : undefined, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : undefined, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : undefined, codeHash ? (0, bytes_1.toBuffer)(codeHash) : undefined);
      }
    }, {
      key: "fromRlpSerializedAccount",
      value: function fromRlpSerializedAccount(serialized) {
        var values = externals_1.rlp.decode(serialized);

        if (!Array.isArray(values)) {
          throw new Error('Invalid serialized account input. Must be array');
        }

        return this.fromValuesArray(values);
      }
    }, {
      key: "fromValuesArray",
      value: function fromValuesArray(values) {
        var _values = _slicedToArray(values, 4),
            nonce = _values[0],
            balance = _values[1],
            stateRoot = _values[2],
            codeHash = _values[3];

        return new Account(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);
      }
    }]);

    return Account;
  }();

  exports.Account = Account;
  /**
   * Checks if the address is a valid. Accepts checksummed addresses too.
   */

  var isValidAddress = function isValidAddress(hexAddress) {
    try {
      (0, helpers_1.assertIsString)(hexAddress);
    } catch (e) {
      return false;
    }

    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
  };

  exports.isValidAddress = isValidAddress;
  /**
   * Returns a checksummed address.
   *
   * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This
   * has the effect of checksummed addresses for one chain having invalid checksums for others.
   * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).
   *
   * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not
   * backwards compatible to the original widely adopted checksum format standard introduced in
   * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.
   * Usage of this EIP is therefore discouraged unless you have a very targeted use case.
   */

  var toChecksumAddress = function toChecksumAddress(hexAddress, eip1191ChainId) {
    (0, helpers_1.assertIsHexString)(hexAddress);
    var address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();
    var prefix = '';

    if (eip1191ChainId) {
      var chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);
      prefix = chainId.toString() + '0x';
    }

    var hash = (0, hash_1.keccakFromString)(prefix + address).toString('hex');
    var ret = '0x';

    for (var i = 0; i < address.length; i++) {
      if (parseInt(hash[i], 16) >= 8) {
        ret += address[i].toUpperCase();
      } else {
        ret += address[i];
      }
    }

    return ret;
  };

  exports.toChecksumAddress = toChecksumAddress;
  /**
   * Checks if the address is a valid checksummed address.
   *
   * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.
   */

  var isValidChecksumAddress = function isValidChecksumAddress(hexAddress, eip1191ChainId) {
    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;
  };

  exports.isValidChecksumAddress = isValidChecksumAddress;
  /**
   * Generates an address of a newly created contract.
   * @param from The address which is creating this new address
   * @param nonce The nonce of the from account
   */

  var generateAddress = function generateAddress(from, nonce) {
    (0, helpers_1.assertIsBuffer)(from);
    (0, helpers_1.assertIsBuffer)(nonce);
    var nonceBN = new externals_1.BN(nonce);

    if (nonceBN.isZero()) {
      // in RLP we want to encode null in the case of zero nonce
      // read the RLP documentation for an answer if you dare
      return (0, hash_1.rlphash)([from, null]).slice(-20);
    } // Only take the lower 160bits of the hash


    return (0, hash_1.rlphash)([from, Buffer$6.from(nonceBN.toArray())]).slice(-20);
  };

  exports.generateAddress = generateAddress;
  /**
   * Generates an address for a contract created using CREATE2.
   * @param from The address which is creating this new address
   * @param salt A salt
   * @param initCode The init code of the contract being created
   */

  var generateAddress2 = function generateAddress2(from, salt, initCode) {
    (0, helpers_1.assertIsBuffer)(from);
    (0, helpers_1.assertIsBuffer)(salt);
    (0, helpers_1.assertIsBuffer)(initCode);
    (0, assert_1["default"])(from.length === 20);
    (0, assert_1["default"])(salt.length === 32);
    var address = (0, hash_1.keccak256)(Buffer$6.concat([Buffer$6.from('ff', 'hex'), from, salt, (0, hash_1.keccak256)(initCode)]));
    return address.slice(-20);
  };

  exports.generateAddress2 = generateAddress2;
  /**
   * Checks if the private key satisfies the rules of the curve secp256k1.
   */

  var isValidPrivate = function isValidPrivate(privateKey) {
    return (0, secp256k1_1.privateKeyVerify)(privateKey);
  };

  exports.isValidPrivate = isValidPrivate;
  /**
   * Checks if the public key satisfies the rules of the curve secp256k1
   * and the requirements of Ethereum.
   * @param publicKey The two points of an uncompressed key, unless sanitize is enabled
   * @param sanitize Accept public keys in other formats
   */

  var isValidPublic = function isValidPublic(publicKey) {
    var sanitize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    (0, helpers_1.assertIsBuffer)(publicKey);

    if (publicKey.length === 64) {
      // Convert to SEC1 for secp256k1
      return (0, secp256k1_1.publicKeyVerify)(Buffer$6.concat([Buffer$6.from([4]), publicKey]));
    }

    if (!sanitize) {
      return false;
    }

    return (0, secp256k1_1.publicKeyVerify)(publicKey);
  };

  exports.isValidPublic = isValidPublic;
  /**
   * Returns the ethereum address of a given public key.
   * Accepts "Ethereum public keys" and SEC1 encoded keys.
   * @param pubKey The two points of an uncompressed key, unless sanitize is enabled
   * @param sanitize Accept public keys in other formats
   */

  var pubToAddress = function pubToAddress(pubKey) {
    var sanitize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    (0, helpers_1.assertIsBuffer)(pubKey);

    if (sanitize && pubKey.length !== 64) {
      pubKey = Buffer$6.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));
    }

    (0, assert_1["default"])(pubKey.length === 64); // Only take the lower 160bits of the hash

    return (0, hash_1.keccak)(pubKey).slice(-20);
  };

  exports.pubToAddress = pubToAddress;
  exports.publicToAddress = exports.pubToAddress;
  /**
   * Returns the ethereum public key of a given private key.
   * @param privateKey A private key must be 256 bits wide
   */

  var privateToPublic = function privateToPublic(privateKey) {
    (0, helpers_1.assertIsBuffer)(privateKey); // skip the type flag and use the X, Y points

    return Buffer$6.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);
  };

  exports.privateToPublic = privateToPublic;
  /**
   * Returns the ethereum address of a given private key.
   * @param privateKey A private key must be 256 bits wide
   */

  var privateToAddress = function privateToAddress(privateKey) {
    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));
  };

  exports.privateToAddress = privateToAddress;
  /**
   * Converts a public key to the Ethereum format.
   */

  var importPublic = function importPublic(publicKey) {
    (0, helpers_1.assertIsBuffer)(publicKey);

    if (publicKey.length !== 64) {
      publicKey = Buffer$6.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));
    }

    return publicKey;
  };

  exports.importPublic = importPublic;
  /**
   * Returns the zero address.
   */

  var zeroAddress = function zeroAddress() {
    var addressLength = 20;
    var addr = (0, bytes_1.zeros)(addressLength);
    return (0, bytes_1.bufferToHex)(addr);
  };

  exports.zeroAddress = zeroAddress;
  /**
   * Checks if a given address is the zero address.
   */

  var isZeroAddress = function isZeroAddress(hexAddress) {
    try {
      (0, helpers_1.assertIsString)(hexAddress);
    } catch (e) {
      return false;
    }

    var zeroAddr = (0, exports.zeroAddress)();
    return zeroAddr === hexAddress;
  };

  exports.isZeroAddress = isZeroAddress;
})(account$1);

var address = {};

var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(address, "__esModule", {
  value: true
});
address.Address = void 0;

var assert_1$1 = __importDefault$1(require$$0$1);

var externals_1$2 = externals;
var bytes_1$4 = bytes$1;
var account_1 = account$1;

var Address = /*#__PURE__*/function () {
  function Address(buf) {
    _classCallCheck$1(this, Address);

    (0, assert_1$1["default"])(buf.length === 20, 'Invalid address length');
    this.buf = buf;
  }
  /**
   * Returns the zero address.
   */


  _createClass$1(Address, [{
    key: "equals",
    value:
    /**
     * Is address equal to another.
     */
    function equals(address) {
      return this.buf.equals(address.buf);
    }
    /**
     * Is address zero.
     */

  }, {
    key: "isZero",
    value: function isZero() {
      return this.equals(Address.zero());
    }
    /**
     * True if address is in the address range defined
     * by EIP-1352
     */

  }, {
    key: "isPrecompileOrSystemAddress",
    value: function isPrecompileOrSystemAddress() {
      var addressBN = new externals_1$2.BN(this.buf);
      var rangeMin = new externals_1$2.BN(0);
      var rangeMax = new externals_1$2.BN('ffff', 'hex');
      return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);
    }
    /**
     * Returns hex encoding of address.
     */

  }, {
    key: "toString",
    value: function toString() {
      return '0x' + this.buf.toString('hex');
    }
    /**
     * Returns Buffer representation of address.
     */

  }, {
    key: "toBuffer",
    value: function toBuffer() {
      return Buffer$6.from(this.buf);
    }
  }], [{
    key: "zero",
    value: function zero() {
      return new Address((0, bytes_1$4.zeros)(20));
    }
    /**
     * Returns an Address object from a hex-encoded string.
     * @param str - Hex-encoded address
     */

  }, {
    key: "fromString",
    value: function fromString(str) {
      (0, assert_1$1["default"])((0, account_1.isValidAddress)(str), 'Invalid address');
      return new Address((0, bytes_1$4.toBuffer)(str));
    }
    /**
     * Returns an address for a given public key.
     * @param pubKey The two points of an uncompressed key
     */

  }, {
    key: "fromPublicKey",
    value: function fromPublicKey(pubKey) {
      (0, assert_1$1["default"])(Buffer$6.isBuffer(pubKey), 'Public key should be Buffer');
      var buf = (0, account_1.pubToAddress)(pubKey);
      return new Address(buf);
    }
    /**
     * Returns an address for a given private key.
     * @param privateKey A private key must be 256 bits wide
     */

  }, {
    key: "fromPrivateKey",
    value: function fromPrivateKey(privateKey) {
      (0, assert_1$1["default"])(Buffer$6.isBuffer(privateKey), 'Private key should be Buffer');
      var buf = (0, account_1.privateToAddress)(privateKey);
      return new Address(buf);
    }
    /**
     * Generates an address for a newly created contract.
     * @param from The address which is creating this new address
     * @param nonce The nonce of the from account
     */

  }, {
    key: "generate",
    value: function generate(from, nonce) {
      (0, assert_1$1["default"])(externals_1$2.BN.isBN(nonce));
      return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer$6)));
    }
    /**
     * Generates an address for a contract created using CREATE2.
     * @param from The address which is creating this new address
     * @param salt A salt
     * @param initCode The init code of the contract being created
     */

  }, {
    key: "generate2",
    value: function generate2(from, salt, initCode) {
      (0, assert_1$1["default"])(Buffer$6.isBuffer(salt));
      (0, assert_1$1["default"])(Buffer$6.isBuffer(initCode));
      return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));
    }
  }]);

  return Address;
}();

address.Address = Address;

var signature$1 = {};

Object.defineProperty(signature$1, "__esModule", {
  value: true
});
signature$1.hashPersonalMessage = signature$1.isValidSignature = signature$1.fromRpcSig = signature$1.toCompactSig = signature$1.toRpcSig = signature$1.ecrecover = signature$1.ecsign = void 0;
var secp256k1_1 = secp256k1$2;
var externals_1$1 = externals;
var bytes_1$3 = bytes$1;
var hash_1$1 = hash$1;
var helpers_1 = helpers;
var types_1 = types;

function ecsign(msgHash, privateKey, chainId) {
  var _ref = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey),
      signature = _ref.signature,
      recovery = _ref.recid;

  var r = Buffer$6.from(signature.slice(0, 32));
  var s = Buffer$6.from(signature.slice(32, 64));

  if (!chainId || typeof chainId === 'number') {
    // return legacy type ECDSASignature (deprecated in favor of ECDSASignatureBuffer to handle large chainIds)
    if (chainId && !Number.isSafeInteger(chainId)) {
      throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');
    }

    var _v = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;

    return {
      r: r,
      s: s,
      v: _v
    };
  }

  var chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);
  var v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer$6);
  return {
    r: r,
    s: s,
    v: v
  };
}

signature$1.ecsign = ecsign;

function calculateSigRecovery$1(v, chainId) {
  var vBN = (0, types_1.toType)(v, types_1.TypeOutput.BN);

  if (!chainId) {
    return vBN.subn(27);
  }

  var chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);
  return vBN.sub(chainIdBN.muln(2).addn(35));
}

function isValidSigRecovery$1(recovery) {
  var rec = new externals_1$1.BN(recovery);
  return rec.eqn(0) || rec.eqn(1);
}
/**
 * ECDSA public key recovery from signature.
 * @returns Recovered public key
 */


var ecrecover = function ecrecover(msgHash, v, r, s, chainId) {
  var signature = Buffer$6.concat([(0, bytes_1$3.setLengthLeft)(r, 32), (0, bytes_1$3.setLengthLeft)(s, 32)], 64);
  var recovery = calculateSigRecovery$1(v, chainId);

  if (!isValidSigRecovery$1(recovery)) {
    throw new Error('Invalid signature v value');
  }

  var senderPubKey = (0, secp256k1_1.ecdsaRecover)(signature, recovery.toNumber(), msgHash);
  return Buffer$6.from((0, secp256k1_1.publicKeyConvert)(senderPubKey, false).slice(1));
};

signature$1.ecrecover = ecrecover;
/**
 * Convert signature parameters into the format of `eth_sign` RPC method.
 * @returns Signature
 */

var toRpcSig = function toRpcSig(v, r, s, chainId) {
  var recovery = calculateSigRecovery$1(v, chainId);

  if (!isValidSigRecovery$1(recovery)) {
    throw new Error('Invalid signature v value');
  } // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin


  return (0, bytes_1$3.bufferToHex)(Buffer$6.concat([(0, bytes_1$3.setLengthLeft)(r, 32), (0, bytes_1$3.setLengthLeft)(s, 32), (0, bytes_1$3.toBuffer)(v)]));
};

signature$1.toRpcSig = toRpcSig;
/**
 * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).
 * @returns Signature
 */

var toCompactSig = function toCompactSig(v, r, s, chainId) {
  var recovery = calculateSigRecovery$1(v, chainId);

  if (!isValidSigRecovery$1(recovery)) {
    throw new Error('Invalid signature v value');
  }

  var vn = (0, types_1.toType)(v, types_1.TypeOutput.Number);
  var ss = s;

  if (vn > 28 && vn % 2 === 1 || vn === 1 || vn === 28) {
    ss = Buffer$6.from(s);
    ss[0] |= 0x80;
  }

  return (0, bytes_1$3.bufferToHex)(Buffer$6.concat([(0, bytes_1$3.setLengthLeft)(r, 32), (0, bytes_1$3.setLengthLeft)(ss, 32)]));
};

signature$1.toCompactSig = toCompactSig;
/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 */

var fromRpcSig = function fromRpcSig(sig) {
  var buf = (0, bytes_1$3.toBuffer)(sig);
  var r;
  var s;
  var v;

  if (buf.length >= 65) {
    r = buf.slice(0, 32);
    s = buf.slice(32, 64);
    v = (0, bytes_1$3.bufferToInt)(buf.slice(64));
  } else if (buf.length === 64) {
    // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)
    r = buf.slice(0, 32);
    s = buf.slice(32, 64);
    v = (0, bytes_1$3.bufferToInt)(buf.slice(32, 33)) >> 7;
    s[0] &= 0x7f;
  } else {
    throw new Error('Invalid signature length');
  } // support both versions of `eth_sign` responses


  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: r,
    s: s
  };
};

signature$1.fromRpcSig = fromRpcSig;
/**
 * Validate a ECDSA signature.
 * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one
 */

var isValidSignature = function isValidSignature(v, r, s) {
  var homesteadOrLater = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var chainId = arguments.length > 4 ? arguments[4] : undefined;
  var SECP256K1_N_DIV_2 = new externals_1$1.BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new externals_1$1.BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (!isValidSigRecovery$1(calculateSigRecovery$1(v, chainId))) {
    return false;
  }

  var rBN = new externals_1$1.BN(r);
  var sBN = new externals_1$1.BN(s);

  if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
    return false;
  }

  if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

signature$1.isValidSignature = isValidSignature;
/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 */

var hashPersonalMessage = function hashPersonalMessage(message) {
  (0, helpers_1.assertIsBuffer)(message);
  var prefix = Buffer$6.from("\x19Ethereum Signed Message:\n".concat(message.length), 'utf-8');
  return (0, hash_1$1.keccak)(Buffer$6.concat([prefix, message]));
};

signature$1.hashPersonalMessage = hashPersonalMessage;

var object$1 = {};

var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(object$1, "__esModule", {
  value: true
});
object$1.defineProperties = void 0;

var assert_1 = __importDefault(require$$0$1);

var internal_1 = internal;
var externals_1 = externals;
var bytes_1$2 = bytes$1;
/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param self the `Object` to define properties on
 * @param fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param data data to be validated against the definitions
 * @deprecated
 */

var defineProperties = function defineProperties(self, fields, data) {
  self.raw = [];
  self._fields = []; // attach the `toJSON`

  self.toJSON = function () {
    var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (label) {
      var obj = {};

      self._fields.forEach(function (field) {
        obj[field] = "0x".concat(self[field].toString('hex'));
      });

      return obj;
    }

    return (0, bytes_1$2.baToJSON)(self.raw);
  };

  self.serialize = function serialize() {
    return externals_1.rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);

    function getter() {
      return self.raw[i];
    }

    function setter(v) {
      v = (0, bytes_1$2.toBuffer)(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer$6.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = (0, bytes_1$2.unpadBuffer)(v);
        (0, assert_1["default"])(field.length >= v.length, "The field ".concat(field.name, " must not have more ").concat(field.length, " bytes"));
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        (0, assert_1["default"])(field.length === v.length, "The field ".concat(field.name, " must have byte length of ").concat(field.length));
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field["default"]) {
      self[field.name] = field["default"];
    } // attach alias


    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  }); // if the constuctor is passed data

  if (data) {
    if (typeof data === 'string') {
      data = Buffer$6.from((0, internal_1.stripHexPrefix)(data), 'hex');
    }

    if (Buffer$6.isBuffer(data)) {
      data = externals_1.rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      } // make sure all the items are buffers


      data.forEach(function (d, i) {
        self[self._fields[i]] = (0, bytes_1$2.toBuffer)(d);
      });
    } else if (_typeof(data) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};

object$1.defineProperties = defineProperties;

(function (exports) {

  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    });
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });

  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
    for (var p in m) {
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    }
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;
  /**
   * Constants
   */

  __exportStar(constants$1, exports);
  /**
   * Account class and helper functions
   */


  __exportStar(account$1, exports);
  /**
   * Address type
   */


  __exportStar(address, exports);
  /**
   * Hash functions
   */


  __exportStar(hash$1, exports);
  /**
   * ECDSA signature
   */


  __exportStar(signature$1, exports);
  /**
   * Utilities for manipulating Buffers, byte arrays, etc.
   */


  __exportStar(bytes$1, exports);
  /**
   * Function for definining properties on an object
   */


  __exportStar(object$1, exports);
  /**
   * External exports (BN, rlp)
   */


  __exportStar(externals, exports);
  /**
   * Helpful TypeScript types
   */


  __exportStar(types, exports);
  /**
   * Export ethjs-util methods
   */


  var internal_1 = internal;
  Object.defineProperty(exports, "isHexPrefixed", {
    enumerable: true,
    get: function get() {
      return internal_1.isHexPrefixed;
    }
  });
  Object.defineProperty(exports, "stripHexPrefix", {
    enumerable: true,
    get: function get() {
      return internal_1.stripHexPrefix;
    }
  });
  Object.defineProperty(exports, "padToEven", {
    enumerable: true,
    get: function get() {
      return internal_1.padToEven;
    }
  });
  Object.defineProperty(exports, "getBinarySize", {
    enumerable: true,
    get: function get() {
      return internal_1.getBinarySize;
    }
  });
  Object.defineProperty(exports, "arrayContainsArray", {
    enumerable: true,
    get: function get() {
      return internal_1.arrayContainsArray;
    }
  });
  Object.defineProperty(exports, "toAscii", {
    enumerable: true,
    get: function get() {
      return internal_1.toAscii;
    }
  });
  Object.defineProperty(exports, "fromUtf8", {
    enumerable: true,
    get: function get() {
      return internal_1.fromUtf8;
    }
  });
  Object.defineProperty(exports, "fromAscii", {
    enumerable: true,
    get: function get() {
      return internal_1.fromAscii;
    }
  });
  Object.defineProperty(exports, "getKeys", {
    enumerable: true,
    get: function get() {
      return internal_1.getKeys;
    }
  });
  Object.defineProperty(exports, "isHexString", {
    enumerable: true,
    get: function get() {
      return internal_1.isHexString;
    }
  });
})(dist$3);

Keypair.generate();

var crc32c = {};

/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */

(function (exports) {

  (function (factory) {
    /*jshint ignore:start */

    /*eslint-disable */
    if (typeof DO_NOT_EXPORT_CRC === 'undefined') {
      {
        factory(exports);
      }
    } else {
      factory({});
    }
    /*eslint-enable */

    /*jshint ignore:end */

  })(function (CRC32C) {
    CRC32C.version = '1.2.2';
    /*global Int32Array */

    function signed_crc_table() {
      var c = 0,
          table = new Array(256);

      for (var n = 0; n != 256; ++n) {
        c = n;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        table[n] = c;
      }

      return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
    }

    var T0 = signed_crc_table();

    function slice_by_16_tables(T) {
      var c = 0,
          v = 0,
          n = 0,
          table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096);

      for (n = 0; n != 256; ++n) {
        table[n] = T[n];
      }

      for (n = 0; n != 256; ++n) {
        v = T[n];

        for (c = 256 + n; c < 4096; c += 256) {
          v = table[c] = v >>> 8 ^ T[v & 0xFF];
        }
      }

      var out = [];

      for (n = 1; n != 16; ++n) {
        out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
      }

      return out;
    }

    var TT = slice_by_16_tables(T0);
    var T1 = TT[0],
        T2 = TT[1],
        T3 = TT[2],
        T4 = TT[3],
        T5 = TT[4];
    var T6 = TT[5],
        T7 = TT[6],
        T8 = TT[7],
        T9 = TT[8],
        Ta = TT[9];
    var Tb = TT[10],
        Tc = TT[11],
        Td = TT[12],
        Te = TT[13],
        Tf = TT[14];

    function crc32_bstr(bstr, seed) {
      var C = seed ^ -1;

      for (var i = 0, L = bstr.length; i < L;) {
        C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 0xFF];
      }

      return ~C;
    }

    function crc32_buf(B, seed) {
      var C = seed ^ -1,
          L = B.length - 15,
          i = 0;

      for (; i < L;) {
        C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
      }

      L += 15;

      while (i < L) {
        C = C >>> 8 ^ T0[(C ^ B[i++]) & 0xFF];
      }

      return ~C;
    }

    function crc32_str(str, seed) {
      var C = seed ^ -1;

      for (var i = 0, L = str.length, c = 0, d = 0; i < L;) {
        c = str.charCodeAt(i++);

        if (c < 0x80) {
          C = C >>> 8 ^ T0[(C ^ c) & 0xFF];
        } else if (c < 0x800) {
          C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 0xFF];
        } else if (c >= 0xD800 && c < 0xE000) {
          c = (c & 1023) + 64;
          d = str.charCodeAt(i++) & 1023;
          C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 0xFF];
        } else {
          C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 0xFF];
        }
      }

      return ~C;
    }

    CRC32C.table = T0; // $FlowIgnore

    CRC32C.bstr = crc32_bstr; // $FlowIgnore

    CRC32C.buf = crc32_buf; // $FlowIgnore

    CRC32C.str = crc32_str;
  });
})(crc32c);

var NodeScore = /*#__PURE__*/_createClass$1(function NodeScore(node) {
  _classCallCheck$1(this, NodeScore);

  _defineProperty$4(this, "node", void 0);

  _defineProperty$4(this, "score", void 0);

  this.node = node;
  this.score = 0;
});
/**
 * TypeScript equivalent of https://github.com/tysonmote/rendezvous/blob/be0258dbbd3d/rendezvous.go
 */


var RendezvousHash = /*#__PURE__*/function () {
  function RendezvousHash() {
    _classCallCheck$1(this, RendezvousHash);

    _defineProperty$4(this, "nodes", []);

    this.add.apply(this, arguments);
  }

  _createClass$1(RendezvousHash, [{
    key: "add",
    value: function add() {
      for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
        nodes[_key] = arguments[_key];
      }

      for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {
        var node = _nodes[_i];
        this.nodes.push(new NodeScore(buffer.Buffer.from(node)));
      }
    }
  }, {
    key: "get",
    value: function get(key) {
      var _maxNode$toString, _maxNode;

      var maxScore = 0;
      var maxNode = null;
      var keyBytes = buffer.Buffer.from(key);

      var _iterator = _createForOfIteratorHelper(this.nodes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var node = _step.value;
          var score = this.hash(node.node, keyBytes);

          if (score > maxScore || score === maxScore && node.node.compare(maxNode) < 0) {
            maxScore = score;
            maxNode = node.node;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return (_maxNode$toString = (_maxNode = maxNode) === null || _maxNode === void 0 ? void 0 : _maxNode.toString()) !== null && _maxNode$toString !== void 0 ? _maxNode$toString : '';
    }
  }, {
    key: "getN",
    value: function getN(n, key) {
      var keyBytes = buffer.Buffer.from(key);

      var _iterator2 = _createForOfIteratorHelper(this.nodes),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var node = _step2.value;
          node.score = this.hash(node.node, keyBytes);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.nodes.sort(function (a, b) {
        if (a.score === b.score) {
          return a.node.compare(b.node);
        }

        return b.score - a.score;
      });

      if (n > this.nodes.length) {
        n = this.nodes.length;
      }

      var nodes = [];

      for (var i = 0; i < n; i++) {
        nodes.push(this.nodes[i].node.toString());
      }

      return nodes;
    }
  }, {
    key: "getNodes",
    value: function getNodes() {
      return this.nodes.map(function (nodeScore) {
        return nodeScore.node.toString();
      });
    }
  }, {
    key: "hash",
    value: function hash(node, key) {
      var combined = buffer.Buffer.concat([key, node]); // Convert to unsigned 32-bit integer to match go implementation, which is uint32 here:
      // https://github.com/tysonmote/rendezvous/blob/be0258dbbd3d/rendezvous.go#L92

      return crc32c.buf(combined, 0) >>> 0;
    }
  }]);

  return RendezvousHash;
}();

var isNodeHealthy = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(endpoint) {
    var logger,
        resp,
        _args3 = arguments;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            logger = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : console;
            _context3.prev = 1;
            _context3.next = 4;
            return axios({
              baseURL: endpoint,
              url: "/health_check",
              method: 'get',
              timeout: 3000
            });

          case 4:
            resp = _context3.sent;

            if (!(resp.status === 200)) {
              _context3.next = 9;
              break;
            }

            return _context3.abrupt("return", true);

          case 9:
            logger.warn("isNodeHealthy: ".concat(endpoint, " returned non-200 status ").concat(resp.status));
            return _context3.abrupt("return", false);

          case 11:
            _context3.next = 17;
            break;

          case 13:
            _context3.prev = 13;
            _context3.t0 = _context3["catch"](1);
            logger.error("isNodeHealthy: Error checking health: ".concat(_context3.t0));
            return _context3.abrupt("return", false);

          case 17:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[1, 13]]);
  }));

  return function isNodeHealthy(_x3) {
    return _ref3.apply(this, arguments);
  };
}();

var defaultStorageNodeSelectorConfig = {
  bootstrapNodes: servicesConfig.storageNodes,
  logger: new Logger()
};

var DISCOVERY_RESPONSE_TIMEOUT = 15000;
var StorageNodeSelector = /*#__PURE__*/function () {
  // endpoints (lowercase)
  function StorageNodeSelector(config) {
    var _this$config$bootstra,
        _this$discoveryNodeSe,
        _this = this;

    _classCallCheck$1(this, StorageNodeSelector);

    _defineProperty$4(this, "config", void 0);

    _defineProperty$4(this, "auth", void 0);

    _defineProperty$4(this, "logger", void 0);

    _defineProperty$4(this, "nodes", void 0);

    _defineProperty$4(this, "orderedNodes", void 0);

    _defineProperty$4(this, "selectedNode", void 0);

    _defineProperty$4(this, "selectedDiscoveryNode", void 0);

    _defineProperty$4(this, "discoveryNodeSelector", void 0);

    _defineProperty$4(this, "initialDiscoveryFetchPromise", void 0);

    _defineProperty$4(this, "resolveInitialDiscoveryFetchPromise", function () {});

    this.config = mergeConfigWithDefaults(config, defaultStorageNodeSelectorConfig);
    this.discoveryNodeSelector = config.discoveryNodeSelector;
    this.auth = config.auth;
    this.logger = this.config.logger.createPrefixedLogger('[storage-node-selector]');
    this.nodes = (_this$config$bootstra = this.config.bootstrapNodes) !== null && _this$config$bootstra !== void 0 ? _this$config$bootstra : [];
    (_this$discoveryNodeSe = this.discoveryNodeSelector) === null || _this$discoveryNodeSe === void 0 ? void 0 : _this$discoveryNodeSe.addEventListener('change', this.onChangeDiscoveryNode.bind(this));
    this.checkIfDiscoveryNodeAlreadyAvailable();
    this.initialDiscoveryFetchPromise = new Promise(function (resolve) {
      _this.resolveInitialDiscoveryFetchPromise = resolve;
    });
  }

  _createClass$1(StorageNodeSelector, [{
    key: "checkIfDiscoveryNodeAlreadyAvailable",
    value: function () {
      var _checkIfDiscoveryNodeAlreadyAvailable = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this$discoveryNodeSe2;

        var endpoint;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return (_this$discoveryNodeSe2 = this.discoveryNodeSelector) === null || _this$discoveryNodeSe2 === void 0 ? void 0 : _this$discoveryNodeSe2.getSelectedEndpoint();

              case 2:
                endpoint = _context.sent;

                if (endpoint) {
                  this.onChangeDiscoveryNode(endpoint);
                }

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function checkIfDiscoveryNodeAlreadyAvailable() {
        return _checkIfDiscoveryNodeAlreadyAvailable.apply(this, arguments);
      }

      return checkIfDiscoveryNodeAlreadyAvailable;
    }()
  }, {
    key: "onChangeDiscoveryNode",
    value: function () {
      var _onChangeDiscoveryNode = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(endpoint) {
        var _responseData$data$ne;

        var healthCheckEndpoint, discoveryHealthCheckResponse, responseData, contentNodes;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.logger.info('Updating list of available content nodes');

                if (!(this.selectedDiscoveryNode === endpoint)) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return");

              case 3:
                this.selectedDiscoveryNode = endpoint;
                healthCheckEndpoint = "".concat(endpoint, "/health_check");
                _context2.next = 7;
                return fetch$1(healthCheckEndpoint);

              case 7:
                discoveryHealthCheckResponse = _context2.sent;

                if (discoveryHealthCheckResponse.ok) {
                  _context2.next = 11;
                  break;
                }

                this.logger.warn('Discovery provider health check did not respond successfully');
                return _context2.abrupt("return");

              case 11:
                _context2.next = 13;
                return discoveryHealthCheckResponse.json();

              case 13:
                responseData = _context2.sent;
                contentNodes = (_responseData$data$ne = responseData.data.network) === null || _responseData$data$ne === void 0 ? void 0 : _responseData$data$ne.content_nodes;

                if (contentNodes) {
                  _context2.next = 18;
                  break;
                }

                this.logger.warn('Discovery provider health check did not contain any available content nodes');
                return _context2.abrupt("return");

              case 18:
                this.nodes = contentNodes;
                this.resolveInitialDiscoveryFetchPromise();

              case 20:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function onChangeDiscoveryNode(_x) {
        return _onChangeDiscoveryNode.apply(this, arguments);
      }

      return onChangeDiscoveryNode;
    }()
  }, {
    key: "getSelectedNode",
    value: function () {
      var _getSelectedNode = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var _this2 = this;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.selectedNode) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return", this.selectedNode);

              case 2:
                if (this.nodes.length) {
                  _context3.next = 5;
                  break;
                }

                _context3.next = 5;
                return Promise.race([this.initialDiscoveryFetchPromise, new Promise(function (resolve) {
                  return setTimeout(function () {
                    _this2.logger.warn('List of storage nodes could not be fetched');

                    resolve();
                  }, DISCOVERY_RESPONSE_TIMEOUT);
                })]);

              case 5:
                _context3.next = 7;
                return this.select();

              case 7:
                return _context3.abrupt("return", _context3.sent);

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getSelectedNode() {
        return _getSelectedNode.apply(this, arguments);
      }

      return getSelectedNode;
    }()
  }, {
    key: "getNodes",
    value: function getNodes(cid) {
      return this.orderNodes(cid);
    }
  }, {
    key: "select",
    value: function () {
      var _select = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _this$selectedNode;

        var currentNodeIndex, selectedNode, nextNodeIndex, nextNode;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (this.orderedNodes) {
                  _context4.next = 8;
                  break;
                }

                _context4.t0 = this;
                _context4.next = 4;
                return this.auth.getAddress();

              case 4:
                _context4.t1 = _context4.sent.toLowerCase();
                _context4.next = 7;
                return _context4.t0.orderNodes.call(_context4.t0, _context4.t1);

              case 7:
                this.orderedNodes = _context4.sent;

              case 8:
                if (!(this.orderedNodes.length === 0)) {
                  _context4.next = 10;
                  break;
                }

                return _context4.abrupt("return", null);

              case 10:
                currentNodeIndex = this.selectedNode ? this.orderedNodes.indexOf(this.selectedNode) : -1;
                nextNodeIndex = currentNodeIndex;

              case 12:
                if (selectedNode) {
                  _context4.next = 25;
                  break;
                }

                nextNodeIndex = (nextNodeIndex + 1) % this.orderedNodes.length;

                if (!(nextNodeIndex === currentNodeIndex)) {
                  _context4.next = 16;
                  break;
                }

                return _context4.abrupt("break", 25);

              case 16:
                nextNode = this.orderedNodes[nextNodeIndex];

                if (nextNode) {
                  _context4.next = 19;
                  break;
                }

                return _context4.abrupt("continue", 12);

              case 19:
                _context4.next = 21;
                return isNodeHealthy(nextNode);

              case 21:
                if (!_context4.sent) {
                  _context4.next = 23;
                  break;
                }

                selectedNode = nextNode;

              case 23:
                _context4.next = 12;
                break;

              case 25:
                this.selectedNode = selectedNode;
                this.logger.info('Selected content node', this.selectedNode);
                return _context4.abrupt("return", (_this$selectedNode = this.selectedNode) !== null && _this$selectedNode !== void 0 ? _this$selectedNode : null);

              case 28:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function select() {
        return _select.apply(this, arguments);
      }

      return select;
    }()
  }, {
    key: "orderNodes",
    value: function orderNodes(key) {
      var endpoints = this.nodes.map(function (node) {
        return node.endpoint.toLowerCase();
      });

      var hash = _construct(RendezvousHash, _toConsumableArray(endpoints));

      return hash.getN(this.nodes.length, key);
    }
  }]);

  return StorageNodeSelector;
}();

/**
 * This file includes schemas for use in EIP-712 compliant signature generation and
 * signature validation, generator functions for generating data
 * in the form needed by eth_personalSign / eth-sig-util's signTypedData functions,
 * generators for contract signing domains, and a helper function for generating
 * cryptographically secure nonces in nodejs or in the browser.
 * modeled off: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md
 */
var domains = {};

function getDomainData(contractName, signatureVersion, chainId, contractAddress) {
  return {
    name: contractName,
    version: signatureVersion,
    chainId: chainId,
    verifyingContract: contractAddress
  };
}

domains.getEntityManagerDomain = function (chainId, contractAddress) {
  return getDomainData('Entity Manager', '1', chainId, contractAddress);
};

var schemas = {};
/* contract signing domain */

schemas.domain = [{
  name: 'name',
  type: 'string'
}, {
  name: 'version',
  type: 'string'
}, {
  name: 'chainId',
  type: 'uint256'
}, {
  name: 'verifyingContract',
  type: 'address'
}];
schemas.manageEntity = [{
  name: 'userId',
  type: 'uint'
}, {
  name: 'entityType',
  type: 'string'
}, {
  name: 'entityId',
  type: 'uint'
}, {
  name: 'action',
  type: 'string'
}, {
  name: 'metadata',
  type: 'string'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
var generators = {};

function getRequestData(domainDataFn, chainId, contractAddress, messageTypeName, messageSchema, message) {
  var domainData = domainDataFn(chainId, contractAddress);
  var types = {
    EIP712Domain: schemas.domain
  };
  types[messageTypeName] = messageSchema;
  return {
    types: types,
    domain: domainData,
    primaryType: messageTypeName,
    message: message
  };
}
/* User Factory Generators */


generators.getAddUserRequestData = function (chainId, contractAddress, handle, nonce) {
  var message = {
    handle: handle,
    nonce: nonce
  };
  return getRequestData(domains.getUserFactoryDomain, chainId, contractAddress, 'AddUserRequest', schemas.addUserRequest, message);
};

generators.getManageEntityData = function (chainId, contractAddress, userId, entityType, entityId, action, metadata, nonce) {
  var message = {
    userId: userId,
    entityType: entityType,
    entityId: entityId,
    action: action,
    metadata: metadata,
    nonce: nonce
  };
  return getRequestData(domains.getEntityManagerDomain, chainId, contractAddress, 'ManageEntity', schemas.manageEntity, message);
};
/** Return a secure random hex string of nChar length in a browser-compatible way
 *  Taken from https://stackoverflow.com/questions/37378237/how-to-generate-a-random-token-of-32-bit-in-javascript
 */


function browserRandomHash(nChar) {
  // convert number of characters to number of bytes
  var nBytes = Math.ceil(nChar = (+nChar || 8) / 2); // create a typed array of that many bytes

  var u = new Uint8Array(nBytes); // populate it wit crypto-random values

  window.crypto.getRandomValues(u); // convert it to an Array of Strings (e.g. '01', 'AF', ..)

  var zpad = function zpad(str) {
    return '00'.slice(str.length) + str;
  };

  var a = Array.prototype.map.call(u, function (x) {
    return zpad(x.toString(16));
  }); // Array of String to String

  var str = a.join('').toLowerCase(); // and snip off the excess digit if we want an odd number

  if (nChar % 2) str = str.slice(1); // return what we made

  return str;
} // We need to detect whether the nodejs crypto module is available to determine how to
// generate secure random numbers below


var nodeCrypto;

try {
  nodeCrypto = require('crypto');
} catch (e) {
  nodeCrypto = null;
}

function getNonce() {
  // detect whether we are in browser or in nodejs, and use the correct csprng
  if (typeof window === 'undefined' || window === null) {
    return '0x' + nodeCrypto.randomBytes(32).toString('hex');
  } else {
    return '0x' + browserRandomHash(64);
  }
}

var signatureSchemas = {
  domains: domains,
  schemas: schemas,
  generators: generators,
  getNonce: getNonce
};

var abi = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_signer",
				type: "address"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_entityType",
				type: "string"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_entityId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_metadata",
				type: "string"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_action",
				type: "string"
			}
		],
		name: "ManageEntity",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "_isVerified",
				type: "bool"
			}
		],
		name: "ManageIsVerified",
		type: "event"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "usedSignatures",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "string",
				name: "name",
				type: "string"
			},
			{
				internalType: "string",
				name: "version",
				type: "string"
			},
			{
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_verifierAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_networkId",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_userId",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "_entityType",
				type: "string"
			},
			{
				internalType: "uint256",
				name: "_entityId",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "_action",
				type: "string"
			},
			{
				internalType: "string",
				name: "_metadata",
				type: "string"
			},
			{
				internalType: "bytes32",
				name: "_nonce",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "manageEntity",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_userId",
				type: "uint256"
			},
			{
				internalType: "bool",
				name: "_isVerified",
				type: "bool"
			}
		],
		name: "manageIsVerified",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];

var defaultEntityManagerConfig = {
  contractAddress: servicesConfig.entityManagerContractAddress,
  web3ProviderUrl: servicesConfig.web3ProviderUrl,
  identityServiceUrl: servicesConfig.identityServiceUrl,
  useDiscoveryRelay: false,
  logger: new Logger()
};
var DEFAULT_GAS_LIMIT = 2000000;
var CONFIRMATION_POLLING_INTERVAL = 2000;
var CONFIRMATION_TIMEOUT = 45000;

var EntityManager = /*#__PURE__*/function () {
  /**
   * Configuration passed in by consumer (with defaults)
   */
  function EntityManager(config) {
    _classCallCheck$1(this, EntityManager);

    _defineProperty$4(this, "config", void 0);

    _defineProperty$4(this, "discoveryNodeSelector", void 0);

    _defineProperty$4(this, "contract", void 0);

    _defineProperty$4(this, "web3", void 0);

    _defineProperty$4(this, "logger", void 0);

    this.config = mergeConfigWithDefaults(config, defaultEntityManagerConfig);
    this.discoveryNodeSelector = config.discoveryNodeSelector;
    this.web3 = new Web3$1(new Web3$1.providers.HttpProvider(this.config.web3ProviderUrl, {
      timeout: 10000
    }));
    this.contract = new this.web3.eth.Contract(abi, this.config.contractAddress);
    this.logger = this.config.logger.createPrefixedLogger('[entity-manager]');
  }
  /**
   * Calls the manage entity method on chain to update some data
   */


  _createClass$1(EntityManager, [{
    key: "manageEntity",
    value: function () {
      var _manageEntity = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
        var userId, entityType, entityId, action, _ref$metadata, metadata, auth, _ref$confirmationTime, confirmationTimeout, _ref$skipConfirmation, skipConfirmation, nonce, chainId, signatureData, senderAddress, signature, method, response, jsonResponse, _jsonResponse$error;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                userId = _ref.userId, entityType = _ref.entityType, entityId = _ref.entityId, action = _ref.action, _ref$metadata = _ref.metadata, metadata = _ref$metadata === void 0 ? '' : _ref$metadata, auth = _ref.auth, _ref$confirmationTime = _ref.confirmationTimeout, confirmationTimeout = _ref$confirmationTime === void 0 ? CONFIRMATION_TIMEOUT : _ref$confirmationTime, _ref$skipConfirmation = _ref.skipConfirmation, skipConfirmation = _ref$skipConfirmation === void 0 ? false : _ref$skipConfirmation;
                nonce = signatureSchemas.getNonce();
                _context.next = 4;
                return this.web3.eth.net.getId();

              case 4:
                chainId = _context.sent;
                signatureData = signatureSchemas.generators.getManageEntityData(chainId, this.config.contractAddress, userId, entityType, entityId, action, metadata, nonce);
                _context.next = 8;
                return auth.getAddress();

              case 8:
                senderAddress = _context.sent;
                _context.next = 11;
                return auth.signTransaction(signatureData);

              case 11:
                signature = _context.sent;
                _context.next = 14;
                return this.contract.methods.manageEntity(userId, entityType, entityId, action, metadata, nonce, signature);

              case 14:
                method = _context.sent;
                _context.t0 = fetch$1;
                _context.t1 = "";
                _context.next = 19;
                return this.getRelayEndpoint();

              case 19:
                _context.t2 = _context.sent;
                _context.t3 = _context.t1.concat.call(_context.t1, _context.t2, "/relay");
                _context.t4 = {
                  method: 'POST',
                  headers: new Headers({
                    'Content-Type': 'application/json'
                  }),
                  body: JSON.stringify({
                    contractAddress: this.config.contractAddress,
                    contractRegistryKey: 'EntityManager',
                    encodedABI: method.encodeABI(),
                    // Gas limit not really needed with ACDC
                    gasLimit: DEFAULT_GAS_LIMIT,
                    senderAddress: senderAddress
                  })
                };
                _context.next = 24;
                return (0, _context.t0)(_context.t3, _context.t4);

              case 24:
                response = _context.sent;
                _context.next = 27;
                return response.json();

              case 27:
                jsonResponse = _context.sent;

                if (!response.ok) {
                  _context.next = 35;
                  break;
                }

                if (skipConfirmation) {
                  _context.next = 32;
                  break;
                }

                _context.next = 32;
                return this.confirmWrite({
                  blockHash: jsonResponse.receipt.blockHash,
                  blockNumber: jsonResponse.receipt.blockNumber,
                  confirmationTimeout: confirmationTimeout
                });

              case 32:
                return _context.abrupt("return", {
                  blockHash: jsonResponse.receipt.blockHash,
                  blockNumber: jsonResponse.receipt.blockNumber
                });

              case 35:
                if (!(response.status === 429)) {
                  _context.next = 40;
                  break;
                }

                this.logger.error('API Rate Limit Exceeded: You have exceeded the allowed number of requests for this action. Please wait and try again later. If you require a higher rate limit, please send an email to api@audius.co with your request, detailing the reasons and expected usage.');
                throw new Error('Error making relay request: API Rate Limit Exceeded. If you require a higher rate limit, please send an email to api@audius.co with your request.');

              case 40:
                throw new Error("Error making relay request".concat(jsonResponse !== null && jsonResponse !== void 0 && (_jsonResponse$error = jsonResponse.error) !== null && _jsonResponse$error !== void 0 && _jsonResponse$error.message ? ": ".concat(jsonResponse.error.message) : '.'));

              case 41:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function manageEntity(_x) {
        return _manageEntity.apply(this, arguments);
      }

      return manageEntity;
    }()
    /**
     * Confirms a write by polling for the block to be indexed by the selected
     * discovery node
     */

  }, {
    key: "confirmWrite",
    value: function () {
      var _confirmWrite = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref2) {
        var _this = this;

        var blockHash, blockNumber, _ref2$confirmationTim, confirmationTimeout, _ref2$confirmationPol, confirmationPollingInterval, confirmBlock, confirmation, start;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                blockHash = _ref2.blockHash, blockNumber = _ref2.blockNumber, _ref2$confirmationTim = _ref2.confirmationTimeout, confirmationTimeout = _ref2$confirmationTim === void 0 ? CONFIRMATION_TIMEOUT : _ref2$confirmationTim, _ref2$confirmationPol = _ref2.confirmationPollingInterval, confirmationPollingInterval = _ref2$confirmationPol === void 0 ? CONFIRMATION_POLLING_INTERVAL : _ref2$confirmationPol;

                confirmBlock = /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                    var endpoint, _yield$yield$fetch$js, block_passed;

                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return _this.discoveryNodeSelector.getSelectedEndpoint();

                          case 2:
                            endpoint = _context2.sent;
                            _context2.next = 5;
                            return fetch$1("".concat(endpoint, "/block_confirmation?blocknumber=").concat(blockNumber, "&blockhash=").concat(blockHash));

                          case 5:
                            _context2.next = 7;
                            return _context2.sent.json();

                          case 7:
                            _yield$yield$fetch$js = _context2.sent;
                            block_passed = _yield$yield$fetch$js.data.block_passed;
                            return _context2.abrupt("return", block_passed ? BlockConfirmation.CONFIRMED : BlockConfirmation.UNKNOWN);

                          case 10:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function confirmBlock() {
                    return _ref3.apply(this, arguments);
                  };
                }();

                _context3.next = 4;
                return confirmBlock();

              case 4:
                confirmation = _context3.sent;
                start = Date.now();

              case 6:
                if (!(confirmation === BlockConfirmation.UNKNOWN)) {
                  _context3.next = 16;
                  break;
                }

                if (!(Date.now() - start > confirmationTimeout)) {
                  _context3.next = 9;
                  break;
                }

                throw new Error("Could not confirm write within ".concat(confirmationTimeout, "ms"));

              case 9:
                _context3.next = 11;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, confirmationPollingInterval);
                });

              case 11:
                _context3.next = 13;
                return confirmBlock();

              case 13:
                confirmation = _context3.sent;
                _context3.next = 6;
                break;

              case 16:
                return _context3.abrupt("return", true);

              case 17:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function confirmWrite(_x2) {
        return _confirmWrite.apply(this, arguments);
      }

      return confirmWrite;
    }()
  }, {
    key: "getCurrentBlock",
    value: function () {
      var _getCurrentBlock = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var currentBlockNumber;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.web3.eth.getBlockNumber();

              case 2:
                currentBlockNumber = _context4.sent;
                _context4.next = 5;
                return this.web3.eth.getBlock(currentBlockNumber);

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getCurrentBlock() {
        return _getCurrentBlock.apply(this, arguments);
      }

      return getCurrentBlock;
    }()
  }, {
    key: "getRelayEndpoint",
    value: function () {
      var _getRelayEndpoint = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var useDiscoveryRelay, discoveryEndpoint;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                useDiscoveryRelay = this.config.useDiscoveryRelay;

                if (!(useDiscoveryRelay === undefined || !useDiscoveryRelay)) {
                  _context5.next = 3;
                  break;
                }

                return _context5.abrupt("return", this.config.identityServiceUrl);

              case 3:
                _context5.next = 5;
                return this.discoveryNodeSelector.getSelectedEndpoint();

              case 5:
                discoveryEndpoint = _context5.sent;

                if (!(discoveryEndpoint === null)) {
                  _context5.next = 8;
                  break;
                }

                return _context5.abrupt("return", this.config.identityServiceUrl);

              case 8:
                return _context5.abrupt("return", discoveryEndpoint);

              case 9:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getRelayEndpoint() {
        return _getRelayEndpoint.apply(this, arguments);
      }

      return getRelayEndpoint;
    }()
  }]);

  return EntityManager;
}();

var wait = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(milliseconds) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return new Promise(function (resolve) {
              return setTimeout(resolve, milliseconds);
            });

          case 2:
            return _context.abrupt("return", _context.sent);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function wait(_x) {
    return _ref.apply(this, arguments);
  };
}();

var defaultStorageServiceConfig = {
  logger: new Logger()
};
var MAX_TRACK_TRANSCODE_TIMEOUT = 3600000; // 1 hour

var MAX_IMAGE_RESIZE_TIMEOUT_MS = 5 * 60000; // 5 minutes

var POLL_STATUS_INTERVAL = 3000; // 3s

/**
 * Recursively sorts object keys alphabetically
 */
function sortObjectKeys(x) {
  if (_typeof(x) !== 'object' || !x) {
    return x;
  }

  if (Array.isArray(x)) {
    return x.map(sortObjectKeys);
  }

  return Object.keys(x).sort().reduce(function (o, k) {
    return _objectSpread2(_objectSpread2({}, o), {}, _defineProperty$4({}, k, sortObjectKeys(x[k])));
  }, {});
}

var Storage = /*#__PURE__*/function () {
  /**
   * Configuration passed in by consumer (with defaults)
   */
  function Storage(config) {
    _classCallCheck$1(this, Storage);

    _defineProperty$4(this, "config", void 0);

    _defineProperty$4(this, "storageNodeSelector", void 0);

    _defineProperty$4(this, "logger", void 0);

    this.config = mergeConfigWithDefaults(config, defaultStorageServiceConfig);
    this.storageNodeSelector = config.storageNodeSelector;
    this.logger = this.config.logger.createPrefixedLogger('[storage]');
  }
  /**
   * Upload a file on content nodes
   * @param uploadId
   * @param data
   * @param auth
   * @returns
   */


  _createClass$1(Storage, [{
    key: "editFile",
    value: function () {
      var _editFile = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
        var uploadId, data, auth, signatureData, signature, signatureEnvelope, contentNodeEndpoint, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                uploadId = _ref.uploadId, data = _ref.data, auth = _ref.auth;
                // Generate signature
                signatureData = {
                  upload_id: uploadId,
                  timestamp: Date.now()
                };
                _context.next = 4;
                return auth.hashAndSign(JSON.stringify(sortObjectKeys(signatureData)));

              case 4:
                signature = _context.sent;
                signatureEnvelope = {
                  data: JSON.stringify(signatureData),
                  signature: signature
                };
                _context.next = 8;
                return this.storageNodeSelector.getSelectedNode();

              case 8:
                contentNodeEndpoint = _context.sent;

                if (contentNodeEndpoint) {
                  _context.next = 11;
                  break;
                }

                throw new Error('No content node available for upload');

              case 11:
                _context.next = 13;
                return axios({
                  method: 'post',
                  url: "".concat(contentNodeEndpoint, "/uploads/").concat(uploadId),
                  maxContentLength: Infinity,
                  data: data,
                  params: {
                    signature: JSON.stringify(signatureEnvelope)
                  }
                });

              case 13:
                response = _context.sent;
                _context.next = 16;
                return this.pollProcessingStatus(uploadId, response.data.template === 'audio' ? MAX_TRACK_TRANSCODE_TIMEOUT : MAX_IMAGE_RESIZE_TIMEOUT_MS);

              case 16:
                return _context.abrupt("return", _context.sent);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function editFile(_x) {
        return _editFile.apply(this, arguments);
      }

      return editFile;
    }()
    /**
     * Upload a file to a content node
     * @param file
     * @param onProgress
     * @param template
     * @param options
     * @returns
     */

  }, {
    key: "uploadFile",
    value: function () {
      var _uploadFile = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {
        var _file$name;

        var file, onProgress, template, _ref2$options, options, formData, contentNodeEndpoint, response;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                file = _ref2.file, onProgress = _ref2.onProgress, template = _ref2.template, _ref2$options = _ref2.options, options = _ref2$options === void 0 ? {} : _ref2$options;
                formData = new FormData$1();
                formData.append('template', template);
                Object.keys(options).forEach(function (key) {
                  formData.append(key, "".concat(options[key]));
                });
                formData.append('files', isNodeFile(file) ? file.buffer : file, (_file$name = file.name) !== null && _file$name !== void 0 ? _file$name : 'blob');
                _context2.next = 7;
                return this.storageNodeSelector.getSelectedNode();

              case 7:
                contentNodeEndpoint = _context2.sent;

                if (contentNodeEndpoint) {
                  _context2.next = 10;
                  break;
                }

                throw new Error('No content node available for upload');

              case 10:
                _context2.next = 12;
                return axios({
                  method: 'post',
                  url: "".concat(contentNodeEndpoint, "/uploads"),
                  maxContentLength: Infinity,
                  data: formData,
                  headers: formData.getBoundary ? {
                    'Content-Type': "multipart/form-data; boundary=".concat(formData.getBoundary())
                  } : undefined,
                  onUploadProgress: function onUploadProgress(progressEvent) {
                    return onProgress === null || onProgress === void 0 ? void 0 : onProgress(progressEvent.loaded, progressEvent.total);
                  }
                });

              case 12:
                response = _context2.sent;
                _context2.next = 15;
                return this.pollProcessingStatus(response.data[0].id, template === 'audio' ? MAX_TRACK_TRANSCODE_TIMEOUT : MAX_IMAGE_RESIZE_TIMEOUT_MS);

              case 15:
                return _context2.abrupt("return", _context2.sent);

              case 16:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function uploadFile(_x2) {
        return _uploadFile.apply(this, arguments);
      }

      return uploadFile;
    }()
    /**
     * Works for both track transcode and image resize jobs
     * @param id ID of the transcode/resize job
     * @param maxPollingMs millis to stop polling and error if job is not done
     * @returns successful job info, or throws error if job fails / times out
     */

  }, {
    key: "pollProcessingStatus",
    value: function () {
      var _pollProcessingStatus = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(id, maxPollingMs) {
        var start, resp, _e$message, _e$response;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                start = Date.now();

              case 1:
                if (!(Date.now() - start < maxPollingMs)) {
                  _context3.next = 21;
                  break;
                }

                _context3.prev = 2;
                _context3.next = 5;
                return this.getProcessingStatus(id);

              case 5:
                resp = _context3.sent;

                if (!((resp === null || resp === void 0 ? void 0 : resp.status) === 'done')) {
                  _context3.next = 8;
                  break;
                }

                return _context3.abrupt("return", resp);

              case 8:
                if (!((resp === null || resp === void 0 ? void 0 : resp.status) === 'error' || (resp === null || resp === void 0 ? void 0 : resp.status) === 'error_retranscode_preview')) {
                  _context3.next = 10;
                  break;
                }

                throw new Error("Upload failed: id=".concat(id, ", resp=").concat(JSON.stringify(resp)));

              case 10:
                _context3.next = 17;
                break;

              case 12:
                _context3.prev = 12;
                _context3.t0 = _context3["catch"](2);

                if (!((_e$message = _context3.t0.message) !== null && _e$message !== void 0 && _e$message.startsWith('Upload failed') || _context3.t0.response && ((_e$response = _context3.t0.response) === null || _e$response === void 0 ? void 0 : _e$response.status) === 422)) {
                  _context3.next = 16;
                  break;
                }

                throw _context3.t0;

              case 16:
                // Swallow errors caused by failure to establish connection to node so we can retry polling
                this.logger.error("Failed to poll for processing status, ".concat(_context3.t0));

              case 17:
                _context3.next = 19;
                return wait(POLL_STATUS_INTERVAL);

              case 19:
                _context3.next = 1;
                break;

              case 21:
                throw new Error("Upload took over ".concat(maxPollingMs, "ms. id=").concat(id));

              case 22:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 12]]);
      }));

      function pollProcessingStatus(_x3, _x4) {
        return _pollProcessingStatus.apply(this, arguments);
      }

      return pollProcessingStatus;
    }()
    /**
     * Gets the task progress given the task type and id associated with the job
     * @param id the id of the transcoding or resizing job
     * @returns the status, and the success or failed response if the job is complete
     */

  }, {
    key: "getProcessingStatus",
    value: function () {
      var _getProcessingStatus = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(id) {
        var contentNodeEndpoint, response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.storageNodeSelector.getSelectedNode();

              case 2:
                contentNodeEndpoint = _context4.sent;
                _context4.next = 5;
                return fetch$1("".concat(contentNodeEndpoint, "/uploads/").concat(id));

              case 5:
                response = _context4.sent;
                _context4.next = 8;
                return response.json();

              case 8:
                return _context4.abrupt("return", _context4.sent);

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getProcessingStatus(_x5) {
        return _getProcessingStatus.apply(this, arguments);
      }

      return getProcessingStatus;
    }()
  }]);

  return Storage;
}();

var NOT_INITIALIZED = 'Auth not initialized - Please provide an apiKey and apiSecret, or a custom implementation of Auth';
var Auth = /*#__PURE__*/_createClass$1(function Auth() {
  _classCallCheck$1(this, Auth);

  _defineProperty$4(this, "getSharedSecret", function () {
    throw new Error(NOT_INITIALIZED);
  });

  _defineProperty$4(this, "sign", function () {
    throw new Error(NOT_INITIALIZED);
  });

  _defineProperty$4(this, "hashAndSign", function () {
    throw new Error('Auth not initialized');
  });

  _defineProperty$4(this, "signTransaction", function () {
    throw new Error(NOT_INITIALIZED);
  });

  _defineProperty$4(this, "getAddress", function () {
    throw new Error(NOT_INITIALIZED);
  });
});

var dist$1 = {};

var secp256k1Lib = {};

// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE


var BN$3 = require$$0$5;
var EC$1 = require$$1.ec;
var ec$1 = new EC$1('secp256k1');
var ecparams$1 = ec$1.curve;

secp256k1Lib.privateKeyExport = function (privateKey, compressed) {
  var d = new BN$3(privateKey);

  if (d.ucmp(ecparams$1.n) >= 0) {
    throw new Error('couldn\'t export to DER format');
  }

  var point = ec$1.g.mul(d);
  return toPublicKey$1(point.getX(), point.getY(), compressed);
};

secp256k1Lib.privateKeyModInverse = function (privateKey) {
  var bn = new BN$3(privateKey);

  if (bn.ucmp(ecparams$1.n) >= 0 || bn.isZero()) {
    throw new Error('private key range is invalid');
  }

  return bn.invm(ecparams$1.n).toArrayLike(Buffer$6, 'be', 32);
};

secp256k1Lib.signatureImport = function (sigObj) {
  var r = new BN$3(sigObj.r);

  if (r.ucmp(ecparams$1.n) >= 0) {
    r = new BN$3(0);
  }

  var s = new BN$3(sigObj.s);

  if (s.ucmp(ecparams$1.n) >= 0) {
    s = new BN$3(0);
  }

  return Buffer$6.concat([r.toArrayLike(Buffer$6, 'be', 32), s.toArrayLike(Buffer$6, 'be', 32)]);
};

secp256k1Lib.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var point = ec$1.keyFromPublic(publicKey);
  var scalar = new BN$3(privateKey);

  if (scalar.ucmp(ecparams$1.n) >= 0 || scalar.isZero()) {
    throw new Error('scalar was invalid (zero or overflow)');
  }

  var shared = point.pub.mul(scalar);
  return toPublicKey$1(shared.getX(), shared.getY(), compressed);
};

var toPublicKey$1 = function toPublicKey(x, y, compressed) {
  var publicKey = void 0;

  if (compressed) {
    publicKey = Buffer$6.alloc(33);
    publicKey[0] = y.isOdd() ? 0x03 : 0x02;
    x.toArrayLike(Buffer$6, 'be', 32).copy(publicKey, 1);
  } else {
    publicKey = Buffer$6.alloc(65);
    publicKey[0] = 0x04;
    x.toArrayLike(Buffer$6, 'be', 32).copy(publicKey, 1);
    y.toArrayLike(Buffer$6, 'be', 32).copy(publicKey, 33);
  }

  return publicKey;
};

var der$2 = {};

// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE


var EC_PRIVKEY_EXPORT_DER_COMPRESSED$1 = Buffer$6.from([// begin
0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20, // private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // middle
0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00, // public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED$1 = Buffer$6.from([// begin
0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20, // private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // middle
0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00, // public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

der$2.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer$6.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED$1 : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED$1);
  privateKey.copy(result, compressed ? 8 : 9);
  publicKey.copy(result, compressed ? 181 : 214);
  return result;
};

der$2.privateKeyImport = function (privateKey) {
  var length = privateKey.length; // sequence header

  var index = 0;
  if (length < index + 1 || privateKey[index] !== 0x30) return null;
  index += 1; // sequence length constructor

  if (length < index + 1 || !(privateKey[index] & 0x80)) return null;
  var lenb = privateKey[index] & 0x7f;
  index += 1;
  if (lenb < 1 || lenb > 2) return null;
  if (length < index + lenb) return null; // sequence length

  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
  index += lenb;
  if (length < index + len) return null; // sequence element 0: version number (=1)

  if (length < index + 3 || privateKey[index] !== 0x02 || privateKey[index + 1] !== 0x01 || privateKey[index + 2] !== 0x01) {
    return null;
  }

  index += 3; // sequence element 1: octet string, up to 32 bytes

  if (length < index + 2 || privateKey[index] !== 0x04 || privateKey[index + 1] > 0x20 || length < index + 2 + privateKey[index + 1]) {
    return null;
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
};

der$2.signatureImportLax = function (signature) {
  var r = Buffer$6.alloc(32, 0);
  var s = Buffer$6.alloc(32, 0);
  var length = signature.length;
  var index = 0; // sequence tag byte

  if (signature[index++] !== 0x30) {
    return null;
  } // sequence length byte


  var lenbyte = signature[index++];

  if (lenbyte & 0x80) {
    index += lenbyte - 0x80;

    if (index > length) {
      return null;
    }
  } // sequence tag byte for r


  if (signature[index++] !== 0x02) {
    return null;
  } // length for r


  var rlen = signature[index++];

  if (rlen & 0x80) {
    lenbyte = rlen - 0x80;

    if (index + lenbyte > length) {
      return null;
    }

    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}

    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      rlen = (rlen << 8) + signature[index];
    }
  }

  if (rlen > length - index) {
    return null;
  }

  var rindex = index;
  index += rlen; // sequence tag byte for s

  if (signature[index++] !== 0x02) {
    return null;
  } // length for s


  var slen = signature[index++];

  if (slen & 0x80) {
    lenbyte = slen - 0x80;

    if (index + lenbyte > length) {
      return null;
    }

    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}

    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      slen = (slen << 8) + signature[index];
    }
  }

  if (slen > length - index) {
    return null;
  }

  var sindex = index;
  index += slen; // ignore leading zeros in r

  for (; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1) {} // copy r value


  if (rlen > 32) {
    return null;
  }

  var rvalue = signature.slice(rindex, rindex + rlen);
  rvalue.copy(r, 32 - rvalue.length); // ignore leading zeros in s

  for (; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1) {} // copy s value


  if (slen > 32) {
    return null;
  }

  var svalue = signature.slice(sindex, sindex + slen);
  svalue.copy(s, 32 - svalue.length);
  return {
    r: r,
    s: s
  };
};

var secp256k1$1 = secp256k1$2;
var secp256k1v3 = secp256k1Lib;
var der$1 = der$2;
/**
 * Verify an ECDSA privateKey
 * @method privateKeyVerify
 * @param {Buffer} privateKey
 * @return {boolean}
 */

var privateKeyVerify = function privateKeyVerify(privateKey) {
  // secp256k1 v4 version throws when privateKey length is not 32
  if (privateKey.length !== 32) {
    return false;
  }

  return secp256k1$1.privateKeyVerify(Uint8Array.from(privateKey));
};
/**
 * Export a privateKey in DER format
 * @method privateKeyExport
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {boolean}
 */


var privateKeyExport = function privateKeyExport(privateKey, compressed) {
  // privateKeyExport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }

  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
  return der$1.privateKeyExport(privateKey, publicKey, compressed);
};
/**
 * Import a privateKey in DER format
 * @method privateKeyImport
 * @param {Buffer} privateKey
 * @return {Buffer}
 */


var privateKeyImport = function privateKeyImport(privateKey) {
  // privateKeyImport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  privateKey = der$1.privateKeyImport(privateKey);

  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
    return privateKey;
  }

  throw new Error("couldn't import from DER format");
};
/**
 * Negate a privateKey by subtracting it from the order of the curve's base point
 * @method privateKeyNegate
 * @param {Buffer} privateKey
 * @return {Buffer}
 */


var privateKeyNegate = function privateKeyNegate(privateKey) {
  return Buffer$6.from(secp256k1$1.privateKeyNegate(Uint8Array.from(privateKey)));
};
/**
 * Compute the inverse of a privateKey (modulo the order of the curve's base point).
 * @method privateKeyModInverse
 * @param {Buffer} privateKey
 * @return {Buffer}
 */


var privateKeyModInverse = function privateKeyModInverse(privateKey) {
  if (privateKey.length !== 32) {
    throw new Error('private key length is invalid');
  }

  return Buffer$6.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};
/**
 * Tweak a privateKey by adding tweak to it.
 * @method privateKeyTweakAdd
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */


var privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {
  return Buffer$6.from(secp256k1$1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};
/**
 * Tweak a privateKey by multiplying it by a tweak.
 * @method privateKeyTweakMul
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */


var privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {
  return Buffer$6.from(secp256k1$1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};
/**
 * Compute the public key for a privateKey.
 * @method publicKeyCreate
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */


var publicKeyCreate = function publicKeyCreate(privateKey, compressed) {
  return Buffer$6.from(secp256k1$1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};
/**
 * Convert a publicKey to compressed or uncompressed form.
 * @method publicKeyConvert
 * @param {Buffer} publicKey
 * @param {boolean} compressed
 * @return {Buffer}
 */


var publicKeyConvert = function publicKeyConvert(publicKey, compressed) {
  return Buffer$6.from(secp256k1$1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};
/**
 * Verify an ECDSA publicKey.
 * @method publicKeyVerify
 * @param {Buffer} publicKey
 * @return {boolean}
 */


var publicKeyVerify = function publicKeyVerify(publicKey) {
  // secp256k1 v4 version throws when publicKey length is not 33 or 65
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    return false;
  }

  return secp256k1$1.publicKeyVerify(Uint8Array.from(publicKey));
};
/**
 * Tweak a publicKey by adding tweak times the generator to it.
 * @method publicKeyTweakAdd
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */


var publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {
  return Buffer$6.from(secp256k1$1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};
/**
 * Tweak a publicKey by multiplying it by a tweak value
 * @method publicKeyTweakMul
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */


var publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {
  return Buffer$6.from(secp256k1$1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};
/**
 * Add a given publicKeys together.
 * @method publicKeyCombine
 * @param {Array<Buffer>} publicKeys
 * @param {boolean} compressed
 * @return {Buffer}
 */


var publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {
  var keys = [];
  publicKeys.forEach(function (publicKey) {
    keys.push(Uint8Array.from(publicKey));
  });
  return Buffer$6.from(secp256k1$1.publicKeyCombine(keys, compressed));
};
/**
 * Convert a signature to a normalized lower-S form.
 * @method signatureNormalize
 * @param {Buffer} signature
 * @return {Buffer}
 */


var signatureNormalize = function signatureNormalize(signature) {
  return Buffer$6.from(secp256k1$1.signatureNormalize(Uint8Array.from(signature)));
};
/**
 * Serialize an ECDSA signature in DER format.
 * @method signatureExport
 * @param {Buffer} signature
 * @return {Buffer}
 */


var signatureExport = function signatureExport(signature) {
  return Buffer$6.from(secp256k1$1.signatureExport(Uint8Array.from(signature)));
};
/**
 * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImport
 * @param {Buffer} signature
 * @return {Buffer}
 */


var signatureImport = function signatureImport(signature) {
  return Buffer$6.from(secp256k1$1.signatureImport(Uint8Array.from(signature)));
};
/**
 * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImportLax
 * @param {Buffer} signature
 * @return {Buffer}
 */


var signatureImportLax = function signatureImportLax(signature) {
  // signatureImportLax method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure that signature is greater than 0
  if (signature.length === 0) {
    throw new RangeError('signature length is invalid');
  }

  var sigObj = der$1.signatureImportLax(signature);

  if (sigObj === null) {
    throw new Error("couldn't parse DER signature");
  }

  return secp256k1v3.signatureImport(sigObj);
};
/**
 * Create an ECDSA signature. Always return low-S signature.
 * @method sign
 * @param {Buffer} message
 * @param {Buffer} privateKey
 * @param {Object} options
 * @return {Buffer}
 */


var sign = function sign(message, privateKey, options) {
  if (options === null) {
    throw new TypeError('options should be an Object');
  }

  var signOptions = void 0;

  if (options) {
    signOptions = {};

    if (options.data === null) {
      throw new TypeError('options.data should be a Buffer');
    }

    if (options.data) {
      // validate option.data length
      if (options.data.length !== 32) {
        throw new RangeError('options.data length is invalid');
      }

      signOptions.data = new Uint8Array(options.data);
    }

    if (options.noncefn === null) {
      throw new TypeError('options.noncefn should be a Function');
    }

    if (options.noncefn) {
      //  convert option.noncefn function signature
      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
        var bufferAlgo = algo != null ? Buffer$6.from(algo) : null;
        var bufferData = data != null ? Buffer$6.from(data) : null;
        var buffer = Buffer$6.from('');

        if (options.noncefn) {
          buffer = options.noncefn(Buffer$6.from(message), Buffer$6.from(privateKey), bufferAlgo, bufferData, attempt);
        }

        return Uint8Array.from(buffer);
      };
    }
  }

  var sig = secp256k1$1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
  return {
    signature: Buffer$6.from(sig.signature),
    recovery: sig.recid
  };
};
/**
 * Verify an ECDSA signature.
 * @method verify
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Buffer} publicKey
 * @return {boolean}
 */


var verify = function verify(message, signature, publicKey) {
  // note: secp256k1 v4 verify method has a different argument order
  return secp256k1$1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
};
/**
 * Recover an ECDSA public key from a signature.
 * @method recover
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Number} recid
 * @param {boolean} compressed
 * @return {Buffer}
 */


var recover = function recover(message, signature, recid, compressed) {
  // note: secp256k1 v4 recover method has a different argument order
  return Buffer$6.from(secp256k1$1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
};
/**
 * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
 * @method ecdh
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @return {Buffer}
 */


var ecdh = function ecdh(publicKey, privateKey) {
  // note: secp256k1 v3 doesn't allow optional parameter
  return Buffer$6.from(secp256k1$1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};
/**
 * Compute an EC Diffie-Hellman secret and return public key as result
 * @method ecdhUnsafe
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */


var ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {
  // ecdhUnsafe method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure valid publicKey length
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    throw new RangeError('public key length is invalid');
  } // ensure valid privateKey length


  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }

  return Buffer$6.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};

var secp256k1Adapter = {
  privateKeyVerify: privateKeyVerify,
  privateKeyExport: privateKeyExport,
  privateKeyImport: privateKeyImport,
  privateKeyNegate: privateKeyNegate,
  privateKeyModInverse: privateKeyModInverse,
  privateKeyTweakAdd: privateKeyTweakAdd,
  privateKeyTweakMul: privateKeyTweakMul,
  publicKeyCreate: publicKeyCreate,
  publicKeyConvert: publicKeyConvert,
  publicKeyVerify: publicKeyVerify,
  publicKeyTweakAdd: publicKeyTweakAdd,
  publicKeyTweakMul: publicKeyTweakMul,
  publicKeyCombine: publicKeyCombine,
  signatureNormalize: signatureNormalize,
  signatureExport: signatureExport,
  signatureImport: signatureImport,
  signatureImportLax: signatureImportLax,
  sign: sign,
  verify: verify,
  recover: recover,
  ecdh: ecdh,
  ecdhUnsafe: ecdhUnsafe
};

var src$1 = function isHexPrefixed(str) {
  if (typeof str !== 'string') {
    throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + _typeof(str) + ", while checking isHexPrefixed.");
  }

  return str.slice(0, 2) === '0x';
};

var isHexPrefixed$1 = src$1;
/**
 * Removes '0x' from a given `String` is present
 * @param {String} str the string value
 * @return {String|Optional} a string by pass if necessary
 */

var src = function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }

  return isHexPrefixed$1(str) ? str.slice(2) : str;
};

var isHexPrefixed = src$1;
var stripHexPrefix = src;
/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */

function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + _typeof(a) + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}
/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */


function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}
/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */


function intToBuffer(i) {
  var hex = intToHex(i);
  return new Buffer$6(padToEven(hex.slice(2)), 'hex');
}
/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */


function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + _typeof(str) + '\'.');
  }

  return Buffer$6.byteLength(str, 'utf8');
}
/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */


function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + _typeof(superset) + '\'');
  }

  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + _typeof(subset) + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}
/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */


function toUtf8(hex) {
  var bufferValue = new Buffer$6(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');
  return bufferValue.toString('utf8');
}
/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */


function toAscii(hex) {
  var str = ''; // eslint-disable-line

  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}
/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */


function fromUtf8(stringValue) {
  var str = new Buffer$6(stringValue, 'utf8');
  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}
/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */


function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line

  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}
/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */


function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + _typeof(params) + '\'');
  }

  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + _typeof(key) + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line

    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }

    result.push(value);
  }

  return result;
}
/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */


function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

var lib$1 = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};

(function (exports) {

  var _typeof$1 = typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol" ? function (obj) {
    return _typeof(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
  };

  var _require = keccak$3,
      keccak224 = _require.keccak224,
      keccak384 = _require.keccak384,
      k256 = _require.keccak256,
      keccak512 = _require.keccak512;
  var secp256k1 = secp256k1Adapter;
  var assert = require$$0$1;
  var rlp = dist$2;
  var BN = require$$0$5;
  var createHash$1 = createHash;
  var Buffer = require$$0$4.Buffer;
  Object.assign(exports, lib$1);
  /**
   * the max integer that this VM can handle (a ```BN```)
   * @var {BN} MAX_INTEGER
   */

  exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);
  /**
   * 2^256 (a ```BN```)
   * @var {BN} TWO_POW256
   */

  exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);
  /**
   * Keccak-256 hash of null (a ```String```)
   * @var {String} KECCAK256_NULL_S
   */

  exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
  exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;
  /**
   * Keccak-256 hash of null (a ```Buffer```)
   * @var {Buffer} KECCAK256_NULL
   */

  exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
  exports.SHA3_NULL = exports.KECCAK256_NULL;
  /**
   * Keccak-256 of an RLP of an empty array (a ```String```)
   * @var {String} KECCAK256_RLP_ARRAY_S
   */

  exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
  exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;
  /**
   * Keccak-256 of an RLP of an empty array (a ```Buffer```)
   * @var {Buffer} KECCAK256_RLP_ARRAY
   */

  exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
  exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;
  /**
   * Keccak-256 hash of the RLP of null  (a ```String```)
   * @var {String} KECCAK256_RLP_S
   */

  exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
  exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;
  /**
   * Keccak-256 hash of the RLP of null (a ```Buffer```)
   * @var {Buffer} KECCAK256_RLP
   */

  exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
  exports.SHA3_RLP = exports.KECCAK256_RLP;
  /**
   * [`BN`](https://github.com/indutny/bn.js)
   * @var {Function}
   */

  exports.BN = BN;
  /**
   * [`rlp`](https://github.com/ethereumjs/rlp)
   * @var {Function}
   */

  exports.rlp = rlp;
  /**
   * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
   * @var {Object}
   */

  exports.secp256k1 = secp256k1;
  /**
   * Returns a buffer filled with 0s
   * @method zeros
   * @param {Number} bytes  the number of bytes the buffer should be
   * @return {Buffer}
   */

  exports.zeros = function (bytes) {
    return Buffer.allocUnsafe(bytes).fill(0);
  };
  /**
    * Returns a zero address
    * @method zeroAddress
    * @return {String}
    */


  exports.zeroAddress = function () {
    var addressLength = 20;
    var zeroAddress = exports.zeros(addressLength);
    return exports.bufferToHex(zeroAddress);
  };
  /**
   * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
   * Or it truncates the beginning if it exceeds.
   * @method lsetLength
   * @param {Buffer|Array} msg the value to pad
   * @param {Number} length the number of bytes the output should be
   * @param {Boolean} [right=false] whether to start padding form the left or right
   * @return {Buffer|Array}
   */


  exports.setLengthLeft = exports.setLength = function (msg, length, right) {
    var buf = exports.zeros(length);
    msg = exports.toBuffer(msg);

    if (right) {
      if (msg.length < length) {
        msg.copy(buf);
        return buf;
      }

      return msg.slice(0, length);
    } else {
      if (msg.length < length) {
        msg.copy(buf, length - msg.length);
        return buf;
      }

      return msg.slice(-length);
    }
  };
  /**
   * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
   * Or it truncates the beginning if it exceeds.
   * @param {Buffer|Array} msg the value to pad
   * @param {Number} length the number of bytes the output should be
   * @return {Buffer|Array}
   */


  exports.setLengthRight = function (msg, length) {
    return exports.setLength(msg, length, true);
  };
  /**
   * Trims leading zeros from a `Buffer` or an `Array`
   * @param {Buffer|Array|String} a
   * @return {Buffer|Array|String}
   */


  exports.unpad = exports.stripZeros = function (a) {
    a = exports.stripHexPrefix(a);
    var first = a[0];

    while (a.length > 0 && first.toString() === '0') {
      a = a.slice(1);
      first = a[0];
    }

    return a;
  };
  /**
   * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
   * @param {*} v the value
   */


  exports.toBuffer = function (v) {
    if (!Buffer.isBuffer(v)) {
      if (Array.isArray(v)) {
        v = Buffer.from(v);
      } else if (typeof v === 'string') {
        if (exports.isHexString(v)) {
          v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
        } else {
          v = Buffer.from(v);
        }
      } else if (typeof v === 'number') {
        v = exports.intToBuffer(v);
      } else if (v === null || v === undefined) {
        v = Buffer.allocUnsafe(0);
      } else if (BN.isBN(v)) {
        v = v.toArrayLike(Buffer);
      } else if (v.toArray) {
        // converts a BN to a Buffer
        v = Buffer.from(v.toArray());
      } else {
        throw new Error('invalid type');
      }
    }

    return v;
  };
  /**
   * Converts a `Buffer` to a `Number`
   * @param {Buffer} buf
   * @return {Number}
   * @throws If the input number exceeds 53 bits.
   */


  exports.bufferToInt = function (buf) {
    return new BN(exports.toBuffer(buf)).toNumber();
  };
  /**
   * Converts a `Buffer` into a hex `String`
   * @param {Buffer} buf
   * @return {String}
   */


  exports.bufferToHex = function (buf) {
    buf = exports.toBuffer(buf);
    return '0x' + buf.toString('hex');
  };
  /**
   * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
   * @param {Buffer} num
   * @return {BN}
   */


  exports.fromSigned = function (num) {
    return new BN(num).fromTwos(256);
  };
  /**
   * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
   * @param {BN} num
   * @return {Buffer}
   */


  exports.toUnsigned = function (num) {
    return Buffer.from(num.toTwos(256).toArray());
  };
  /**
   * Creates Keccak hash of the input
   * @param {Buffer|Array|String|Number} a the input data
   * @param {Number} [bits=256] the Keccak width
   * @return {Buffer}
   */


  exports.keccak = function (a, bits) {
    a = exports.toBuffer(a);
    if (!bits) bits = 256;

    switch (bits) {
      case 224:
        {
          return keccak224(a);
        }

      case 256:
        {
          return k256(a);
        }

      case 384:
        {
          return keccak384(a);
        }

      case 512:
        {
          return keccak512(a);
        }

      default:
        {
          throw new Error('Invald algorithm: keccak' + bits);
        }
    }
  };
  /**
   * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
   * @param {Buffer|Array|String|Number} a the input data
   * @return {Buffer}
   */


  exports.keccak256 = function (a) {
    return exports.keccak(a);
  };
  /**
   * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
   * @param {Buffer|Array|String|Number} a the input data
   * @param {Number} [bits=256] the SHA-3 width
   * @return {Buffer}
   */


  exports.sha3 = exports.keccak;
  /**
   * Creates SHA256 hash of the input
   * @param {Buffer|Array|String|Number} a the input data
   * @return {Buffer}
   */

  exports.sha256 = function (a) {
    a = exports.toBuffer(a);
    return createHash$1('sha256').update(a).digest();
  };
  /**
   * Creates RIPEMD160 hash of the input
   * @param {Buffer|Array|String|Number} a the input data
   * @param {Boolean} padded whether it should be padded to 256 bits or not
   * @return {Buffer}
   */


  exports.ripemd160 = function (a, padded) {
    a = exports.toBuffer(a);
    var hash = createHash$1('rmd160').update(a).digest();

    if (padded === true) {
      return exports.setLength(hash, 32);
    } else {
      return hash;
    }
  };
  /**
   * Creates SHA-3 hash of the RLP encoded version of the input
   * @param {Buffer|Array|String|Number} a the input data
   * @return {Buffer}
   */


  exports.rlphash = function (a) {
    return exports.keccak(rlp.encode(a));
  };
  /**
   * Checks if the private key satisfies the rules of the curve secp256k1.
   * @param {Buffer} privateKey
   * @return {Boolean}
   */


  exports.isValidPrivate = function (privateKey) {
    return secp256k1.privateKeyVerify(privateKey);
  };
  /**
   * Checks if the public key satisfies the rules of the curve secp256k1
   * and the requirements of Ethereum.
   * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
   * @param {Boolean} [sanitize=false] Accept public keys in other formats
   * @return {Boolean}
   */


  exports.isValidPublic = function (publicKey, sanitize) {
    if (publicKey.length === 64) {
      // Convert to SEC1 for secp256k1
      return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
    }

    if (!sanitize) {
      return false;
    }

    return secp256k1.publicKeyVerify(publicKey);
  };
  /**
   * Returns the ethereum address of a given public key.
   * Accepts "Ethereum public keys" and SEC1 encoded keys.
   * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
   * @param {Boolean} [sanitize=false] Accept public keys in other formats
   * @return {Buffer}
   */


  exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
    pubKey = exports.toBuffer(pubKey);

    if (sanitize && pubKey.length !== 64) {
      pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
    }

    assert(pubKey.length === 64); // Only take the lower 160bits of the hash

    return exports.keccak(pubKey).slice(-20);
  };
  /**
   * Returns the ethereum public key of a given private key
   * @param {Buffer} privateKey A private key must be 256 bits wide
   * @return {Buffer}
   */


  var privateToPublic = exports.privateToPublic = function (privateKey) {
    privateKey = exports.toBuffer(privateKey); // skip the type flag and use the X, Y points

    return secp256k1.publicKeyCreate(privateKey, false).slice(1);
  };
  /**
   * Converts a public key to the Ethereum format.
   * @param {Buffer} publicKey
   * @return {Buffer}
   */


  exports.importPublic = function (publicKey) {
    publicKey = exports.toBuffer(publicKey);

    if (publicKey.length !== 64) {
      publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
    }

    return publicKey;
  };
  /**
   * ECDSA sign
   * @param {Buffer} msgHash
   * @param {Buffer} privateKey
   * @return {Object}
   */


  exports.ecsign = function (msgHash, privateKey) {
    var sig = secp256k1.sign(msgHash, privateKey);
    var ret = {};
    ret.r = sig.signature.slice(0, 32);
    ret.s = sig.signature.slice(32, 64);
    ret.v = sig.recovery + 27;
    return ret;
  };
  /**
   * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
   * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
   * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
   * used to produce the signature.
   * @param message
   * @returns {Buffer} hash
   */


  exports.hashPersonalMessage = function (message) {
    var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
    return exports.keccak(Buffer.concat([prefix, message]));
  };
  /**
   * ECDSA public key recovery from signature
   * @param {Buffer} msgHash
   * @param {Number} v
   * @param {Buffer} r
   * @param {Buffer} s
   * @return {Buffer} publicKey
   */


  exports.ecrecover = function (msgHash, v, r, s) {
    var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
    var recovery = v - 27;

    if (recovery !== 0 && recovery !== 1) {
      throw new Error('Invalid signature v value');
    }

    var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
    return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
  };
  /**
   * Convert signature parameters into the format of `eth_sign` RPC method
   * @param {Number} v
   * @param {Buffer} r
   * @param {Buffer} s
   * @return {String} sig
   */


  exports.toRpcSig = function (v, r, s) {
    // NOTE: with potential introduction of chainId this might need to be updated
    if (v !== 27 && v !== 28) {
      throw new Error('Invalid recovery id');
    } // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
    // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053


    return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
  };
  /**
   * Convert signature format of the `eth_sign` RPC method to signature parameters
   * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
   * @param {String} sig
   * @return {Object}
   */


  exports.fromRpcSig = function (sig) {
    sig = exports.toBuffer(sig); // NOTE: with potential introduction of chainId this might need to be updated

    if (sig.length !== 65) {
      throw new Error('Invalid signature length');
    }

    var v = sig[64]; // support both versions of `eth_sign` responses

    if (v < 27) {
      v += 27;
    }

    return {
      v: v,
      r: sig.slice(0, 32),
      s: sig.slice(32, 64)
    };
  };
  /**
   * Returns the ethereum address of a given private key
   * @param {Buffer} privateKey A private key must be 256 bits wide
   * @return {Buffer}
   */


  exports.privateToAddress = function (privateKey) {
    return exports.publicToAddress(privateToPublic(privateKey));
  };
  /**
   * Checks if the address is a valid. Accepts checksummed addresses too
   * @param {String} address
   * @return {Boolean}
   */


  exports.isValidAddress = function (address) {
    return /^0x[0-9a-fA-F]{40}$/.test(address);
  };
  /**
    * Checks if a given address is a zero address
    * @method isZeroAddress
    * @param {String} address
    * @return {Boolean}
    */


  exports.isZeroAddress = function (address) {
    var zeroAddress = exports.zeroAddress();
    return zeroAddress === exports.addHexPrefix(address);
  };
  /**
   * Returns a checksummed address
   * @param {String} address
   * @return {String}
   */


  exports.toChecksumAddress = function (address) {
    address = exports.stripHexPrefix(address).toLowerCase();
    var hash = exports.keccak(address).toString('hex');
    var ret = '0x';

    for (var i = 0; i < address.length; i++) {
      if (parseInt(hash[i], 16) >= 8) {
        ret += address[i].toUpperCase();
      } else {
        ret += address[i];
      }
    }

    return ret;
  };
  /**
   * Checks if the address is a valid checksummed address
   * @param {Buffer} address
   * @return {Boolean}
   */


  exports.isValidChecksumAddress = function (address) {
    return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
  };
  /**
   * Generates an address of a newly created contract
   * @param {Buffer} from the address which is creating this new address
   * @param {Buffer} nonce the nonce of the from account
   * @return {Buffer}
   */


  exports.generateAddress = function (from, nonce) {
    from = exports.toBuffer(from);
    nonce = new BN(nonce);

    if (nonce.isZero()) {
      // in RLP we want to encode null in the case of zero nonce
      // read the RLP documentation for an answer if you dare
      nonce = null;
    } else {
      nonce = Buffer.from(nonce.toArray());
    } // Only take the lower 160bits of the hash


    return exports.rlphash([from, nonce]).slice(-20);
  };
  /**
   * Returns true if the supplied address belongs to a precompiled account (Byzantium)
   * @param {Buffer|String} address
   * @return {Boolean}
   */


  exports.isPrecompiled = function (address) {
    var a = exports.unpad(address);
    return a.length === 1 && a[0] >= 1 && a[0] <= 8;
  };
  /**
   * Adds "0x" to a given `String` if it does not already start with "0x"
   * @param {String} str
   * @return {String}
   */


  exports.addHexPrefix = function (str) {
    if (typeof str !== 'string') {
      return str;
    }

    return exports.isHexPrefixed(str) ? str : '0x' + str;
  };
  /**
   * Validate ECDSA signature
   * @method isValidSignature
   * @param {Buffer} v
   * @param {Buffer} r
   * @param {Buffer} s
   * @param {Boolean} [homestead=true]
   * @return {Boolean}
   */


  exports.isValidSignature = function (v, r, s, homestead) {
    var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
    var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

    if (r.length !== 32 || s.length !== 32) {
      return false;
    }

    if (v !== 27 && v !== 28) {
      return false;
    }

    r = new BN(r);
    s = new BN(s);

    if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
      return false;
    }

    if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
      return false;
    }

    return true;
  };
  /**
   * Converts a `Buffer` or `Array` to JSON
   * @param {Buffer|Array} ba
   * @return {Array|String|null}
   */


  exports.baToJSON = function (ba) {
    if (Buffer.isBuffer(ba)) {
      return '0x' + ba.toString('hex');
    } else if (ba instanceof Array) {
      var array = [];

      for (var i = 0; i < ba.length; i++) {
        array.push(exports.baToJSON(ba[i]));
      }

      return array;
    }
  };
  /**
   * Defines properties on a `Object`. It make the assumption that underlying data is binary.
   * @param {Object} self the `Object` to define properties on
   * @param {Array} fields an array fields to define. Fields can contain:
   * * `name` - the name of the properties
   * * `length` - the number of bytes the field can have
   * * `allowLess` - if the field can be less than the length
   * * `allowEmpty`
   * @param {*} data data to be validated against the definitions
   */


  exports.defineProperties = function (self, fields, data) {
    self.raw = [];
    self._fields = []; // attach the `toJSON`

    self.toJSON = function (label) {
      if (label) {
        var obj = {};

        self._fields.forEach(function (field) {
          obj[field] = '0x' + self[field].toString('hex');
        });

        return obj;
      }

      return exports.baToJSON(this.raw);
    };

    self.serialize = function serialize() {
      return rlp.encode(self.raw);
    };

    fields.forEach(function (field, i) {
      self._fields.push(field.name);

      function getter() {
        return self.raw[i];
      }

      function setter(v) {
        v = exports.toBuffer(v);

        if (v.toString('hex') === '00' && !field.allowZero) {
          v = Buffer.allocUnsafe(0);
        }

        if (field.allowLess && field.length) {
          v = exports.stripZeros(v);
          assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
        } else if (!(field.allowZero && v.length === 0) && field.length) {
          assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
        }

        self.raw[i] = v;
      }

      Object.defineProperty(self, field.name, {
        enumerable: true,
        configurable: true,
        get: getter,
        set: setter
      });

      if (field["default"]) {
        self[field.name] = field["default"];
      } // attach alias


      if (field.alias) {
        Object.defineProperty(self, field.alias, {
          enumerable: false,
          configurable: true,
          set: setter,
          get: getter
        });
      }
    }); // if the constuctor is passed data

    if (data) {
      if (typeof data === 'string') {
        data = Buffer.from(exports.stripHexPrefix(data), 'hex');
      }

      if (Buffer.isBuffer(data)) {
        data = rlp.decode(data);
      }

      if (Array.isArray(data)) {
        if (data.length > self._fields.length) {
          throw new Error('wrong number of fields in data');
        } // make sure all the items are buffers


        data.forEach(function (d, i) {
          self[self._fields[i]] = exports.toBuffer(d);
        });
      } else if ((typeof data === 'undefined' ? 'undefined' : _typeof$1(data)) === 'object') {
        var keys = Object.keys(data);
        fields.forEach(function (field) {
          if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
          if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
        });
      } else {
        throw new Error('invalid data');
      }
    }
  };
})(dist$1);

var dist = {};

var secp256k1v3Adapter = {};

var secp256k1v3Lib = {};

// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE


Object.defineProperty(secp256k1v3Lib, "__esModule", {
  value: true
});
var BN$2 = require$$0$5;
var EC = require$$1.ec;
var ec = new EC('secp256k1');
var ecparams = ec.curve;

secp256k1v3Lib.privateKeyExport = function (privateKey, compressed) {
  if (compressed === void 0) {
    compressed = true;
  }

  var d = new BN$2(privateKey);

  if (d.ucmp(ecparams.n) >= 0) {
    throw new Error("couldn't export to DER format");
  }

  var point = ec.g.mul(d);
  return toPublicKey(point.getX(), point.getY(), compressed);
};

secp256k1v3Lib.privateKeyModInverse = function (privateKey) {
  var bn = new BN$2(privateKey);

  if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
    throw new Error('private key range is invalid');
  }

  return bn.invm(ecparams.n).toArrayLike(Buffer$6, 'be', 32);
};

secp256k1v3Lib.signatureImport = function (sigObj) {
  var r = new BN$2(sigObj.r);

  if (r.ucmp(ecparams.n) >= 0) {
    r = new BN$2(0);
  }

  var s = new BN$2(sigObj.s);

  if (s.ucmp(ecparams.n) >= 0) {
    s = new BN$2(0);
  }

  return Buffer$6.concat([r.toArrayLike(Buffer$6, 'be', 32), s.toArrayLike(Buffer$6, 'be', 32)]);
};

secp256k1v3Lib.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  if (compressed === void 0) {
    compressed = true;
  }

  var point = ec.keyFromPublic(publicKey);
  var scalar = new BN$2(privateKey);

  if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
    throw new Error('scalar was invalid (zero or overflow)');
  }

  var shared = point.pub.mul(scalar);
  return toPublicKey(shared.getX(), shared.getY(), compressed);
};

var toPublicKey = function toPublicKey(x, y, compressed) {
  var publicKey;

  if (compressed) {
    publicKey = Buffer$6.alloc(33);
    publicKey[0] = y.isOdd() ? 0x03 : 0x02;
    x.toArrayLike(Buffer$6, 'be', 32).copy(publicKey, 1);
  } else {
    publicKey = Buffer$6.alloc(65);
    publicKey[0] = 0x04;
    x.toArrayLike(Buffer$6, 'be', 32).copy(publicKey, 1);
    y.toArrayLike(Buffer$6, 'be', 32).copy(publicKey, 33);
  }

  return publicKey;
};

var der = {};

// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE


Object.defineProperty(der, "__esModule", {
  value: true
});
var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer$6.from([// begin
0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20, // private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // middle
0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00, // public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer$6.from([// begin
0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20, // private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // middle
0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00, // public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

der.privateKeyExport = function (privateKey, publicKey, compressed) {
  if (compressed === void 0) {
    compressed = true;
  }

  var result = Buffer$6.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
  privateKey.copy(result, compressed ? 8 : 9);
  publicKey.copy(result, compressed ? 181 : 214);
  return result;
};

der.privateKeyImport = function (privateKey) {
  var length = privateKey.length; // sequence header

  var index = 0;
  if (length < index + 1 || privateKey[index] !== 0x30) return null;
  index += 1; // sequence length constructor

  if (length < index + 1 || !(privateKey[index] & 0x80)) return null;
  var lenb = privateKey[index] & 0x7f;
  index += 1;
  if (lenb < 1 || lenb > 2) return null;
  if (length < index + lenb) return null; // sequence length

  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
  index += lenb;
  if (length < index + len) return null; // sequence element 0: version number (=1)

  if (length < index + 3 || privateKey[index] !== 0x02 || privateKey[index + 1] !== 0x01 || privateKey[index + 2] !== 0x01) {
    return null;
  }

  index += 3; // sequence element 1: octet string, up to 32 bytes

  if (length < index + 2 || privateKey[index] !== 0x04 || privateKey[index + 1] > 0x20 || length < index + 2 + privateKey[index + 1]) {
    return null;
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
};

der.signatureImportLax = function (signature) {
  var r = Buffer$6.alloc(32, 0);
  var s = Buffer$6.alloc(32, 0);
  var length = signature.length;
  var index = 0; // sequence tag byte

  if (signature[index++] !== 0x30) {
    return null;
  } // sequence length byte


  var lenbyte = signature[index++];

  if (lenbyte & 0x80) {
    index += lenbyte - 0x80;

    if (index > length) {
      return null;
    }
  } // sequence tag byte for r


  if (signature[index++] !== 0x02) {
    return null;
  } // length for r


  var rlen = signature[index++];

  if (rlen & 0x80) {
    lenbyte = rlen - 0x80;

    if (index + lenbyte > length) {
      return null;
    }

    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {
    }

    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      rlen = (rlen << 8) + signature[index];
    }
  }

  if (rlen > length - index) {
    return null;
  }

  var rindex = index;
  index += rlen; // sequence tag byte for s

  if (signature[index++] !== 0x02) {
    return null;
  } // length for s


  var slen = signature[index++];

  if (slen & 0x80) {
    lenbyte = slen - 0x80;

    if (index + lenbyte > length) {
      return null;
    }

    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {
    }

    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      slen = (slen << 8) + signature[index];
    }
  }

  if (slen > length - index) {
    return null;
  }

  var sindex = index;
  index += slen; // ignore leading zeros in r

  for (; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1) {
  } // copy r value


  if (rlen > 32) {
    return null;
  }

  var rvalue = signature.slice(rindex, rindex + rlen);
  rvalue.copy(r, 32 - rvalue.length); // ignore leading zeros in s

  for (; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1) {
  } // copy s value


  if (slen > 32) {
    return null;
  }

  var svalue = signature.slice(sindex, sindex + slen);
  svalue.copy(s, 32 - svalue.length);
  return {
    r: r,
    s: s
  };
};

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;
  var secp256k1 = secp256k1$2;
  var secp256k1v3 = secp256k1v3Lib;
  var der$1 = der;
  /**
   * Verify an ECDSA privateKey
   * @method privateKeyVerify
   * @param {Buffer} privateKey
   * @return {boolean}
   */

  exports.privateKeyVerify = function (privateKey) {
    // secp256k1 v4 version throws when privateKey length is not 32
    if (privateKey.length !== 32) {
      return false;
    }

    return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
  };
  /**
   * Export a privateKey in DER format
   * @method privateKeyExport
   * @param {Buffer} privateKey
   * @param {boolean} compressed
   * @return {boolean}
   */


  exports.privateKeyExport = function (privateKey, compressed) {
    // secp256k1 v4 version throws when privateKey length is not 32
    if (privateKey.length !== 32) {
      throw new RangeError('private key length is invalid');
    }

    var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
    return der$1.privateKeyExport(privateKey, publicKey, compressed);
  };
  /**
   * Import a privateKey in DER format
   * @method privateKeyImport
   * @param {Buffer} privateKey
   * @return {Buffer}
   */


  exports.privateKeyImport = function (privateKey) {
    // privateKeyImport method is not part of secp256k1 v4 package
    // this implementation is based on v3
    privateKey = der$1.privateKeyImport(privateKey);

    if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {
      return privateKey;
    }

    throw new Error("couldn't import from DER format");
  };
  /**
   * Negate a privateKey by subtracting it from the order of the curve's base point
   * @method privateKeyNegate
   * @param {Buffer} privateKey
   * @return {Buffer}
   */


  exports.privateKeyNegate = function (privateKey) {
    return Buffer$6.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
  };
  /**
   * Compute the inverse of a privateKey (modulo the order of the curve's base point).
   * @method privateKeyModInverse
   * @param {Buffer} privateKey
   * @return {Buffer}
   */


  exports.privateKeyModInverse = function (privateKey) {
    if (privateKey.length !== 32) {
      throw new Error('private key length is invalid');
    }

    return Buffer$6.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
  };
  /**
   * Tweak a privateKey by adding tweak to it.
   * @method privateKeyTweakAdd
   * @param {Buffer} privateKey
   * @param {Buffer} tweak
   * @return {Buffer}
   */


  exports.privateKeyTweakAdd = function (privateKey, tweak) {
    return Buffer$6.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
  };
  /**
   * Tweak a privateKey by multiplying it by a tweak.
   * @method privateKeyTweakMul
   * @param {Buffer} privateKey
   * @param {Buffer} tweak
   * @return {Buffer}
   */


  exports.privateKeyTweakMul = function (privateKey, tweak) {
    return Buffer$6.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
  };
  /**
   * Compute the public key for a privateKey.
   * @method publicKeyCreate
   * @param {Buffer} privateKey
   * @param {boolean} compressed
   * @return {Buffer}
   */


  exports.publicKeyCreate = function (privateKey, compressed) {
    return Buffer$6.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
  };
  /**
   * Convert a publicKey to compressed or uncompressed form.
   * @method publicKeyConvert
   * @param {Buffer} publicKey
   * @param {boolean} compressed
   * @return {Buffer}
   */


  exports.publicKeyConvert = function (publicKey, compressed) {
    return Buffer$6.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
  };
  /**
   * Verify an ECDSA publicKey.
   * @method publicKeyVerify
   * @param {Buffer} publicKey
   * @return {boolean}
   */


  exports.publicKeyVerify = function (publicKey) {
    // secp256k1 v4 version throws when publicKey length is not 33 or 65
    if (publicKey.length !== 33 && publicKey.length !== 65) {
      return false;
    }

    return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
  };
  /**
   * Tweak a publicKey by adding tweak times the generator to it.
   * @method publicKeyTweakAdd
   * @param {Buffer} publicKey
   * @param {Buffer} tweak
   * @param {boolean} compressed
   * @return {Buffer}
   */


  exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
    return Buffer$6.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
  };
  /**
   * Tweak a publicKey by multiplying it by a tweak value
   * @method publicKeyTweakMul
   * @param {Buffer} publicKey
   * @param {Buffer} tweak
   * @param {boolean} compressed
   * @return {Buffer}
   */


  exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
    return Buffer$6.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
  };
  /**
   * Add a given publicKeys together.
   * @method publicKeyCombine
   * @param {Array<Buffer>} publicKeys
   * @param {boolean} compressed
   * @return {Buffer}
   */


  exports.publicKeyCombine = function (publicKeys, compressed) {
    var keys = [];
    publicKeys.forEach(function (publicKey) {
      keys.push(Uint8Array.from(publicKey));
    });
    return Buffer$6.from(secp256k1.publicKeyCombine(keys, compressed));
  };
  /**
   * Convert a signature to a normalized lower-S form.
   * @method signatureNormalize
   * @param {Buffer} signature
   * @return {Buffer}
   */


  exports.signatureNormalize = function (signature) {
    return Buffer$6.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
  };
  /**
   * Serialize an ECDSA signature in DER format.
   * @method signatureExport
   * @param {Buffer} signature
   * @return {Buffer}
   */


  exports.signatureExport = function (signature) {
    return Buffer$6.from(secp256k1.signatureExport(Uint8Array.from(signature)));
  };
  /**
   * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
   * @method signatureImport
   * @param {Buffer} signature
   * @return {Buffer}
   */


  exports.signatureImport = function (signature) {
    return Buffer$6.from(secp256k1.signatureImport(Uint8Array.from(signature)));
  };
  /**
   * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
   * @method signatureImportLax
   * @param {Buffer} signature
   * @return {Buffer}
   */


  exports.signatureImportLax = function (signature) {
    // signatureImportLax method is not part of secp256k1 v4 package
    // this implementation is based on v3
    // ensure that signature is greater than 0
    if (signature.length === 0) {
      throw new RangeError('signature length is invalid');
    }

    var sigObj = der$1.signatureImportLax(signature);

    if (sigObj === null) {
      throw new Error("couldn't parse DER signature");
    }

    return secp256k1v3.signatureImport(sigObj);
  };
  /**
   * Create an ECDSA signature. Always return low-S signature.
   * @method sign
   * @param {Buffer} message
   * @param {Buffer} privateKey
   * @param {Object} options
   * @return {Buffer}
   */


  exports.sign = function (message, privateKey, options) {
    if (options === null) {
      throw new TypeError('options should be an Object');
    }

    var signOptions = undefined;

    if (options) {
      signOptions = {};

      if (options.data === null) {
        // validate option.data length
        throw new TypeError('options.data should be a Buffer');
      }

      if (options.data) {
        if (options.data.length != 32) {
          throw new RangeError('options.data length is invalid');
        }

        signOptions.data = new Uint8Array(options.data);
      }

      if (options.noncefn === null) {
        throw new TypeError('options.noncefn should be a Function');
      }

      if (options.noncefn) {
        // convert option.noncefn function signature
        signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
          var bufferAlgo = algo != null ? Buffer$6.from(algo) : null;
          var bufferData = data != null ? Buffer$6.from(data) : null;
          var buffer = Buffer$6.from('');

          if (options.noncefn) {
            buffer = options.noncefn(Buffer$6.from(message), Buffer$6.from(privateKey), bufferAlgo, bufferData, attempt);
          }

          return new Uint8Array(buffer);
        };
      }
    }

    var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
    return {
      signature: Buffer$6.from(sig.signature),
      recovery: sig.recid
    };
  };
  /**
   * Verify an ECDSA signature.
   * @method verify
   * @param {Buffer} message
   * @param {Buffer} signature
   * @param {Buffer} publicKey
   * @return {boolean}
   */


  exports.verify = function (message, signature, publicKey) {
    return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
  };
  /**
   * Recover an ECDSA public key from a signature.
   * @method recover
   * @param {Buffer} message
   * @param {Buffer} signature
   * @param {Number} recid
   * @param {boolean} compressed
   * @return {Buffer}
   */


  exports.recover = function (message, signature, recid, compressed) {
    return Buffer$6.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
  };
  /**
   * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
   * @method ecdh
   * @param {Buffer} publicKey
   * @param {Buffer} privateKey
   * @return {Buffer}
   */


  exports.ecdh = function (publicKey, privateKey) {
    // note: secp256k1 v3 doesn't allow optional parameter
    return Buffer$6.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
  };

  exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
    // ecdhUnsafe method is not part of secp256k1 v4 package
    // this implementation is based on v3
    // ensure valid publicKey length
    if (publicKey.length !== 33 && publicKey.length !== 65) {
      throw new RangeError('public key length is invalid');
    } // ensure valid privateKey length


    if (privateKey.length !== 32) {
      throw new RangeError('private key length is invalid');
    }

    return Buffer$6.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
  };
})(secp256k1v3Adapter);

var constants = {};

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;
  var BN = require$$0$5;
  /**
   * The max integer that this VM can handle
   */

  exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);
  /**
   * 2^256
   */

  exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);
  /**
   * Keccak-256 hash of null
   */

  exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
  /**
   * Keccak-256 hash of null
   */

  exports.KECCAK256_NULL = Buffer$6.from(exports.KECCAK256_NULL_S, 'hex');
  /**
   * Keccak-256 of an RLP of an empty array
   */

  exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
  /**
   * Keccak-256 of an RLP of an empty array
   */

  exports.KECCAK256_RLP_ARRAY = Buffer$6.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
  /**
   * Keccak-256 hash of the RLP of null
   */

  exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
  /**
   * Keccak-256 hash of the RLP of null
   */

  exports.KECCAK256_RLP = Buffer$6.from(exports.KECCAK256_RLP_S, 'hex');
})(constants);

var account = {};

var bytes = {};

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.stripZeros = exports.unpad = exports.setLengthRight = exports.setLength = exports.setLengthLeft = exports.zeros = void 0;
  var ethjsUtil = lib$1;
  var BN = require$$0$5;
  /**
   * Returns a buffer filled with 0s.
   * @param bytes the number of bytes the buffer should be
   */

  exports.zeros = function (bytes) {
    return Buffer$6.allocUnsafe(bytes).fill(0);
  };
  /**
   * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
   * Or it truncates the beginning if it exceeds.
   * @param msg the value to pad (Buffer|Array)
   * @param length the number of bytes the output should be
   * @param right whether to start padding form the left or right
   * @return (Buffer|Array)
   */


  exports.setLengthLeft = function (msg, length, right) {
    if (right === void 0) {
      right = false;
    }

    var buf = exports.zeros(length);
    msg = exports.toBuffer(msg);

    if (right) {
      if (msg.length < length) {
        msg.copy(buf);
        return buf;
      }

      return msg.slice(0, length);
    } else {
      if (msg.length < length) {
        msg.copy(buf, length - msg.length);
        return buf;
      }

      return msg.slice(-length);
    }
  };

  exports.setLength = exports.setLengthLeft;
  /**
   * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
   * Or it truncates the beginning if it exceeds.
   * @param msg the value to pad (Buffer|Array)
   * @param length the number of bytes the output should be
   * @return (Buffer|Array)
   */

  exports.setLengthRight = function (msg, length) {
    return exports.setLength(msg, length, true);
  };
  /**
   * Trims leading zeros from a `Buffer` or an `Array`.
   * @param a (Buffer|Array|String)
   * @return (Buffer|Array|String)
   */


  exports.unpad = function (a) {
    a = ethjsUtil.stripHexPrefix(a);
    var first = a[0];

    while (a.length > 0 && first.toString() === '0') {
      a = a.slice(1);
      first = a[0];
    }

    return a;
  };

  exports.stripZeros = exports.unpad;
  /**
   * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
   * @param v the value
   */

  exports.toBuffer = function (v) {
    if (!Buffer$6.isBuffer(v)) {
      if (Array.isArray(v)) {
        v = Buffer$6.from(v);
      } else if (typeof v === 'string') {
        if (ethjsUtil.isHexString(v)) {
          v = Buffer$6.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(v)), 'hex');
        } else {
          throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v);
        }
      } else if (typeof v === 'number') {
        v = ethjsUtil.intToBuffer(v);
      } else if (v === null || v === undefined) {
        v = Buffer$6.allocUnsafe(0);
      } else if (BN.isBN(v)) {
        v = v.toArrayLike(Buffer$6);
      } else if (v.toArray) {
        // converts a BN to a Buffer
        v = Buffer$6.from(v.toArray());
      } else {
        throw new Error('invalid type');
      }
    }

    return v;
  };
  /**
   * Converts a `Buffer` to a `Number`.
   * @param buf `Buffer` object to convert
   * @throws If the input number exceeds 53 bits.
   */


  exports.bufferToInt = function (buf) {
    return new BN(exports.toBuffer(buf)).toNumber();
  };
  /**
   * Converts a `Buffer` into a `0x`-prefixed hex `String`.
   * @param buf `Buffer` object to convert
   */


  exports.bufferToHex = function (buf) {
    buf = exports.toBuffer(buf);
    return '0x' + buf.toString('hex');
  };
  /**
   * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
   * @param num Signed integer value
   */


  exports.fromSigned = function (num) {
    return new BN(num).fromTwos(256);
  };
  /**
   * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
   * @param num
   */


  exports.toUnsigned = function (num) {
    return Buffer$6.from(num.toTwos(256).toArray());
  };
  /**
   * Adds "0x" to a given `String` if it does not already start with "0x".
   */


  exports.addHexPrefix = function (str) {
    if (typeof str !== 'string') {
      return str;
    }

    return ethjsUtil.isHexPrefixed(str) ? str : '0x' + str;
  };
  /**
   * Converts a `Buffer` or `Array` to JSON.
   * @param ba (Buffer|Array)
   * @return (Array|String|null)
   */


  exports.baToJSON = function (ba) {
    if (Buffer$6.isBuffer(ba)) {
      return "0x" + ba.toString('hex');
    } else if (ba instanceof Array) {
      var array = [];

      for (var i = 0; i < ba.length; i++) {
        array.push(exports.baToJSON(ba[i]));
      }

      return array;
    }
  };
})(bytes);

var hash = {};

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.rlphash = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.keccak = void 0;
  var _a = keccak$3,
      keccak224 = _a.keccak224,
      keccak384 = _a.keccak384,
      k256 = _a.keccak256,
      keccak512 = _a.keccak512;
  var createHash$1 = createHash;
  var ethjsUtil = lib$1;
  var rlp = dist$2;
  var bytes_1 = bytes;
  /**
   * Creates Keccak hash of the input
   * @param a The input data (Buffer|Array|String|Number) If the string is a 0x-prefixed hex value
   * it's interpreted as hexadecimal, otherwise as utf8.
   * @param bits The Keccak width
   */

  exports.keccak = function (a, bits) {
    if (bits === void 0) {
      bits = 256;
    }

    if (typeof a === 'string' && !ethjsUtil.isHexString(a)) {
      a = Buffer$6.from(a, 'utf8');
    } else {
      a = bytes_1.toBuffer(a);
    }

    if (!bits) bits = 256;

    switch (bits) {
      case 224:
        {
          return keccak224(a);
        }

      case 256:
        {
          return k256(a);
        }

      case 384:
        {
          return keccak384(a);
        }

      case 512:
        {
          return keccak512(a);
        }

      default:
        {
          throw new Error("Invald algorithm: keccak" + bits);
        }
    }
  };
  /**
   * Creates Keccak-256 hash of the input, alias for keccak(a, 256).
   * @param a The input data (Buffer|Array|String|Number)
   */


  exports.keccak256 = function (a) {
    return exports.keccak(a);
  };
  /**
   * Creates SHA256 hash of the input.
   * @param a The input data (Buffer|Array|String|Number)
   */


  exports.sha256 = function (a) {
    a = bytes_1.toBuffer(a);
    return createHash$1('sha256').update(a).digest();
  };
  /**
   * Creates RIPEMD160 hash of the input.
   * @param a The input data (Buffer|Array|String|Number)
   * @param padded Whether it should be padded to 256 bits or not
   */


  exports.ripemd160 = function (a, padded) {
    a = bytes_1.toBuffer(a);
    var hash = createHash$1('rmd160').update(a).digest();

    if (padded === true) {
      return bytes_1.setLength(hash, 32);
    } else {
      return hash;
    }
  };
  /**
   * Creates SHA-3 hash of the RLP encoded version of the input.
   * @param a The input data
   */


  exports.rlphash = function (a) {
    return exports.keccak(rlp.encode(a));
  };
})(hash);

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;
  var assert = require$$0$1;
  var ethjsUtil = lib$1;
  var secp256k1 = secp256k1v3Adapter;
  var BN = require$$0$5;
  var bytes_1 = bytes;
  var hash_1 = hash;
  /**
   * Returns a zero address.
   */

  exports.zeroAddress = function () {
    var addressLength = 20;
    var addr = bytes_1.zeros(addressLength);
    return bytes_1.bufferToHex(addr);
  };
  /**
   * Checks if the address is a valid. Accepts checksummed addresses too.
   */


  exports.isValidAddress = function (address) {
    return /^0x[0-9a-fA-F]{40}$/.test(address);
  };
  /**
   * Checks if a given address is a zero address.
   */


  exports.isZeroAddress = function (address) {
    var zeroAddr = exports.zeroAddress();
    return zeroAddr === bytes_1.addHexPrefix(address);
  };
  /**
   * Returns a checksummed address.
   *
   * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This
   * has the effect of checksummed addresses for one chain having invalid checksums for others.
   * For more details, consult EIP-1191.
   *
   * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly
   * used variation in Ethereum was without the chainId. This may change in the future.
   */


  exports.toChecksumAddress = function (address, eip1191ChainId) {
    address = ethjsUtil.stripHexPrefix(address).toLowerCase();
    var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';
    var hash = hash_1.keccak(prefix + address).toString('hex');
    var ret = '0x';

    for (var i = 0; i < address.length; i++) {
      if (parseInt(hash[i], 16) >= 8) {
        ret += address[i].toUpperCase();
      } else {
        ret += address[i];
      }
    }

    return ret;
  };
  /**
   * Checks if the address is a valid checksummed address.
   *
   * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.
   */


  exports.isValidChecksumAddress = function (address, eip1191ChainId) {
    return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;
  };
  /**
   * Generates an address of a newly created contract.
   * @param from The address which is creating this new address
   * @param nonce The nonce of the from account
   */


  exports.generateAddress = function (from, nonce) {
    from = bytes_1.toBuffer(from);
    var nonceBN = new BN(nonce);

    if (nonceBN.isZero()) {
      // in RLP we want to encode null in the case of zero nonce
      // read the RLP documentation for an answer if you dare
      return hash_1.rlphash([from, null]).slice(-20);
    } // Only take the lower 160bits of the hash


    return hash_1.rlphash([from, Buffer$6.from(nonceBN.toArray())]).slice(-20);
  };
  /**
   * Generates an address for a contract created using CREATE2.
   * @param from The address which is creating this new address
   * @param salt A salt
   * @param initCode The init code of the contract being created
   */


  exports.generateAddress2 = function (from, salt, initCode) {
    var fromBuf = bytes_1.toBuffer(from);
    var saltBuf = bytes_1.toBuffer(salt);
    var initCodeBuf = bytes_1.toBuffer(initCode);
    assert(fromBuf.length === 20);
    assert(saltBuf.length === 32);
    var address = hash_1.keccak256(Buffer$6.concat([Buffer$6.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));
    return address.slice(-20);
  };
  /**
   * Returns true if the supplied address belongs to a precompiled account (Byzantium).
   */


  exports.isPrecompiled = function (address) {
    var a = bytes_1.unpad(address);
    return a.length === 1 && a[0] >= 1 && a[0] <= 8;
  };
  /**
   * Checks if the private key satisfies the rules of the curve secp256k1.
   */


  exports.isValidPrivate = function (privateKey) {
    return secp256k1.privateKeyVerify(privateKey);
  };
  /**
   * Checks if the public key satisfies the rules of the curve secp256k1
   * and the requirements of Ethereum.
   * @param publicKey The two points of an uncompressed key, unless sanitize is enabled
   * @param sanitize Accept public keys in other formats
   */


  exports.isValidPublic = function (publicKey, sanitize) {
    if (sanitize === void 0) {
      sanitize = false;
    }

    if (publicKey.length === 64) {
      // Convert to SEC1 for secp256k1
      return secp256k1.publicKeyVerify(Buffer$6.concat([Buffer$6.from([4]), publicKey]));
    }

    if (!sanitize) {
      return false;
    }

    return secp256k1.publicKeyVerify(publicKey);
  };
  /**
   * Returns the ethereum address of a given public key.
   * Accepts "Ethereum public keys" and SEC1 encoded keys.
   * @param pubKey The two points of an uncompressed key, unless sanitize is enabled
   * @param sanitize Accept public keys in other formats
   */


  exports.pubToAddress = function (pubKey, sanitize) {
    if (sanitize === void 0) {
      sanitize = false;
    }

    pubKey = bytes_1.toBuffer(pubKey);

    if (sanitize && pubKey.length !== 64) {
      pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
    }

    assert(pubKey.length === 64); // Only take the lower 160bits of the hash

    return hash_1.keccak(pubKey).slice(-20);
  };

  exports.publicToAddress = exports.pubToAddress;
  /**
   * Returns the ethereum address of a given private key.
   * @param privateKey A private key must be 256 bits wide
   */

  exports.privateToAddress = function (privateKey) {
    return exports.publicToAddress(exports.privateToPublic(privateKey));
  };
  /**
   * Returns the ethereum public key of a given private key.
   * @param privateKey A private key must be 256 bits wide
   */


  exports.privateToPublic = function (privateKey) {
    privateKey = bytes_1.toBuffer(privateKey); // skip the type flag and use the X, Y points

    return secp256k1.publicKeyCreate(privateKey, false).slice(1);
  };
  /**
   * Converts a public key to the Ethereum format.
   */


  exports.importPublic = function (publicKey) {
    publicKey = bytes_1.toBuffer(publicKey);

    if (publicKey.length !== 64) {
      publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
    }

    return publicKey;
  };
})(account);

var signature = {};

Object.defineProperty(signature, "__esModule", {
  value: true
});
signature.hashPersonalMessage = signature.isValidSignature = signature.fromRpcSig = signature.toRpcSig = signature.ecrecover = signature.ecsign = void 0;
var secp256k1 = secp256k1v3Adapter;
var BN$1 = require$$0$5;
var bytes_1$1 = bytes;
var hash_1 = hash;
/**
 * Returns the ECDSA signature of a message hash.
 */

signature.ecsign = function (msgHash, privateKey, chainId) {
  var sig = secp256k1.sign(msgHash, privateKey);
  var recovery = sig.recovery;
  var ret = {
    r: sig.signature.slice(0, 32),
    s: sig.signature.slice(32, 64),
    v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27
  };
  return ret;
};
/**
 * ECDSA public key recovery from signature.
 * @returns Recovered public key
 */


signature.ecrecover = function (msgHash, v, r, s, chainId) {
  var signature = Buffer$6.concat([bytes_1$1.setLength(r, 32), bytes_1$1.setLength(s, 32)], 64);
  var recovery = calculateSigRecovery(v, chainId);

  if (!isValidSigRecovery(recovery)) {
    throw new Error('Invalid signature v value');
  }

  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};
/**
 * Convert signature parameters into the format of `eth_sign` RPC method.
 * @returns Signature
 */


signature.toRpcSig = function (v, r, s, chainId) {
  var recovery = calculateSigRecovery(v, chainId);

  if (!isValidSigRecovery(recovery)) {
    throw new Error('Invalid signature v value');
  } // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin


  return bytes_1$1.bufferToHex(Buffer$6.concat([bytes_1$1.setLengthLeft(r, 32), bytes_1$1.setLengthLeft(s, 32), bytes_1$1.toBuffer(v)]));
};
/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 */


signature.fromRpcSig = function (sig) {
  var buf = bytes_1$1.toBuffer(sig); // NOTE: with potential introduction of chainId this might need to be updated

  if (buf.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = buf[64]; // support both versions of `eth_sign` responses

  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: buf.slice(0, 32),
    s: buf.slice(32, 64)
  };
};
/**
 * Validate a ECDSA signature.
 * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one
 */


signature.isValidSignature = function (v, r, s, homesteadOrLater, chainId) {
  if (homesteadOrLater === void 0) {
    homesteadOrLater = true;
  }

  var SECP256K1_N_DIV_2 = new BN$1('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN$1('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
    return false;
  }

  var rBN = new BN$1(r);
  var sBN = new BN$1(s);

  if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
    return false;
  }

  if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};
/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 */


signature.hashPersonalMessage = function (message) {
  var prefix = Buffer$6.from("\x19Ethereum Signed Message:\n" + message.length.toString(), 'utf-8');
  return hash_1.keccak(Buffer$6.concat([prefix, message]));
};

function calculateSigRecovery(v, chainId) {
  return chainId ? v - (2 * chainId + 35) : v - 27;
}

function isValidSigRecovery(recovery) {
  return recovery === 0 || recovery === 1;
}

var object = {};

Object.defineProperty(object, "__esModule", {
  value: true
});
object.defineProperties = void 0;
var assert = require$$0$1;
var ethjsUtil = lib$1;
var rlp = dist$2;
var bytes_1 = bytes;
/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param self the `Object` to define properties on
 * @param fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param data data to be validated against the definitions
 * @deprecated
 */

object.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = []; // attach the `toJSON`

  self.toJSON = function (label) {
    if (label === void 0) {
      label = false;
    }

    if (label) {
      var obj_1 = {};

      self._fields.forEach(function (field) {
        obj_1[field] = "0x" + self[field].toString('hex');
      });

      return obj_1;
    }

    return bytes_1.baToJSON(self.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);

    function getter() {
      return self.raw[i];
    }

    function setter(v) {
      v = bytes_1.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer$6.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = bytes_1.stripZeros(v);
        assert(field.length >= v.length, "The field " + field.name + " must not have more " + field.length + " bytes");
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, "The field " + field.name + " must have byte length of " + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field["default"]) {
      self[field.name] = field["default"];
    } // attach alias


    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  }); // if the constuctor is passed data

  if (data) {
    if (typeof data === 'string') {
      data = Buffer$6.from(ethjsUtil.stripHexPrefix(data), 'hex');
    }

    if (Buffer$6.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      } // make sure all the items are buffers


      data.forEach(function (d, i) {
        self[self._fields[i]] = bytes_1.toBuffer(d);
      });
    } else if (_typeof(data) === 'object') {
      var keys_1 = Object.keys(data);
      fields.forEach(function (field) {
        if (keys_1.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys_1.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};

(function (exports) {

  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    });
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });

  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
    for (var p in m) {
      if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
    }
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.secp256k1 = exports.rlp = exports.BN = void 0;
  var secp256k1 = secp256k1v3Adapter;
  exports.secp256k1 = secp256k1;
  var ethjsUtil = lib$1;
  var BN = require$$0$5;
  exports.BN = BN;
  var rlp = dist$2;
  exports.rlp = rlp;
  Object.assign(exports, ethjsUtil);
  /**
   * Constants
   */

  __exportStar(constants, exports);
  /**
   * Public-key cryptography (secp256k1) and addresses
   */


  __exportStar(account, exports);
  /**
   * Hash functions
   */


  __exportStar(hash, exports);
  /**
   * ECDSA signature
   */


  __exportStar(signature, exports);
  /**
   * Utilities for manipulating Buffers, byte arrays, etc.
   */


  __exportStar(bytes, exports);
  /**
   * Function for definining properties on an object
   */


  __exportStar(object, exports);
})(dist);

var utils = dist;
var BN = require$$0$5;

var ABI = function ABI() {}; // Convert from short to canonical names
// FIXME: optimise or make this nicer?


function elementaryName(name) {
  if (name.startsWith('int[')) {
    return 'int256' + name.slice(3);
  } else if (name === 'int') {
    return 'int256';
  } else if (name.startsWith('uint[')) {
    return 'uint256' + name.slice(4);
  } else if (name === 'uint') {
    return 'uint256';
  } else if (name.startsWith('fixed[')) {
    return 'fixed128x128' + name.slice(5);
  } else if (name === 'fixed') {
    return 'fixed128x128';
  } else if (name.startsWith('ufixed[')) {
    return 'ufixed128x128' + name.slice(6);
  } else if (name === 'ufixed') {
    return 'ufixed128x128';
  }

  return name;
}

ABI.eventID = function (name, types) {
  // FIXME: use node.js util.format?
  var sig = name + '(' + types.map(elementaryName).join(',') + ')';
  return utils.keccak256(Buffer$6.from(sig));
};

ABI.methodID = function (name, types) {
  return ABI.eventID(name, types).slice(0, 4);
}; // Parse N from type<N>


function parseTypeN(type) {
  return parseInt(/^\D+(\d+)$/.exec(type)[1], 10);
} // Parse N,M from type<N>x<M>


function parseTypeNxM(type) {
  var tmp = /^\D+(\d+)x(\d+)$/.exec(type);
  return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
} // Parse N in type[<N>] where "type" can itself be an array type.


function parseTypeArray(type) {
  var tmp = type.match(/(.*)\[(.*?)\]$/);

  if (tmp) {
    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10);
  }

  return null;
}

function parseNumber(arg) {
  var type = _typeof(arg);

  if (type === 'string') {
    if (utils.isHexPrefixed(arg)) {
      return new BN(utils.stripHexPrefix(arg), 16);
    } else {
      return new BN(arg, 10);
    }
  } else if (type === 'number') {
    return new BN(arg);
  } else if (arg.toArray) {
    // assume this is a BN for the moment, replace with BN.isBN soon
    return arg;
  } else {
    throw new Error('Argument is not a number');
  }
} // someMethod(bytes,uint)
// someMethod(bytes,uint):(boolean)


function parseSignature(sig) {
  var tmp = /^(\w+)\((.*)\)$/.exec(sig);

  if (tmp.length !== 3) {
    throw new Error('Invalid method signature');
  }

  var args = /^(.+)\):\((.+)$/.exec(tmp[2]);

  if (args !== null && args.length === 3) {
    return {
      method: tmp[1],
      args: args[1].split(','),
      retargs: args[2].split(',')
    };
  } else {
    var params = tmp[2].split(',');

    if (params.length === 1 && params[0] === '') {
      // Special-case (possibly naive) fixup for functions that take no arguments.
      // TODO: special cases are always bad, but this makes the function return
      // match what the calling functions expect
      params = [];
    }

    return {
      method: tmp[1],
      args: params
    };
  }
} // Encodes a single item (can be dynamic array)
// @returns: Buffer


function encodeSingle(type, arg) {
  var size, num, ret, i;

  if (type === 'address') {
    return encodeSingle('uint160', parseNumber(arg));
  } else if (type === 'bool') {
    return encodeSingle('uint8', arg ? 1 : 0);
  } else if (type === 'string') {
    return encodeSingle('bytes', Buffer$6.from(arg, 'utf8'));
  } else if (isArray(type)) {
    // this part handles fixed-length ([2]) and variable length ([]) arrays
    // NOTE: we catch here all calls to arrays, that simplifies the rest
    if (typeof arg.length === 'undefined') {
      throw new Error('Not an array?');
    }

    size = parseTypeArray(type);

    if (size !== 'dynamic' && size !== 0 && arg.length > size) {
      throw new Error('Elements exceed array size: ' + size);
    }

    ret = [];
    type = type.slice(0, type.lastIndexOf('['));

    if (typeof arg === 'string') {
      arg = JSON.parse(arg);
    }

    for (i in arg) {
      ret.push(encodeSingle(type, arg[i]));
    }

    if (size === 'dynamic') {
      var length = encodeSingle('uint256', arg.length);
      ret.unshift(length);
    }

    return Buffer$6.concat(ret);
  } else if (type === 'bytes') {
    arg = Buffer$6.from(arg);
    ret = Buffer$6.concat([encodeSingle('uint256', arg.length), arg]);

    if (arg.length % 32 !== 0) {
      ret = Buffer$6.concat([ret, utils.zeros(32 - arg.length % 32)]);
    }

    return ret;
  } else if (type.startsWith('bytes')) {
    size = parseTypeN(type);

    if (size < 1 || size > 32) {
      throw new Error('Invalid bytes<N> width: ' + size);
    }

    return utils.setLengthRight(arg, 32);
  } else if (type.startsWith('uint')) {
    size = parseTypeN(type);

    if (size % 8 || size < 8 || size > 256) {
      throw new Error('Invalid uint<N> width: ' + size);
    }

    num = parseNumber(arg);

    if (num.bitLength() > size) {
      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());
    }

    if (num < 0) {
      throw new Error('Supplied uint is negative');
    }

    return num.toArrayLike(Buffer$6, 'be', 32);
  } else if (type.startsWith('int')) {
    size = parseTypeN(type);

    if (size % 8 || size < 8 || size > 256) {
      throw new Error('Invalid int<N> width: ' + size);
    }

    num = parseNumber(arg);

    if (num.bitLength() > size) {
      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());
    }

    return num.toTwos(256).toArrayLike(Buffer$6, 'be', 32);
  } else if (type.startsWith('ufixed')) {
    size = parseTypeNxM(type);
    num = parseNumber(arg);

    if (num < 0) {
      throw new Error('Supplied ufixed is negative');
    }

    return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))));
  } else if (type.startsWith('fixed')) {
    size = parseTypeNxM(type);
    return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))));
  }

  throw new Error('Unsupported or invalid type: ' + type);
} // Decodes a single item (can be dynamic array)
// @returns: array
// FIXME: this method will need a lot of attention at checking limits and validation


function decodeSingle(parsedType, data, offset) {
  if (typeof parsedType === 'string') {
    parsedType = parseType(parsedType);
  }

  var size, num, ret, i;

  if (parsedType.name === 'address') {
    return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer$6, 'be', 20).toString('hex');
  } else if (parsedType.name === 'bool') {
    return decodeSingle(parsedType.rawType, data, offset).toString() === new BN(1).toString();
  } else if (parsedType.name === 'string') {
    var bytes = decodeSingle(parsedType.rawType, data, offset);
    return Buffer$6.from(bytes, 'utf8').toString();
  } else if (parsedType.isArray) {
    // this part handles fixed-length arrays ([2]) and variable length ([]) arrays
    // NOTE: we catch here all calls to arrays, that simplifies the rest
    ret = [];
    size = parsedType.size;

    if (parsedType.size === 'dynamic') {
      offset = decodeSingle('uint256', data, offset).toNumber();
      size = decodeSingle('uint256', data, offset).toNumber();
      offset = offset + 32;
    }

    for (i = 0; i < size; i++) {
      var decoded = decodeSingle(parsedType.subArray, data, offset);
      ret.push(decoded);
      offset += parsedType.subArray.memoryUsage;
    }

    return ret;
  } else if (parsedType.name === 'bytes') {
    offset = decodeSingle('uint256', data, offset).toNumber();
    size = decodeSingle('uint256', data, offset).toNumber();
    return data.slice(offset + 32, offset + 32 + size);
  } else if (parsedType.name.startsWith('bytes')) {
    return data.slice(offset, offset + parsedType.size);
  } else if (parsedType.name.startsWith('uint')) {
    num = new BN(data.slice(offset, offset + 32), 16, 'be');

    if (num.bitLength() > parsedType.size) {
      throw new Error('Decoded int exceeds width: ' + parsedType.size + ' vs ' + num.bitLength());
    }

    return num;
  } else if (parsedType.name.startsWith('int')) {
    num = new BN(data.slice(offset, offset + 32), 16, 'be').fromTwos(256);

    if (num.bitLength() > parsedType.size) {
      throw new Error('Decoded uint exceeds width: ' + parsedType.size + ' vs ' + num.bitLength());
    }

    return num;
  } else if (parsedType.name.startsWith('ufixed')) {
    size = new BN(2).pow(new BN(parsedType.size[1]));
    num = decodeSingle('uint256', data, offset);

    if (!num.mod(size).isZero()) {
      throw new Error('Decimals not supported yet');
    }

    return num.div(size);
  } else if (parsedType.name.startsWith('fixed')) {
    size = new BN(2).pow(new BN(parsedType.size[1]));
    num = decodeSingle('int256', data, offset);

    if (!num.mod(size).isZero()) {
      throw new Error('Decimals not supported yet');
    }

    return num.div(size);
  }

  throw new Error('Unsupported or invalid type: ' + parsedType.name);
} // Parse the given type
// @returns: {} containing the type itself, memory usage and (including size and subArray if applicable)


function parseType(type) {
  var size;
  var ret;

  if (isArray(type)) {
    size = parseTypeArray(type);
    var subArray = type.slice(0, type.lastIndexOf('['));
    subArray = parseType(subArray);
    ret = {
      isArray: true,
      name: type,
      size: size,
      memoryUsage: size === 'dynamic' ? 32 : subArray.memoryUsage * size,
      subArray: subArray
    };
    return ret;
  } else {
    var rawType;

    switch (type) {
      case 'address':
        rawType = 'uint160';
        break;

      case 'bool':
        rawType = 'uint8';
        break;

      case 'string':
        rawType = 'bytes';
        break;
    }

    ret = {
      rawType: rawType,
      name: type,
      memoryUsage: 32
    };

    if (type.startsWith('bytes') && type !== 'bytes' || type.startsWith('uint') || type.startsWith('int')) {
      ret.size = parseTypeN(type);
    } else if (type.startsWith('ufixed') || type.startsWith('fixed')) {
      ret.size = parseTypeNxM(type);
    }

    if (type.startsWith('bytes') && type !== 'bytes' && (ret.size < 1 || ret.size > 32)) {
      throw new Error('Invalid bytes<N> width: ' + ret.size);
    }

    if ((type.startsWith('uint') || type.startsWith('int')) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {
      throw new Error('Invalid int/uint<N> width: ' + ret.size);
    }

    return ret;
  }
} // Is a type dynamic?


function isDynamic(type) {
  // FIXME: handle all types? I don't think anything is missing now
  return type === 'string' || type === 'bytes' || parseTypeArray(type) === 'dynamic';
} // Is a type an array?


function isArray(type) {
  return type.lastIndexOf(']') === type.length - 1;
} // Encode a method/event with arguments
// @types an array of string type names
// @args  an array of the appropriate values


ABI.rawEncode = function (types, values) {
  var output = [];
  var data = [];
  var headLength = 0;
  types.forEach(function (type) {
    if (isArray(type)) {
      var size = parseTypeArray(type);

      if (size !== 'dynamic') {
        headLength += 32 * size;
      } else {
        headLength += 32;
      }
    } else {
      headLength += 32;
    }
  });

  for (var i = 0; i < types.length; i++) {
    var type = elementaryName(types[i]);
    var value = values[i];
    var cur = encodeSingle(type, value); // Use the head/tail method for storing dynamic data

    if (isDynamic(type)) {
      output.push(encodeSingle('uint256', headLength));
      data.push(cur);
      headLength += cur.length;
    } else {
      output.push(cur);
    }
  }

  return Buffer$6.concat(output.concat(data));
};

ABI.rawDecode = function (types, data) {
  var ret = [];
  data = Buffer$6.from(data);
  var offset = 0;

  for (var i = 0; i < types.length; i++) {
    var type = elementaryName(types[i]);
    var parsed = parseType(type);
    var decoded = decodeSingle(parsed, data, offset);
    offset += parsed.memoryUsage;
    ret.push(decoded);
  }

  return ret;
};

ABI.simpleEncode = function (method) {
  var args = Array.prototype.slice.call(arguments).slice(1);
  var sig = parseSignature(method); // FIXME: validate/convert arguments

  if (args.length !== sig.args.length) {
    throw new Error('Argument count mismatch');
  }

  return Buffer$6.concat([ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args)]);
};

ABI.simpleDecode = function (method, data) {
  var sig = parseSignature(method); // FIXME: validate/convert arguments

  if (!sig.retargs) {
    throw new Error('No return values in method');
  }

  return ABI.rawDecode(sig.retargs, data);
};

function stringify(type, value) {
  if (type.startsWith('address') || type.startsWith('bytes')) {
    return '0x' + value.toString('hex');
  } else {
    return value.toString();
  }
}

ABI.stringify = function (types, values) {
  var ret = [];

  for (var i in types) {
    var type = types[i];
    var value = values[i]; // if it is an array type, concat the items

    if (/^[^\[]+\[.*\]$/.test(type)) {
      value = value.map(function (item) {
        return stringify(type, item);
      }).join(', ');
    } else {
      value = stringify(type, value);
    }

    ret.push(value);
  }

  return ret;
};

ABI.solidityHexValue = function (type, value, bitsize) {
  // pass in bitsize = null if use default bitsize
  var size, num;

  if (isArray(type)) {
    var subType = type.replace(/\[.*?\]/, '');

    if (!isArray(subType)) {
      var arraySize = parseTypeArray(type);

      if (arraySize !== 'dynamic' && arraySize !== 0 && value.length > arraySize) {
        throw new Error('Elements exceed array size: ' + arraySize);
      }
    }

    var arrayValues = value.map(function (v) {
      return ABI.solidityHexValue(subType, v, 256);
    });
    return Buffer$6.concat(arrayValues);
  } else if (type === 'bytes') {
    return value;
  } else if (type === 'string') {
    return Buffer$6.from(value, 'utf8');
  } else if (type === 'bool') {
    bitsize = bitsize || 8;
    var padding = Array(bitsize / 4).join('0');
    return Buffer$6.from(value ? padding + '1' : padding + '0', 'hex');
  } else if (type === 'address') {
    var bytesize = 20;

    if (bitsize) {
      bytesize = bitsize / 8;
    }

    return utils.setLengthLeft(value, bytesize);
  } else if (type.startsWith('bytes')) {
    size = parseTypeN(type);

    if (size < 1 || size > 32) {
      throw new Error('Invalid bytes<N> width: ' + size);
    }

    return utils.setLengthRight(value, size);
  } else if (type.startsWith('uint')) {
    size = parseTypeN(type);

    if (size % 8 || size < 8 || size > 256) {
      throw new Error('Invalid uint<N> width: ' + size);
    }

    num = parseNumber(value);

    if (num.bitLength() > size) {
      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());
    }

    bitsize = bitsize || size;
    return num.toArrayLike(Buffer$6, 'be', bitsize / 8);
  } else if (type.startsWith('int')) {
    size = parseTypeN(type);

    if (size % 8 || size < 8 || size > 256) {
      throw new Error('Invalid int<N> width: ' + size);
    }

    num = parseNumber(value);

    if (num.bitLength() > size) {
      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());
    }

    bitsize = bitsize || size;
    return num.toTwos(size).toArrayLike(Buffer$6, 'be', bitsize / 8);
  } else {
    // FIXME: support all other types
    throw new Error('Unsupported or invalid type: ' + type);
  }
};

ABI.solidityPack = function (types, values) {
  if (types.length !== values.length) {
    throw new Error('Number of types are not matching the values');
  }

  var ret = [];

  for (var i = 0; i < types.length; i++) {
    var type = elementaryName(types[i]);
    var value = values[i];
    ret.push(ABI.solidityHexValue(type, value, null));
  }

  return Buffer$6.concat(ret);
};

ABI.soliditySHA3 = function (types, values) {
  return utils.keccak256(ABI.solidityPack(types, values));
};

ABI.soliditySHA256 = function (types, values) {
  return utils.sha256(ABI.solidityPack(types, values));
};

ABI.solidityRIPEMD160 = function (types, values) {
  return utils.ripemd160(ABI.solidityPack(types, values), true);
}; // Serpent's users are familiar with this encoding
// - s: string
// - b: bytes
// - b<N>: bytes<N>
// - i: int256
// - a: int256[]


function isNumeric(c) {
  // FIXME: is this correct? Seems to work
  return c >= '0' && c <= '9';
} // For a "documentation" refer to https://github.com/ethereum/serpent/blob/develop/preprocess.cpp


ABI.fromSerpent = function (sig) {
  var ret = [];

  for (var i = 0; i < sig.length; i++) {
    var type = sig[i];

    if (type === 's') {
      ret.push('bytes');
    } else if (type === 'b') {
      var tmp = 'bytes';
      var j = i + 1;

      while (j < sig.length && isNumeric(sig[j])) {
        tmp += sig[j] - '0';
        j++;
      }

      i = j - 1;
      ret.push(tmp);
    } else if (type === 'i') {
      ret.push('int256');
    } else if (type === 'a') {
      ret.push('int256[]');
    } else {
      throw new Error('Unsupported or invalid type: ' + type);
    }
  }

  return ret;
};

ABI.toSerpent = function (types) {
  var ret = [];

  for (var i = 0; i < types.length; i++) {
    var type = types[i];

    if (type === 'bytes') {
      ret.push('s');
    } else if (type.startsWith('bytes')) {
      ret.push('b' + parseTypeN(type));
    } else if (type === 'int256') {
      ret.push('i');
    } else if (type === 'int256[]') {
      ret.push('a');
    } else {
      throw new Error('Unsupported or invalid type: ' + type);
    }
  }

  return ret.join('');
};

var lib = ABI;

var ethereumjsAbi = lib;

var naclFast = {exports: {}};

(function (module) {
  (function (nacl) {
    // Public domain.
    //
    // Implementation derived from TweetNaCl version 20140427.
    // See for details: http://tweetnacl.cr.yp.to/

    var gf = function gf(init) {
      var i,
          r = new Float64Array(16);
      if (init) for (i = 0; i < init.length; i++) {
        r[i] = init[i];
      }
      return r;
    }; //  Pluggable, initialized in high-level API below.


    var randombytes = function
      /* x, n */
    randombytes() {
      throw new Error('no PRNG');
    };

    var _0 = new Uint8Array(16);

    var _9 = new Uint8Array(32);

    _9[0] = 9;

    var gf0 = gf(),
        gf1 = gf([1]),
        _121665 = gf([0xdb41, 1]),
        D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
        D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
        X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
        Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
        I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

    function ts64(x, i, h, l) {
      x[i] = h >> 24 & 0xff;
      x[i + 1] = h >> 16 & 0xff;
      x[i + 2] = h >> 8 & 0xff;
      x[i + 3] = h & 0xff;
      x[i + 4] = l >> 24 & 0xff;
      x[i + 5] = l >> 16 & 0xff;
      x[i + 6] = l >> 8 & 0xff;
      x[i + 7] = l & 0xff;
    }

    function vn(x, xi, y, yi, n) {
      var i,
          d = 0;

      for (i = 0; i < n; i++) {
        d |= x[xi + i] ^ y[yi + i];
      }

      return (1 & d - 1 >>> 8) - 1;
    }

    function crypto_verify_16(x, xi, y, yi) {
      return vn(x, xi, y, yi, 16);
    }

    function crypto_verify_32(x, xi, y, yi) {
      return vn(x, xi, y, yi, 32);
    }

    function core_salsa20(o, p, k, c) {
      var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24,
          j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24,
          j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24,
          j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24,
          j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24,
          j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24,
          j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24,
          j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24,
          j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24,
          j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24,
          j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24,
          j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24,
          j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24,
          j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24,
          j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24,
          j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;
      var x0 = j0,
          x1 = j1,
          x2 = j2,
          x3 = j3,
          x4 = j4,
          x5 = j5,
          x6 = j6,
          x7 = j7,
          x8 = j8,
          x9 = j9,
          x10 = j10,
          x11 = j11,
          x12 = j12,
          x13 = j13,
          x14 = j14,
          x15 = j15,
          u;

      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }

      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x0 >>> 0 & 0xff;
      o[1] = x0 >>> 8 & 0xff;
      o[2] = x0 >>> 16 & 0xff;
      o[3] = x0 >>> 24 & 0xff;
      o[4] = x1 >>> 0 & 0xff;
      o[5] = x1 >>> 8 & 0xff;
      o[6] = x1 >>> 16 & 0xff;
      o[7] = x1 >>> 24 & 0xff;
      o[8] = x2 >>> 0 & 0xff;
      o[9] = x2 >>> 8 & 0xff;
      o[10] = x2 >>> 16 & 0xff;
      o[11] = x2 >>> 24 & 0xff;
      o[12] = x3 >>> 0 & 0xff;
      o[13] = x3 >>> 8 & 0xff;
      o[14] = x3 >>> 16 & 0xff;
      o[15] = x3 >>> 24 & 0xff;
      o[16] = x4 >>> 0 & 0xff;
      o[17] = x4 >>> 8 & 0xff;
      o[18] = x4 >>> 16 & 0xff;
      o[19] = x4 >>> 24 & 0xff;
      o[20] = x5 >>> 0 & 0xff;
      o[21] = x5 >>> 8 & 0xff;
      o[22] = x5 >>> 16 & 0xff;
      o[23] = x5 >>> 24 & 0xff;
      o[24] = x6 >>> 0 & 0xff;
      o[25] = x6 >>> 8 & 0xff;
      o[26] = x6 >>> 16 & 0xff;
      o[27] = x6 >>> 24 & 0xff;
      o[28] = x7 >>> 0 & 0xff;
      o[29] = x7 >>> 8 & 0xff;
      o[30] = x7 >>> 16 & 0xff;
      o[31] = x7 >>> 24 & 0xff;
      o[32] = x8 >>> 0 & 0xff;
      o[33] = x8 >>> 8 & 0xff;
      o[34] = x8 >>> 16 & 0xff;
      o[35] = x8 >>> 24 & 0xff;
      o[36] = x9 >>> 0 & 0xff;
      o[37] = x9 >>> 8 & 0xff;
      o[38] = x9 >>> 16 & 0xff;
      o[39] = x9 >>> 24 & 0xff;
      o[40] = x10 >>> 0 & 0xff;
      o[41] = x10 >>> 8 & 0xff;
      o[42] = x10 >>> 16 & 0xff;
      o[43] = x10 >>> 24 & 0xff;
      o[44] = x11 >>> 0 & 0xff;
      o[45] = x11 >>> 8 & 0xff;
      o[46] = x11 >>> 16 & 0xff;
      o[47] = x11 >>> 24 & 0xff;
      o[48] = x12 >>> 0 & 0xff;
      o[49] = x12 >>> 8 & 0xff;
      o[50] = x12 >>> 16 & 0xff;
      o[51] = x12 >>> 24 & 0xff;
      o[52] = x13 >>> 0 & 0xff;
      o[53] = x13 >>> 8 & 0xff;
      o[54] = x13 >>> 16 & 0xff;
      o[55] = x13 >>> 24 & 0xff;
      o[56] = x14 >>> 0 & 0xff;
      o[57] = x14 >>> 8 & 0xff;
      o[58] = x14 >>> 16 & 0xff;
      o[59] = x14 >>> 24 & 0xff;
      o[60] = x15 >>> 0 & 0xff;
      o[61] = x15 >>> 8 & 0xff;
      o[62] = x15 >>> 16 & 0xff;
      o[63] = x15 >>> 24 & 0xff;
    }

    function core_hsalsa20(o, p, k, c) {
      var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24,
          j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24,
          j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24,
          j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24,
          j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24,
          j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24,
          j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24,
          j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24,
          j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24,
          j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24,
          j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24,
          j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24,
          j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24,
          j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24,
          j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24,
          j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;
      var x0 = j0,
          x1 = j1,
          x2 = j2,
          x3 = j3,
          x4 = j4,
          x5 = j5,
          x6 = j6,
          x7 = j7,
          x8 = j8,
          x9 = j9,
          x10 = j10,
          x11 = j11,
          x12 = j12,
          x13 = j13,
          x14 = j14,
          x15 = j15,
          u;

      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }

      o[0] = x0 >>> 0 & 0xff;
      o[1] = x0 >>> 8 & 0xff;
      o[2] = x0 >>> 16 & 0xff;
      o[3] = x0 >>> 24 & 0xff;
      o[4] = x5 >>> 0 & 0xff;
      o[5] = x5 >>> 8 & 0xff;
      o[6] = x5 >>> 16 & 0xff;
      o[7] = x5 >>> 24 & 0xff;
      o[8] = x10 >>> 0 & 0xff;
      o[9] = x10 >>> 8 & 0xff;
      o[10] = x10 >>> 16 & 0xff;
      o[11] = x10 >>> 24 & 0xff;
      o[12] = x15 >>> 0 & 0xff;
      o[13] = x15 >>> 8 & 0xff;
      o[14] = x15 >>> 16 & 0xff;
      o[15] = x15 >>> 24 & 0xff;
      o[16] = x6 >>> 0 & 0xff;
      o[17] = x6 >>> 8 & 0xff;
      o[18] = x6 >>> 16 & 0xff;
      o[19] = x6 >>> 24 & 0xff;
      o[20] = x7 >>> 0 & 0xff;
      o[21] = x7 >>> 8 & 0xff;
      o[22] = x7 >>> 16 & 0xff;
      o[23] = x7 >>> 24 & 0xff;
      o[24] = x8 >>> 0 & 0xff;
      o[25] = x8 >>> 8 & 0xff;
      o[26] = x8 >>> 16 & 0xff;
      o[27] = x8 >>> 24 & 0xff;
      o[28] = x9 >>> 0 & 0xff;
      o[29] = x9 >>> 8 & 0xff;
      o[30] = x9 >>> 16 & 0xff;
      o[31] = x9 >>> 24 & 0xff;
    }

    function crypto_core_salsa20(out, inp, k, c) {
      core_salsa20(out, inp, k, c);
    }

    function crypto_core_hsalsa20(out, inp, k, c) {
      core_hsalsa20(out, inp, k, c);
    }

    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]); // "expand 32-byte k"

    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
      var z = new Uint8Array(16),
          x = new Uint8Array(64);
      var u, i;

      for (i = 0; i < 16; i++) {
        z[i] = 0;
      }

      for (i = 0; i < 8; i++) {
        z[i] = n[i];
      }

      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);

        for (i = 0; i < 64; i++) {
          c[cpos + i] = m[mpos + i] ^ x[i];
        }

        u = 1;

        for (i = 8; i < 16; i++) {
          u = u + (z[i] & 0xff) | 0;
          z[i] = u & 0xff;
          u >>>= 8;
        }

        b -= 64;
        cpos += 64;
        mpos += 64;
      }

      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);

        for (i = 0; i < b; i++) {
          c[cpos + i] = m[mpos + i] ^ x[i];
        }
      }

      return 0;
    }

    function crypto_stream_salsa20(c, cpos, b, n, k) {
      var z = new Uint8Array(16),
          x = new Uint8Array(64);
      var u, i;

      for (i = 0; i < 16; i++) {
        z[i] = 0;
      }

      for (i = 0; i < 8; i++) {
        z[i] = n[i];
      }

      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);

        for (i = 0; i < 64; i++) {
          c[cpos + i] = x[i];
        }

        u = 1;

        for (i = 8; i < 16; i++) {
          u = u + (z[i] & 0xff) | 0;
          z[i] = u & 0xff;
          u >>>= 8;
        }

        b -= 64;
        cpos += 64;
      }

      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);

        for (i = 0; i < b; i++) {
          c[cpos + i] = x[i];
        }
      }

      return 0;
    }

    function crypto_stream(c, cpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);

      for (var i = 0; i < 8; i++) {
        sn[i] = n[i + 16];
      }

      return crypto_stream_salsa20(c, cpos, d, sn, s);
    }

    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);

      for (var i = 0; i < 8; i++) {
        sn[i] = n[i + 16];
      }

      return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
    }
    /*
    * Port of Andrew Moon's Poly1305-donna-16. Public domain.
    * https://github.com/floodyberry/poly1305-donna
    */


    var poly1305 = function poly1305(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = key[0] & 0xff | (key[1] & 0xff) << 8;
      this.r[0] = t0 & 0x1fff;
      t1 = key[2] & 0xff | (key[3] & 0xff) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;
      t2 = key[4] & 0xff | (key[5] & 0xff) << 8;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;
      t3 = key[6] & 0xff | (key[7] & 0xff) << 8;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;
      t4 = key[8] & 0xff | (key[9] & 0xff) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;
      this.r[5] = t4 >>> 1 & 0x1ffe;
      t5 = key[10] & 0xff | (key[11] & 0xff) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;
      t6 = key[12] & 0xff | (key[13] & 0xff) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;
      t7 = key[14] & 0xff | (key[15] & 0xff) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;
      this.r[9] = t7 >>> 5 & 0x007f;
      this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
      this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
      this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
      this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
      this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
      this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
      this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
      this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
    };

    poly1305.prototype.blocks = function (m, mpos, bytes) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t2, t3, t4, t5, t6, t7, c;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0],
          h1 = this.h[1],
          h2 = this.h[2],
          h3 = this.h[3],
          h4 = this.h[4],
          h5 = this.h[5],
          h6 = this.h[6],
          h7 = this.h[7],
          h8 = this.h[8],
          h9 = this.h[9];
      var r0 = this.r[0],
          r1 = this.r[1],
          r2 = this.r[2],
          r3 = this.r[3],
          r4 = this.r[4],
          r5 = this.r[5],
          r6 = this.r[6],
          r7 = this.r[7],
          r8 = this.r[8],
          r9 = this.r[9];

      while (bytes >= 16) {
        t0 = m[mpos + 0] & 0xff | (m[mpos + 1] & 0xff) << 8;
        h0 += t0 & 0x1fff;
        t1 = m[mpos + 2] & 0xff | (m[mpos + 3] & 0xff) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 0x1fff;
        t2 = m[mpos + 4] & 0xff | (m[mpos + 5] & 0xff) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 0x1fff;
        t3 = m[mpos + 6] & 0xff | (m[mpos + 7] & 0xff) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 0x1fff;
        t4 = m[mpos + 8] & 0xff | (m[mpos + 9] & 0xff) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 0x1fff;
        h5 += t4 >>> 1 & 0x1fff;
        t5 = m[mpos + 10] & 0xff | (m[mpos + 11] & 0xff) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 0x1fff;
        t6 = m[mpos + 12] & 0xff | (m[mpos + 13] & 0xff) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 0x1fff;
        t7 = m[mpos + 14] & 0xff | (m[mpos + 15] & 0xff) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 0x1fff;
        h9 += t7 >>> 5 | hibit;
        c = 0;
        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 0x1fff;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 0x1fff;
        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 0x1fff;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 0x1fff;
        d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 0x1fff;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 0x1fff;
        d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 0x1fff;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 0x1fff;
        d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = d4 >>> 13;
        d4 &= 0x1fff;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 0x1fff;
        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = d5 >>> 13;
        d5 &= 0x1fff;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 0x1fff;
        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = d6 >>> 13;
        d6 &= 0x1fff;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 0x1fff;
        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = d7 >>> 13;
        d7 &= 0x1fff;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 0x1fff;
        d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = d8 >>> 13;
        d8 &= 0x1fff;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 0x1fff;
        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = d9 >>> 13;
        d9 &= 0x1fff;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += d9 >>> 13;
        d9 &= 0x1fff;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 0x1fff;
        c = c >>> 13;
        d1 += c;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }

      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };

    poly1305.prototype.finish = function (mac, macpos) {
      var g = new Uint16Array(10);
      var c, mask, f, i;

      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;

        for (; i < 16; i++) {
          this.buffer[i] = 0;
        }

        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }

      c = this.h[1] >>> 13;
      this.h[1] &= 0x1fff;

      for (i = 2; i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 0x1fff;
      }

      this.h[0] += c * 5;
      c = this.h[0] >>> 13;
      this.h[0] &= 0x1fff;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 0x1fff;
      this.h[2] += c;
      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 0x1fff;

      for (i = 1; i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 0x1fff;
      }

      g[9] -= 1 << 13;
      mask = (c ^ 1) - 1;

      for (i = 0; i < 10; i++) {
        g[i] &= mask;
      }

      mask = ~mask;

      for (i = 0; i < 10; i++) {
        this.h[i] = this.h[i] & mask | g[i];
      }

      this.h[0] = (this.h[0] | this.h[1] << 13) & 0xffff;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 0xffff;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 0xffff;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 0xffff;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 0xffff;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 0xffff;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 0xffff;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 0xffff;
      f = this.h[0] + this.pad[0];
      this.h[0] = f & 0xffff;

      for (i = 1; i < 8; i++) {
        f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
        this.h[i] = f & 0xffff;
      }

      mac[macpos + 0] = this.h[0] >>> 0 & 0xff;
      mac[macpos + 1] = this.h[0] >>> 8 & 0xff;
      mac[macpos + 2] = this.h[1] >>> 0 & 0xff;
      mac[macpos + 3] = this.h[1] >>> 8 & 0xff;
      mac[macpos + 4] = this.h[2] >>> 0 & 0xff;
      mac[macpos + 5] = this.h[2] >>> 8 & 0xff;
      mac[macpos + 6] = this.h[3] >>> 0 & 0xff;
      mac[macpos + 7] = this.h[3] >>> 8 & 0xff;
      mac[macpos + 8] = this.h[4] >>> 0 & 0xff;
      mac[macpos + 9] = this.h[4] >>> 8 & 0xff;
      mac[macpos + 10] = this.h[5] >>> 0 & 0xff;
      mac[macpos + 11] = this.h[5] >>> 8 & 0xff;
      mac[macpos + 12] = this.h[6] >>> 0 & 0xff;
      mac[macpos + 13] = this.h[6] >>> 8 & 0xff;
      mac[macpos + 14] = this.h[7] >>> 0 & 0xff;
      mac[macpos + 15] = this.h[7] >>> 8 & 0xff;
    };

    poly1305.prototype.update = function (m, mpos, bytes) {
      var i, want;

      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes) want = bytes;

        for (i = 0; i < want; i++) {
          this.buffer[this.leftover + i] = m[mpos + i];
        }

        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16) return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }

      if (bytes >= 16) {
        want = bytes - bytes % 16;
        this.blocks(m, mpos, want);
        mpos += want;
        bytes -= want;
      }

      if (bytes) {
        for (i = 0; i < bytes; i++) {
          this.buffer[this.leftover + i] = m[mpos + i];
        }

        this.leftover += bytes;
      }
    };

    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
      var s = new poly1305(k);
      s.update(m, mpos, n);
      s.finish(out, outpos);
      return 0;
    }

    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x, 0, m, mpos, n, k);
      return crypto_verify_16(h, hpos, x, 0);
    }

    function crypto_secretbox(c, m, d, n, k) {
      var i;
      if (d < 32) return -1;
      crypto_stream_xor(c, 0, m, 0, d, n, k);
      crypto_onetimeauth(c, 16, c, 32, d - 32, c);

      for (i = 0; i < 16; i++) {
        c[i] = 0;
      }

      return 0;
    }

    function crypto_secretbox_open(m, c, d, n, k) {
      var i;
      var x = new Uint8Array(32);
      if (d < 32) return -1;
      crypto_stream(x, 0, 32, n, k);
      if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
      crypto_stream_xor(m, 0, c, 0, d, n, k);

      for (i = 0; i < 32; i++) {
        m[i] = 0;
      }

      return 0;
    }

    function set25519(r, a) {
      var i;

      for (i = 0; i < 16; i++) {
        r[i] = a[i] | 0;
      }
    }

    function car25519(o) {
      var i,
          v,
          c = 1;

      for (i = 0; i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }

      o[0] += c - 1 + 37 * (c - 1);
    }

    function sel25519(p, q, b) {
      var t,
          c = ~(b - 1);

      for (var i = 0; i < 16; i++) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }

    function pack25519(o, n) {
      var i, j, b;
      var m = gf(),
          t = gf();

      for (i = 0; i < 16; i++) {
        t[i] = n[i];
      }

      car25519(t);
      car25519(t);
      car25519(t);

      for (j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;

        for (i = 1; i < 15; i++) {
          m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 0xffff;
        }

        m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1 - b);
      }

      for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
      }
    }

    function neq25519(a, b) {
      var c = new Uint8Array(32),
          d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }

    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }

    function unpack25519(o, n) {
      var i;

      for (i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      }

      o[15] &= 0x7fff;
    }

    function A(o, a, b) {
      for (var i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
      }
    }

    function Z(o, a, b) {
      for (var i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
      }
    }

    function M(o, a, b) {
      var v,
          c,
          t0 = 0,
          t1 = 0,
          t2 = 0,
          t3 = 0,
          t4 = 0,
          t5 = 0,
          t6 = 0,
          t7 = 0,
          t8 = 0,
          t9 = 0,
          t10 = 0,
          t11 = 0,
          t12 = 0,
          t13 = 0,
          t14 = 0,
          t15 = 0,
          t16 = 0,
          t17 = 0,
          t18 = 0,
          t19 = 0,
          t20 = 0,
          t21 = 0,
          t22 = 0,
          t23 = 0,
          t24 = 0,
          t25 = 0,
          t26 = 0,
          t27 = 0,
          t28 = 0,
          t29 = 0,
          t30 = 0,
          b0 = b[0],
          b1 = b[1],
          b2 = b[2],
          b3 = b[3],
          b4 = b[4],
          b5 = b[5],
          b6 = b[6],
          b7 = b[7],
          b8 = b[8],
          b9 = b[9],
          b10 = b[10],
          b11 = b[11],
          b12 = b[12],
          b13 = b[13],
          b14 = b[14],
          b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30; // t15 left as is
      // first car

      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1); // second car

      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }

    function S(o, a) {
      M(o, a, a);
    }

    function inv25519(o, i) {
      var c = gf();
      var a;

      for (a = 0; a < 16; a++) {
        c[a] = i[a];
      }

      for (a = 253; a >= 0; a--) {
        S(c, c);
        if (a !== 2 && a !== 4) M(c, c, i);
      }

      for (a = 0; a < 16; a++) {
        o[a] = c[a];
      }
    }

    function pow2523(o, i) {
      var c = gf();
      var a;

      for (a = 0; a < 16; a++) {
        c[a] = i[a];
      }

      for (a = 250; a >= 0; a--) {
        S(c, c);
        if (a !== 1) M(c, c, i);
      }

      for (a = 0; a < 16; a++) {
        o[a] = c[a];
      }
    }

    function crypto_scalarmult(q, n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80),
          r,
          i;
      var a = gf(),
          b = gf(),
          c = gf(),
          d = gf(),
          e = gf(),
          f = gf();

      for (i = 0; i < 31; i++) {
        z[i] = n[i];
      }

      z[31] = n[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p);

      for (i = 0; i < 16; i++) {
        b[i] = x[i];
        d[i] = a[i] = c[i] = 0;
      }

      a[0] = d[0] = 1;

      for (i = 254; i >= 0; --i) {
        r = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        A(e, a, c);
        Z(a, a, c);
        A(c, b, d);
        Z(b, b, d);
        S(d, e);
        S(f, a);
        M(a, c, a);
        M(c, b, e);
        A(e, a, c);
        Z(a, a, c);
        S(b, a);
        Z(c, d, f);
        M(a, c, _121665);
        A(a, a, d);
        M(c, c, a);
        M(a, d, f);
        M(d, b, x);
        S(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }

      for (i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
      }

      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      M(x16, x16, x32);
      pack25519(q, x16);
      return 0;
    }

    function crypto_scalarmult_base(q, n) {
      return crypto_scalarmult(q, n, _9);
    }

    function crypto_box_keypair(y, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y, x);
    }

    function crypto_box_beforenm(k, y, x) {
      var s = new Uint8Array(32);
      crypto_scalarmult(s, x, y);
      return crypto_core_hsalsa20(k, _0, s, sigma);
    }

    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;

    function crypto_box(c, m, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_afternm(c, m, d, n, k);
    }

    function crypto_box_open(m, c, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_open_afternm(m, c, d, n, k);
    }

    var K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];

    function crypto_hashblocks_hl(hh, hl, m, n) {
      var wh = new Int32Array(16),
          wl = new Int32Array(16),
          bh0,
          bh1,
          bh2,
          bh3,
          bh4,
          bh5,
          bh6,
          bh7,
          bl0,
          bl1,
          bl2,
          bl3,
          bl4,
          bl5,
          bl6,
          bl7,
          th,
          tl,
          i,
          j,
          h,
          l,
          a,
          b,
          c,
          d;
      var ah0 = hh[0],
          ah1 = hh[1],
          ah2 = hh[2],
          ah3 = hh[3],
          ah4 = hh[4],
          ah5 = hh[5],
          ah6 = hh[6],
          ah7 = hh[7],
          al0 = hl[0],
          al1 = hl[1],
          al2 = hl[2],
          al3 = hl[3],
          al4 = hl[4],
          al5 = hl[5],
          al6 = hl[6],
          al7 = hl[7];
      var pos = 0;

      while (n >= 128) {
        for (i = 0; i < 16; i++) {
          j = 8 * i + pos;
          wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
          wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
        }

        for (i = 0; i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7; // add

          h = ah7;
          l = al7;
          a = l & 0xffff;
          b = l >>> 16;
          c = h & 0xffff;
          d = h >>> 16; // Sigma1

          h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16; // Ch

          h = ah4 & ah5 ^ ~ah4 & ah6;
          l = al4 & al5 ^ ~al4 & al6;
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16; // K

          h = K[i * 2];
          l = K[i * 2 + 1];
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16; // w

          h = wh[i % 16];
          l = wl[i % 16];
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          th = c & 0xffff | d << 16;
          tl = a & 0xffff | b << 16; // add

          h = th;
          l = tl;
          a = l & 0xffff;
          b = l >>> 16;
          c = h & 0xffff;
          d = h >>> 16; // Sigma0

          h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16; // Maj

          h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh7 = c & 0xffff | d << 16;
          bl7 = a & 0xffff | b << 16; // add

          h = bh3;
          l = bl3;
          a = l & 0xffff;
          b = l >>> 16;
          c = h & 0xffff;
          d = h >>> 16;
          h = th;
          l = tl;
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh3 = c & 0xffff | d << 16;
          bl3 = a & 0xffff | b << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;

          if (i % 16 === 15) {
            for (j = 0; j < 16; j++) {
              // add
              h = wh[j];
              l = wl[j];
              a = l & 0xffff;
              b = l >>> 16;
              c = h & 0xffff;
              d = h >>> 16;
              h = wh[(j + 9) % 16];
              l = wl[(j + 9) % 16];
              a += l & 0xffff;
              b += l >>> 16;
              c += h & 0xffff;
              d += h >>> 16; // sigma0

              th = wh[(j + 1) % 16];
              tl = wl[(j + 1) % 16];
              h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a += l & 0xffff;
              b += l >>> 16;
              c += h & 0xffff;
              d += h >>> 16; // sigma1

              th = wh[(j + 14) % 16];
              tl = wl[(j + 14) % 16];
              h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a += l & 0xffff;
              b += l >>> 16;
              c += h & 0xffff;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              wh[j] = c & 0xffff | d << 16;
              wl[j] = a & 0xffff | b << 16;
            }
          }
        } // add


        h = ah0;
        l = al0;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = c & 0xffff | d << 16;
        hl[0] = al0 = a & 0xffff | b << 16;
        h = ah1;
        l = al1;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = c & 0xffff | d << 16;
        hl[1] = al1 = a & 0xffff | b << 16;
        h = ah2;
        l = al2;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = c & 0xffff | d << 16;
        hl[2] = al2 = a & 0xffff | b << 16;
        h = ah3;
        l = al3;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = c & 0xffff | d << 16;
        hl[3] = al3 = a & 0xffff | b << 16;
        h = ah4;
        l = al4;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = c & 0xffff | d << 16;
        hl[4] = al4 = a & 0xffff | b << 16;
        h = ah5;
        l = al5;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = c & 0xffff | d << 16;
        hl[5] = al5 = a & 0xffff | b << 16;
        h = ah6;
        l = al6;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = c & 0xffff | d << 16;
        hl[6] = al6 = a & 0xffff | b << 16;
        h = ah7;
        l = al7;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = c & 0xffff | d << 16;
        hl[7] = al7 = a & 0xffff | b << 16;
        pos += 128;
        n -= 128;
      }

      return n;
    }

    function crypto_hash(out, m, n) {
      var hh = new Int32Array(8),
          hl = new Int32Array(8),
          x = new Uint8Array(256),
          i,
          b = n;
      hh[0] = 0x6a09e667;
      hh[1] = 0xbb67ae85;
      hh[2] = 0x3c6ef372;
      hh[3] = 0xa54ff53a;
      hh[4] = 0x510e527f;
      hh[5] = 0x9b05688c;
      hh[6] = 0x1f83d9ab;
      hh[7] = 0x5be0cd19;
      hl[0] = 0xf3bcc908;
      hl[1] = 0x84caa73b;
      hl[2] = 0xfe94f82b;
      hl[3] = 0x5f1d36f1;
      hl[4] = 0xade682d1;
      hl[5] = 0x2b3e6c1f;
      hl[6] = 0xfb41bd6b;
      hl[7] = 0x137e2179;
      crypto_hashblocks_hl(hh, hl, m, n);
      n %= 128;

      for (i = 0; i < n; i++) {
        x[i] = m[b - n + i];
      }

      x[n] = 128;
      n = 256 - 128 * (n < 112 ? 1 : 0);
      x[n - 9] = 0;
      ts64(x, n - 8, b / 0x20000000 | 0, b << 3);
      crypto_hashblocks_hl(hh, hl, x, n);

      for (i = 0; i < 8; i++) {
        ts64(out, 8 * i, hh[i], hl[i]);
      }

      return 0;
    }

    function add(p, q) {
      var a = gf(),
          b = gf(),
          c = gf(),
          d = gf(),
          e = gf(),
          f = gf(),
          g = gf(),
          h = gf(),
          t = gf();
      Z(a, p[1], p[0]);
      Z(t, q[1], q[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q[0], q[1]);
      M(b, b, t);
      M(c, p[3], q[3]);
      M(c, c, D2);
      M(d, p[2], q[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e, h);
    }

    function cswap(p, q, b) {
      var i;

      for (i = 0; i < 4; i++) {
        sel25519(p[i], q[i], b);
      }
    }

    function pack(r, p) {
      var tx = gf(),
          ty = gf(),
          zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }

    function scalarmult(p, q, s) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);

      for (i = 255; i >= 0; --i) {
        b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        add(q, p);
        add(p, p);
        cswap(p, q, b);
      }
    }

    function scalarbase(p, s) {
      var q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p, q, s);
    }

    function crypto_sign_keypair(pk, sk, seeded) {
      var d = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var i;
      if (!seeded) randombytes(sk, 32);
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack(pk, p);

      for (i = 0; i < 32; i++) {
        sk[i + 32] = pk[i];
      }

      return 0;
    }

    var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

    function modL(r, x) {
      var carry, i, j, k;

      for (i = 63; i >= 32; --i) {
        carry = 0;

        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = Math.floor((x[j] + 128) / 256);
          x[j] -= carry * 256;
        }

        x[j] += carry;
        x[i] = 0;
      }

      carry = 0;

      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }

      for (j = 0; j < 32; j++) {
        x[j] -= carry * L[j];
      }

      for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }

    function reduce(r) {
      var x = new Float64Array(64),
          i;

      for (i = 0; i < 64; i++) {
        x[i] = r[i];
      }

      for (i = 0; i < 64; i++) {
        r[i] = 0;
      }

      modL(r, x);
    } // Note: difference from C - smlen returned, not passed as argument.


    function crypto_sign(sm, m, n, sk) {
      var d = new Uint8Array(64),
          h = new Uint8Array(64),
          r = new Uint8Array(64);
      var i,
          j,
          x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;

      for (i = 0; i < n; i++) {
        sm[64 + i] = m[i];
      }

      for (i = 0; i < 32; i++) {
        sm[32 + i] = d[32 + i];
      }

      crypto_hash(r, sm.subarray(32), n + 32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);

      for (i = 32; i < 64; i++) {
        sm[i] = sk[i];
      }

      crypto_hash(h, sm, n + 64);
      reduce(h);

      for (i = 0; i < 64; i++) {
        x[i] = 0;
      }

      for (i = 0; i < 32; i++) {
        x[i] = r[i];
      }

      for (i = 0; i < 32; i++) {
        for (j = 0; j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }

      modL(sm.subarray(32), x);
      return smlen;
    }

    function unpackneg(r, p) {
      var t = gf(),
          chk = gf(),
          num = gf(),
          den = gf(),
          den2 = gf(),
          den4 = gf(),
          den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D);
      Z(num, num, r[2]);
      A(den, r[2], den);
      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) M(r[0], r[0], I);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) return -1;
      if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
      M(r[3], r[0], r[1]);
      return 0;
    }

    function crypto_sign_open(m, sm, n, pk) {
      var i;
      var t = new Uint8Array(32),
          h = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()],
          q = [gf(), gf(), gf(), gf()];
      if (n < 64) return -1;
      if (unpackneg(q, pk)) return -1;

      for (i = 0; i < n; i++) {
        m[i] = sm[i];
      }

      for (i = 0; i < 32; i++) {
        m[i + 32] = pk[i];
      }

      crypto_hash(h, m, n);
      reduce(h);
      scalarmult(p, q, h);
      scalarbase(q, sm.subarray(32));
      add(p, q);
      pack(t, p);
      n -= 64;

      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0; i < n; i++) {
          m[i] = 0;
        }

        return -1;
      }

      for (i = 0; i < n; i++) {
        m[i] = sm[i + 64];
      }

      return n;
    }

    var crypto_secretbox_KEYBYTES = 32,
        crypto_secretbox_NONCEBYTES = 24,
        crypto_secretbox_ZEROBYTES = 32,
        crypto_secretbox_BOXZEROBYTES = 16,
        crypto_scalarmult_BYTES = 32,
        crypto_scalarmult_SCALARBYTES = 32,
        crypto_box_PUBLICKEYBYTES = 32,
        crypto_box_SECRETKEYBYTES = 32,
        crypto_box_BEFORENMBYTES = 32,
        crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
        crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
        crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
        crypto_sign_BYTES = 64,
        crypto_sign_PUBLICKEYBYTES = 32,
        crypto_sign_SECRETKEYBYTES = 64,
        crypto_sign_SEEDBYTES = 32,
        crypto_hash_BYTES = 64;
    nacl.lowlevel = {
      crypto_core_hsalsa20: crypto_core_hsalsa20,
      crypto_stream_xor: crypto_stream_xor,
      crypto_stream: crypto_stream,
      crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
      crypto_stream_salsa20: crypto_stream_salsa20,
      crypto_onetimeauth: crypto_onetimeauth,
      crypto_onetimeauth_verify: crypto_onetimeauth_verify,
      crypto_verify_16: crypto_verify_16,
      crypto_verify_32: crypto_verify_32,
      crypto_secretbox: crypto_secretbox,
      crypto_secretbox_open: crypto_secretbox_open,
      crypto_scalarmult: crypto_scalarmult,
      crypto_scalarmult_base: crypto_scalarmult_base,
      crypto_box_beforenm: crypto_box_beforenm,
      crypto_box_afternm: crypto_box_afternm,
      crypto_box: crypto_box,
      crypto_box_open: crypto_box_open,
      crypto_box_keypair: crypto_box_keypair,
      crypto_hash: crypto_hash,
      crypto_sign: crypto_sign,
      crypto_sign_keypair: crypto_sign_keypair,
      crypto_sign_open: crypto_sign_open,
      crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES: crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
      crypto_hash_BYTES: crypto_hash_BYTES,
      gf: gf,
      D: D,
      L: L,
      pack25519: pack25519,
      unpack25519: unpack25519,
      M: M,
      A: A,
      S: S,
      Z: Z,
      pow2523: pow2523,
      add: add,
      set25519: set25519,
      modL: modL,
      scalarmult: scalarmult,
      scalarbase: scalarbase
    };
    /* High-level API */

    function checkLengths(k, n) {
      if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
      if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
    }

    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
      if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
    }

    function checkArrayTypes() {
      for (var i = 0; i < arguments.length; i++) {
        if (!(arguments[i] instanceof Uint8Array)) throw new TypeError('unexpected type, use Uint8Array');
      }
    }

    function cleanup(arr) {
      for (var i = 0; i < arr.length; i++) {
        arr[i] = 0;
      }
    }

    nacl.randomBytes = function (n) {
      var b = new Uint8Array(n);
      randombytes(b, n);
      return b;
    };

    nacl.secretbox = function (msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m.length);

      for (var i = 0; i < msg.length; i++) {
        m[i + crypto_secretbox_ZEROBYTES] = msg[i];
      }

      crypto_secretbox(c, m, m.length, nonce, key);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };

    nacl.secretbox.open = function (box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m = new Uint8Array(c.length);

      for (var i = 0; i < box.length; i++) {
        c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      }

      if (c.length < 32) return null;
      if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
      return m.subarray(crypto_secretbox_ZEROBYTES);
    };

    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

    nacl.scalarMult = function (n, p) {
      checkArrayTypes(n, p);
      if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
      if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q, n, p);
      return q;
    };

    nacl.scalarMult.base = function (n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q, n);
      return q;
    };

    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

    nacl.box = function (msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k);
    };

    nacl.box.before = function (publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k, publicKey, secretKey);
      return k;
    };

    nacl.box.after = nacl.secretbox;

    nacl.box.open = function (msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k);
    };

    nacl.box.open.after = nacl.secretbox.open;

    nacl.box.keyPair = function () {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return {
        publicKey: pk,
        secretKey: sk
      };
    };

    nacl.box.keyPair.fromSecretKey = function (secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return {
        publicKey: pk,
        secretKey: new Uint8Array(secretKey)
      };
    };

    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;

    nacl.sign = function (msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };

    nacl.sign.open = function (signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0) return null;
      var m = new Uint8Array(mlen);

      for (var i = 0; i < m.length; i++) {
        m[i] = tmp[i];
      }

      return m;
    };

    nacl.sign.detached = function (msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);

      for (var i = 0; i < sig.length; i++) {
        sig[i] = signedMsg[i];
      }

      return sig;
    };

    nacl.sign.detached.verify = function (msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES) throw new Error('bad signature size');
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;

      for (i = 0; i < crypto_sign_BYTES; i++) {
        sm[i] = sig[i];
      }

      for (i = 0; i < msg.length; i++) {
        sm[i + crypto_sign_BYTES] = msg[i];
      }

      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };

    nacl.sign.keyPair = function () {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return {
        publicKey: pk,
        secretKey: sk
      };
    };

    nacl.sign.keyPair.fromSecretKey = function (secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);

      for (var i = 0; i < pk.length; i++) {
        pk[i] = secretKey[32 + i];
      }

      return {
        publicKey: pk,
        secretKey: new Uint8Array(secretKey)
      };
    };

    nacl.sign.keyPair.fromSeed = function (seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES) throw new Error('bad seed size');
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);

      for (var i = 0; i < 32; i++) {
        sk[i] = seed[i];
      }

      crypto_sign_keypair(pk, sk, true);
      return {
        publicKey: pk,
        secretKey: sk
      };
    };

    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;

    nacl.hash = function (msg) {
      checkArrayTypes(msg);
      var h = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h, msg, msg.length);
      return h;
    };

    nacl.hash.hashLength = crypto_hash_BYTES;

    nacl.verify = function (x, y) {
      checkArrayTypes(x, y); // Zero length arguments are considered not equal.

      if (x.length === 0 || y.length === 0) return false;
      if (x.length !== y.length) return false;
      return vn(x, 0, y, 0, x.length) === 0 ? true : false;
    };

    nacl.setPRNG = function (fn) {
      randombytes = fn;
    };

    (function () {
      // Initialize PRNG if environment provides CSPRNG.
      // If not, methods calling randombytes will throw.
      var crypto = typeof self !== 'undefined' ? self.crypto || self.msCrypto : null;

      if (crypto && crypto.getRandomValues) {
        // Browsers.
        var QUOTA = 65536;
        nacl.setPRNG(function (x, n) {
          var i,
              v = new Uint8Array(n);

          for (i = 0; i < n; i += QUOTA) {
            crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }

          for (i = 0; i < n; i++) {
            x[i] = v[i];
          }

          cleanup(v);
        });
      } else if (typeof commonjsRequire !== 'undefined') {
        // Node.js.
        crypto = require$$0;

        if (crypto && crypto.randomBytes) {
          nacl.setPRNG(function (x, n) {
            var i,
                v = crypto.randomBytes(n);

            for (i = 0; i < n; i++) {
              x[i] = v[i];
            }

            cleanup(v);
          });
        }
      }
    })();
  })(module.exports ? module.exports : self.nacl = self.nacl || {});
})(naclFast);

var naclUtil = {exports: {}};

(function (module) {
  // Written in 2014-2016 by Dmitry Chestnykh and Devi Mandiri.
  // Public domain.
  (function (root, f) {

    if (module.exports) module.exports = f();else if (root.nacl) root.nacl.util = f();else {
      root.nacl = {};
      root.nacl.util = f();
    }
  })(commonjsGlobal, function () {

    var util = {};

    function validateBase64(s) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s)) {
        throw new TypeError('invalid encoding');
      }
    }

    util.decodeUTF8 = function (s) {
      if (typeof s !== 'string') throw new TypeError('expected string');
      var i,
          d = unescape(encodeURIComponent(s)),
          b = new Uint8Array(d.length);

      for (i = 0; i < d.length; i++) {
        b[i] = d.charCodeAt(i);
      }

      return b;
    };

    util.encodeUTF8 = function (arr) {
      var i,
          s = [];

      for (i = 0; i < arr.length; i++) {
        s.push(String.fromCharCode(arr[i]));
      }

      return decodeURIComponent(escape(s.join('')));
    };

    if (typeof atob === 'undefined') {
      // Node.js
      if (typeof Buffer$6.from !== 'undefined') {
        // Node v6 and later
        util.encodeBase64 = function (arr) {
          // v6 and later
          return Buffer$6.from(arr).toString('base64');
        };

        util.decodeBase64 = function (s) {
          validateBase64(s);
          return new Uint8Array(Array.prototype.slice.call(Buffer$6.from(s, 'base64'), 0));
        };
      } else {
        // Node earlier than v6
        util.encodeBase64 = function (arr) {
          // v6 and later
          return new Buffer$6(arr).toString('base64');
        };

        util.decodeBase64 = function (s) {
          validateBase64(s);
          return new Uint8Array(Array.prototype.slice.call(new Buffer$6(s, 'base64'), 0));
        };
      }
    } else {
      // Browsers
      util.encodeBase64 = function (arr) {
        var i,
            s = [],
            len = arr.length;

        for (i = 0; i < len; i++) {
          s.push(String.fromCharCode(arr[i]));
        }

        return btoa(s.join(''));
      };

      util.decodeBase64 = function (s) {
        validateBase64(s);
        var i,
            d = atob(s),
            b = new Uint8Array(d.length);

        for (i = 0; i < d.length; i++) {
          b[i] = d.charCodeAt(i);
        }

        return b;
      };
    }

    return util;
  });
})(naclUtil);

var Buffer$1 = buffer.Buffer;
var ethUtil = dist$1;
var ethAbi = ethereumjsAbi;
var nacl = naclFast.exports;
nacl.util = naclUtil.exports;
var TYPED_MESSAGE_SCHEMA = {
  type: 'object',
  properties: {
    types: {
      type: 'object',
      additionalProperties: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: {
              type: 'string'
            },
            type: {
              type: 'string'
            }
          },
          required: ['name', 'type']
        }
      }
    },
    primaryType: {
      type: 'string'
    },
    domain: {
      type: 'object'
    },
    message: {
      type: 'object'
    }
  },
  required: ['types', 'primaryType', 'domain', 'message']
};
/**
 * A collection of utility functions used for signing typed data
 */

var TypedDataUtils = {
  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData: function encodeData(primaryType, data, types) {
    var _this = this;

    var useV4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var encodedTypes = ['bytes32'];
    var encodedValues = [this.hashType(primaryType, types)];

    if (useV4) {
      var encodeField = function encodeField(name, type, value) {
        if (types[type] !== undefined) {
          return ['bytes32', value === null || value === undefined ? '0x0000000000000000000000000000000000000000000000000000000000000000' : ethUtil.keccak(_this.encodeData(type, value, types, useV4))];
        }

        if (value === undefined) {
          throw new Error("missing value for field ".concat(name, " of type ").concat(type));
        }

        if (type === 'bytes') {
          return ['bytes32', ethUtil.keccak(value)];
        }

        if (type === 'string') {
          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
          if (typeof value === 'string') {
            value = Buffer$1.from(value, 'utf8');
          }

          return ['bytes32', ethUtil.keccak(value)];
        }

        if (type.lastIndexOf(']') === type.length - 1) {
          var parsedType = type.slice(0, type.lastIndexOf('['));
          var typeValuePairs = value.map(function (item) {
            return encodeField(name, parsedType, item);
          });
          return ['bytes32', ethUtil.keccak(ethAbi.rawEncode(typeValuePairs.map(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 1),
                _type = _ref2[0];

            return _type;
          }), typeValuePairs.map(function (_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2),
                _value = _ref4[1];

            return _value;
          })))];
        }

        return [type, value];
      };

      var _iterator = _createForOfIteratorHelper(types[primaryType]),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var field = _step.value;

          var _encodeField = encodeField(field.name, field.type, data[field.name]),
              _encodeField2 = _slicedToArray(_encodeField, 2),
              type = _encodeField2[0],
              value = _encodeField2[1];

          encodedTypes.push(type);
          encodedValues.push(value);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else {
      var _iterator2 = _createForOfIteratorHelper(types[primaryType]),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _field = _step2.value;
          var _value2 = data[_field.name];

          if (_value2 !== undefined) {
            if (_field.type === 'bytes') {
              encodedTypes.push('bytes32');
              _value2 = ethUtil.keccak(_value2);
              encodedValues.push(_value2);
            } else if (_field.type === 'string') {
              encodedTypes.push('bytes32'); // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex

              if (typeof _value2 === 'string') {
                _value2 = Buffer$1.from(_value2, 'utf8');
              }

              _value2 = ethUtil.keccak(_value2);
              encodedValues.push(_value2);
            } else if (types[_field.type] !== undefined) {
              encodedTypes.push('bytes32');
              _value2 = ethUtil.keccak(this.encodeData(_field.type, _value2, types, useV4));
              encodedValues.push(_value2);
            } else if (_field.type.lastIndexOf(']') === _field.type.length - 1) {
              throw new Error('Arrays currently unimplemented in encodeData');
            } else {
              encodedTypes.push(_field.type);
              encodedValues.push(_value2);
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }

    return ethAbi.rawEncode(encodedTypes, encodedValues);
  },

  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType: function encodeType(primaryType, types) {
    var result = '';
    var deps = this.findTypeDependencies(primaryType, types).filter(function (dep) {
      return dep !== primaryType;
    });
    deps = [primaryType].concat(deps.sort());

    var _iterator3 = _createForOfIteratorHelper(deps),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var type = _step3.value;
        var children = types[type];

        if (!children) {
          throw new Error("No type definition specified: ".concat(type));
        }

        result += "".concat(type, "(").concat(types[type].map(function (_ref5) {
          var name = _ref5.name,
              _type = _ref5.type;
          return "".concat(_type, " ").concat(name);
        }).join(','), ")");
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    return result;
  },

  /**
   * Finds all types within a type defintion object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies: function findTypeDependencies(primaryType, types) {
    var results = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    var _primaryType$match = primaryType.match(/^[0-9A-Z_a-z]*/),
        _primaryType$match2 = _slicedToArray(_primaryType$match, 1),
        firstWord = _primaryType$match2[0];

    primaryType = firstWord;

    if (results.includes(primaryType) || types[primaryType] === undefined) {
      return results;
    }

    results.push(primaryType);

    var _iterator4 = _createForOfIteratorHelper(types[primaryType]),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var field = _step4.value;

        var _iterator5 = _createForOfIteratorHelper(this.findTypeDependencies(field.type, types, results)),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var dep = _step5.value;
            !results.includes(dep) && results.push(dep);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    return results;
  },

  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashStruct: function hashStruct(primaryType, data, types) {
    var useV4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4));
  },

  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType: function hashType(primaryType, types) {
    return ethUtil.keccak(this.encodeType(primaryType, types));
  },

  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData: function sanitizeData(data) {
    var sanitizedData = {};

    for (var _i = 0, _Object$keys = Object.keys(TYPED_MESSAGE_SCHEMA.properties); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      data[key] && (sanitizedData[key] = data[key]);
    }

    if (sanitizedData.types) {
      sanitizedData.types = _objectSpread2({
        EIP712Domain: []
      }, sanitizedData.types);
    }

    return sanitizedData;
  },

  /**
   * Signs a typed message as per EIP-712 and returns its keccak hash
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - keccak hash of the resulting signed message
   */
  sign: function sign(typedData) {
    var useV4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var sanitizedData = this.sanitizeData(typedData);
    var parts = [Buffer$1.from('1901', 'hex')];
    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));

    if (sanitizedData.primaryType !== 'EIP712Domain') {
      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
    }

    return ethUtil.keccak(Buffer$1.concat(parts));
  }
};
var ethSigUtil = {
  TYPED_MESSAGE_SCHEMA: TYPED_MESSAGE_SCHEMA,
  TypedDataUtils: TypedDataUtils,
  concatSig: function concatSig(v, r, s) {
    var rSig = ethUtil.fromSigned(r);
    var sSig = ethUtil.fromSigned(s);
    var vSig = ethUtil.bufferToInt(v);
    var rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64);
    var sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64);
    var vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig));
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex');
  },
  normalize: function normalize(input) {
    if (!input) {
      return undefined;
    }

    if (typeof input === 'number') {
      var buffer = ethUtil.toBuffer(input);
      input = ethUtil.bufferToHex(buffer);
    }

    if (typeof input !== 'string') {
      var msg = 'eth-sig-util.normalize() requires hex string or integer input.';
      msg += " received ".concat(_typeof(input), ": ").concat(input);
      throw new Error(msg);
    }

    return ethUtil.addHexPrefix(input.toLowerCase());
  },
  personalSign: function personalSign(privateKey, msgParams) {
    var message = ethUtil.toBuffer(msgParams.data);
    var msgHash = ethUtil.hashPersonalMessage(message);
    var sig = ethUtil.ecsign(msgHash, privateKey);
    var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));
    return serialized;
  },
  recoverPersonalSignature: function recoverPersonalSignature(msgParams) {
    var publicKey = getPublicKeyFor(msgParams);
    var sender = ethUtil.publicToAddress(publicKey);
    var senderHex = ethUtil.bufferToHex(sender);
    return senderHex;
  },
  extractPublicKey: function extractPublicKey(msgParams) {
    var publicKey = getPublicKeyFor(msgParams);
    return "0x".concat(publicKey.toString('hex'));
  },
  typedSignatureHash: function typedSignatureHash(typedData) {
    var hashBuffer = _typedSignatureHash(typedData);

    return ethUtil.bufferToHex(hashBuffer);
  },
  signTypedDataLegacy: function signTypedDataLegacy(privateKey, msgParams) {
    var msgHash = _typedSignatureHash(msgParams.data);

    var sig = ethUtil.ecsign(msgHash, privateKey);
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));
  },
  recoverTypedSignatureLegacy: function recoverTypedSignatureLegacy(msgParams) {
    var msgHash = _typedSignatureHash(msgParams.data);

    var publicKey = recoverPublicKey(msgHash, msgParams.sig);
    var sender = ethUtil.publicToAddress(publicKey);
    return ethUtil.bufferToHex(sender);
  },
  encrypt: function encrypt(receiverPublicKey, msgParams, version) {
    switch (version) {
      case 'x25519-xsalsa20-poly1305':
        {
          if (typeof msgParams.data === 'undefined') {
            throw new Error('Cannot detect secret message, message params should be of the form {data: "secret message"} ');
          } // generate ephemeral keypair


          var ephemeralKeyPair = nacl.box.keyPair(); // assemble encryption parameters - from string to UInt8

          var pubKeyUInt8Array;

          try {
            pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey);
          } catch (err) {
            throw new Error('Bad public key');
          }

          var msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data);
          var nonce = nacl.randomBytes(nacl.box.nonceLength); // encrypt

          var encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey); // handle encrypted data

          var output = {
            version: 'x25519-xsalsa20-poly1305',
            nonce: nacl.util.encodeBase64(nonce),
            ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),
            ciphertext: nacl.util.encodeBase64(encryptedMessage)
          }; // return encrypted msg data

          return output;
        }

      default:
        throw new Error('Encryption type/version not supported');
    }
  },
  encryptSafely: function encryptSafely(receiverPublicKey, msgParams, version) {
    var DEFAULT_PADDING_LENGTH = Math.pow(2, 11);
    var NACL_EXTRA_BYTES = 16;
    var data = msgParams.data;

    if (!data) {
      throw new Error('Cannot encrypt empty msg.data');
    }

    if (_typeof(data) === 'object' && data.toJSON) {
      // remove toJSON attack vector
      // TODO, check all possible children
      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');
    } // add padding


    var dataWithPadding = {
      data: data,
      padding: ''
    }; // calculate padding

    var dataLength = Buffer$1.byteLength(JSON.stringify(dataWithPadding), 'utf-8');
    var modVal = dataLength % DEFAULT_PADDING_LENGTH;
    var padLength = 0; // Only pad if necessary

    if (modVal > 0) {
      padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes
    }

    dataWithPadding.padding = '0'.repeat(padLength);
    var paddedMsgParams = {
      data: JSON.stringify(dataWithPadding)
    };
    return this.encrypt(receiverPublicKey, paddedMsgParams, version);
  },
  decrypt: function decrypt(encryptedData, receiverPrivateKey) {
    switch (encryptedData.version) {
      case 'x25519-xsalsa20-poly1305':
        {
          // string to buffer to UInt8Array
          var recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey);
          var recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey; // assemble decryption parameters

          var nonce = nacl.util.decodeBase64(encryptedData.nonce);
          var ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext);
          var ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey); // decrypt

          var decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey); // return decrypted msg data

          var output;

          try {
            output = nacl.util.encodeUTF8(decryptedMessage);
          } catch (err) {
            throw new Error('Decryption failed.');
          }

          if (output) {
            return output;
          }

          throw new Error('Decryption failed.');
        }

      default:
        throw new Error('Encryption type/version not supported.');
    }
  },
  decryptSafely: function decryptSafely(encryptedData, receiverPrivateKey) {
    var dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey));
    return dataWithPadding.data;
  },
  getEncryptionPublicKey: function getEncryptionPublicKey(privateKey) {
    var privateKeyUint8Array = nacl_decodeHex(privateKey);
    var encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;
    return nacl.util.encodeBase64(encryptionPublicKey);
  },

  /**
   * A generic entry point for all typed data methods to be passed, includes a version parameter.
   */
  signTypedMessage: function signTypedMessage(privateKey, msgParams) {
    var version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'V4';

    switch (version) {
      case 'V1':
        return this.signTypedDataLegacy(privateKey, msgParams);

      case 'V3':
        return this.signTypedData(privateKey, msgParams);

      case 'V4':
      default:
        return this.signTypedData_v4(privateKey, msgParams);
    }
  },
  recoverTypedMessage: function recoverTypedMessage(msgParams) {
    var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'V4';

    switch (version) {
      case 'V1':
        return this.recoverTypedSignatureLegacy(msgParams);

      case 'V3':
        return this.recoverTypedSignature(msgParams);

      case 'V4':
      default:
        return this.recoverTypedSignature_v4(msgParams);
    }
  },
  signTypedData: function signTypedData(privateKey, msgParams) {
    var message = TypedDataUtils.sign(msgParams.data, false);
    var sig = ethUtil.ecsign(message, privateKey);
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));
  },
  signTypedData_v4: function signTypedData_v4(privateKey, msgParams) {
    var message = TypedDataUtils.sign(msgParams.data);
    var sig = ethUtil.ecsign(message, privateKey);
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));
  },
  recoverTypedSignature: function recoverTypedSignature(msgParams) {
    var message = TypedDataUtils.sign(msgParams.data, false);
    var publicKey = recoverPublicKey(message, msgParams.sig);
    var sender = ethUtil.publicToAddress(publicKey);
    return ethUtil.bufferToHex(sender);
  },
  recoverTypedSignature_v4: function recoverTypedSignature_v4(msgParams) {
    var message = TypedDataUtils.sign(msgParams.data);
    var publicKey = recoverPublicKey(message, msgParams.sig);
    var sender = ethUtil.publicToAddress(publicKey);
    return ethUtil.bufferToHex(sender);
  }
};
/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */

function _typedSignatureHash(typedData) {
  var error = new Error('Expect argument to be non-empty array');

  if (_typeof(typedData) !== 'object' || !typedData.length) {
    throw error;
  }

  var data = typedData.map(function (e) {
    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value;
  });
  var types = typedData.map(function (e) {
    return e.type;
  });
  var schema = typedData.map(function (e) {
    if (!e.name) {
      throw error;
    }

    return "".concat(e.type, " ").concat(e.name);
  });
  return ethAbi.soliditySHA3(['bytes32', 'bytes32'], [ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema), ethAbi.soliditySHA3(types, data)]);
}

function recoverPublicKey(hash, sig) {
  var signature = ethUtil.toBuffer(sig);
  var sigParams = ethUtil.fromRpcSig(signature);
  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s);
}

function getPublicKeyFor(msgParams) {
  var message = ethUtil.toBuffer(msgParams.data);
  var msgHash = ethUtil.hashPersonalMessage(message);
  return recoverPublicKey(msgHash, msgParams.sig);
}

function padWithZeroes(number, length) {
  var myString = "".concat(number);

  while (myString.length < length) {
    myString = "0".concat(myString);
  }

  return myString;
} // converts hex strings to the Uint8Array format used by nacl


function nacl_decodeHex(msgHex) {
  var msgBase64 = Buffer$1.from(msgHex, 'hex').toString('base64');
  return nacl.util.decodeBase64(msgBase64);
}

/**
 * AuthService for Developer Apps wishing to write on a user's behalf
 */

var AppAuth = /*#__PURE__*/_createClass$1(function AppAuth(apiKey, apiSecret) {
  var _this = this;

  _classCallCheck$1(this, AppAuth);

  _defineProperty$4(this, "apiKey", void 0);

  _defineProperty$4(this, "apiSecret", void 0);

  _defineProperty$4(this, "getSharedSecret", /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            throw new Error('AppAuth does not support getSharedSecret');

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));

  _defineProperty$4(this, "sign", function () {
    throw new Error('AppAuth does not support sign');
  });

  _defineProperty$4(this, "hashAndSign", function () {
    throw new Error('AppAuth does not support hashAndSign');
  });

  _defineProperty$4(this, "signTransaction", /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(data) {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (_this.apiSecret) {
                _context2.next = 2;
                break;
              }

              throw new Error('AppAuth cannot `signTransaction` because apiSecret was not provided when initializing the SDK.');

            case 2:
              return _context2.abrupt("return", ethSigUtil.signTypedData(Buffer.from(_this.apiSecret, 'hex'), {
                data: data
              }));

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }());

  _defineProperty$4(this, "getAddress", /*#__PURE__*/_asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", "0x".concat(_this.apiKey));

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  })));

  this.apiKey = apiKey.replace(/^0x/, '');

  if (apiSecret) {
    this.apiSecret = apiSecret.replace(/^0x/, '');
  } else {
    this.apiSecret = null;
  }
});

var DevAppSchema = z.object({
  /**
   * Your app name
   */
  appName: z.optional(z.string()),

  /**
   * Services injection
   */
  services: z.optional(z.custom()),

  /**
   * API key, required for writes
   */
  apiKey: z.string().min(1),

  /**
   * API secret, required for writes
   */
  apiSecret: z.optional(z.string().min(1))
});
var CustomAppSchema = z.object({
  /**
   * Your app name
   */
  appName: z.string().min(1),

  /**
   * Services injection
   */
  services: z.optional(z.custom()),

  /**
   * API key, required for writes
   */
  apiKey: z.optional(z.string().min(1)),

  /**
   * API secret, required for writes
   */
  apiSecret: z.optional(z.string().min(1))
});
var SdkConfigSchema = z.union([DevAppSchema, CustomAppSchema]);

/**
 * The Audius SDK
 */

var sdk = function sdk(config) {
  SdkConfigSchema.parse(config);
  var appName = config.appName,
      apiKey = config.apiKey; // Initialize services

  var services = initializeServices(config); // Initialize APIs

  var apis = initializeApis({
    appName: appName,
    services: services
  }); // Initialize OAuth

  var oauth = typeof window !== 'undefined' ? new OAuth({
    appName: appName,
    apiKey: apiKey,
    usersApi: apis.users,
    logger: services.logger
  }) : undefined;
  return _objectSpread2({
    oauth: oauth
  }, apis);
};

var initializeServices = function initializeServices(config) {
  var _config$services$logg, _config$services, _config$services$stor, _config$services2, _config$services$auth, _config$services3, _config$services$disc, _config$services4, _config$services$disc2, _config$services5;

  var defaultLogger = new Logger();
  var logger = (_config$services$logg = (_config$services = config.services) === null || _config$services === void 0 ? void 0 : _config$services.logger) !== null && _config$services$logg !== void 0 ? _config$services$logg : defaultLogger;

  if (config.apiSecret && isBrowser) {
    logger.warn("apiSecret should only be provided server side so that it isn't exposed");
  }

  var defaultAuthService = config.apiKey ? new AppAuth(config.apiKey, config.apiSecret) : new Auth();
  var defaultDiscoveryNodeSelector = new DiscoveryNodeSelector({
    logger: logger
  });
  var storageNodeSelector = (_config$services$stor = (_config$services2 = config.services) === null || _config$services2 === void 0 ? void 0 : _config$services2.storageNodeSelector) !== null && _config$services$stor !== void 0 ? _config$services$stor : new StorageNodeSelector({
    auth: (_config$services$auth = (_config$services3 = config.services) === null || _config$services3 === void 0 ? void 0 : _config$services3.auth) !== null && _config$services$auth !== void 0 ? _config$services$auth : defaultAuthService,
    discoveryNodeSelector: (_config$services$disc = (_config$services4 = config.services) === null || _config$services4 === void 0 ? void 0 : _config$services4.discoveryNodeSelector) !== null && _config$services$disc !== void 0 ? _config$services$disc : defaultDiscoveryNodeSelector,
    logger: logger
  });
  var defaultEntityManager = new EntityManager(_objectSpread2(_objectSpread2({}, defaultEntityManagerConfig), {}, {
    discoveryNodeSelector: (_config$services$disc2 = (_config$services5 = config.services) === null || _config$services5 === void 0 ? void 0 : _config$services5.discoveryNodeSelector) !== null && _config$services$disc2 !== void 0 ? _config$services$disc2 : defaultDiscoveryNodeSelector
  }));
  var defaultStorage = new Storage({
    storageNodeSelector: storageNodeSelector,
    logger: logger
  });
  var defaultServices = {
    storageNodeSelector: storageNodeSelector,
    discoveryNodeSelector: defaultDiscoveryNodeSelector,
    entityManager: defaultEntityManager,
    storage: defaultStorage,
    auth: defaultAuthService,
    logger: logger
  };
  return _objectSpread2(_objectSpread2({}, defaultServices), config.services);
};

var initializeApis = function initializeApis(_ref) {
  var appName = _ref.appName,
      services = _ref.services;
  var middleware = [addAppNameMiddleware({
    appName: appName,
    services: services
  }), services.discoveryNodeSelector.createMiddleware()];
  var generatedApiClientConfig = new Configuration$1({
    fetchApi: fetch$1,
    middleware: middleware
  });
  var tracks = new TracksApi$1(generatedApiClientConfig, services.discoveryNodeSelector, services.storage, services.entityManager, services.auth, services.logger);
  var users = new UsersApi$1(generatedApiClientConfig, services.storage, services.entityManager, services.auth, services.logger);
  var albums = new AlbumsApi(generatedApiClientConfig, services.storage, services.entityManager, services.auth, services.logger);
  var playlists = new PlaylistsApi$1(generatedApiClientConfig, services.storage, services.entityManager, services.auth, services.logger);
  var tips = new TipsApi$1(generatedApiClientConfig);

  var _ResolveApi = new ResolveApi(generatedApiClientConfig),
      resolve = _ResolveApi.resolve;

  var chats = new ChatsApi(new Configuration$1({
    fetchApi: fetch$1,
    basePath: '',
    middleware: middleware
  }), services.auth, services.discoveryNodeSelector, services.logger);
  var grants = new GrantsApi(generatedApiClientConfig, services.entityManager, services.auth);
  var developerApps = new DeveloperAppsApi(generatedApiClientConfig, services.entityManager, services.auth);
  var generatedApiClientConfigFull = new Configuration({
    fetchApi: fetch$1,
    middleware: middleware
  });
  var full = {
    tracks: new TracksApi(generatedApiClientConfigFull),
    users: new UsersApi(generatedApiClientConfigFull),
    search: new SearchApi(generatedApiClientConfigFull),
    playlists: new PlaylistsApi(generatedApiClientConfigFull),
    reactions: new ReactionsApi(generatedApiClientConfigFull),
    tips: new TipsApi(generatedApiClientConfigFull),
    transactions: new TransactionsApi(generatedApiClientConfigFull)
  };
  return {
    tracks: tracks,
    users: users,
    albums: albums,
    playlists: playlists,
    tips: tips,
    resolve: resolve,
    full: full,
    chats: chats,
    grants: grants,
    developerApps: developerApps
  };
};

export { ALLOWED_AUDIO_MIME_TYPES, ALLOWED_IMAGE_MIME_TYPES, ActivityFromJSON, ActivityFromJSONTyped, ActivityToJSON, AddTrackToPlaylistSchema, AlbumsApi, AppAuth, AudioFile, Auth, AuthorizedAppFromJSON, AuthorizedAppFromJSONTyped, AuthorizedAppToJSON, AuthorizedAppsFromJSON, AuthorizedAppsFromJSONTyped, AuthorizedAppsToJSON, BASE_PATH$1 as BASE_PATH, BaseAPI$1 as BaseAPI, BlobApiResponse$1 as BlobApiResponse, COLLECTION_FORMATS$1 as COLLECTION_FORMATS, ChatBlockRequestSchema, ChatCreateRequestSchema, ChatDeleteRequestSchema, ChatGetAllRequestSchema, ChatGetBlockersRequestSchema, ChatGetMessagesRequestSchema, ChatGetPermissionRequestSchema, ChatGetRequestSchema, ChatGetUnreadCountRequestSchema, ChatInviteRequestSchema, ChatListenRequestSchema, ChatMessageRequestSchema, ChatPermission, ChatPermitRequestSchema, ChatReactRequestSchema, ChatReadRequestSchema, ChatUnfurlRequestSchema, ChatValidateCanCreateRequestSchema, Configuration$1 as Configuration, ConnectedWalletsFromJSON, ConnectedWalletsFromJSONTyped, ConnectedWalletsResponseFromJSON, ConnectedWalletsResponseFromJSONTyped, ConnectedWalletsResponseToJSON, ConnectedWalletsToJSON, CoverPhotoFromJSON$1 as CoverPhotoFromJSON, CoverPhotoFromJSONTyped$1 as CoverPhotoFromJSONTyped, CoverPhotoToJSON$1 as CoverPhotoToJSON, CreateDeveloperAppSchema, CreateGrantSchema, CreatePlaylistSchema, CrossPlatformFileSchema, DECISION_TREE_STATE, DecodedUserTokenFromJSON, DecodedUserTokenFromJSONTyped, DecodedUserTokenToJSON, DefaultConfig$1 as DefaultConfig, DeleteAlbumSchema, DeleteDeveloperAppSchema, DeletePlaylistSchema, DeleteTrackSchema, DeveloperAppFromJSON, DeveloperAppFromJSONTyped, DeveloperAppResponseFromJSON, DeveloperAppResponseFromJSONTyped, DeveloperAppResponseToJSON, DeveloperAppToJSON, DeveloperAppsApi, DeveloperAppsFromJSON, DeveloperAppsFromJSONTyped, DeveloperAppsToJSON, DiscoveryNodeSelector, EncodedUserIdFromJSON, EncodedUserIdFromJSONTyped, EncodedUserIdToJSON, EntityManager, FavoriteAlbumSchema, FavoriteFromJSON$1 as FavoriteFromJSON, FavoriteFromJSONTyped$1 as FavoriteFromJSONTyped, FavoritePlaylistSchema, FavoriteToJSON$1 as FavoriteToJSON, FavoriteTrackSchema, FavoritesResponseFromJSON, FavoritesResponseFromJSONTyped, FavoritesResponseToJSON, FetchError$1 as FetchError, FollowUserSchema, FollowersResponseFromJSON, FollowersResponseFromJSONTyped, FollowersResponseToJSON, FollowingResponseFromJSON$1 as FollowingResponseFromJSON, FollowingResponseFromJSONTyped$1 as FollowingResponseFromJSONTyped, FollowingResponseToJSON$1 as FollowingResponseToJSON, Genre, GetAIAttributedTracksByUserHandleFilterTracksEnum$1 as GetAIAttributedTracksByUserHandleFilterTracksEnum, GetAIAttributedTracksByUserHandleSortDirectionEnum$1 as GetAIAttributedTracksByUserHandleSortDirectionEnum, GetAIAttributedTracksByUserHandleSortEnum$1 as GetAIAttributedTracksByUserHandleSortEnum, GetAIAttributedTracksByUserHandleSortMethodEnum$1 as GetAIAttributedTracksByUserHandleSortMethodEnum, GetAudioTransactionHistorySortDirectionEnum, GetAudioTransactionHistorySortMethodEnum, GetSupportersFromJSON, GetSupportersFromJSONTyped, GetSupportersToJSON, GetSupportingFromJSON, GetSupportingFromJSONTyped, GetSupportingToJSON, GetTipsCurrentUserFollowsEnum$1 as GetTipsCurrentUserFollowsEnum, GetTipsResponseFromJSON$1 as GetTipsResponseFromJSON, GetTipsResponseFromJSONTyped$1 as GetTipsResponseFromJSONTyped, GetTipsResponseToJSON$1 as GetTipsResponseToJSON, GetTipsUniqueByEnum$1 as GetTipsUniqueByEnum, GetTracksByUserFilterTracksEnum$1 as GetTracksByUserFilterTracksEnum, GetTracksByUserSortDirectionEnum$1 as GetTracksByUserSortDirectionEnum, GetTracksByUserSortEnum$1 as GetTracksByUserSortEnum, GetTracksByUserSortMethodEnum$1 as GetTracksByUserSortMethodEnum, GetTrendingPlaylistsTimeEnum$1 as GetTrendingPlaylistsTimeEnum, GetTrendingTracksTimeEnum$1 as GetTrendingTracksTimeEnum, GrantsApi, HashId, ImageFile, JSONApiResponse$1 as JSONApiResponse, Logger, Mood, ParseRequestError, PlaylistAddedTimestampFromJSON$1 as PlaylistAddedTimestampFromJSON, PlaylistAddedTimestampFromJSONTyped$1 as PlaylistAddedTimestampFromJSONTyped, PlaylistAddedTimestampToJSON$1 as PlaylistAddedTimestampToJSON, PlaylistArtworkFromJSON$1 as PlaylistArtworkFromJSON, PlaylistArtworkFromJSONTyped$1 as PlaylistArtworkFromJSONTyped, PlaylistArtworkToJSON$1 as PlaylistArtworkToJSON, PlaylistFromJSON, PlaylistFromJSONTyped, PlaylistResponseFromJSON, PlaylistResponseFromJSONTyped, PlaylistResponseToJSON, PlaylistSearchResultFromJSON, PlaylistSearchResultFromJSONTyped, PlaylistSearchResultToJSON, PlaylistToJSON, PlaylistTracksResponseFromJSON, PlaylistTracksResponseFromJSONTyped, PlaylistTracksResponseToJSON, PlaylistsApi$1 as PlaylistsApi, PremiumConditionsEthNFTCollection, PremiumConditionsFollowUserId, PremiumConditionsNFTCollection, PremiumConditionsSolNFTCollection, PremiumConditionsTipUserId, ProfilePictureFromJSON$1 as ProfilePictureFromJSON, ProfilePictureFromJSONTyped$1 as ProfilePictureFromJSONTyped, ProfilePictureToJSON$1 as ProfilePictureToJSON, PublishPlaylistSchema, RelatedArtistResponseFromJSON, RelatedArtistResponseFromJSONTyped, RelatedArtistResponseToJSON, RemixParentFromJSON, RemixParentFromJSONTyped, RemixParentToJSON, RemoveTrackFromPlaylistSchema, RendezvousHash, RepostAlbumSchema, RepostPlaylistSchema, RepostTrackSchema, RepostsFromJSON, RepostsFromJSONTyped, RepostsToJSON, RequiredError$1 as RequiredError, ResolveApi, ResponseError$1 as ResponseError, RevokeGrantSchema, Storage, StorageNodeSelector, SubscribeToUserSchema, SubscribersResponseFromJSON, SubscribersResponseFromJSONTyped, SubscribersResponseToJSON, SupporterFromJSON, SupporterFromJSONTyped, SupporterToJSON, SupportingFromJSON, SupportingFromJSONTyped, SupportingToJSON, TagsResponseFromJSON, TagsResponseFromJSONTyped, TagsResponseToJSON, TextApiResponse$1 as TextApiResponse, TipFromJSON, TipFromJSONTyped, TipToJSON, TipsApi$1 as TipsApi, TrackArtworkFromJSON$1 as TrackArtworkFromJSON, TrackArtworkFromJSONTyped$1 as TrackArtworkFromJSONTyped, TrackArtworkToJSON$1 as TrackArtworkToJSON, TrackElementFromJSON, TrackElementFromJSONTyped, TrackElementToJSON, TrackFromJSON, TrackFromJSONTyped, TrackResponseFromJSON, TrackResponseFromJSONTyped, TrackResponseToJSON, TrackSearchFromJSON, TrackSearchFromJSONTyped, TrackSearchToJSON, TrackToJSON, TracksApi$1 as TracksApi, TracksResponseFromJSON, TracksResponseFromJSONTyped, TracksResponseToJSON, TrendingPlaylistsResponseFromJSON, TrendingPlaylistsResponseFromJSONTyped, TrendingPlaylistsResponseToJSON, UnfavoriteAlbumSchema, UnfavoritePlaylistSchema, UnfavoriteTrackSchema, UnfollowUserSchema, UnrepostAlbumSchema, UnrepostPlaylistSchema, UnrepostTrackSchema, UnsubscribeFromUserSchema, UpdateProfileSchema, UserAssociatedWalletResponseFromJSON, UserAssociatedWalletResponseFromJSONTyped, UserAssociatedWalletResponseToJSON, UserFromJSON, UserFromJSONTyped, UserResponseFromJSON, UserResponseFromJSONTyped, UserResponseToJSON, UserSearchFromJSON, UserSearchFromJSONTyped, UserSearchToJSON, UserToJSON, UsersApi$1 as UsersApi, VerifyTokenFromJSON, VerifyTokenFromJSONTyped, VerifyTokenToJSON, VoidApiResponse$1 as VoidApiResponse, canConsumeForm$1 as canConsumeForm, createUpdateAlbumSchema, createUpdatePlaylistMetadataSchema, createUpdatePlaylistSchema, createUpdateTrackSchema, createUploadAlbumMetadataSchema, createUploadAlbumSchema, createUploadPlaylistSchema, createUploadTrackMetadataSchema, createUploadTrackSchema, servicesConfig$2 as developmentConfig, exists$1 as exists, index as full, getAlbumSchema, getAlbumTracksSchema, instanceOfActivity, instanceOfAuthorizedApp, instanceOfAuthorizedApps, instanceOfConnectedWallets, instanceOfConnectedWalletsResponse, instanceOfCoverPhoto$1 as instanceOfCoverPhoto, instanceOfDecodedUserToken, instanceOfDeveloperApp, instanceOfDeveloperAppResponse, instanceOfDeveloperApps, instanceOfEncodedUserId, instanceOfFavorite$1 as instanceOfFavorite, instanceOfFavoritesResponse, instanceOfFollowersResponse, instanceOfFollowingResponse$1 as instanceOfFollowingResponse, instanceOfGetSupporters, instanceOfGetSupporting, instanceOfGetTipsResponse$1 as instanceOfGetTipsResponse, instanceOfPlaylist, instanceOfPlaylistAddedTimestamp$1 as instanceOfPlaylistAddedTimestamp, instanceOfPlaylistArtwork$1 as instanceOfPlaylistArtwork, instanceOfPlaylistResponse, instanceOfPlaylistSearchResult, instanceOfPlaylistTracksResponse, instanceOfProfilePicture$1 as instanceOfProfilePicture, instanceOfRelatedArtistResponse, instanceOfRemixParent, instanceOfReposts, instanceOfSubscribersResponse, instanceOfSupporter, instanceOfSupporting, instanceOfTagsResponse, instanceOfTip, instanceOfTrack, instanceOfTrackArtwork$1 as instanceOfTrackArtwork, instanceOfTrackElement, instanceOfTrackResponse, instanceOfTrackSearch, instanceOfTracksResponse, instanceOfTrendingPlaylistsResponse, instanceOfUser, instanceOfUserAssociatedWalletResponse, instanceOfUserResponse, instanceOfUserSearch, instanceOfVerifyToken, isNodeFile, mapValues$1 as mapValues, servicesConfig as productionConfig, querystring$1 as querystring, sdk, servicesConfig$1 as stagingConfig };
//# sourceMappingURL=index.browser.esm.js.map
