import { isBrowser } from 'browser-or-node';
import { z } from 'zod';
import Hashids from 'hashids';
import snakecaseKeys from 'snakecase-keys';
import * as fileType from 'file-type';
import retry from 'async-retry';
import { pick, shuffle } from 'lodash';
import * as aes from 'micro-aes-gcm';
import { base64 } from '@scure/base';
import { ulid } from 'ulid';
import * as secp from '@noble/secp256k1';
import WebSocket from 'isomorphic-ws';
import EventEmitter from 'events';
import fetch$1, { Headers } from 'cross-fetch';
import semver from 'semver';
import { AbortController } from 'node-abort-controller';
import bs58 from 'bs58';
import require$$0 from 'web3';
import axios from 'axios';
import { callbackify, promisify } from 'util';
import { importer } from 'ipfs-unixfs-importer';
import fs from 'fs';
import { Stream } from 'stream';
import crypto from 'crypto';
import 'assert';
import 'ethereumjs-util';
import '@ethersproject/solidity';
import { Keypair } from '@solana/web3.js';
import { Buffer as Buffer$1 } from 'buffer';
import FormData$1 from 'form-data';
import { signTypedData } from 'eth-sig-util';

function _asyncIterator(iterable) {
  var method,
      async,
      sync,
      retry = 2;

  for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {
    if (async && null != (method = iterable[async])) return method.call(iterable);
    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
    async = "@@asyncIterator", sync = "@@iterator";
  }

  throw new TypeError("Object is not async iterable");
}

function AsyncFromSyncIterator(s) {
  function AsyncFromSyncIteratorContinuation(r) {
    if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
    var done = r.done;
    return Promise.resolve(r.value).then(function (value) {
      return {
        value: value,
        done: done
      };
    });
  }

  return AsyncFromSyncIterator = function (s) {
    this.s = s, this.n = s.next;
  }, AsyncFromSyncIterator.prototype = {
    s: null,
    n: null,
    next: function () {
      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
    },
    return: function (value) {
      var ret = this.s.return;
      return void 0 === ret ? Promise.resolve({
        value: value,
        done: !0
      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
    },
    throw: function (value) {
      var thr = this.s.return;
      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
    }
  }, new AsyncFromSyncIterator(s);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var isOAuthScopeValid = function isOAuthScopeValid(scope) {
  var validScopes = new Set(OAUTH_SCOPE_OPTIONS);
  return scope.findIndex(function (s) {
    return !validScopes.has(s);
  }) === -1;
};

var ParseRequestError = /*#__PURE__*/function (_Error) {
  _inherits(ParseRequestError, _Error);

  var _super = _createSuper(ParseRequestError);

  function ParseRequestError(method, innerError) {
    var _this;

    _classCallCheck(this, ParseRequestError);

    _this = _super.call(this, "'".concat(method, "' => ").concat(innerError.message));

    _defineProperty$1(_assertThisInitialized(_this), "method", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "innerError", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "name", 'ParseRequestError');

    _this.method = method;
    _this.innerError = innerError;
    return _this;
  }

  return _createClass(ParseRequestError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * @param name Name of the method for which the parameters are being parsed
 * @param schema Zod schema that defines the shape of the request parameters
 * @returns The parsed data or throws an error
 */

var parseParams = function parseParams(name, schema) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
      var result;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return schema.safeParseAsync(params);

            case 2:
              result = _context.sent;

              if (result.success) {
                _context.next = 5;
                break;
              }

              throw new ParseRequestError(name, result.error);

            case 5:
              return _context.abrupt("return", result.data);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

var isApiKeyValid = function isApiKeyValid(apiKey) {
  try {
    if (apiKey.length !== 40) {
      return false;
    }

    var hexadecimalRegex = /^[0-9a-fA-F]+$/;
    return hexadecimalRegex.test(apiKey);
  } catch (_e) {
    return false;
  }
};

var IsWriteAccessGrantedSchema = z.object({
  userId: z.string(),
  apiKey: z.optional(z.custom(function (data) {
    return isApiKeyValid(data);
  }))
});
var OAUTH_SCOPE_OPTIONS = ['read', 'write'];

var CSS = "\n.audiusLoginButton {\n  cursor: pointer;\n  font-family: Helvetica, Arial, sans-serif;\n  text-align: center;\n  color: #FFFFFF;\n  font-weight: 700;\n  font-size: 14px;\n  line-height: 100%;\n  align-items: center;\n  display: flex;\n  border: 0;\n  height: 28px;\n  justify-content: center;\n  padding: 0px 16px;\n  background: #CC0FE0;\n  border-radius: 4px;\n  transition: all 0.07s ease-in-out;\n}\n\n.audiusLoginButton:hover {\n  background: #D127E3;\n  transform: perspective(1px) scale3d(1.04, 1.04, 1.04);\n}\n\n.audiusLoginButton.disableHoverGrow:hover {\n  transform: none;\n}\n\n.audiusLoginButton:active {\n  background: #A30CB3;\n}\n\n.audiusLoginButton.pill {\n  border-radius: 99px;\n}\n\n.audiusLoginButton.fullWidth {\n  width: 100%;\n}\n\n.audiusLoginButton.small {\n  height: 20px;\n  font-size: 11px;\n  padding: 0px 32px;\n}\n\n.audiusLoginButton.large {\n  height: 40px;\n  font-size: 18px;\n  padding: 0px 18px;\n}\n"; // From https://stackoverflow.com/a/27747377

var generateId = function generateId() {
  var arr = new Uint8Array(40 / 2) // Result of function will be 40 chars long
  ;
  (window.crypto || window.msCrypto).getRandomValues(arr);
  return Array.from(arr, function dec2hex(dec) {
    return dec.toString(16).padStart(2, '0');
  }).join('');
};

var generateAudiusLogoSvg = function generateAudiusLogoSvg(size) {
  var height;
  var paddingRight;

  if (size === 'small') {
    height = 16;
    paddingRight = 5;
  } else if (size === 'medium') {
    height = 18;
    paddingRight = 5;
  } else {
    height = 24;
    paddingRight = 10;
  }

  return "<svg width=\"".concat(height, "px\" height=\"").concat(height, "px\" viewBox=\"0 0 56 48\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"padding-right: ").concat(paddingRight, "px;\">\n<g id=\"Assets\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n    <g id=\"assets\" transform=\"translate(-1555.000000, -2588.000000)\">\n        <g id=\"audiusLogoGlyph\" transform=\"translate(1555.000000, 2588.000000)\">\n            <path d=\"M55.8191698,46.0362519 L42.4551012,23.3458831 L36.1870263,12.7036635 L29.0910326,0.65551431 C28.5766233,-0.217848954 27.2890668,-0.218676884 26.7734944,0.654065432 L13.3787621,23.3270477 L7.90582764,32.5909699 C7.39025522,33.4637122 8.03324043,34.5553386 9.06332791,34.5560631 L19.4031138,34.56279 C19.881044,34.5631005 20.3230236,34.3136864 20.5623059,33.9087249 L25.9362708,24.8122516 L26.7580568,23.4212248 C26.790518,23.3662709 26.8260456,23.3149392 26.8641108,23.2669192 C27.4325516,22.5520012 28.5935412,22.6041608 29.0755951,23.4226737 L34.6514114,32.8894388 L35.682239,34.6396841 C35.7412402,34.7399672 35.7843808,34.8430445 35.813987,34.9470533 C36.0430129,35.7492145 35.4339691,36.6039494 34.5220954,36.6034319 L22.3586676,36.5954631 C21.8806317,36.5951526 21.4387578,36.8445667 21.1994756,37.2496317 L16.0236614,46.0105861 C15.5080889,46.8833284 16.1510741,47.9749548 17.1810559,47.9756793 L27.9002253,47.9827167 L41.2664086,47.9913065 L54.6590261,47.9999997 C55.6892193,48.0006207 56.3335791,46.9096152 55.8191698,46.0362519\" id=\"Audius-Logo\" fill=\"#ffffff\" fill-rule=\"evenodd\"></path>\n            <rect id=\"bound\" x=\"0\" y=\"0\" width=\"56\" height=\"48\"></rect>\n        </g>\n    </g>\n</g>\n</svg>");
};

var CSRF_TOKEN_KEY = 'audiusOauthState';
var OAUTH_URL = {
  production: 'https://audius.co/oauth/auth',
  staging: 'https://staging.audius.co/oauth/auth'
};
var OAuth = /*#__PURE__*/function () {
  function OAuth(config) {
    var _config$apiKey;

    _classCallCheck(this, OAuth);

    _defineProperty$1(this, "config", void 0);

    _defineProperty$1(this, "activePopupWindow", void 0);

    _defineProperty$1(this, "popupCheckInterval", void 0);

    _defineProperty$1(this, "loginSuccessCallback", void 0);

    _defineProperty$1(this, "loginErrorCallback", void 0);

    _defineProperty$1(this, "apiKey", void 0);

    _defineProperty$1(this, "env", 'production');

    _defineProperty$1(this, "logger", void 0);

    this.config = config;

    if (typeof window === 'undefined') {
      throw new Error('Audius OAuth SDK functions are only available in browser. Refer to our documentation to learn how to implement Audius OAuth manually: https://docs.audius.org/developers/log-in-with-audius#manual-implementation.');
    }

    this.apiKey = (_config$apiKey = config.apiKey) !== null && _config$apiKey !== void 0 ? _config$apiKey : null;
    this.activePopupWindow = null;
    this.loginSuccessCallback = null;
    this.loginErrorCallback = null;
    this.popupCheckInterval = null;
    this.logger = config.logger.createPrefixedLogger('[oauth]');
  }

  _createClass(OAuth, [{
    key: "init",
    value: function init(_ref) {
      var _this = this;

      var successCallback = _ref.successCallback,
          errorCallback = _ref.errorCallback,
          _ref$env = _ref.env,
          env = _ref$env === void 0 ? 'production' : _ref$env;
      this.loginSuccessCallback = successCallback;
      this.loginErrorCallback = errorCallback !== null && errorCallback !== void 0 ? errorCallback : null;
      this.env = env;
      window.addEventListener('message', function (e) {
        _this._receiveMessage(e);
      }, false);
    }
  }, {
    key: "isWriteAccessGranted",
    value: function () {
      var _isWriteAccessGranted = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var _authorizedApps$data,
            _this2 = this;

        var _yield$parseParams, userId, apiKey, authorizedApps, foundIndex;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return parseParams('isWriteAccessGranted', IsWriteAccessGrantedSchema)(params);

              case 2:
                _yield$parseParams = _context.sent;
                userId = _yield$parseParams.userId;
                apiKey = _yield$parseParams.apiKey;

                if (!this.apiKey && !apiKey) {
                  this._surfaceError('Need to init Audius SDK with API key or pass in API Key directly to oauth.isWriteAccessGranted.');
                }

                _context.next = 8;
                return this.config.usersApi.getAuthorizedApps({
                  id: userId
                });

              case 8:
                authorizedApps = _context.sent;
                foundIndex = (_authorizedApps$data = authorizedApps.data) === null || _authorizedApps$data === void 0 ? void 0 : _authorizedApps$data.findIndex(function (a) {
                  return a.address.toLowerCase() === "0x".concat((apiKey || _this2.apiKey).toLowerCase());
                });
                return _context.abrupt("return", foundIndex !== undefined && foundIndex > -1);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function isWriteAccessGranted(_x) {
        return _isWriteAccessGranted.apply(this, arguments);
      }

      return isWriteAccessGranted;
    }()
  }, {
    key: "login",
    value: function login(_ref2) {
      var _this3 = this;

      var _ref2$scope = _ref2.scope,
          scope = _ref2$scope === void 0 ? 'read' : _ref2$scope;
      var scopeFormatted = typeof scope === 'string' ? [scope] : scope;

      if (!this.config.appName && !this.apiKey) {
        this._surfaceError('App name not set (set with `init` method).');

        return;
      }

      if (scope.includes('write') && !this.apiKey) {
        this._surfaceError("The 'write' scope requires Audius SDK to be initialized with an API key");
      }

      if (!this.loginSuccessCallback) {
        this._surfaceError('Login success callback not set (set with `init` method).');

        return;
      }

      if (!isOAuthScopeValid(scopeFormatted)) {
        this._surfaceError('Scope must be `read` or `write`.');

        return;
      }

      var csrfToken = generateId();
      window.localStorage.setItem(CSRF_TOKEN_KEY, csrfToken);
      var windowOptions = 'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=375, height=720, top=100, left=100';
      var originURISafe = encodeURIComponent(window.location.origin);
      var appIdURISafe = encodeURIComponent(this.apiKey || this.config.appName);
      var appIdURIParam = "".concat(this.apiKey ? 'api_key' : 'app_name', "=").concat(appIdURISafe);
      var scopeUriParam = scope.includes('write') ? 'write' : 'read';
      var fullOauthUrl = "".concat(OAUTH_URL[this.env], "?scope=").concat(scopeUriParam, "&state=").concat(csrfToken, "&redirect_uri=postMessage&origin=").concat(originURISafe, "&").concat(appIdURIParam);
      this.activePopupWindow = window.open(fullOauthUrl, '', windowOptions);

      this._clearPopupCheckInterval();

      this.popupCheckInterval = setInterval(function () {
        var _this3$activePopupWin;

        if ((_this3$activePopupWin = _this3.activePopupWindow) !== null && _this3$activePopupWin !== void 0 && _this3$activePopupWin.closed) {
          _this3._surfaceError('The login popup was closed prematurely.');

          if (_this3.popupCheckInterval) {
            clearInterval(_this3.popupCheckInterval);
          }
        }
      }, 500);
    }
  }, {
    key: "renderButton",
    value: function renderButton(_ref3) {
      var _buttonOptions$size,
          _buttonOptions$custom,
          _this4 = this;

      var element = _ref3.element,
          _ref3$scope = _ref3.scope,
          scope = _ref3$scope === void 0 ? 'read' : _ref3$scope,
          buttonOptions = _ref3.buttonOptions;

      if (!element) {
        this.logger.error('Target element for Audius OAuth button is empty.');
      }

      var style = document.createElement('style');
      style.textContent = CSS;
      document.head.appendChild(style);
      var button = document.createElement('button');
      button.id = 'audius-login-button';
      button.classList.add('audiusLoginButton');

      if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.corners) === 'pill') {
        button.classList.add('pill');
      }

      if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) === 'small') {
        button.classList.add('small');
      }

      if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) === 'large') {
        button.classList.add('large');
      }

      if (buttonOptions !== null && buttonOptions !== void 0 && buttonOptions.fullWidth) {
        button.classList.add('fullWidth');
      }

      if (buttonOptions !== null && buttonOptions !== void 0 && buttonOptions.disableHoverGrow) {
        button.classList.add('disableHoverGrow');
      }

      button.innerHTML = "".concat(generateAudiusLogoSvg((_buttonOptions$size = buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) !== null && _buttonOptions$size !== void 0 ? _buttonOptions$size : 'medium'), " ").concat((_buttonOptions$custom = buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.customText) !== null && _buttonOptions$custom !== void 0 ? _buttonOptions$custom : 'Continue With Audius');

      button.onclick = function () {
        _this4.login({
          scope: scope
        });
      };

      element.replaceWith(button);
    }
    /**
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     * @deprecated see `UsersApi.verifyIDToken`
     * @param token the token to verify
     * @returns
     */

  }, {
    key: "verifyToken",
    value: function () {
      var _verifyToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(token) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.config.usersApi.verifyIDToken({
                  token: token
                });

              case 2:
                return _context2.abrupt("return", _context2.sent);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function verifyToken(_x2) {
        return _verifyToken.apply(this, arguments);
      }

      return verifyToken;
    }()
    /* ------- INTERNAL FUNCTIONS ------- */

  }, {
    key: "_surfaceError",
    value: function _surfaceError(errorMessage) {
      if (this.loginErrorCallback) {
        this.loginErrorCallback(errorMessage);
      } else {
        this.logger.error(errorMessage);
      }
    }
  }, {
    key: "_clearPopupCheckInterval",
    value: function _clearPopupCheckInterval() {
      if (this.popupCheckInterval) {
        clearInterval(this.popupCheckInterval);
      }
    }
  }, {
    key: "_receiveMessage",
    value: function () {
      var _receiveMessage2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(event) {
        var oauthOrigin, decodedJwt;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                oauthOrigin = new URL(OAUTH_URL[this.env]).origin;

                if (!(event.origin !== oauthOrigin || event.source !== this.activePopupWindow || !event.data.state || !event.data.token)) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt("return");

              case 3:
                this._clearPopupCheckInterval();

                if (this.activePopupWindow) {
                  if (!this.activePopupWindow.closed) {
                    this.activePopupWindow.close();
                  }

                  this.activePopupWindow = null;
                }

                if (window.localStorage.getItem(CSRF_TOKEN_KEY) !== event.data.state) {
                  this._surfaceError('State mismatch.');
                } // Verify token and decode


                _context3.next = 8;
                return this.verifyToken(event.data.token);

              case 8:
                decodedJwt = _context3.sent;

                if (decodedJwt !== null && decodedJwt !== void 0 && decodedJwt.data) {
                  if (this.loginSuccessCallback) {
                    this.loginSuccessCallback(decodedJwt.data);
                  }
                } else {
                  this._surfaceError('The token was invalid.');
                }

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _receiveMessage(_x3) {
        return _receiveMessage2.apply(this, arguments);
      }

      return _receiveMessage;
    }()
  }]);

  return OAuth;
}();

var Action;

(function (Action) {
  Action["CREATE"] = "Create";
  Action["UPDATE"] = "Update";
  Action["DELETE"] = "Delete";
  Action["VERIFY"] = "Verify";
  Action["FOLLOW"] = "Follow";
  Action["UNFOLLOW"] = "Unfollow";
  Action["SAVE"] = "Save";
  Action["UNSAVE"] = "Unsave";
  Action["REPOST"] = "Repost";
  Action["UNREPOST"] = "Unrepost";
  Action["SUBSCRIBE"] = "Subscribe";
  Action["UNSUBSCRIBE"] = "Unsubscribe";
  Action["VIEW"] = "View";
  Action["VIEW_PLAYLIST"] = "ViewPlaylist";
})(Action || (Action = {}));

var EntityType;

(function (EntityType) {
  EntityType["PLAYLIST"] = "Playlist";
  EntityType["TRACK"] = "Track";
  EntityType["USER"] = "User";
  EntityType["USER_REPLICA_SET"] = "UserReplicaSet";
  EntityType["NOTIFICATION"] = "Notification";
  EntityType["DEVELOPER_APP"] = "DeveloperApp";
  EntityType["GRANT"] = "Grant";
})(EntityType || (EntityType = {}));

var BlockConfirmation;

(function (BlockConfirmation) {
  BlockConfirmation["CONFIRMED"] = "CONFIRMED";
  BlockConfirmation["DENIED"] = "DENIED";
  BlockConfirmation["UNKNOWN"] = "UNKNOWN";
})(BlockConfirmation || (BlockConfirmation = {}));

var HASH_SALT$1 = 'azowernasdfoia';
var MIN_LENGTH$1 = 5;
var hashids$1 = new Hashids(HASH_SALT$1, MIN_LENGTH$1);
/**
 * Decodes a string id into an int. Returns null if an invalid ID.
 */

var decodeHashId = function decodeHashId(id) {
  try {
    var ids = hashids$1.decode(id);
    if (!ids.length) return null;
    var num = Number(ids[0]);
    if (isNaN(num)) return null;
    return num;
  } catch (e) {
    return null;
  }
};
/**
 * Encodes an int to a string based hashid
 */

var encodeHashId = function encodeHashId(id) {
  try {
    if (id === null) return null;
    var encodedId = hashids$1.encode(id);
    return encodedId;
  } catch (e) {
    return null;
  }
};

var HashId = z.string().transform(function (data, context) {
  var id = decodeHashId(data);

  if (id === null) {
    context.addIssue({
      code: z.ZodIssueCode.custom,
      message: 'Hash id is invalid'
    });
    return z.NEVER;
  }

  return id;
});

var CreateGrantSchema = z.object({
  userId: HashId,
  appApiKey: z.custom(function (data) {
    return isApiKeyValid(data);
  })
});
var RevokeGrantSchema = z.object({
  userId: HashId,
  appApiKey: z.custom(function (data) {
    return isApiKeyValid(data);
  })
});

var GrantsApi = /*#__PURE__*/function () {
  function GrantsApi(_config, entityManager, auth) {
    _classCallCheck(this, GrantsApi);

    _defineProperty$1(this, "entityManager", void 0);

    _defineProperty$1(this, "auth", void 0);

    this.entityManager = entityManager;
    this.auth = auth;
  }
  /**
   * When user authorizes app to perform actions on their behalf
   */


  _createClass(GrantsApi, [{
    key: "createGrant",
    value: function () {
      var _createGrant = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var _yield$parseParams, userId, appApiKey;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return parseParams('createGrant', CreateGrantSchema)(params);

              case 2:
                _yield$parseParams = _context.sent;
                userId = _yield$parseParams.userId;
                appApiKey = _yield$parseParams.appApiKey;
                _context.next = 7;
                return this.entityManager.manageEntity({
                  userId: userId,
                  entityType: EntityType.GRANT,
                  entityId: 0,
                  action: Action.CREATE,
                  metadata: JSON.stringify({
                    grantee_address: "0x".concat(appApiKey)
                  }),
                  auth: this.auth
                });

              case 7:
                return _context.abrupt("return", _context.sent);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function createGrant(_x) {
        return _createGrant.apply(this, arguments);
      }

      return createGrant;
    }()
    /**
     * When user revokes an app's authorization to perform actions on their behalf
     */

  }, {
    key: "revokeGrant",
    value: function () {
      var _revokeGrant = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        var _yield$parseParams2, userId, appApiKey;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return parseParams('revokeGrant', RevokeGrantSchema)(params);

              case 2:
                _yield$parseParams2 = _context2.sent;
                userId = _yield$parseParams2.userId;
                appApiKey = _yield$parseParams2.appApiKey;
                _context2.next = 7;
                return this.entityManager.manageEntity({
                  userId: userId,
                  entityType: EntityType.GRANT,
                  entityId: 0,
                  action: Action.DELETE,
                  metadata: JSON.stringify({
                    grantee_address: "0x".concat(appApiKey)
                  }),
                  auth: this.auth
                });

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function revokeGrant(_x2) {
        return _revokeGrant.apply(this, arguments);
      }

      return revokeGrant;
    }()
  }]);

  return GrantsApi;
}();

var web3;

if (typeof window !== 'undefined' && window && window.Web3) {
  web3 = window.Web3;
} else {
  web3 = require('web3');
}

var Web3$1 = web3;

/* tslint:disable */

/* eslint-disable */

/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var BASE_PATH$1 = "/v1".replace(/\/+$/, "");
var Configuration$1 = /*#__PURE__*/function () {
  function Configuration() {
    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Configuration);

    _defineProperty$1(this, "configuration", void 0);

    this.configuration = configuration;
  }

  _createClass(Configuration, [{
    key: "config",
    set: function set(configuration) {
      this.configuration = configuration;
    }
  }, {
    key: "basePath",
    get: function get() {
      return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH$1;
    }
  }, {
    key: "fetchApi",
    get: function get() {
      return this.configuration.fetchApi;
    }
  }, {
    key: "middleware",
    get: function get() {
      return this.configuration.middleware || [];
    }
  }, {
    key: "queryParamsStringify",
    get: function get() {
      return this.configuration.queryParamsStringify || querystring$1;
    }
  }, {
    key: "username",
    get: function get() {
      return this.configuration.username;
    }
  }, {
    key: "password",
    get: function get() {
      return this.configuration.password;
    }
  }, {
    key: "apiKey",
    get: function get() {
      var apiKey = this.configuration.apiKey;

      if (apiKey) {
        return typeof apiKey === 'function' ? apiKey : function () {
          return apiKey;
        };
      }

      return undefined;
    }
  }, {
    key: "accessToken",
    get: function get() {
      var accessToken = this.configuration.accessToken;

      if (accessToken) {
        return typeof accessToken === 'function' ? accessToken : /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", accessToken);

                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
      }

      return undefined;
    }
  }, {
    key: "headers",
    get: function get() {
      return this.configuration.headers;
    }
  }, {
    key: "credentials",
    get: function get() {
      return this.configuration.credentials;
    }
  }]);

  return Configuration;
}();
var DefaultConfig$1 = new Configuration$1();
/**
 * This is the base class for all generated API classes.
 */

var BaseAPI$1 = /*#__PURE__*/function () {
  function BaseAPI() {
    var _this = this;

    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultConfig$1;

    _classCallCheck(this, BaseAPI);

    _defineProperty$1(this, "configuration", void 0);

    _defineProperty$1(this, "middleware", void 0);

    _defineProperty$1(this, "fetchApi", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url, init) {
        var fetchParams, _iterator, _step, _middleware, response, _iterator2, _step2, middleware, _iterator3, _step3, _middleware2;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                fetchParams = {
                  url: url,
                  init: init
                };
                _iterator = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 2;

                _iterator.s();

              case 4:
                if ((_step = _iterator.n()).done) {
                  _context2.next = 15;
                  break;
                }

                _middleware = _step.value;

                if (!_middleware.pre) {
                  _context2.next = 13;
                  break;
                }

                _context2.next = 9;
                return _middleware.pre(_objectSpread2({
                  fetch: _this.fetchApi
                }, fetchParams));

              case 9:
                _context2.t0 = _context2.sent;

                if (_context2.t0) {
                  _context2.next = 12;
                  break;
                }

                _context2.t0 = fetchParams;

              case 12:
                fetchParams = _context2.t0;

              case 13:
                _context2.next = 4;
                break;

              case 15:
                _context2.next = 20;
                break;

              case 17:
                _context2.prev = 17;
                _context2.t1 = _context2["catch"](2);

                _iterator.e(_context2.t1);

              case 20:
                _context2.prev = 20;

                _iterator.f();

                return _context2.finish(20);

              case 23:
                response = undefined;
                _context2.prev = 24;
                _context2.next = 27;
                return (_this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);

              case 27:
                response = _context2.sent;
                _context2.next = 60;
                break;

              case 30:
                _context2.prev = 30;
                _context2.t2 = _context2["catch"](24);
                _iterator2 = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 33;

                _iterator2.s();

              case 35:
                if ((_step2 = _iterator2.n()).done) {
                  _context2.next = 46;
                  break;
                }

                middleware = _step2.value;

                if (!middleware.onError) {
                  _context2.next = 44;
                  break;
                }

                _context2.next = 40;
                return middleware.onError({
                  fetch: _this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  error: _context2.t2,
                  response: response ? response.clone() : undefined
                });

              case 40:
                _context2.t3 = _context2.sent;

                if (_context2.t3) {
                  _context2.next = 43;
                  break;
                }

                _context2.t3 = response;

              case 43:
                response = _context2.t3;

              case 44:
                _context2.next = 35;
                break;

              case 46:
                _context2.next = 51;
                break;

              case 48:
                _context2.prev = 48;
                _context2.t4 = _context2["catch"](33);

                _iterator2.e(_context2.t4);

              case 51:
                _context2.prev = 51;

                _iterator2.f();

                return _context2.finish(51);

              case 54:
                if (!(response === undefined)) {
                  _context2.next = 60;
                  break;
                }

                if (!(_context2.t2 instanceof Error)) {
                  _context2.next = 59;
                  break;
                }

                throw new FetchError$1(_context2.t2, 'The request failed and the interceptors did not return an alternative response');

              case 59:
                throw _context2.t2;

              case 60:
                _iterator3 = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 61;

                _iterator3.s();

              case 63:
                if ((_step3 = _iterator3.n()).done) {
                  _context2.next = 74;
                  break;
                }

                _middleware2 = _step3.value;

                if (!_middleware2.post) {
                  _context2.next = 72;
                  break;
                }

                _context2.next = 68;
                return _middleware2.post({
                  fetch: _this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  response: response.clone()
                });

              case 68:
                _context2.t5 = _context2.sent;

                if (_context2.t5) {
                  _context2.next = 71;
                  break;
                }

                _context2.t5 = response;

              case 71:
                response = _context2.t5;

              case 72:
                _context2.next = 63;
                break;

              case 74:
                _context2.next = 79;
                break;

              case 76:
                _context2.prev = 76;
                _context2.t6 = _context2["catch"](61);

                _iterator3.e(_context2.t6);

              case 79:
                _context2.prev = 79;

                _iterator3.f();

                return _context2.finish(79);

              case 82:
                return _context2.abrupt("return", response);

              case 83:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[2, 17, 20, 23], [24, 30], [33, 48, 51, 54], [61, 76, 79, 82]]);
      }));

      return function (_x, _x2) {
        return _ref2.apply(this, arguments);
      };
    }());

    this.configuration = configuration;
    this.middleware = configuration.middleware;
  }
  /** @hidden */


  _createClass(BaseAPI, [{
    key: "withMiddleware",
    value: function withMiddleware() {
      var _next$middleware;

      var next = this.clone();
      next.middleware = (_next$middleware = next.middleware).concat.apply(_next$middleware, arguments);
      return next;
    }
    /** @hidden */

  }, {
    key: "withPreMiddleware",
    value: function withPreMiddleware() {
      for (var _len = arguments.length, preMiddlewares = new Array(_len), _key = 0; _key < _len; _key++) {
        preMiddlewares[_key] = arguments[_key];
      }

      var middlewares = preMiddlewares.map(function (pre) {
        return {
          pre: pre
        };
      });
      return this.withMiddleware.apply(this, _toConsumableArray(middlewares));
    }
    /** @hidden */

  }, {
    key: "withPostMiddleware",
    value: function withPostMiddleware() {
      for (var _len2 = arguments.length, postMiddlewares = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        postMiddlewares[_key2] = arguments[_key2];
      }

      var middlewares = postMiddlewares.map(function (post) {
        return {
          post: post
        };
      });
      return this.withMiddleware.apply(this, _toConsumableArray(middlewares));
    }
    /** @hidden */

  }, {
    key: "request",
    value: function () {
      var _request = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(context, initOverrides) {
        var _yield$this$createFet, url, init, response;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.createFetchParams(context, initOverrides);

              case 2:
                _yield$this$createFet = _context3.sent;
                url = _yield$this$createFet.url;
                init = _yield$this$createFet.init;
                _context3.next = 7;
                return this.fetchApi(url, init);

              case 7:
                response = _context3.sent;

                if (!(response && response.status >= 200 && response.status < 300)) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt("return", response);

              case 10:
                throw new ResponseError$1(response, 'Response returned an error code');

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function request(_x3, _x4) {
        return _request.apply(this, arguments);
      }

      return request;
    }()
  }, {
    key: "createFetchParams",
    value: function () {
      var _createFetchParams = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(context, initOverrides) {
        var url, headers, initOverrideFn, initParams, overriddenInit, init;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                url = this.configuration.basePath + context.path;

                if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                  // only add the querystring to the URL if there are query parameters.
                  // this is done to avoid urls ending with a "?" character which buggy webservers
                  // do not handle correctly sometimes.
                  url += '?' + this.configuration.queryParamsStringify(context.query);
                }

                headers = Object.assign({}, this.configuration.headers, context.headers);
                Object.keys(headers).forEach(function (key) {
                  return headers[key] === undefined ? delete headers[key] : {};
                });
                initOverrideFn = typeof initOverrides === "function" ? initOverrides : /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                  return regeneratorRuntime.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          return _context4.abrupt("return", initOverrides);

                        case 1:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                }));
                initParams = {
                  method: context.method,
                  headers: headers,
                  body: context.body,
                  credentials: this.configuration.credentials
                };
                _context5.t0 = _objectSpread2;
                _context5.t1 = _objectSpread2({}, initParams);
                _context5.next = 10;
                return initOverrideFn({
                  init: initParams,
                  context: context
                });

              case 10:
                _context5.t2 = _context5.sent;
                overriddenInit = (0, _context5.t0)(_context5.t1, _context5.t2);
                init = _objectSpread2(_objectSpread2({}, overriddenInit), {}, {
                  body: isFormData$1(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob$1(overriddenInit.body) || isString$1(overriddenInit.body) ? overriddenInit.body : JSON.stringify(overriddenInit.body)
                });
                return _context5.abrupt("return", {
                  url: url,
                  init: init
                });

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function createFetchParams(_x5, _x6) {
        return _createFetchParams.apply(this, arguments);
      }

      return createFetchParams;
    }()
  }, {
    key: "clone",
    value:
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    function clone() {
      var constructor = this.constructor;
      var next = new constructor(this.configuration);
      next.middleware = this.middleware.slice();
      return next;
    }
  }]);

  return BaseAPI;
}();

function isBlob$1(value) {
  return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData$1(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}

function isString$1(value) {
  return typeof value === 'string';
}

var ResponseError$1 = /*#__PURE__*/function (_Error) {
  _inherits(ResponseError, _Error);

  var _super = _createSuper(ResponseError);

  function ResponseError(response, msg) {
    var _this2;

    _classCallCheck(this, ResponseError);

    _this2 = _super.call(this, msg);

    _defineProperty$1(_assertThisInitialized(_this2), "response", void 0);

    _defineProperty$1(_assertThisInitialized(_this2), "name", "ResponseError");

    _this2.response = response;
    return _this2;
  }

  return _createClass(ResponseError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var FetchError$1 = /*#__PURE__*/function (_Error2) {
  _inherits(FetchError, _Error2);

  var _super2 = _createSuper(FetchError);

  function FetchError(cause, msg) {
    var _this3;

    _classCallCheck(this, FetchError);

    _this3 = _super2.call(this, msg);

    _defineProperty$1(_assertThisInitialized(_this3), "cause", void 0);

    _defineProperty$1(_assertThisInitialized(_this3), "name", "FetchError");

    _this3.cause = cause;
    return _this3;
  }

  return _createClass(FetchError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var RequiredError$1 = /*#__PURE__*/function (_Error3) {
  _inherits(RequiredError, _Error3);

  var _super3 = _createSuper(RequiredError);

  function RequiredError(field, msg) {
    var _this4;

    _classCallCheck(this, RequiredError);

    _this4 = _super3.call(this, msg);

    _defineProperty$1(_assertThisInitialized(_this4), "field", void 0);

    _defineProperty$1(_assertThisInitialized(_this4), "name", "RequiredError");

    _this4.field = field;
    return _this4;
  }

  return _createClass(RequiredError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var COLLECTION_FORMATS$1 = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|"
};
function exists$1(json, key) {
  var value = json[key];
  return value !== null && value !== undefined;
}
function querystring$1(params) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return Object.keys(params).sort().map(function (key) {
    return querystringSingleKey$1(key, params[key], prefix);
  }).filter(function (part) {
    return part.length > 0;
  }).join('&');
}

function querystringSingleKey$1(key, value) {
  var keyPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);

  if (value instanceof Array) {
    var multiValue = value.map(function (singleValue) {
      return encodeURIComponent(String(singleValue));
    }).join("&".concat(encodeURIComponent(fullKey), "="));
    return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
  }

  if (value instanceof Set) {
    var valueAsArray = Array.from(value);
    return querystringSingleKey$1(key, valueAsArray, keyPrefix);
  }

  if (value instanceof Date) {
    return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
  }

  if (value instanceof Object) {
    return querystring$1(value, fullKey);
  }

  return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
}

function mapValues$1(data, fn) {
  return Object.keys(data).reduce(function (acc, key) {
    return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty$1({}, key, fn(data[key])));
  }, {});
}
function canConsumeForm$1(consumes) {
  var _iterator4 = _createForOfIteratorHelper(consumes),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var consume = _step4.value;

      if ('multipart/form-data' === consume.contentType) {
        return true;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return false;
}
var JSONApiResponse$1 = /*#__PURE__*/function () {
  function JSONApiResponse(raw) {
    var transformer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (jsonValue) {
      return jsonValue;
    };

    _classCallCheck(this, JSONApiResponse);

    _defineProperty$1(this, "raw", void 0);

    _defineProperty$1(this, "transformer", void 0);

    this.raw = raw;
    this.transformer = transformer;
  }

  _createClass(JSONApiResponse, [{
    key: "value",
    value: function () {
      var _value = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.t0 = this;
                _context6.next = 3;
                return this.raw.json();

              case 3:
                _context6.t1 = _context6.sent;
                return _context6.abrupt("return", _context6.t0.transformer.call(_context6.t0, _context6.t1));

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function value() {
        return _value.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return JSONApiResponse;
}();
var VoidApiResponse$1 = /*#__PURE__*/function () {
  function VoidApiResponse(raw) {
    _classCallCheck(this, VoidApiResponse);

    _defineProperty$1(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass(VoidApiResponse, [{
    key: "value",
    value: function () {
      var _value2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", undefined);

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function value() {
        return _value2.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return VoidApiResponse;
}();
var BlobApiResponse$1 = /*#__PURE__*/function () {
  function BlobApiResponse(raw) {
    _classCallCheck(this, BlobApiResponse);

    _defineProperty$1(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass(BlobApiResponse, [{
    key: "value",
    value: function () {
      var _value3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.raw.blob();

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function value() {
        return _value3.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return BlobApiResponse;
}();
var TextApiResponse$1 = /*#__PURE__*/function () {
  function TextApiResponse(raw) {
    _classCallCheck(this, TextApiResponse);

    _defineProperty$1(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass(TextApiResponse, [{
    key: "value",
    value: function () {
      var _value4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.raw.text();

              case 2:
                return _context9.abrupt("return", _context9.sent);

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function value() {
        return _value4.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return TextApiResponse;
}();

/* tslint:disable */
/**
 * Check if a given object implements the Activity interface.
 */

function instanceOfActivity(value) {
  var isInstance = true;
  return isInstance;
}
function ActivityFromJSON(json) {
  return ActivityFromJSONTyped(json);
}
function ActivityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'timestamp': !exists$1(json, 'timestamp') ? undefined : json['timestamp'],
    'itemType': !exists$1(json, 'item_type') ? undefined : json['item_type'],
    'item': !exists$1(json, 'item') ? undefined : json['item']
  };
}
function ActivityToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': value.item
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AuthorizedApp interface.
 */

function instanceOfAuthorizedApp(value) {
  var isInstance = true;
  isInstance = isInstance && "address" in value;
  isInstance = isInstance && "name" in value;
  isInstance = isInstance && "grantorUserId" in value;
  isInstance = isInstance && "grantCreatedAt" in value;
  isInstance = isInstance && "grantUpdatedAt" in value;
  return isInstance;
}
function AuthorizedAppFromJSON(json) {
  return AuthorizedAppFromJSONTyped(json);
}
function AuthorizedAppFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'address': json['address'],
    'name': json['name'],
    'description': !exists$1(json, 'description') ? undefined : json['description'],
    'grantorUserId': json['grantor_user_id'],
    'grantCreatedAt': json['grant_created_at'],
    'grantUpdatedAt': json['grant_updated_at']
  };
}
function AuthorizedAppToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'address': value.address,
    'name': value.name,
    'description': value.description,
    'grantor_user_id': value.grantorUserId,
    'grant_created_at': value.grantCreatedAt,
    'grant_updated_at': value.grantUpdatedAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AuthorizedApps interface.
 */

function instanceOfAuthorizedApps(value) {
  var isInstance = true;
  return isInstance;
}
function AuthorizedAppsFromJSON(json) {
  return AuthorizedAppsFromJSONTyped(json);
}
function AuthorizedAppsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(AuthorizedAppFromJSON)
  };
}
function AuthorizedAppsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(AuthorizedAppToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ConnectedWallets interface.
 */

function instanceOfConnectedWallets(value) {
  var isInstance = true;
  isInstance = isInstance && "ercWallets" in value;
  isInstance = isInstance && "splWallets" in value;
  return isInstance;
}
function ConnectedWalletsFromJSON(json) {
  return ConnectedWalletsFromJSONTyped(json);
}
function ConnectedWalletsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'ercWallets': json['erc_wallets'],
    'splWallets': json['spl_wallets']
  };
}
function ConnectedWalletsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'erc_wallets': value.ercWallets,
    'spl_wallets': value.splWallets
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ConnectedWalletsResponse interface.
 */

function instanceOfConnectedWalletsResponse(value) {
  var isInstance = true;
  return isInstance;
}
function ConnectedWalletsResponseFromJSON(json) {
  return ConnectedWalletsResponseFromJSONTyped(json);
}
function ConnectedWalletsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : ConnectedWalletsFromJSON(json['data'])
  };
}
function ConnectedWalletsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': ConnectedWalletsToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoverPhoto interface.
 */

function instanceOfCoverPhoto$1(value) {
  var isInstance = true;
  return isInstance;
}
function CoverPhotoFromJSON$1(json) {
  return CoverPhotoFromJSONTyped$1(json);
}
function CoverPhotoFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_640x': !exists$1(json, '640x') ? undefined : json['640x'],
    '_2000x': !exists$1(json, '2000x') ? undefined : json['2000x']
  };
}
function CoverPhotoToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '640x': value._640x,
    '2000x': value._2000x
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ProfilePicture interface.
 */

function instanceOfProfilePicture$1(value) {
  var isInstance = true;
  return isInstance;
}
function ProfilePictureFromJSON$1(json) {
  return ProfilePictureFromJSONTyped$1(json);
}
function ProfilePictureFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists$1(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists$1(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists$1(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function ProfilePictureToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DecodedUserToken interface.
 */

function instanceOfDecodedUserToken(value) {
  var isInstance = true;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "email" in value;
  isInstance = isInstance && "name" in value;
  isInstance = isInstance && "handle" in value;
  isInstance = isInstance && "verified" in value;
  isInstance = isInstance && "sub" in value;
  isInstance = isInstance && "iat" in value;
  return isInstance;
}
function DecodedUserTokenFromJSON(json) {
  return DecodedUserTokenFromJSONTyped(json);
}
function DecodedUserTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': json['userId'],
    'email': json['email'],
    'name': json['name'],
    'handle': json['handle'],
    'verified': json['verified'],
    'profilePicture': !exists$1(json, 'profilePicture') ? undefined : ProfilePictureFromJSON$1(json['profilePicture']),
    'sub': json['sub'],
    'iat': json['iat']
  };
}
function DecodedUserTokenToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'userId': value.userId,
    'email': value.email,
    'name': value.name,
    'handle': value.handle,
    'verified': value.verified,
    'profilePicture': ProfilePictureToJSON$1(value.profilePicture),
    'sub': value.sub,
    'iat': value.iat
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DeveloperApp interface.
 */

function instanceOfDeveloperApp(value) {
  var isInstance = true;
  isInstance = isInstance && "address" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "name" in value;
  return isInstance;
}
function DeveloperAppFromJSON(json) {
  return DeveloperAppFromJSONTyped(json);
}
function DeveloperAppFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'address': json['address'],
    'userId': json['user_id'],
    'name': json['name'],
    'description': !exists$1(json, 'description') ? undefined : json['description']
  };
}
function DeveloperAppToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'address': value.address,
    'user_id': value.userId,
    'name': value.name,
    'description': value.description
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DeveloperAppResponse interface.
 */

function instanceOfDeveloperAppResponse(value) {
  var isInstance = true;
  return isInstance;
}
function DeveloperAppResponseFromJSON(json) {
  return DeveloperAppResponseFromJSONTyped(json);
}
function DeveloperAppResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : DeveloperAppFromJSON(json['data'])
  };
}
function DeveloperAppResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': DeveloperAppToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DeveloperApps interface.
 */

function instanceOfDeveloperApps(value) {
  var isInstance = true;
  return isInstance;
}
function DeveloperAppsFromJSON(json) {
  return DeveloperAppsFromJSONTyped(json);
}
function DeveloperAppsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(DeveloperAppFromJSON)
  };
}
function DeveloperAppsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(DeveloperAppToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the EncodedUserId interface.
 */

function instanceOfEncodedUserId(value) {
  var isInstance = true;
  return isInstance;
}
function EncodedUserIdFromJSON(json) {
  return EncodedUserIdFromJSONTyped(json);
}
function EncodedUserIdFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': !exists$1(json, 'user_id') ? undefined : json['user_id']
  };
}
function EncodedUserIdToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'user_id': value.userId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Favorite interface.
 */

function instanceOfFavorite$1(value) {
  var isInstance = true;
  isInstance = isInstance && "favoriteItemId" in value;
  isInstance = isInstance && "favoriteType" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "createdAt" in value;
  return isInstance;
}
function FavoriteFromJSON$1(json) {
  return FavoriteFromJSONTyped$1(json);
}
function FavoriteFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'favoriteItemId': json['favorite_item_id'],
    'favoriteType': json['favorite_type'],
    'userId': json['user_id'],
    'createdAt': json['created_at']
  };
}
function FavoriteToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'favorite_item_id': value.favoriteItemId,
    'favorite_type': value.favoriteType,
    'user_id': value.userId,
    'created_at': value.createdAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FavoritesResponse interface.
 */

function instanceOfFavoritesResponse(value) {
  var isInstance = true;
  return isInstance;
}
function FavoritesResponseFromJSON(json) {
  return FavoritesResponseFromJSONTyped(json);
}
function FavoritesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(FavoriteFromJSON$1)
  };
}
function FavoritesResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(FavoriteToJSON$1)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the User interface.
 */

function instanceOfUser(value) {
  var isInstance = true;
  isInstance = isInstance && "albumCount" in value;
  isInstance = isInstance && "followeeCount" in value;
  isInstance = isInstance && "followerCount" in value;
  isInstance = isInstance && "handle" in value;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isVerified" in value;
  isInstance = isInstance && "name" in value;
  isInstance = isInstance && "playlistCount" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "trackCount" in value;
  isInstance = isInstance && "isDeactivated" in value;
  isInstance = isInstance && "isAvailable" in value;
  isInstance = isInstance && "ercWallet" in value;
  isInstance = isInstance && "splWallet" in value;
  isInstance = isInstance && "supporterCount" in value;
  isInstance = isInstance && "supportingCount" in value;
  isInstance = isInstance && "totalAudioBalance" in value;
  return isInstance;
}
function UserFromJSON(json) {
  return UserFromJSONTyped(json);
}
function UserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'albumCount': json['album_count'],
    'artistPickTrackId': !exists$1(json, 'artist_pick_track_id') ? undefined : json['artist_pick_track_id'],
    'bio': !exists$1(json, 'bio') ? undefined : json['bio'],
    'coverPhoto': !exists$1(json, 'cover_photo') ? undefined : CoverPhotoFromJSON$1(json['cover_photo']),
    'followeeCount': json['followee_count'],
    'followerCount': json['follower_count'],
    'doesFollowCurrentUser': !exists$1(json, 'does_follow_current_user') ? undefined : json['does_follow_current_user'],
    'handle': json['handle'],
    'id': json['id'],
    'isVerified': json['is_verified'],
    'location': !exists$1(json, 'location') ? undefined : json['location'],
    'name': json['name'],
    'playlistCount': json['playlist_count'],
    'profilePicture': !exists$1(json, 'profile_picture') ? undefined : ProfilePictureFromJSON$1(json['profile_picture']),
    'repostCount': json['repost_count'],
    'trackCount': json['track_count'],
    'isDeactivated': json['is_deactivated'],
    'isAvailable': json['is_available'],
    'ercWallet': json['erc_wallet'],
    'splWallet': json['spl_wallet'],
    'supporterCount': json['supporter_count'],
    'supportingCount': json['supporting_count'],
    'totalAudioBalance': json['total_audio_balance']
  };
}
function UserToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'album_count': value.albumCount,
    'artist_pick_track_id': value.artistPickTrackId,
    'bio': value.bio,
    'cover_photo': CoverPhotoToJSON$1(value.coverPhoto),
    'followee_count': value.followeeCount,
    'follower_count': value.followerCount,
    'does_follow_current_user': value.doesFollowCurrentUser,
    'handle': value.handle,
    'id': value.id,
    'is_verified': value.isVerified,
    'location': value.location,
    'name': value.name,
    'playlist_count': value.playlistCount,
    'profile_picture': ProfilePictureToJSON$1(value.profilePicture),
    'repost_count': value.repostCount,
    'track_count': value.trackCount,
    'is_deactivated': value.isDeactivated,
    'is_available': value.isAvailable,
    'erc_wallet': value.ercWallet,
    'spl_wallet': value.splWallet,
    'supporter_count': value.supporterCount,
    'supporting_count': value.supportingCount,
    'total_audio_balance': value.totalAudioBalance
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowersResponse interface.
 */

function instanceOfFollowersResponse(value) {
  var isInstance = true;
  return isInstance;
}
function FollowersResponseFromJSON(json) {
  return FollowersResponseFromJSONTyped(json);
}
function FollowersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function FollowersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowingResponse interface.
 */

function instanceOfFollowingResponse$1(value) {
  var isInstance = true;
  return isInstance;
}
function FollowingResponseFromJSON$1(json) {
  return FollowingResponseFromJSONTyped$1(json);
}
function FollowingResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function FollowingResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Supporter interface.
 */

function instanceOfSupporter(value) {
  var isInstance = true;
  isInstance = isInstance && "rank" in value;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "sender" in value;
  return isInstance;
}
function SupporterFromJSON(json) {
  return SupporterFromJSONTyped(json);
}
function SupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'sender': UserFromJSON(json['sender'])
  };
}
function SupporterToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'rank': value.rank,
    'amount': value.amount,
    'sender': UserToJSON(value.sender)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetSupporters interface.
 */

function instanceOfGetSupporters(value) {
  var isInstance = true;
  return isInstance;
}
function GetSupportersFromJSON(json) {
  return GetSupportersFromJSONTyped(json);
}
function GetSupportersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(SupporterFromJSON)
  };
}
function GetSupportersToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(SupporterToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Supporting interface.
 */

function instanceOfSupporting(value) {
  var isInstance = true;
  isInstance = isInstance && "rank" in value;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "receiver" in value;
  return isInstance;
}
function SupportingFromJSON(json) {
  return SupportingFromJSONTyped(json);
}
function SupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'receiver': UserFromJSON(json['receiver'])
  };
}
function SupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'rank': value.rank,
    'amount': value.amount,
    'receiver': UserToJSON(value.receiver)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetSupporting interface.
 */

function instanceOfGetSupporting(value) {
  var isInstance = true;
  return isInstance;
}
function GetSupportingFromJSON(json) {
  return GetSupportingFromJSONTyped(json);
}
function GetSupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(SupportingFromJSON)
  };
}
function GetSupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(SupportingToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Tip interface.
 */

function instanceOfTip(value) {
  var isInstance = true;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "createdAt" in value;
  return isInstance;
}
function TipFromJSON(json) {
  return TipFromJSONTyped(json);
}
function TipFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'amount': json['amount'],
    'sender': !exists$1(json, 'sender') ? undefined : UserFromJSON(json['sender']),
    'receiver': !exists$1(json, 'receiver') ? undefined : UserFromJSON(json['receiver']),
    'createdAt': json['created_at']
  };
}
function TipToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'amount': value.amount,
    'sender': UserToJSON(value.sender),
    'receiver': UserToJSON(value.receiver),
    'created_at': value.createdAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetTipsResponse interface.
 */

function instanceOfGetTipsResponse$1(value) {
  var isInstance = true;
  return isInstance;
}
function GetTipsResponseFromJSON$1(json) {
  return GetTipsResponseFromJSONTyped$1(json);
}
function GetTipsResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(TipFromJSON)
  };
}
function GetTipsResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(TipToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistAddedTimestamp interface.
 */

function instanceOfPlaylistAddedTimestamp$1(value) {
  var isInstance = true;
  isInstance = isInstance && "metadataTimestamp" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "trackId" in value;
  return isInstance;
}
function PlaylistAddedTimestampFromJSON$1(json) {
  return PlaylistAddedTimestampFromJSONTyped$1(json);
}
function PlaylistAddedTimestampFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'metadataTimestamp': json['metadata_timestamp'],
    'timestamp': json['timestamp'],
    'trackId': json['track_id']
  };
}
function PlaylistAddedTimestampToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'metadata_timestamp': value.metadataTimestamp,
    'timestamp': value.timestamp,
    'track_id': value.trackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistArtwork interface.
 */

function instanceOfPlaylistArtwork$1(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistArtworkFromJSON$1(json) {
  return PlaylistArtworkFromJSONTyped$1(json);
}
function PlaylistArtworkFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists$1(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists$1(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists$1(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function PlaylistArtworkToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Playlist interface.
 */

function instanceOfPlaylist(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isAlbum" in value;
  isInstance = isInstance && "isImageAutogenerated" in value;
  isInstance = isInstance && "playlistName" in value;
  isInstance = isInstance && "playlistContents" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "totalPlayCount" in value;
  isInstance = isInstance && "user" in value;
  return isInstance;
}
function PlaylistFromJSON(json) {
  return PlaylistFromJSONTyped(json);
}
function PlaylistFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists$1(json, 'artwork') ? undefined : PlaylistArtworkFromJSON$1(json['artwork']),
    'description': !exists$1(json, 'description') ? undefined : json['description'],
    'permalink': !exists$1(json, 'permalink') ? undefined : json['permalink'],
    'id': json['id'],
    'isAlbum': json['is_album'],
    'isImageAutogenerated': json['is_image_autogenerated'],
    'playlistName': json['playlist_name'],
    'playlistContents': json['playlist_contents'].map(PlaylistAddedTimestampFromJSON$1),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'totalPlayCount': json['total_play_count'],
    'user': UserFromJSON(json['user'])
  };
}
function PlaylistToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': PlaylistArtworkToJSON$1(value.artwork),
    'description': value.description,
    'permalink': value.permalink,
    'id': value.id,
    'is_album': value.isAlbum,
    'is_image_autogenerated': value.isImageAutogenerated,
    'playlist_name': value.playlistName,
    'playlist_contents': value.playlistContents.map(PlaylistAddedTimestampToJSON$1),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'total_play_count': value.totalPlayCount,
    'user': UserToJSON(value.user)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistResponse interface.
 */

function instanceOfPlaylistResponse(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistResponseFromJSON(json) {
  return PlaylistResponseFromJSONTyped(json);
}
function PlaylistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(PlaylistFromJSON)
  };
}
function PlaylistResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(PlaylistToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistSearchResult interface.
 */

function instanceOfPlaylistSearchResult(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistSearchResultFromJSON(json) {
  return PlaylistSearchResultFromJSONTyped(json);
}
function PlaylistSearchResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(PlaylistFromJSON)
  };
}
function PlaylistSearchResultToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(PlaylistToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackElement interface.
 */

function instanceOfTrackElement(value) {
  var isInstance = true;
  isInstance = isInstance && "parentTrackId" in value;
  return isInstance;
}
function TrackElementFromJSON(json) {
  return TrackElementFromJSONTyped(json);
}
function TrackElementFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'parentTrackId': json['parent_track_id']
  };
}
function TrackElementToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'parent_track_id': value.parentTrackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixParent interface.
 */

function instanceOfRemixParent(value) {
  var isInstance = true;
  return isInstance;
}
function RemixParentFromJSON(json) {
  return RemixParentFromJSONTyped(json);
}
function RemixParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'tracks': !exists$1(json, 'tracks') ? undefined : json['tracks'].map(TrackElementFromJSON)
  };
}
function RemixParentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackElementToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackArtwork interface.
 */

function instanceOfTrackArtwork$1(value) {
  var isInstance = true;
  return isInstance;
}
function TrackArtworkFromJSON$1(json) {
  return TrackArtworkFromJSONTyped$1(json);
}
function TrackArtworkFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists$1(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists$1(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists$1(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function TrackArtworkToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Track interface.
 */

function instanceOfTrack(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "title" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "duration" in value;
  isInstance = isInstance && "playCount" in value;
  return isInstance;
}
function TrackFromJSON(json) {
  return TrackFromJSONTyped(json);
}
function TrackFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists$1(json, 'artwork') ? undefined : TrackArtworkFromJSON$1(json['artwork']),
    'description': !exists$1(json, 'description') ? undefined : json['description'],
    'genre': !exists$1(json, 'genre') ? undefined : json['genre'],
    'id': json['id'],
    'trackCid': !exists$1(json, 'track_cid') ? undefined : json['track_cid'],
    'previewCid': !exists$1(json, 'preview_cid') ? undefined : json['preview_cid'],
    'mood': !exists$1(json, 'mood') ? undefined : json['mood'],
    'releaseDate': !exists$1(json, 'release_date') ? undefined : json['release_date'],
    'remixOf': !exists$1(json, 'remix_of') ? undefined : RemixParentFromJSON(json['remix_of']),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'tags': !exists$1(json, 'tags') ? undefined : json['tags'],
    'title': json['title'],
    'user': UserFromJSON(json['user']),
    'duration': json['duration'],
    'downloadable': !exists$1(json, 'downloadable') ? undefined : json['downloadable'],
    'playCount': json['play_count'],
    'permalink': !exists$1(json, 'permalink') ? undefined : json['permalink'],
    'isStreamable': !exists$1(json, 'is_streamable') ? undefined : json['is_streamable']
  };
}
function TrackToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': TrackArtworkToJSON$1(value.artwork),
    'description': value.description,
    'genre': value.genre,
    'id': value.id,
    'track_cid': value.trackCid,
    'preview_cid': value.previewCid,
    'mood': value.mood,
    'release_date': value.releaseDate,
    'remix_of': RemixParentToJSON(value.remixOf),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'tags': value.tags,
    'title': value.title,
    'user': UserToJSON(value.user),
    'duration': value.duration,
    'downloadable': value.downloadable,
    'play_count': value.playCount,
    'permalink': value.permalink,
    'is_streamable': value.isStreamable
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistTracksResponse interface.
 */

function instanceOfPlaylistTracksResponse(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistTracksResponseFromJSON(json) {
  return PlaylistTracksResponseFromJSONTyped(json);
}
function PlaylistTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(TrackFromJSON)
  };
}
function PlaylistTracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(TrackToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RelatedArtistResponse interface.
 */

function instanceOfRelatedArtistResponse(value) {
  var isInstance = true;
  return isInstance;
}
function RelatedArtistResponseFromJSON(json) {
  return RelatedArtistResponseFromJSONTyped(json);
}
function RelatedArtistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function RelatedArtistResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Reposts interface.
 */

function instanceOfReposts(value) {
  var isInstance = true;
  return isInstance;
}
function RepostsFromJSON(json) {
  return RepostsFromJSONTyped(json);
}
function RepostsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(ActivityFromJSON)
  };
}
function RepostsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(ActivityToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SubscribersResponse interface.
 */

function instanceOfSubscribersResponse(value) {
  var isInstance = true;
  return isInstance;
}
function SubscribersResponseFromJSON(json) {
  return SubscribersResponseFromJSONTyped(json);
}
function SubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function SubscribersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TagsResponse interface.
 */

function instanceOfTagsResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TagsResponseFromJSON(json) {
  return TagsResponseFromJSONTyped(json);
}
function TagsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data']
  };
}
function TagsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackResponse interface.
 */

function instanceOfTrackResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TrackResponseFromJSON(json) {
  return TrackResponseFromJSONTyped(json);
}
function TrackResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : TrackFromJSON(json['data'])
  };
}
function TrackResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': TrackToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackSearch interface.
 */

function instanceOfTrackSearch(value) {
  var isInstance = true;
  return isInstance;
}
function TrackSearchFromJSON(json) {
  return TrackSearchFromJSONTyped(json);
}
function TrackSearchFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(TrackFromJSON)
  };
}
function TrackSearchToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(TrackToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TracksResponse interface.
 */

function instanceOfTracksResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TracksResponseFromJSON(json) {
  return TracksResponseFromJSONTyped(json);
}
function TracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(TrackFromJSON)
  };
}
function TracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(TrackToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingPlaylistsResponse interface.
 */

function instanceOfTrendingPlaylistsResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TrendingPlaylistsResponseFromJSON(json) {
  return TrendingPlaylistsResponseFromJSONTyped(json);
}
function TrendingPlaylistsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(PlaylistFromJSON)
  };
}
function TrendingPlaylistsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(PlaylistToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserAssociatedWalletResponse interface.
 */

function instanceOfUserAssociatedWalletResponse(value) {
  var isInstance = true;
  return isInstance;
}
function UserAssociatedWalletResponseFromJSON(json) {
  return UserAssociatedWalletResponseFromJSONTyped(json);
}
function UserAssociatedWalletResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : EncodedUserIdFromJSON(json['data'])
  };
}
function UserAssociatedWalletResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': EncodedUserIdToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserResponse interface.
 */

function instanceOfUserResponse(value) {
  var isInstance = true;
  return isInstance;
}
function UserResponseFromJSON(json) {
  return UserResponseFromJSONTyped(json);
}
function UserResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : UserFromJSON(json['data'])
  };
}
function UserResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': UserToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserSearch interface.
 */

function instanceOfUserSearch(value) {
  var isInstance = true;
  return isInstance;
}
function UserSearchFromJSON(json) {
  return UserSearchFromJSONTyped(json);
}
function UserSearchFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function UserSearchToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the VerifyToken interface.
 */

function instanceOfVerifyToken(value) {
  var isInstance = true;
  return isInstance;
}
function VerifyTokenFromJSON(json) {
  return VerifyTokenFromJSONTyped(json);
}
function VerifyTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists$1(json, 'data') ? undefined : DecodedUserTokenFromJSON(json['data'])
  };
}
function VerifyTokenToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': DecodedUserTokenToJSON(value.data)
  };
}

/**
 *
 */

var DeveloperAppsApi$1 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(DeveloperAppsApi, _runtime$BaseAPI);

  var _super = _createSuper(DeveloperAppsApi);

  function DeveloperAppsApi() {
    _classCallCheck(this, DeveloperAppsApi);

    return _super.apply(this, arguments);
  }

  _createClass(DeveloperAppsApi, [{
    key: "getDeveloperAppRaw",
    value:
    /** @hidden
     * Gets developer app matching given address (API key)
     */
    function () {
      var _getDeveloperAppRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.address === null || params.address === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('address', 'Required parameter params.address was null or undefined when calling getDeveloperApp.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context.next = 6;
                return this.request({
                  path: "/developer_apps/{address}".replace("{".concat("address", "}"), encodeURIComponent(String(params.address))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return DeveloperAppResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getDeveloperAppRaw(_x, _x2) {
        return _getDeveloperAppRaw.apply(this, arguments);
      }

      return getDeveloperAppRaw;
    }()
    /**
     * Gets developer app matching given address (API key)
     */

  }, {
    key: "getDeveloperApp",
    value: function () {
      var _getDeveloperApp = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getDeveloperAppRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getDeveloperApp(_x3, _x4) {
        return _getDeveloperApp.apply(this, arguments);
      }

      return getDeveloperApp;
    }()
  }]);

  return DeveloperAppsApi;
}(BaseAPI$1);

/**
 *
 */

var PlaylistsApi$2 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(PlaylistsApi, _runtime$BaseAPI);

  var _super = _createSuper(PlaylistsApi);

  function PlaylistsApi() {
    _classCallCheck(this, PlaylistsApi);

    return _super.apply(this, arguments);
  }

  _createClass(PlaylistsApi, [{
    key: "getPlaylistRaw",
    value:
    /** @hidden
     * Get a playlist by ID
     */
    function () {
      var _getPlaylistRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylist.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context.next = 7;
                return this.request({
                  path: "/playlists/{playlist_id}".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return PlaylistResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getPlaylistRaw(_x, _x2) {
        return _getPlaylistRaw.apply(this, arguments);
      }

      return getPlaylistRaw;
    }()
    /**
     * Get a playlist by ID
     */

  }, {
    key: "getPlaylist",
    value: function () {
      var _getPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getPlaylistRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getPlaylist(_x3, _x4) {
        return _getPlaylist.apply(this, arguments);
      }

      return getPlaylist;
    }()
    /** @hidden
     * Fetch tracks within a playlist.
     */

  }, {
    key: "getPlaylistTracksRaw",
    value: function () {
      var _getPlaylistTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError$1('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylistTracks.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context3.next = 6;
                return this.request({
                  path: "/playlists/{playlist_id}/tracks".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return PlaylistTracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getPlaylistTracksRaw(_x5, _x6) {
        return _getPlaylistTracksRaw.apply(this, arguments);
      }

      return getPlaylistTracksRaw;
    }()
    /**
     * Fetch tracks within a playlist.
     */

  }, {
    key: "getPlaylistTracks",
    value: function () {
      var _getPlaylistTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getPlaylistTracksRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getPlaylistTracks(_x7, _x8) {
        return _getPlaylistTracks.apply(this, arguments);
      }

      return getPlaylistTracks;
    }()
    /** @hidden
     * Gets trending playlists for a time period
     */

  }, {
    key: "getTrendingPlaylistsRaw",
    value: function () {
      var _getTrendingPlaylistsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                queryParameters = {};

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context5.next = 5;
                return this.request({
                  path: "/playlists/trending",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 5:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TrendingPlaylistsResponseFromJSON(jsonValue);
                }));

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getTrendingPlaylistsRaw(_x9, _x10) {
        return _getTrendingPlaylistsRaw.apply(this, arguments);
      }

      return getTrendingPlaylistsRaw;
    }()
    /**
     * Gets trending playlists for a time period
     */

  }, {
    key: "getTrendingPlaylists",
    value: function () {
      var _getTrendingPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var params,
            initOverrides,
            response,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                params = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
                initOverrides = _args6.length > 1 ? _args6[1] : undefined;
                _context6.next = 4;
                return this.getTrendingPlaylistsRaw(params, initOverrides);

              case 4:
                response = _context6.sent;
                _context6.next = 7;
                return response.value();

              case 7:
                return _context6.abrupt("return", _context6.sent);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getTrendingPlaylists() {
        return _getTrendingPlaylists.apply(this, arguments);
      }

      return getTrendingPlaylists;
    }()
    /** @hidden
     * Search for a playlist
     */

  }, {
    key: "searchPlaylistsRaw",
    value: function () {
      var _searchPlaylistsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context7.next = 2;
                  break;
                }

                throw new RequiredError$1('query', 'Required parameter params.query was null or undefined when calling searchPlaylists.');

              case 2:
                queryParameters = {};

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                headerParameters = {};
                _context7.next = 7;
                return this.request({
                  path: "/playlists/search",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return PlaylistSearchResultFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function searchPlaylistsRaw(_x11, _x12) {
        return _searchPlaylistsRaw.apply(this, arguments);
      }

      return searchPlaylistsRaw;
    }()
    /**
     * Search for a playlist
     */

  }, {
    key: "searchPlaylists",
    value: function () {
      var _searchPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.searchPlaylistsRaw(params, initOverrides);

              case 2:
                response = _context8.sent;
                _context8.next = 5;
                return response.value();

              case 5:
                return _context8.abrupt("return", _context8.sent);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function searchPlaylists(_x13, _x14) {
        return _searchPlaylists.apply(this, arguments);
      }

      return searchPlaylists;
    }()
  }]);

  return PlaylistsApi;
}(BaseAPI$1);
/**
 * @export
 */

var GetTrendingPlaylistsTimeEnum$1 = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};

/**
 *
 */

var TipsApi$1 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TipsApi, _runtime$BaseAPI);

  var _super = _createSuper(TipsApi);

  function TipsApi() {
    _classCallCheck(this, TipsApi);

    return _super.apply(this, arguments);
  }

  _createClass(TipsApi, [{
    key: "getTipsRaw",
    value:
    /** @hidden
     * Gets the most recent tips on the network
     */
    function () {
      var _getTipsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.receiverMinFollowers !== undefined) {
                  queryParameters['receiver_min_followers'] = params.receiverMinFollowers;
                }

                if (params.receiverIsVerified !== undefined) {
                  queryParameters['receiver_is_verified'] = params.receiverIsVerified;
                }

                if (params.currentUserFollows !== undefined) {
                  queryParameters['current_user_follows'] = params.currentUserFollows;
                }

                if (params.uniqueBy !== undefined) {
                  queryParameters['unique_by'] = params.uniqueBy;
                }

                headerParameters = {};
                _context.next = 11;
                return this.request({
                  path: "/tips",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return GetTipsResponseFromJSON$1(jsonValue);
                }));

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getTipsRaw(_x, _x2) {
        return _getTipsRaw.apply(this, arguments);
      }

      return getTipsRaw;
    }()
    /**
     * Gets the most recent tips on the network
     */

  }, {
    key: "getTips",
    value: function () {
      var _getTips = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var params,
            initOverrides,
            response,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                params = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                initOverrides = _args2.length > 1 ? _args2[1] : undefined;
                _context2.next = 4;
                return this.getTipsRaw(params, initOverrides);

              case 4:
                response = _context2.sent;
                _context2.next = 7;
                return response.value();

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getTips() {
        return _getTips.apply(this, arguments);
      }

      return getTips;
    }()
  }]);

  return TipsApi;
}(BaseAPI$1);
/**
 * @export
 */

var GetTipsCurrentUserFollowsEnum$1 = {
  Sender: 'sender',
  Receiver: 'receiver',
  SenderOrReceiver: 'sender_or_receiver'
};
/**
 * @export
 */

var GetTipsUniqueByEnum$1 = {
  Sender: 'sender',
  Receiver: 'receiver'
};

/**
 *
 */

var TracksApi$2 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TracksApi, _runtime$BaseAPI);

  var _super = _createSuper(TracksApi);

  function TracksApi() {
    _classCallCheck(this, TracksApi);

    return _super.apply(this, arguments);
  }

  _createClass(TracksApi, [{
    key: "getBulkTracksRaw",
    value:
    /** @hidden
     * Gets a list of tracks using their IDs or permalinks
     */
    function () {
      var _getBulkTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                queryParameters = {};

                if (params.permalink) {
                  queryParameters['permalink'] = params.permalink;
                }

                if (params.id) {
                  queryParameters['id'] = params.id;
                }

                headerParameters = {};
                _context.next = 6;
                return this.request({
                  path: "/tracks",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getBulkTracksRaw(_x, _x2) {
        return _getBulkTracksRaw.apply(this, arguments);
      }

      return getBulkTracksRaw;
    }()
    /**
     * Gets a list of tracks using their IDs or permalinks
     */

  }, {
    key: "getBulkTracks",
    value: function () {
      var _getBulkTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var params,
            initOverrides,
            response,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                params = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                initOverrides = _args2.length > 1 ? _args2[1] : undefined;
                _context2.next = 4;
                return this.getBulkTracksRaw(params, initOverrides);

              case 4:
                response = _context2.sent;
                _context2.next = 7;
                return response.value();

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getBulkTracks() {
        return _getBulkTracks.apply(this, arguments);
      }

      return getBulkTracks;
    }()
    /** @hidden
     * Gets a track by ID
     */

  }, {
    key: "getTrackRaw",
    value: function () {
      var _getTrackRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrack.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context3.next = 6;
                return this.request({
                  path: "/tracks/{track_id}".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TrackResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getTrackRaw(_x3, _x4) {
        return _getTrackRaw.apply(this, arguments);
      }

      return getTrackRaw;
    }()
    /**
     * Gets a track by ID
     */

  }, {
    key: "getTrack",
    value: function () {
      var _getTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getTrackRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getTrack(_x5, _x6) {
        return _getTrack.apply(this, arguments);
      }

      return getTrack;
    }()
    /** @hidden
     * Gets the top 100 trending (most popular) tracks on Audius
     */

  }, {
    key: "getTrendingTracksRaw",
    value: function () {
      var _getTrendingTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                queryParameters = {};

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context5.next = 6;
                return this.request({
                  path: "/tracks/trending",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getTrendingTracksRaw(_x7, _x8) {
        return _getTrendingTracksRaw.apply(this, arguments);
      }

      return getTrendingTracksRaw;
    }()
    /**
     * Gets the top 100 trending (most popular) tracks on Audius
     */

  }, {
    key: "getTrendingTracks",
    value: function () {
      var _getTrendingTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var params,
            initOverrides,
            response,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                params = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
                initOverrides = _args6.length > 1 ? _args6[1] : undefined;
                _context6.next = 4;
                return this.getTrendingTracksRaw(params, initOverrides);

              case 4:
                response = _context6.sent;
                _context6.next = 7;
                return response.value();

              case 7:
                return _context6.abrupt("return", _context6.sent);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getTrendingTracks() {
        return _getTrendingTracks.apply(this, arguments);
      }

      return getTrendingTracks;
    }()
    /** @hidden
     * Gets the top 100 trending underground tracks on Audius
     */

  }, {
    key: "getUndergroundTrendingTracksRaw",
    value: function () {
      var _getUndergroundTrendingTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                headerParameters = {};
                _context7.next = 6;
                return this.request({
                  path: "/tracks/trending/underground",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getUndergroundTrendingTracksRaw(_x9, _x10) {
        return _getUndergroundTrendingTracksRaw.apply(this, arguments);
      }

      return getUndergroundTrendingTracksRaw;
    }()
    /**
     * Gets the top 100 trending underground tracks on Audius
     */

  }, {
    key: "getUndergroundTrendingTracks",
    value: function () {
      var _getUndergroundTrendingTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var params,
            initOverrides,
            response,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                params = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};
                initOverrides = _args8.length > 1 ? _args8[1] : undefined;
                _context8.next = 4;
                return this.getUndergroundTrendingTracksRaw(params, initOverrides);

              case 4:
                response = _context8.sent;
                _context8.next = 7;
                return response.value();

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getUndergroundTrendingTracks() {
        return _getUndergroundTrendingTracks.apply(this, arguments);
      }

      return getUndergroundTrendingTracks;
    }()
    /** @hidden
     * Search for a track or tracks
     */

  }, {
    key: "searchTracksRaw",
    value: function () {
      var _searchTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError$1('query', 'Required parameter params.query was null or undefined when calling searchTracks.');

              case 2:
                queryParameters = {};

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.onlyDownloadable !== undefined) {
                  queryParameters['only_downloadable'] = params.onlyDownloadable;
                }

                headerParameters = {};
                _context9.next = 8;
                return this.request({
                  path: "/tracks/search",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context9.sent;
                return _context9.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TrackSearchFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function searchTracksRaw(_x11, _x12) {
        return _searchTracksRaw.apply(this, arguments);
      }

      return searchTracksRaw;
    }()
    /**
     * Search for a track or tracks
     */

  }, {
    key: "searchTracks",
    value: function () {
      var _searchTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.searchTracksRaw(params, initOverrides);

              case 2:
                response = _context10.sent;
                _context10.next = 5;
                return response.value();

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function searchTracks(_x13, _x14) {
        return _searchTracks.apply(this, arguments);
      }

      return searchTracks;
    }()
    /** @hidden
     * This endpoint accepts the Range header for streaming. https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests
     * Get the streamable MP3 file of a track
     */

  }, {
    key: "streamTrackRaw",
    value: function () {
      var _streamTrackRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context11.next = 2;
                  break;
                }

                throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling streamTrack.');

              case 2:
                queryParameters = {};

                if (params.preview !== undefined) {
                  queryParameters['preview'] = params.preview;
                }

                if (params.userSignature !== undefined) {
                  queryParameters['user_signature'] = params.userSignature;
                }

                if (params.userData !== undefined) {
                  queryParameters['user_data'] = params.userData;
                }

                if (params.premiumContentSignature !== undefined) {
                  queryParameters['premium_content_signature'] = params.premiumContentSignature;
                }

                if (params.filename !== undefined) {
                  queryParameters['filename'] = params.filename;
                }

                if (params.skipPlayCount !== undefined) {
                  queryParameters['skip_play_count'] = params.skipPlayCount;
                }

                headerParameters = {};
                _context11.next = 12;
                return this.request({
                  path: "/tracks/{track_id}/stream".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 12:
                response = _context11.sent;
                return _context11.abrupt("return", new VoidApiResponse$1(response));

              case 14:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function streamTrackRaw(_x15, _x16) {
        return _streamTrackRaw.apply(this, arguments);
      }

      return streamTrackRaw;
    }()
    /**
     * This endpoint accepts the Range header for streaming. https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests
     * Get the streamable MP3 file of a track
     */

  }, {
    key: "streamTrack",
    value: function () {
      var _streamTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.streamTrackRaw(params, initOverrides);

              case 2:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function streamTrack(_x17, _x18) {
        return _streamTrack.apply(this, arguments);
      }

      return streamTrack;
    }()
  }]);

  return TracksApi;
}(BaseAPI$1);
/**
 * @export
 */

var GetTrendingTracksTimeEnum$1 = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};

/**
 *
 */

var UsersApi$2 = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(UsersApi, _runtime$BaseAPI);

  var _super = _createSuper(UsersApi);

  function UsersApi() {
    _classCallCheck(this, UsersApi);

    return _super.apply(this, arguments);
  }

  _createClass(UsersApi, [{
    key: "getAIAttributedTracksByUserHandleRaw",
    value:
    /** @hidden
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */
    function () {
      var _getAIAttributedTracksByUserHandleRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('handle', 'Required parameter params.handle was null or undefined when calling getAIAttributedTracksByUserHandle.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context.next = 14;
                return this.request({
                  path: "/users/handle/{handle}/tracks/ai_attributed".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAIAttributedTracksByUserHandleRaw(_x, _x2) {
        return _getAIAttributedTracksByUserHandleRaw.apply(this, arguments);
      }

      return getAIAttributedTracksByUserHandleRaw;
    }()
    /**
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */

  }, {
    key: "getAIAttributedTracksByUserHandle",
    value: function () {
      var _getAIAttributedTracksByUserHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getAIAttributedTracksByUserHandleRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getAIAttributedTracksByUserHandle(_x3, _x4) {
        return _getAIAttributedTracksByUserHandle.apply(this, arguments);
      }

      return getAIAttributedTracksByUserHandle;
    }()
    /** @hidden
     * Get the apps that user has authorized to write to their account
     */

  }, {
    key: "getAuthorizedAppsRaw",
    value: function () {
      var _getAuthorizedAppsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getAuthorizedApps.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context3.next = 6;
                return this.request({
                  path: "/users/{id}/authorized_apps".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return AuthorizedAppsFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getAuthorizedAppsRaw(_x5, _x6) {
        return _getAuthorizedAppsRaw.apply(this, arguments);
      }

      return getAuthorizedAppsRaw;
    }()
    /**
     * Get the apps that user has authorized to write to their account
     */

  }, {
    key: "getAuthorizedApps",
    value: function () {
      var _getAuthorizedApps = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getAuthorizedAppsRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAuthorizedApps(_x7, _x8) {
        return _getAuthorizedApps.apply(this, arguments);
      }

      return getAuthorizedApps;
    }()
    /** @hidden
     * Get the User\'s ERC and SPL connected wallets
     */

  }, {
    key: "getConnectedWalletsRaw",
    value: function () {
      var _getConnectedWalletsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context5.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getConnectedWallets.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context5.next = 6;
                return this.request({
                  path: "/users/{id}/connected_wallets".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return ConnectedWalletsResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getConnectedWalletsRaw(_x9, _x10) {
        return _getConnectedWalletsRaw.apply(this, arguments);
      }

      return getConnectedWalletsRaw;
    }()
    /**
     * Get the User\'s ERC and SPL connected wallets
     */

  }, {
    key: "getConnectedWallets",
    value: function () {
      var _getConnectedWallets = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getConnectedWalletsRaw(params, initOverrides);

              case 2:
                response = _context6.sent;
                _context6.next = 5;
                return response.value();

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getConnectedWallets(_x11, _x12) {
        return _getConnectedWallets.apply(this, arguments);
      }

      return getConnectedWallets;
    }()
    /** @hidden
     * Gets the developer apps that the user owns
     */

  }, {
    key: "getDeveloperAppsRaw",
    value: function () {
      var _getDeveloperAppsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context7.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getDeveloperApps.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context7.next = 6;
                return this.request({
                  path: "/users/{id}/developer_apps".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return DeveloperAppsFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getDeveloperAppsRaw(_x13, _x14) {
        return _getDeveloperAppsRaw.apply(this, arguments);
      }

      return getDeveloperAppsRaw;
    }()
    /**
     * Gets the developer apps that the user owns
     */

  }, {
    key: "getDeveloperApps",
    value: function () {
      var _getDeveloperApps = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getDeveloperAppsRaw(params, initOverrides);

              case 2:
                response = _context8.sent;
                _context8.next = 5;
                return response.value();

              case 5:
                return _context8.abrupt("return", _context8.sent);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getDeveloperApps(_x15, _x16) {
        return _getDeveloperApps.apply(this, arguments);
      }

      return getDeveloperApps;
    }()
    /** @hidden
     * Gets a user\'s favorite tracks
     */

  }, {
    key: "getFavoritesRaw",
    value: function () {
      var _getFavoritesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getFavorites.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context9.next = 6;
                return this.request({
                  path: "/users/{id}/favorites".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context9.sent;
                return _context9.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return FavoritesResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getFavoritesRaw(_x17, _x18) {
        return _getFavoritesRaw.apply(this, arguments);
      }

      return getFavoritesRaw;
    }()
    /**
     * Gets a user\'s favorite tracks
     */

  }, {
    key: "getFavorites",
    value: function () {
      var _getFavorites = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getFavoritesRaw(params, initOverrides);

              case 2:
                response = _context10.sent;
                _context10.next = 5;
                return response.value();

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getFavorites(_x19, _x20) {
        return _getFavorites.apply(this, arguments);
      }

      return getFavorites;
    }()
    /** @hidden
     * All users that follow the provided user
     */

  }, {
    key: "getFollowersRaw",
    value: function () {
      var _getFollowersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context11.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getFollowers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context11.next = 9;
                return this.request({
                  path: "/users/{id}/followers".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context11.sent;
                return _context11.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return FollowersResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getFollowersRaw(_x21, _x22) {
        return _getFollowersRaw.apply(this, arguments);
      }

      return getFollowersRaw;
    }()
    /**
     * All users that follow the provided user
     */

  }, {
    key: "getFollowers",
    value: function () {
      var _getFollowers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getFollowersRaw(params, initOverrides);

              case 2:
                response = _context12.sent;
                _context12.next = 5;
                return response.value();

              case 5:
                return _context12.abrupt("return", _context12.sent);

              case 6:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getFollowers(_x23, _x24) {
        return _getFollowers.apply(this, arguments);
      }

      return getFollowers;
    }()
    /** @hidden
     * All users that the provided user follows
     */

  }, {
    key: "getFollowingRaw",
    value: function () {
      var _getFollowingRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context13.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getFollowing.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context13.next = 9;
                return this.request({
                  path: "/users/{id}/following".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context13.sent;
                return _context13.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return FollowingResponseFromJSON$1(jsonValue);
                }));

              case 11:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getFollowingRaw(_x25, _x26) {
        return _getFollowingRaw.apply(this, arguments);
      }

      return getFollowingRaw;
    }()
    /**
     * All users that the provided user follows
     */

  }, {
    key: "getFollowing",
    value: function () {
      var _getFollowing = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getFollowingRaw(params, initOverrides);

              case 2:
                response = _context14.sent;
                _context14.next = 5;
                return response.value();

              case 5:
                return _context14.abrupt("return", _context14.sent);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getFollowing(_x27, _x28) {
        return _getFollowing.apply(this, arguments);
      }

      return getFollowing;
    }()
    /** @hidden
     * Gets a list of users that might be of interest to followers of this user.
     */

  }, {
    key: "getRelatedUsersRaw",
    value: function () {
      var _getRelatedUsersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context15.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getRelatedUsers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context15.next = 9;
                return this.request({
                  path: "/users/{id}/related".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context15.sent;
                return _context15.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return RelatedArtistResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getRelatedUsersRaw(_x29, _x30) {
        return _getRelatedUsersRaw.apply(this, arguments);
      }

      return getRelatedUsersRaw;
    }()
    /**
     * Gets a list of users that might be of interest to followers of this user.
     */

  }, {
    key: "getRelatedUsers",
    value: function () {
      var _getRelatedUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.getRelatedUsersRaw(params, initOverrides);

              case 2:
                response = _context16.sent;
                _context16.next = 5;
                return response.value();

              case 5:
                return _context16.abrupt("return", _context16.sent);

              case 6:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getRelatedUsers(_x31, _x32) {
        return _getRelatedUsers.apply(this, arguments);
      }

      return getRelatedUsers;
    }()
    /** @hidden
     * Gets the given user\'s reposts
     */

  }, {
    key: "getRepostsRaw",
    value: function () {
      var _getRepostsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context17.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getReposts.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context17.next = 9;
                return this.request({
                  path: "/users/{id}/reposts".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context17.sent;
                return _context17.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return RepostsFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getRepostsRaw(_x33, _x34) {
        return _getRepostsRaw.apply(this, arguments);
      }

      return getRepostsRaw;
    }()
    /**
     * Gets the given user\'s reposts
     */

  }, {
    key: "getReposts",
    value: function () {
      var _getReposts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.getRepostsRaw(params, initOverrides);

              case 2:
                response = _context18.sent;
                _context18.next = 5;
                return response.value();

              case 5:
                return _context18.abrupt("return", _context18.sent);

              case 6:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getReposts(_x35, _x36) {
        return _getReposts.apply(this, arguments);
      }

      return getReposts;
    }()
    /** @hidden
     * All users that subscribe to the provided user
     */

  }, {
    key: "getSubscribersRaw",
    value: function () {
      var _getSubscribersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context19.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getSubscribers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context19.next = 9;
                return this.request({
                  path: "/users/{id}/subscribers".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context19.sent;
                return _context19.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return SubscribersResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getSubscribersRaw(_x37, _x38) {
        return _getSubscribersRaw.apply(this, arguments);
      }

      return getSubscribersRaw;
    }()
    /**
     * All users that subscribe to the provided user
     */

  }, {
    key: "getSubscribers",
    value: function () {
      var _getSubscribers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getSubscribersRaw(params, initOverrides);

              case 2:
                response = _context20.sent;
                _context20.next = 5;
                return response.value();

              case 5:
                return _context20.abrupt("return", _context20.sent);

              case 6:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getSubscribers(_x39, _x40) {
        return _getSubscribers.apply(this, arguments);
      }

      return getSubscribers;
    }()
    /** @hidden
     * Gets the supporters of the given user
     */

  }, {
    key: "getSupportersRaw",
    value: function () {
      var _getSupportersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context21.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getSupporters.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                headerParameters = {};
                _context21.next = 8;
                return this.request({
                  path: "/users/{id}/supporters".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context21.sent;
                return _context21.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return GetSupportersFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getSupportersRaw(_x41, _x42) {
        return _getSupportersRaw.apply(this, arguments);
      }

      return getSupportersRaw;
    }()
    /**
     * Gets the supporters of the given user
     */

  }, {
    key: "getSupporters",
    value: function () {
      var _getSupporters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getSupportersRaw(params, initOverrides);

              case 2:
                response = _context22.sent;
                _context22.next = 5;
                return response.value();

              case 5:
                return _context22.abrupt("return", _context22.sent);

              case 6:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getSupporters(_x43, _x44) {
        return _getSupporters.apply(this, arguments);
      }

      return getSupporters;
    }()
    /** @hidden
     * Gets the users that the given user supports
     */

  }, {
    key: "getSupportingsRaw",
    value: function () {
      var _getSupportingsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context23.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getSupportings.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                headerParameters = {};
                _context23.next = 8;
                return this.request({
                  path: "/users/{id}/supporting".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context23.sent;
                return _context23.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return GetSupportingFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getSupportingsRaw(_x45, _x46) {
        return _getSupportingsRaw.apply(this, arguments);
      }

      return getSupportingsRaw;
    }()
    /**
     * Gets the users that the given user supports
     */

  }, {
    key: "getSupportings",
    value: function () {
      var _getSupportings = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.getSupportingsRaw(params, initOverrides);

              case 2:
                response = _context24.sent;
                _context24.next = 5;
                return response.value();

              case 5:
                return _context24.abrupt("return", _context24.sent);

              case 6:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getSupportings(_x47, _x48) {
        return _getSupportings.apply(this, arguments);
      }

      return getSupportings;
    }()
    /** @hidden
     * Gets the most used track tags by a user.
     * Fetch most used tags in a user\'s tracks
     */

  }, {
    key: "getTopTrackTagsRaw",
    value: function () {
      var _getTopTrackTagsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context25.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getTopTrackTags.');

              case 2:
                queryParameters = {};

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context25.next = 8;
                return this.request({
                  path: "/users/{id}/tags".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context25.sent;
                return _context25.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TagsResponseFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getTopTrackTagsRaw(_x49, _x50) {
        return _getTopTrackTagsRaw.apply(this, arguments);
      }

      return getTopTrackTagsRaw;
    }()
    /**
     * Gets the most used track tags by a user.
     * Fetch most used tags in a user\'s tracks
     */

  }, {
    key: "getTopTrackTags",
    value: function () {
      var _getTopTrackTags = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.getTopTrackTagsRaw(params, initOverrides);

              case 2:
                response = _context26.sent;
                _context26.next = 5;
                return response.value();

              case 5:
                return _context26.abrupt("return", _context26.sent);

              case 6:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function getTopTrackTags(_x51, _x52) {
        return _getTopTrackTags.apply(this, arguments);
      }

      return getTopTrackTags;
    }()
    /** @hidden
     * Gets the tracks created by a user using their user ID
     */

  }, {
    key: "getTracksByUserRaw",
    value: function () {
      var _getTracksByUserRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context27.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getTracksByUser.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context27.next = 14;
                return this.request({
                  path: "/users/{id}/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context27.sent;
                return _context27.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return TracksResponseFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getTracksByUserRaw(_x53, _x54) {
        return _getTracksByUserRaw.apply(this, arguments);
      }

      return getTracksByUserRaw;
    }()
    /**
     * Gets the tracks created by a user using their user ID
     */

  }, {
    key: "getTracksByUser",
    value: function () {
      var _getTracksByUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.getTracksByUserRaw(params, initOverrides);

              case 2:
                response = _context28.sent;
                _context28.next = 5;
                return response.value();

              case 5:
                return _context28.abrupt("return", _context28.sent);

              case 6:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getTracksByUser(_x55, _x56) {
        return _getTracksByUser.apply(this, arguments);
      }

      return getTracksByUser;
    }()
    /** @hidden
     * Gets a single user by their user ID
     */

  }, {
    key: "getUserRaw",
    value: function () {
      var _getUserRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context29.next = 2;
                  break;
                }

                throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getUser.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context29.next = 6;
                return this.request({
                  path: "/users/{id}".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context29.sent;
                return _context29.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return UserResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getUserRaw(_x57, _x58) {
        return _getUserRaw.apply(this, arguments);
      }

      return getUserRaw;
    }()
    /**
     * Gets a single user by their user ID
     */

  }, {
    key: "getUser",
    value: function () {
      var _getUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this.getUserRaw(params, initOverrides);

              case 2:
                response = _context30.sent;
                _context30.next = 5;
                return response.value();

              case 5:
                return _context30.abrupt("return", _context30.sent);

              case 6:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getUser(_x59, _x60) {
        return _getUser.apply(this, arguments);
      }

      return getUser;
    }()
    /** @hidden
     * Gets a single user by their handle
     */

  }, {
    key: "getUserByHandleRaw",
    value: function () {
      var _getUserByHandleRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context31.next = 2;
                  break;
                }

                throw new RequiredError$1('handle', 'Required parameter params.handle was null or undefined when calling getUserByHandle.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context31.next = 7;
                return this.request({
                  path: "/users/handle/{handle}".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context31.sent;
                return _context31.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return UserResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getUserByHandleRaw(_x61, _x62) {
        return _getUserByHandleRaw.apply(this, arguments);
      }

      return getUserByHandleRaw;
    }()
    /**
     * Gets a single user by their handle
     */

  }, {
    key: "getUserByHandle",
    value: function () {
      var _getUserByHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.getUserByHandleRaw(params, initOverrides);

              case 2:
                response = _context32.sent;
                _context32.next = 5;
                return response.value();

              case 5:
                return _context32.abrupt("return", _context32.sent);

              case 6:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getUserByHandle(_x63, _x64) {
        return _getUserByHandle.apply(this, arguments);
      }

      return getUserByHandle;
    }()
    /** @hidden
     * Gets a User ID from an associated wallet address
     */

  }, {
    key: "getUserIDFromWalletRaw",
    value: function () {
      var _getUserIDFromWalletRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                if (!(params.associatedWallet === null || params.associatedWallet === undefined)) {
                  _context33.next = 2;
                  break;
                }

                throw new RequiredError$1('associatedWallet', 'Required parameter params.associatedWallet was null or undefined when calling getUserIDFromWallet.');

              case 2:
                queryParameters = {};

                if (params.associatedWallet !== undefined) {
                  queryParameters['associated_wallet'] = params.associatedWallet;
                }

                headerParameters = {};
                _context33.next = 7;
                return this.request({
                  path: "/users/id",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context33.sent;
                return _context33.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return UserAssociatedWalletResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getUserIDFromWalletRaw(_x65, _x66) {
        return _getUserIDFromWalletRaw.apply(this, arguments);
      }

      return getUserIDFromWalletRaw;
    }()
    /**
     * Gets a User ID from an associated wallet address
     */

  }, {
    key: "getUserIDFromWallet",
    value: function () {
      var _getUserIDFromWallet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                _context34.next = 2;
                return this.getUserIDFromWalletRaw(params, initOverrides);

              case 2:
                response = _context34.sent;
                _context34.next = 5;
                return response.value();

              case 5:
                return _context34.abrupt("return", _context34.sent);

              case 6:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function getUserIDFromWallet(_x67, _x68) {
        return _getUserIDFromWallet.apply(this, arguments);
      }

      return getUserIDFromWallet;
    }()
    /** @hidden
     * Search for users that match the given query
     */

  }, {
    key: "searchUsersRaw",
    value: function () {
      var _searchUsersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context35.next = 2;
                  break;
                }

                throw new RequiredError$1('query', 'Required parameter params.query was null or undefined when calling searchUsers.');

              case 2:
                queryParameters = {};

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                headerParameters = {};
                _context35.next = 7;
                return this.request({
                  path: "/users/search",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context35.sent;
                return _context35.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return UserSearchFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function searchUsersRaw(_x69, _x70) {
        return _searchUsersRaw.apply(this, arguments);
      }

      return searchUsersRaw;
    }()
    /**
     * Search for users that match the given query
     */

  }, {
    key: "searchUsers",
    value: function () {
      var _searchUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                _context36.next = 2;
                return this.searchUsersRaw(params, initOverrides);

              case 2:
                response = _context36.sent;
                _context36.next = 5;
                return response.value();

              case 5:
                return _context36.abrupt("return", _context36.sent);

              case 6:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function searchUsers(_x71, _x72) {
        return _searchUsers.apply(this, arguments);
      }

      return searchUsers;
    }()
    /** @hidden
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     */

  }, {
    key: "verifyIDTokenRaw",
    value: function () {
      var _verifyIDTokenRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                if (!(params.token === null || params.token === undefined)) {
                  _context37.next = 2;
                  break;
                }

                throw new RequiredError$1('token', 'Required parameter params.token was null or undefined when calling verifyIDToken.');

              case 2:
                queryParameters = {};

                if (params.token !== undefined) {
                  queryParameters['token'] = params.token;
                }

                headerParameters = {};
                _context37.next = 7;
                return this.request({
                  path: "/users/verify_token",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context37.sent;
                return _context37.abrupt("return", new JSONApiResponse$1(response, function (jsonValue) {
                  return VerifyTokenFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function verifyIDTokenRaw(_x73, _x74) {
        return _verifyIDTokenRaw.apply(this, arguments);
      }

      return verifyIDTokenRaw;
    }()
    /**
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     */

  }, {
    key: "verifyIDToken",
    value: function () {
      var _verifyIDToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                _context38.next = 2;
                return this.verifyIDTokenRaw(params, initOverrides);

              case 2:
                response = _context38.sent;
                _context38.next = 5;
                return response.value();

              case 5:
                return _context38.abrupt("return", _context38.sent);

              case 6:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function verifyIDToken(_x75, _x76) {
        return _verifyIDToken.apply(this, arguments);
      }

      return verifyIDToken;
    }()
  }]);

  return UsersApi;
}(BaseAPI$1);
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortEnum$1 = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortMethodEnum$1 = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Length: 'length',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortDirectionEnum$1 = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleFilterTracksEnum$1 = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */

var GetTracksByUserSortEnum$1 = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetTracksByUserSortMethodEnum$1 = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Length: 'length',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetTracksByUserSortDirectionEnum$1 = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetTracksByUserFilterTracksEnum$1 = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};

var CreateDeveloperAppSchema = z.object({
  name: z.string(),
  description: z.optional(z.string().max(128)),
  userId: HashId
});
var DeleteDeveloperAppSchema = z.object({
  userId: HashId,
  appApiKey: z.custom(function (data) {
    return isApiKeyValid(data);
  })
});

var DeveloperAppsApi = /*#__PURE__*/function (_GeneratedDeveloperAp) {
  _inherits(DeveloperAppsApi, _GeneratedDeveloperAp);

  var _super = _createSuper(DeveloperAppsApi);

  function DeveloperAppsApi(config, entityManager, auth) {
    var _this;

    _classCallCheck(this, DeveloperAppsApi);

    _this = _super.call(this, config);

    _defineProperty$1(_assertThisInitialized(_this), "entityManager", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "web3", void 0);

    _this.entityManager = entityManager;
    _this.auth = auth;
    _this.web3 = new Web3$1();
    return _this;
  }
  /**
   * Create a developer app
   */


  _createClass(DeveloperAppsApi, [{
    key: "createDeveloperApp",
    value: function () {
      var _createDeveloperApp = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, advancedOptions) {
        var _yield$parseParams, name, userId, description, wallet, privateKey, address, unixTs, message, signature, response, apiKey, apiSecret;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return parseParams('createDeveloperApp', CreateDeveloperAppSchema)(params);

              case 2:
                _yield$parseParams = _context.sent;
                name = _yield$parseParams.name;
                userId = _yield$parseParams.userId;
                description = _yield$parseParams.description;
                wallet = this.web3.eth.accounts.create();
                privateKey = wallet.privateKey;
                address = wallet.address;
                unixTs = Math.round(new Date().getTime() / 1000); // current unix timestamp (sec)

                message = "Creating Audius developer app at ".concat(unixTs);
                signature = wallet.sign(message).signature;
                _context.next = 14;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.DEVELOPER_APP,
                  entityId: 0,
                  action: Action.CREATE,
                  metadata: JSON.stringify({
                    name: name,
                    description: description,
                    app_signature: {
                      message: message,
                      signature: signature
                    }
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 14:
                response = _context.sent;
                apiKey = address.slice(2).toLowerCase();
                apiSecret = privateKey.slice(2).toLowerCase();
                return _context.abrupt("return", _objectSpread2(_objectSpread2({}, response), {}, {
                  apiKey: apiKey,
                  apiSecret: apiSecret
                }));

              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function createDeveloperApp(_x, _x2) {
        return _createDeveloperApp.apply(this, arguments);
      }

      return createDeveloperApp;
    }()
    /**
     * Delete a developer app
     */

  }, {
    key: "deleteDeveloperApp",
    value: function () {
      var _deleteDeveloperApp = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        var _yield$parseParams2, userId, appApiKey;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return parseParams('deleteDeveloperApp', DeleteDeveloperAppSchema)(params);

              case 2:
                _yield$parseParams2 = _context2.sent;
                userId = _yield$parseParams2.userId;
                appApiKey = _yield$parseParams2.appApiKey;
                _context2.next = 7;
                return this.entityManager.manageEntity({
                  userId: userId,
                  entityType: EntityType.DEVELOPER_APP,
                  entityId: 0,
                  action: Action.DELETE,
                  metadata: JSON.stringify({
                    address: "0x".concat(appApiKey)
                  }),
                  auth: this.auth
                });

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function deleteDeveloperApp(_x3) {
        return _deleteDeveloperApp.apply(this, arguments);
      }

      return deleteDeveloperApp;
    }()
  }]);

  return DeveloperAppsApi;
}(DeveloperAppsApi$1);

var fileTypeBrowser;

if (typeof window !== 'undefined' && window) {
  fileTypeBrowser = require('file-type/browser');
}
/**
 * Type representing a file in Node environment
 */


var NodeFileSchema = z.object({
  buffer: z.custom(function (data) {
    return data;
  }),
  name: z.optional(z.string())
});
var BrowserFileSchema = z.custom(function (data) {
  return data;
});
/**
 * Type representing a file in Node and browser environments
 */

var CrossPlatformFileSchema = z.union([NodeFileSchema, BrowserFileSchema]);
var isNodeFile = function isNodeFile(file) {
  if (file && file.buffer) {
    return true;
  }

  return false;
};
var ALLOWED_IMAGE_MIME_TYPES = ['image/jpeg', 'image/png', 'image/bmp', 'image/tiff', 'image/gif', 'image/webp'];
var ALLOWED_AUDIO_MIME_TYPES = ['audio/mpeg', 'audio/mp3', 'audio/aiff', 'audio/flac', 'audio/ogg', 'audio/wav', 'audio/vnd.wave'];

var getFileType = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(file) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!isNodeFile(file)) {
              _context.next = 6;
              break;
            }

            _context.next = 3;
            return fileType.fromBuffer(file.buffer);

          case 3:
            _context.t0 = _context.sent;
            _context.next = 9;
            break;

          case 6:
            _context.next = 8;
            return fileTypeBrowser.fromBlob(file);

          case 8:
            _context.t0 = _context.sent;

          case 9:
            return _context.abrupt("return", _context.t0);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getFileType(_x) {
    return _ref.apply(this, arguments);
  };
}();

var ImageFile = CrossPlatformFileSchema.refine( /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(file) {
    var fileType;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getFileType(file);

          case 2:
            fileType = _context2.sent;
            return _context2.abrupt("return", fileType && ALLOWED_IMAGE_MIME_TYPES.includes(fileType.mime));

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}(), "Image file has invalid file type. Supported file types are: ".concat(ALLOWED_IMAGE_MIME_TYPES.join(', ')));
var AudioFile = CrossPlatformFileSchema.refine( /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(file) {
    var fileType;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return getFileType(file);

          case 2:
            fileType = _context3.sent;
            return _context3.abrupt("return", fileType && ALLOWED_AUDIO_MIME_TYPES.includes(fileType.mime));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
}(), "Audio file has invalid file type. Supported file types are: ".concat(ALLOWED_AUDIO_MIME_TYPES.join(', ')));

var Mood;

(function (Mood) {
  Mood["PEACEFUL"] = "Peaceful";
  Mood["ROMANTIC"] = "Romantic";
  Mood["SENTIMENTAL"] = "Sentimental";
  Mood["TENDER"] = "Tender";
  Mood["EASYGOING"] = "Easygoing";
  Mood["YEARNING"] = "Yearning";
  Mood["SOPHISTICATED"] = "Sophisticated";
  Mood["SENSUAL"] = "Sensual";
  Mood["COOL"] = "Cool";
  Mood["GRITTY"] = "Gritty";
  Mood["MELANCHOLY"] = "Melancholy";
  Mood["SERIOUS"] = "Serious";
  Mood["BROODING"] = "Brooding";
  Mood["FIERY"] = "Fiery";
  Mood["DEFIANT"] = "Defiant";
  Mood["AGGRESSIVE"] = "Aggressive";
  Mood["ROWDY"] = "Rowdy";
  Mood["EXCITED"] = "Excited";
  Mood["ENERGIZING"] = "Energizing";
  Mood["EMPOWERING"] = "Empowering";
  Mood["STIRRING"] = "Stirring";
  Mood["UPBEAT"] = "Upbeat";
  Mood["OTHER"] = "Other";
})(Mood || (Mood = {}));

var Genre;

(function (Genre) {
  Genre["ALL"] = "All Genres";
  Genre["ELECTRONIC"] = "Electronic";
  Genre["ROCK"] = "Rock";
  Genre["METAL"] = "Metal";
  Genre["ALTERNATIVE"] = "Alternative";
  Genre["HIP_HOP_RAP"] = "Hip-Hop/Rap";
  Genre["EXPERIMENTAL"] = "Experimental";
  Genre["PUNK"] = "Punk";
  Genre["FOLK"] = "Folk";
  Genre["POP"] = "Pop";
  Genre["AMBIENT"] = "Ambient";
  Genre["SOUNDTRACK"] = "Soundtrack";
  Genre["WORLD"] = "World";
  Genre["JAZZ"] = "Jazz";
  Genre["ACOUSTIC"] = "Acoustic";
  Genre["FUNK"] = "Funk";
  Genre["R_AND_B_SOUL"] = "R&B/Soul";
  Genre["DEVOTIONAL"] = "Devotional";
  Genre["CLASSICAL"] = "Classical";
  Genre["REGGAE"] = "Reggae";
  Genre["PODCASTS"] = "Podcasts";
  Genre["COUNTRY"] = "Country";
  Genre["SPOKEN_WORK"] = "Spoken Word";
  Genre["COMEDY"] = "Comedy";
  Genre["BLUES"] = "Blues";
  Genre["KIDS"] = "Kids";
  Genre["AUDIOBOOKS"] = "Audiobooks";
  Genre["LATIN"] = "Latin";
  Genre["LOFI"] = "Lo-Fi";
  Genre["HYPERPOP"] = "Hyperpop"; // Electronic Subgenres

  Genre["TECHNO"] = "Techno";
  Genre["TRAP"] = "Trap";
  Genre["HOUSE"] = "House";
  Genre["TECH_HOUSE"] = "Tech House";
  Genre["DEEP_HOUSE"] = "Deep House";
  Genre["DISCO"] = "Disco";
  Genre["ELECTRO"] = "Electro";
  Genre["JUNGLE"] = "Jungle";
  Genre["PROGRESSIVE_HOUSE"] = "Progressive House";
  Genre["HARDSTYLE"] = "Hardstyle";
  Genre["GLITCH_HOP"] = "Glitch Hop";
  Genre["TRANCE"] = "Trance";
  Genre["FUTURE_BASS"] = "Future Bass";
  Genre["FUTURE_HOUSE"] = "Future House";
  Genre["TROPICAL_HOUSE"] = "Tropical House";
  Genre["DOWNTEMPO"] = "Downtempo";
  Genre["DRUM_AND_BASS"] = "Drum & Bass";
  Genre["DUBSTEP"] = "Dubstep";
  Genre["JERSEY_CLUB"] = "Jersey Club";
  Genre["VAPORWAVE"] = "Vaporwave";
  Genre["MOOMBAHTON"] = "Moombahton";
})(Genre || (Genre = {}));

var messages = {
  titleRequiredError: 'Your track must have a name',
  artworkRequiredError: 'Artwork is required',
  genreRequiredError: 'Genre is required',
  invalidReleaseDateError: 'Release date should not be in the future'
};
var PremiumConditionsEthNFTCollection = z.object({
  chain: z.literal('eth'),
  address: z.string(),
  standard: z.union([z.literal('ERC721'), z.literal('ERC1155')]),
  name: z.string(),
  slug: z.string(),
  imageUrl: z.optional(z.string()),
  externalLink: z.optional(z.string())
}).strict();
var PremiumConditionsSolNFTCollection = z.object({
  chain: z.literal('sol'),
  address: z.string(),
  name: z.string(),
  imageUrl: z.optional(z.string()),
  externalLink: z.optional(z.string())
}).strict();
var PremiumConditionsNFTCollection = z.union([PremiumConditionsEthNFTCollection, PremiumConditionsSolNFTCollection]);
var PremiumConditionsFollowUserId = z.object({
  followUserId: HashId
}).strict();
var PremiumConditionsTipUserId = z.object({
  tipUserId: HashId
}).strict();
var createUploadTrackMetadataSchema = function createUploadTrackMetadataSchema() {
  return z.object({
    aiAttributionUserId: z.optional(HashId),
    description: z.optional(z.string().max(1000)),
    download: z.optional(z.object({
      cid: z.string(),
      isDownloadable: z["boolean"](),
      requiresFollow: z["boolean"]()
    }).strict().nullable()),
    fieldVisibility: z.optional(z.object({
      mood: z.optional(z["boolean"]()),
      tags: z.optional(z["boolean"]()),
      genre: z.optional(z["boolean"]()),
      share: z.optional(z["boolean"]()),
      playCount: z.optional(z["boolean"]()),
      remixes: z.optional(z["boolean"]())
    })),
    genre: z["enum"](Object.values(Genre)).nullable().refine(function (val) {
      return val !== null;
    }, {
      message: messages.genreRequiredError
    }),
    isPremium: z.optional(z["boolean"]()),
    isrc: z.optional(z.string().nullable()),
    isUnlisted: z.optional(z["boolean"]()),
    iswc: z.optional(z.string().nullable()),
    license: z.optional(z.string().nullable()),
    mood: z.optional(z["enum"](Object.values(Mood))).nullable(),
    premiumConditions: z.optional(z.union([PremiumConditionsNFTCollection, PremiumConditionsFollowUserId, PremiumConditionsTipUserId])),
    releaseDate: z.optional(z.date().max(new Date(), {
      message: messages.invalidReleaseDateError
    })),
    remixOf: z.optional(z.object({
      tracks: z.array(z.object({
        parentTrackId: HashId
      })).min(1)
    }).strict()),
    tags: z.optional(z.string()),
    title: z.string({
      required_error: messages.titleRequiredError
    }),
    previewStartSeconds: z.optional(z.number()),
    audioUploadId: z.optional(z.string()),
    previewCid: z.optional(z.string())
  });
};
var createUploadTrackSchema = function createUploadTrackSchema() {
  return z.object({
    userId: HashId,
    coverArtFile: ImageFile,
    metadata: createUploadTrackMetadataSchema().strict(),
    onProgress: z.optional(z["function"]().args(z.number())),
    trackFile: AudioFile
  }).strict();
};
var createUpdateTrackSchema = function createUpdateTrackSchema() {
  return z.object({
    userId: HashId,
    trackId: HashId,
    metadata: createUploadTrackMetadataSchema().strict().partial(),
    transcodePreview: z.optional(z["boolean"]()),
    coverArtFile: z.optional(ImageFile),
    onProgress: z.optional(z["function"]().args(z.number()))
  }).strict();
};
var DeleteTrackSchema = z.object({
  userId: HashId,
  trackId: HashId
}).strict();
var FavoriteTrackSchema = z.object({
  userId: HashId,
  trackId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: z["boolean"]()
  }).strict())
}).strict();
var UnfavoriteTrackSchema = z.object({
  userId: HashId,
  trackId: HashId
}).strict();
var RepostTrackSchema = z.object({
  userId: HashId,
  trackId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: z["boolean"]()
  }).strict())
}).strict();
var UnrepostTrackSchema = z.object({
  userId: HashId,
  trackId: HashId
}).strict();

var CreatePlaylistMetadataSchema = z.object({
  description: z.optional(z.string().max(1000)),
  playlistName: z.string(),
  isPrivate: z.optional(z["boolean"]())
}).strict();
var CreatePlaylistSchema = z.object({
  coverArtFile: z.optional(ImageFile),
  metadata: CreatePlaylistMetadataSchema,
  onProgress: z.optional(z["function"]().args(z.number())),
  trackIds: z.optional(z.array(HashId)),
  userId: HashId
}).strict();
var createUpdatePlaylistMetadataSchema = function createUpdatePlaylistMetadataSchema() {
  return createUploadPlaylistMetadataSchema().partial().merge(z.object({
    isPrivate: z.optional(z["boolean"]()),
    playlistContents: z.optional(z.array(z.object({
      timestamp: z.number(),
      metadataTimestamp: z.optional(z.number()),
      trackId: HashId
    })))
  })).strict();
};
var createUpdatePlaylistSchema = function createUpdatePlaylistSchema() {
  return z.object({
    userId: HashId,
    playlistId: HashId,
    coverArtFile: z.optional(ImageFile),
    metadata: createUpdatePlaylistMetadataSchema(),
    onProgress: z.optional(z["function"]().args(z.number()))
  }).strict();
};

var createUploadPlaylistMetadataSchema = function createUploadPlaylistMetadataSchema() {
  return z.object({
    description: z.optional(z.string().max(1000)),
    genre: z["enum"](Object.values(Genre)),
    license: z.optional(z.string()),
    mood: z.optional(z["enum"](Object.values(Mood))),
    playlistName: z.string(),
    releaseDate: z.optional(z.date().max(new Date(), {
      message: 'should not be in the future'
    })),
    tags: z.optional(z.string()),
    upc: z.optional(z.string())
  }).strict();
};

var createPlaylistTrackMetadataSchema = function createPlaylistTrackMetadataSchema() {
  return createUploadTrackMetadataSchema().partial({
    genre: true,
    mood: true,
    tags: true
  });
};

var createUploadPlaylistSchema = function createUploadPlaylistSchema() {
  return z.object({
    userId: HashId,
    coverArtFile: ImageFile,
    metadata: createUploadPlaylistMetadataSchema(),
    onProgress: z.optional(z["function"]().args(z.number())),

    /**
     * Track metadata is populated from the playlist if fields are missing
     */
    trackMetadatas: z.array(createPlaylistTrackMetadataSchema()),
    trackFiles: z.array(AudioFile)
  }).strict();
};
var PublishPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
var AddTrackToPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  trackId: HashId
}).strict();
var RemoveTrackFromPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  trackIndex: z.number()
}).strict();
var DeletePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
var FavoritePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: z["boolean"]()
  }).strict())
}).strict();
var UnfavoritePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
var RepostPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: z["boolean"]()
  }).strict())
}).strict();
var UnrepostPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();

/**
 * Calls fn and then retries once after 500ms, again after 1500ms, and again after 4000ms
 */

var retry3 = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(fn) {
    var onRetry,
        _args = arguments;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            onRetry = _args.length > 1 && _args[1] !== undefined ? _args[1] : function (_err) {};
            _context.next = 3;
            return retry(fn, {
              minTimeout: 500,
              maxTimeout: 4000,
              factor: 3,
              retries: 3,
              onRetry: onRetry
            });

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function retry3(_x) {
    return _ref.apply(this, arguments);
  };
}();

var TrackUploadHelper = /*#__PURE__*/function (_BaseAPI) {
  _inherits(TrackUploadHelper, _BaseAPI);

  var _super = _createSuper(TrackUploadHelper);

  function TrackUploadHelper() {
    _classCallCheck(this, TrackUploadHelper);

    return _super.apply(this, arguments);
  }

  _createClass(TrackUploadHelper, [{
    key: "generateId",
    value: function () {
      var _generateId = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(type) {
        var response, _yield$response$json, data, id;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.request({
                  path: "/".concat(type, "s/unclaimed_id"),
                  method: 'GET',
                  headers: {},
                  query: {
                    noCache: Math.floor(Math.random() * 1000).toString()
                  }
                });

              case 2:
                response = _context.sent;
                _context.next = 5;
                return response.json();

              case 5:
                _yield$response$json = _context.sent;
                data = _yield$response$json.data;
                id = decodeHashId(data);

                if (!(id === null)) {
                  _context.next = 10;
                  break;
                }

                throw new Error("Could not generate ".concat(type, " id"));

              case 10:
                return _context.abrupt("return", id);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function generateId(_x) {
        return _generateId.apply(this, arguments);
      }

      return generateId;
    }()
  }, {
    key: "transformTrackUploadMetadata",
    value: function transformTrackUploadMetadata(inputMetadata, userId) {
      var metadata = _objectSpread2(_objectSpread2({}, inputMetadata), {}, {
        ownerId: userId
      });

      var isPremium = metadata.isPremium;
      var isUnlisted = metadata.isUnlisted; // If track is premium, set remixes to false

      if (isPremium && metadata.fieldVisibility) {
        metadata.fieldVisibility.remixes = false;
      } // If track is public, set required visibility fields to true


      if (!isUnlisted) {
        metadata.fieldVisibility = _objectSpread2(_objectSpread2({}, metadata.fieldVisibility), {}, {
          genre: true,
          mood: true,
          tags: true,
          share: true,
          playCount: true
        });
      }

      return metadata;
    }
  }, {
    key: "populateTrackMetadataWithUploadResponse",
    value: function populateTrackMetadataWithUploadResponse(trackMetadata, audioResponse, coverArtResponse) {
      var _trackMetadata$downlo;

      return _objectSpread2(_objectSpread2({}, trackMetadata), {}, {
        trackSegments: [],
        trackCid: audioResponse.results['320'],
        previewCid: trackMetadata.previewStartSeconds ? audioResponse.results["320_preview|".concat(trackMetadata.previewStartSeconds)] : trackMetadata.previewCid,
        audioUploadId: audioResponse.id,
        download: (_trackMetadata$downlo = trackMetadata.download) !== null && _trackMetadata$downlo !== void 0 && _trackMetadata$downlo.isDownloadable ? _objectSpread2(_objectSpread2({}, trackMetadata.download), {}, {
          cid: audioResponse.results['320']
        }) : trackMetadata.download,
        coverArtSizes: coverArtResponse.id,
        duration: parseInt(audioResponse.probe.format.duration, 10)
      });
    }
  }]);

  return TrackUploadHelper;
}(BaseAPI$1);

var PlaylistsApi$1 = /*#__PURE__*/function (_GeneratedPlaylistsAp) {
  _inherits(PlaylistsApi, _GeneratedPlaylistsAp);

  var _super = _createSuper(PlaylistsApi);

  function PlaylistsApi(configuration, storage, entityManager, auth, logger) {
    var _this;

    _classCallCheck(this, PlaylistsApi);

    _this = _super.call(this, configuration);

    _defineProperty$1(_assertThisInitialized(_this), "storage", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "entityManager", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "logger", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "trackUploadHelper", void 0);

    _this.storage = storage;
    _this.entityManager = entityManager;
    _this.auth = auth;
    _this.logger = logger;
    _this.trackUploadHelper = new TrackUploadHelper(configuration);
    _this.logger = logger.createPrefixedLogger('[playlists-api]');
    return _this;
  }
  /** @hidden
   * Create a playlist from existing tracks
   */


  _createClass(PlaylistsApi, [{
    key: "createPlaylist",
    value: function () {
      var _createPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, advancedOptions) {
        var _this2 = this;

        var _yield$parseParams, userId, coverArtFile, metadata, onProgress, trackIds, coverArtResponse, playlistId, currentBlock, updatedMetadata, response;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return parseParams('createPlaylist', CreatePlaylistSchema)(params);

              case 2:
                _yield$parseParams = _context2.sent;
                userId = _yield$parseParams.userId;
                coverArtFile = _yield$parseParams.coverArtFile;
                metadata = _yield$parseParams.metadata;
                onProgress = _yield$parseParams.onProgress;
                trackIds = _yield$parseParams.trackIds;
                _context2.t0 = coverArtFile;

                if (!_context2.t0) {
                  _context2.next = 13;
                  break;
                }

                _context2.next = 12;
                return retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.next = 2;
                          return _this2.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context.abrupt("return", _context.sent);

                        case 3:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                })), function (e) {
                  _this2.logger.info('Retrying uploadPlaylistCoverArt', e);
                });

              case 12:
                _context2.t0 = _context2.sent;

              case 13:
                coverArtResponse = _context2.t0;
                _context2.next = 16;
                return this.trackUploadHelper.generateId('playlist');

              case 16:
                playlistId = _context2.sent;
                _context2.next = 19;
                return this.entityManager.getCurrentBlock();

              case 19:
                currentBlock = _context2.sent;
                // Update metadata to include track ids
                updatedMetadata = _objectSpread2(_objectSpread2({}, metadata), {}, {
                  playlistContents: {
                    trackIds: (trackIds !== null && trackIds !== void 0 ? trackIds : []).map(function (trackId) {
                      return {
                        track: trackId,
                        time: currentBlock.timestamp
                      };
                    })
                  },
                  playlistImageSizesMultihash: coverArtResponse === null || coverArtResponse === void 0 ? void 0 : coverArtResponse.id
                }); // Write playlist metadata to chain

                _context2.next = 23;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.CREATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys(updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 23:
                response = _context2.sent;
                return _context2.abrupt("return", _objectSpread2(_objectSpread2({}, response), {}, {
                  playlistId: encodeHashId(playlistId)
                }));

              case 25:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function createPlaylist(_x, _x2) {
        return _createPlaylist.apply(this, arguments);
      }

      return createPlaylist;
    }()
    /** @hidden
     * Upload a playlist
     * Uploads the specified tracks and combines them into a playlist
     */

  }, {
    key: "uploadPlaylist",
    value: function () {
      var _uploadPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, advancedOptions) {
        var parsedParameters;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return parseParams('uploadPlaylist', createUploadPlaylistSchema())(params);

              case 2:
                parsedParameters = _context3.sent;
                _context3.next = 5;
                return this.uploadPlaylistInternal(parsedParameters, advancedOptions);

              case 5:
                return _context3.abrupt("return", _context3.sent);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function uploadPlaylist(_x3, _x4) {
        return _uploadPlaylist.apply(this, arguments);
      }

      return uploadPlaylist;
    }()
    /** @hidden
     * Publish a playlist
     * Changes a playlist from private to public
     */

  }, {
    key: "publishPlaylist",
    value: function () {
      var _publishPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, advancedOptions) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('publishPlaylist', PublishPlaylistSchema)(params);

              case 2:
                _context4.next = 4;
                return this.fetchAndUpdatePlaylist({
                  userId: params.userId,
                  playlistId: params.playlistId,
                  updateMetadata: function updateMetadata(playlist) {
                    return _objectSpread2(_objectSpread2({}, playlist), {}, {
                      isPrivate: false
                    });
                  }
                }, advancedOptions);

              case 4:
                return _context4.abrupt("return", _context4.sent);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function publishPlaylist(_x5, _x6) {
        return _publishPlaylist.apply(this, arguments);
      }

      return publishPlaylist;
    }()
    /** @hidden
     * Add a single track to the end of a playlist
     * For more control use updatePlaylist
     */

  }, {
    key: "addTrackToPlaylist",
    value: function () {
      var _addTrackToPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, advancedOptions) {
        var currentBlock;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return parseParams('addTrackToPlaylist', AddTrackToPlaylistSchema)(params);

              case 2:
                _context5.next = 4;
                return this.entityManager.getCurrentBlock();

              case 4:
                currentBlock = _context5.sent;
                _context5.next = 7;
                return this.fetchAndUpdatePlaylist({
                  userId: params.userId,
                  playlistId: params.playlistId,
                  updateMetadata: function updateMetadata(playlist) {
                    var _playlist$playlistCon;

                    return _objectSpread2(_objectSpread2({}, playlist), {}, {
                      playlistContents: [].concat(_toConsumableArray((_playlist$playlistCon = playlist.playlistContents) !== null && _playlist$playlistCon !== void 0 ? _playlist$playlistCon : []), [{
                        trackId: params.trackId,
                        timestamp: currentBlock.timestamp
                      }])
                    });
                  }
                }, advancedOptions);

              case 7:
                return _context5.abrupt("return", _context5.sent);

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function addTrackToPlaylist(_x7, _x8) {
        return _addTrackToPlaylist.apply(this, arguments);
      }

      return addTrackToPlaylist;
    }()
    /** @hidden
     * Removes a single track at the given index of playlist
     * For more control use updatePlaylist
     */

  }, {
    key: "removeTrackFromPlaylist",
    value: function () {
      var _removeTrackFromPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, advancedOptions) {
        var _yield$parseParams2, trackIndex;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return parseParams('removeTrackFromPlaylist', RemoveTrackFromPlaylistSchema)(params);

              case 2:
                _yield$parseParams2 = _context6.sent;
                trackIndex = _yield$parseParams2.trackIndex;
                _context6.next = 6;
                return this.fetchAndUpdatePlaylist({
                  userId: params.userId,
                  playlistId: params.playlistId,
                  updateMetadata: function updateMetadata(playlist) {
                    if (!playlist.playlistContents || playlist.playlistContents.length <= trackIndex) {
                      throw new Error("No track exists at index ".concat(trackIndex));
                    }

                    playlist.playlistContents.splice(trackIndex, 1);
                    return _objectSpread2(_objectSpread2({}, playlist), {}, {
                      playlistContents: playlist.playlistContents
                    });
                  }
                }, advancedOptions);

              case 6:
                return _context6.abrupt("return", _context6.sent);

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function removeTrackFromPlaylist(_x9, _x10) {
        return _removeTrackFromPlaylist.apply(this, arguments);
      }

      return removeTrackFromPlaylist;
    }()
    /** @hidden
     * Update a playlist
     */

  }, {
    key: "updatePlaylist",
    value: function () {
      var _updatePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, advancedOptions) {
        var parsedParameters;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('updatePlaylist', createUpdatePlaylistSchema())(params);

              case 2:
                parsedParameters = _context7.sent;
                _context7.next = 5;
                return this.updatePlaylistInternal(parsedParameters, advancedOptions);

              case 5:
                return _context7.abrupt("return", _context7.sent);

              case 6:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function updatePlaylist(_x11, _x12) {
        return _updatePlaylist.apply(this, arguments);
      }

      return updatePlaylist;
    }()
    /** @hidden
     * Delete a playlist
     */

  }, {
    key: "deletePlaylist",
    value: function () {
      var _deletePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, advancedOptions) {
        var _yield$parseParams3, userId, playlistId;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return parseParams('deletePlaylist', DeletePlaylistSchema)(params);

              case 2:
                _yield$parseParams3 = _context8.sent;
                userId = _yield$parseParams3.userId;
                playlistId = _yield$parseParams3.playlistId;
                _context8.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.DELETE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function deletePlaylist(_x13, _x14) {
        return _deletePlaylist.apply(this, arguments);
      }

      return deletePlaylist;
    }()
    /** @hidden
     * Favorite a playlist
     */

  }, {
    key: "favoritePlaylist",
    value: function () {
      var _favoritePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, advancedOptions) {
        var _yield$parseParams4, userId, playlistId, metadata;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return parseParams('favoritePlaylist', FavoritePlaylistSchema)(params);

              case 2:
                _yield$parseParams4 = _context9.sent;
                userId = _yield$parseParams4.userId;
                playlistId = _yield$parseParams4.playlistId;
                metadata = _yield$parseParams4.metadata;
                _context9.next = 8;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.SAVE,
                  metadata: metadata && JSON.stringify(snakecaseKeys(metadata)),
                  auth: this.auth
                }, advancedOptions));

              case 8:
                return _context9.abrupt("return", _context9.sent);

              case 9:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function favoritePlaylist(_x15, _x16) {
        return _favoritePlaylist.apply(this, arguments);
      }

      return favoritePlaylist;
    }()
    /** @hidden
     * Unfavorite a playlist
     */

  }, {
    key: "unfavoritePlaylist",
    value: function () {
      var _unfavoritePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, advancedOptions) {
        var _yield$parseParams5, userId, playlistId;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return parseParams('unfavoritePlaylist', UnfavoritePlaylistSchema)(params);

              case 2:
                _yield$parseParams5 = _context10.sent;
                userId = _yield$parseParams5.userId;
                playlistId = _yield$parseParams5.playlistId;
                _context10.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.UNSAVE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context10.abrupt("return", _context10.sent);

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function unfavoritePlaylist(_x17, _x18) {
        return _unfavoritePlaylist.apply(this, arguments);
      }

      return unfavoritePlaylist;
    }()
    /** @hidden
     * Repost a playlist
     */

  }, {
    key: "repostPlaylist",
    value: function () {
      var _repostPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, advancedOptions) {
        var _yield$parseParams6, userId, playlistId, metadata;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return parseParams('respostPlaylist', RepostPlaylistSchema)(params);

              case 2:
                _yield$parseParams6 = _context11.sent;
                userId = _yield$parseParams6.userId;
                playlistId = _yield$parseParams6.playlistId;
                metadata = _yield$parseParams6.metadata;
                _context11.next = 8;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.REPOST,
                  metadata: metadata && JSON.stringify(snakecaseKeys(metadata)),
                  auth: this.auth
                }, advancedOptions));

              case 8:
                return _context11.abrupt("return", _context11.sent);

              case 9:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function repostPlaylist(_x19, _x20) {
        return _repostPlaylist.apply(this, arguments);
      }

      return repostPlaylist;
    }()
    /** @hidden
     * Unrepost a playlist
     */

  }, {
    key: "unrepostPlaylist",
    value: function () {
      var _unrepostPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, advancedOptions) {
        var _yield$parseParams7, userId, playlistId;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return parseParams('unrepostPlaylist', UnrepostPlaylistSchema)(params);

              case 2:
                _yield$parseParams7 = _context12.sent;
                userId = _yield$parseParams7.userId;
                playlistId = _yield$parseParams7.playlistId;
                _context12.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.UNREPOST,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context12.abrupt("return", _context12.sent);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function unrepostPlaylist(_x21, _x22) {
        return _unrepostPlaylist.apply(this, arguments);
      }

      return unrepostPlaylist;
    }()
    /** @internal
     * Combines the metadata for a track and a collection (playlist or album),
     * taking the metadata from the playlist when the track is missing it.
     */

  }, {
    key: "combineMetadata",
    value: function combineMetadata(trackMetadata, playlistMetadata) {
      var metadata = trackMetadata;
      if (!metadata.mood) metadata.mood = playlistMetadata.mood;

      if (playlistMetadata.tags) {
        if (!metadata.tags) {
          // Take playlist tags
          metadata.tags = playlistMetadata.tags;
        } else {
          // Combine tags and dedupe
          metadata.tags = _toConsumableArray(new Set([].concat(_toConsumableArray(metadata.tags.split(',')), _toConsumableArray(playlistMetadata.tags.split(','))))).join(',');
        }
      }

      return trackMetadata;
    }
    /** @internal
     * Update helper method that first fetches a playlist and then updates it
     */

  }, {
    key: "fetchAndUpdatePlaylist",
    value: function () {
      var _fetchAndUpdatePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref2, advancedOptions) {
        var _playlistResponse$dat;

        var userId, playlistId, updateMetadata, playlistResponse, playlist, supportedUpdateFields;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                userId = _ref2.userId, playlistId = _ref2.playlistId, updateMetadata = _ref2.updateMetadata;
                _context13.next = 3;
                return this.getPlaylist({
                  playlistId: playlistId,
                  userId: userId
                });

              case 3:
                playlistResponse = _context13.sent;
                playlist = (_playlistResponse$dat = playlistResponse.data) === null || _playlistResponse$dat === void 0 ? void 0 : _playlistResponse$dat[0];

                if (playlist) {
                  _context13.next = 7;
                  break;
                }

                throw new Error("Could not fetch playlist: ".concat(playlistId));

              case 7:
                supportedUpdateFields = Object.keys(createUpdatePlaylistMetadataSchema().shape);
                _context13.next = 10;
                return this.updatePlaylist({
                  userId: userId,
                  playlistId: playlistId,
                  metadata: updateMetadata(pick(playlist, supportedUpdateFields))
                }, advancedOptions);

              case 10:
                return _context13.abrupt("return", _context13.sent);

              case 11:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function fetchAndUpdatePlaylist(_x23, _x24) {
        return _fetchAndUpdatePlaylist.apply(this, arguments);
      }

      return fetchAndUpdatePlaylist;
    }()
    /** @internal
     * Method to upload a playlist with already parsed inputs
     * This is used for both playlists and albums
     */

  }, {
    key: "uploadPlaylistInternal",
    value: function () {
      var _uploadPlaylistInternal = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(_ref3, advancedOptions) {
        var _this3 = this;

        var userId, coverArtFile, trackFiles, onProgress, metadata, trackMetadatas, _yield$Promise$all, _yield$Promise$all2, coverArtResponse, audioResponses, trackIds, playlistId, currentBlock, updatedMetadata, response;

        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                userId = _ref3.userId, coverArtFile = _ref3.coverArtFile, trackFiles = _ref3.trackFiles, onProgress = _ref3.onProgress, metadata = _ref3.metadata, trackMetadatas = _ref3.trackMetadatas;
                _context18.next = 3;
                return Promise.all([retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
                  return regeneratorRuntime.wrap(function _callee14$(_context14) {
                    while (1) {
                      switch (_context14.prev = _context14.next) {
                        case 0:
                          _context14.next = 2;
                          return _this3.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context14.abrupt("return", _context14.sent);

                        case 3:
                        case "end":
                          return _context14.stop();
                      }
                    }
                  }, _callee14);
                })), function (e) {
                  _this3.logger.info('Retrying uploadPlaylistCoverArt', e);
                })].concat(_toConsumableArray(trackFiles.map( /*#__PURE__*/function () {
                  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(trackFile) {
                    return regeneratorRuntime.wrap(function _callee16$(_context16) {
                      while (1) {
                        switch (_context16.prev = _context16.next) {
                          case 0:
                            _context16.next = 2;
                            return retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
                              return regeneratorRuntime.wrap(function _callee15$(_context15) {
                                while (1) {
                                  switch (_context15.prev = _context15.next) {
                                    case 0:
                                      _context15.next = 2;
                                      return _this3.storage.uploadFile({
                                        file: trackFile,
                                        onProgress: onProgress,
                                        template: 'audio'
                                      });

                                    case 2:
                                      return _context15.abrupt("return", _context15.sent);

                                    case 3:
                                    case "end":
                                      return _context15.stop();
                                  }
                                }
                              }, _callee15);
                            })), function (e) {
                              _this3.logger.info('Retrying uploadTrackAudio', e);
                            });

                          case 2:
                            return _context16.abrupt("return", _context16.sent);

                          case 3:
                          case "end":
                            return _context16.stop();
                        }
                      }
                    }, _callee16);
                  }));

                  return function (_x27) {
                    return _ref5.apply(this, arguments);
                  };
                }()))));

              case 3:
                _yield$Promise$all = _context18.sent;
                _yield$Promise$all2 = _toArray(_yield$Promise$all);
                coverArtResponse = _yield$Promise$all2[0];
                audioResponses = _yield$Promise$all2.slice(1);
                _context18.next = 9;
                return Promise.all(trackMetadatas.map( /*#__PURE__*/function () {
                  var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(parsedTrackMetadata, i) {
                    var trackMetadata, audioResponse, updatedMetadata, trackId;
                    return regeneratorRuntime.wrap(function _callee17$(_context17) {
                      while (1) {
                        switch (_context17.prev = _context17.next) {
                          case 0:
                            // Transform track metadata
                            trackMetadata = _this3.combineMetadata(_this3.trackUploadHelper.transformTrackUploadMetadata(parsedTrackMetadata, userId), metadata);
                            audioResponse = audioResponses[i];

                            if (audioResponse) {
                              _context17.next = 4;
                              break;
                            }

                            throw new Error("Failed to upload track: ".concat(trackMetadata.title));

                          case 4:
                            // Update metadata to include uploaded CIDs
                            updatedMetadata = _this3.trackUploadHelper.populateTrackMetadataWithUploadResponse(trackMetadata, audioResponse, coverArtResponse);
                            _context17.next = 7;
                            return _this3.trackUploadHelper.generateId('track');

                          case 7:
                            trackId = _context17.sent;
                            _context17.next = 10;
                            return _this3.entityManager.manageEntity(_objectSpread2({
                              userId: userId,
                              entityType: EntityType.TRACK,
                              entityId: trackId,
                              action: Action.CREATE,
                              metadata: JSON.stringify({
                                cid: '',
                                data: snakecaseKeys(updatedMetadata)
                              }),
                              auth: _this3.auth
                            }, advancedOptions));

                          case 10:
                            return _context17.abrupt("return", trackId);

                          case 11:
                          case "end":
                            return _context17.stop();
                        }
                      }
                    }, _callee17);
                  }));

                  return function (_x28, _x29) {
                    return _ref7.apply(this, arguments);
                  };
                }()));

              case 9:
                trackIds = _context18.sent;
                _context18.next = 12;
                return this.trackUploadHelper.generateId('playlist');

              case 12:
                playlistId = _context18.sent;
                _context18.next = 15;
                return this.entityManager.getCurrentBlock();

              case 15:
                currentBlock = _context18.sent;
                // Update metadata to include track ids and cover art cid
                updatedMetadata = _objectSpread2(_objectSpread2({}, metadata), {}, {
                  isPrivate: false,
                  playlistContents: {
                    trackIds: trackIds.map(function (trackId) {
                      return {
                        track: trackId,
                        time: currentBlock.timestamp
                      };
                    })
                  },
                  playlistImageSizesMultihash: coverArtResponse.id
                }); // Write playlist metadata to chain

                _context18.next = 19;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.CREATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys(updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 19:
                response = _context18.sent;
                return _context18.abrupt("return", _objectSpread2(_objectSpread2({}, response), {}, {
                  playlistId: encodeHashId(playlistId)
                }));

              case 21:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function uploadPlaylistInternal(_x25, _x26) {
        return _uploadPlaylistInternal.apply(this, arguments);
      }

      return uploadPlaylistInternal;
    }()
    /** @internal
     * Method to update a playlist with already parsed inputs
     * This is used for both playlists and albums
     */

  }, {
    key: "updatePlaylistInternal",
    value: function () {
      var _updatePlaylistInternal = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(_ref8, advancedOptions) {
        var _this4 = this;

        var userId, playlistId, coverArtFile, onProgress, metadata, coverArtResponse, updatedMetadata;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                userId = _ref8.userId, playlistId = _ref8.playlistId, coverArtFile = _ref8.coverArtFile, onProgress = _ref8.onProgress, metadata = _ref8.metadata;
                _context20.t0 = coverArtFile;

                if (!_context20.t0) {
                  _context20.next = 6;
                  break;
                }

                _context20.next = 5;
                return retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
                  return regeneratorRuntime.wrap(function _callee19$(_context19) {
                    while (1) {
                      switch (_context19.prev = _context19.next) {
                        case 0:
                          _context19.next = 2;
                          return _this4.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context19.abrupt("return", _context19.sent);

                        case 3:
                        case "end":
                          return _context19.stop();
                      }
                    }
                  }, _callee19);
                })), function (e) {
                  _this4.logger.info('Retrying uploadPlaylistCoverArt', e);
                });

              case 5:
                _context20.t0 = _context20.sent;

              case 6:
                coverArtResponse = _context20.t0;
                updatedMetadata = _objectSpread2(_objectSpread2(_objectSpread2({}, metadata), metadata.playlistContents ? {
                  playlistContents: {
                    trackIds: metadata.playlistContents.map(function (_ref10) {
                      var trackId = _ref10.trackId,
                          metadataTimestamp = _ref10.metadataTimestamp,
                          timestamp = _ref10.timestamp;
                      return {
                        track: trackId,
                        // default to timestamp for legacy playlists
                        time: metadataTimestamp !== null && metadataTimestamp !== void 0 ? metadataTimestamp : timestamp
                      };
                    })
                  }
                } : {}), coverArtResponse ? {
                  playlistImageSizesMultihash: coverArtResponse.id
                } : {});
                _context20.next = 10;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.PLAYLIST,
                  entityId: playlistId,
                  action: Action.UPDATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys(updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 10:
                return _context20.abrupt("return", _context20.sent);

              case 11:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function updatePlaylistInternal(_x30, _x31) {
        return _updatePlaylistInternal.apply(this, arguments);
      }

      return updatePlaylistInternal;
    }()
  }]);

  return PlaylistsApi;
}(PlaylistsApi$2);

var getAlbumSchema = z.object({
  userId: z.string(),
  albumId: z.string()
});
var getAlbumTracksSchema = z.object({
  albumId: z.string()
});
var createUploadAlbumMetadataSchema = function createUploadAlbumMetadataSchema() {
  return z.object({
    albumName: z.string(),
    description: z.optional(z.string().max(1000)),
    genre: z["enum"](Object.values(Genre)),
    license: z.optional(z.string()),
    mood: z.optional(z["enum"](Object.values(Mood))),
    releaseDate: z.optional(z.date().max(new Date(), {
      message: 'should not be in the future'
    })),
    tags: z.optional(z.string()),
    upc: z.optional(z.string())
  }).strict();
};

var createAlbumTrackMetadataSchema = function createAlbumTrackMetadataSchema() {
  return createUploadTrackMetadataSchema().partial({
    genre: true,
    mood: true,
    tags: true
  });
};

var createUploadAlbumSchema = function createUploadAlbumSchema() {
  return z.object({
    userId: HashId,
    coverArtFile: ImageFile,
    metadata: createUploadAlbumMetadataSchema(),
    onProgress: z.optional(z["function"]().args(z.number())),

    /**
     * Track metadata is populated from the album if fields are missing
     */
    trackMetadatas: z.array(createAlbumTrackMetadataSchema()),
    trackFiles: z.array(AudioFile)
  }).strict();
};
var createUpdateAlbumSchema = function createUpdateAlbumSchema() {
  return z.object({
    userId: HashId,
    albumId: HashId,
    coverArtFile: z.optional(ImageFile),
    metadata: createUploadAlbumMetadataSchema().partial(),
    onProgress: z.optional(z["function"]().args(z.number()))
  }).strict();
};
var DeleteAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId
}).strict();
var FavoriteAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: z["boolean"]()
  }))
}).strict();
var UnfavoriteAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId
}).strict();
var RepostAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: z["boolean"]()
  }))
}).strict();
var UnrepostAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId
}).strict();

var _excluded = ["metadata"],
    _excluded2 = ["albumName"],
    _excluded3 = ["albumId", "metadata"],
    _excluded4 = ["albumName"];
var AlbumsApi = /*#__PURE__*/function () {
  function AlbumsApi(configuration, storage, entityManager, auth, logger) {
    _classCallCheck(this, AlbumsApi);

    _defineProperty$1(this, "playlistsApi", void 0);

    this.playlistsApi = new PlaylistsApi$1(configuration, storage, entityManager, auth, logger);
  } // READS


  _createClass(AlbumsApi, [{
    key: "getAlbum",
    value: function () {
      var _getAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var userId, albumId;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                userId = params.userId, albumId = params.albumId;
                _context.next = 3;
                return this.playlistsApi.getPlaylist({
                  userId: userId,
                  playlistId: albumId
                });

              case 3:
                return _context.abrupt("return", _context.sent);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAlbum(_x) {
        return _getAlbum.apply(this, arguments);
      }

      return getAlbum;
    }()
  }, {
    key: "getAlbumTracks",
    value: function () {
      var _getAlbumTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        var albumId;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                albumId = params.albumId;
                _context2.next = 3;
                return this.playlistsApi.getPlaylistTracks({
                  playlistId: albumId
                });

              case 3:
                return _context2.abrupt("return", _context2.sent);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getAlbumTracks(_x2) {
        return _getAlbumTracks.apply(this, arguments);
      }

      return getAlbumTracks;
    }() // WRITES

    /** @hidden
     * Upload an album
     * Uploads the specified tracks and combines them into an album
     */

  }, {
    key: "uploadAlbum",
    value: function () {
      var _uploadAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, advancedOptions) {
        var _yield$parseParams, metadata, parsedParameters, albumName, playlistMetadata, response;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return parseParams('uploadAlbum', createUploadAlbumSchema())(params);

              case 2:
                _yield$parseParams = _context3.sent;
                metadata = _yield$parseParams.metadata;
                parsedParameters = _objectWithoutProperties(_yield$parseParams, _excluded);
                albumName = metadata.albumName, playlistMetadata = _objectWithoutProperties(metadata, _excluded2); // Call uploadPlaylistInternal with parsed inputs

                _context3.next = 8;
                return this.playlistsApi.uploadPlaylistInternal(_objectSpread2(_objectSpread2({}, parsedParameters), {}, {
                  metadata: _objectSpread2(_objectSpread2({}, playlistMetadata), {}, {
                    playlistName: albumName,
                    isAlbum: true
                  })
                }), advancedOptions);

              case 8:
                response = _context3.sent;
                return _context3.abrupt("return", {
                  blockHash: response.blockHash,
                  blockNumber: response.blockNumber,
                  albumId: response.playlistId
                });

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function uploadAlbum(_x3, _x4) {
        return _uploadAlbum.apply(this, arguments);
      }

      return uploadAlbum;
    }()
    /** @hidden
     * Update an album
     */

  }, {
    key: "updateAlbum",
    value: function () {
      var _updateAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, advancedOptions) {
        var _yield$parseParams2, albumId, metadata, parsedParameters, albumName, playlistMetadata;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('updateAlbum', createUpdateAlbumSchema())(params);

              case 2:
                _yield$parseParams2 = _context4.sent;
                albumId = _yield$parseParams2.albumId;
                metadata = _yield$parseParams2.metadata;
                parsedParameters = _objectWithoutProperties(_yield$parseParams2, _excluded3);
                albumName = metadata.albumName, playlistMetadata = _objectWithoutProperties(metadata, _excluded4); // Call updatePlaylistInternal with parsed inputs

                _context4.next = 9;
                return this.playlistsApi.updatePlaylistInternal(_objectSpread2(_objectSpread2({}, parsedParameters), {}, {
                  playlistId: albumId,
                  metadata: _objectSpread2(_objectSpread2({}, playlistMetadata), {}, {
                    playlistName: albumName
                  })
                }), advancedOptions);

              case 9:
                return _context4.abrupt("return", _context4.sent);

              case 10:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function updateAlbum(_x5, _x6) {
        return _updateAlbum.apply(this, arguments);
      }

      return updateAlbum;
    }()
    /** @hidden
     * Delete an album
     */

  }, {
    key: "deleteAlbum",
    value: function () {
      var _deleteAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, advancedOptions) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return parseParams('deleteAlbum', DeleteAlbumSchema)(params);

              case 2:
                _context5.next = 4;
                return this.playlistsApi.deletePlaylist({
                  userId: params.userId,
                  playlistId: params.albumId
                }, advancedOptions);

              case 4:
                return _context5.abrupt("return", _context5.sent);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function deleteAlbum(_x7, _x8) {
        return _deleteAlbum.apply(this, arguments);
      }

      return deleteAlbum;
    }()
    /** @hidden
     * Favorite an album
     */

  }, {
    key: "favoriteAlbum",
    value: function () {
      var _favoriteAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, advancedOptions) {
        var _yield$parseParams3, metadata;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return parseParams('favoriteAlbum', FavoriteAlbumSchema)(params);

              case 2:
                _yield$parseParams3 = _context6.sent;
                metadata = _yield$parseParams3.metadata;
                _context6.next = 6;
                return this.playlistsApi.favoritePlaylist({
                  userId: params.userId,
                  playlistId: params.albumId,
                  metadata: metadata
                }, advancedOptions);

              case 6:
                return _context6.abrupt("return", _context6.sent);

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function favoriteAlbum(_x9, _x10) {
        return _favoriteAlbum.apply(this, arguments);
      }

      return favoriteAlbum;
    }()
    /** @hidden
     * Unfavorite an album
     */

  }, {
    key: "unfavoriteAlbum",
    value: function () {
      var _unfavoriteAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, advancedOptions) {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('unfavoriteAlbum', UnfavoriteAlbumSchema)(params);

              case 2:
                _context7.next = 4;
                return this.playlistsApi.unfavoritePlaylist({
                  userId: params.userId,
                  playlistId: params.albumId
                }, advancedOptions);

              case 4:
                return _context7.abrupt("return", _context7.sent);

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function unfavoriteAlbum(_x11, _x12) {
        return _unfavoriteAlbum.apply(this, arguments);
      }

      return unfavoriteAlbum;
    }()
    /** @hidden
     * Repost an album
     */

  }, {
    key: "repostAlbum",
    value: function () {
      var _repostAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, advancedOptions) {
        var _yield$parseParams4, metadata;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return parseParams('repostAlbum', RepostAlbumSchema)(params);

              case 2:
                _yield$parseParams4 = _context8.sent;
                metadata = _yield$parseParams4.metadata;
                _context8.next = 6;
                return this.playlistsApi.repostPlaylist({
                  userId: params.userId,
                  playlistId: params.albumId,
                  metadata: metadata
                }, advancedOptions);

              case 6:
                return _context8.abrupt("return", _context8.sent);

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function repostAlbum(_x13, _x14) {
        return _repostAlbum.apply(this, arguments);
      }

      return repostAlbum;
    }()
    /** @hidden
     * Unrepost an album
     */

  }, {
    key: "unrepostAlbum",
    value: function () {
      var _unrepostAlbum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, advancedOptions) {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return parseParams('unrepostAlbum', UnrepostAlbumSchema)(params);

              case 2:
                _context9.next = 4;
                return this.playlistsApi.unrepostPlaylist({
                  userId: params.userId,
                  playlistId: params.albumId
                }, advancedOptions);

              case 4:
                return _context9.abrupt("return", _context9.sent);

              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function unrepostAlbum(_x15, _x16) {
        return _unrepostAlbum.apply(this, arguments);
      }

      return unrepostAlbum;
    }()
  }]);

  return AlbumsApi;
}();

var TracksApi$1 = /*#__PURE__*/function (_GeneratedTracksApi) {
  _inherits(TracksApi, _GeneratedTracksApi);

  var _super = _createSuper(TracksApi);

  function TracksApi(configuration, discoveryNodeSelectorService, storage, entityManager, auth, logger) {
    var _this;

    _classCallCheck(this, TracksApi);

    _this = _super.call(this, configuration);

    _defineProperty$1(_assertThisInitialized(_this), "discoveryNodeSelectorService", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "storage", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "entityManager", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "logger", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "trackUploadHelper", void 0);

    _this.discoveryNodeSelectorService = discoveryNodeSelectorService;
    _this.storage = storage;
    _this.entityManager = entityManager;
    _this.auth = auth;
    _this.logger = logger;
    _this.trackUploadHelper = new TrackUploadHelper(configuration);
    _this.logger = logger.createPrefixedLogger('[tracks-api]');
    return _this;
  }
  /**
   * Get the url of the track's streamable mp3 file
   */
  // @ts-expect-error


  _createClass(TracksApi, [{
    key: "streamTrack",
    value: function () {
      var _streamTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var path, host;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrack.');

              case 2:
                path = "/tracks/{track_id}/stream".replace("{".concat('track_id', "}"), encodeURIComponent(String(params.trackId)));
                _context.next = 5;
                return this.discoveryNodeSelectorService.getSelectedEndpoint();

              case 5:
                host = _context.sent;
                return _context.abrupt("return", "".concat(host).concat(BASE_PATH$1).concat(path));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function streamTrack(_x) {
        return _streamTrack.apply(this, arguments);
      }

      return streamTrack;
    }()
    /** @hidden
     * Upload a track
     */

  }, {
    key: "uploadTrack",
    value: function () {
      var _uploadTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, advancedOptions) {
        var _this2 = this;

        var _yield$parseParams, userId, trackFile, coverArtFile, parsedMetadata, onProgress, metadata, uploadOptions, _yield$Promise$all, _yield$Promise$all2, coverArtResponse, audioResponse, updatedMetadata, trackId, response;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('uploadTrack', createUploadTrackSchema())(params);

              case 2:
                _yield$parseParams = _context4.sent;
                userId = _yield$parseParams.userId;
                trackFile = _yield$parseParams.trackFile;
                coverArtFile = _yield$parseParams.coverArtFile;
                parsedMetadata = _yield$parseParams.metadata;
                onProgress = _yield$parseParams.onProgress;
                // Transform metadata
                metadata = this.trackUploadHelper.transformTrackUploadMetadata(parsedMetadata, userId);
                uploadOptions = {};

                if (metadata.previewStartSeconds) {
                  uploadOptions['previewStartSeconds'] = metadata.previewStartSeconds.toString();
                } // Upload track audio and cover art to storage node


                _context4.next = 13;
                return Promise.all([retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                  return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.next = 2;
                          return _this2.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context2.abrupt("return", _context2.sent);

                        case 3:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                })), function (e) {
                  _this2.logger.info('Retrying uploadTrackCoverArt', e);
                }), retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                  return regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 2;
                          return _this2.storage.uploadFile({
                            file: trackFile,
                            onProgress: onProgress,
                            template: 'audio',
                            options: uploadOptions
                          });

                        case 2:
                          return _context3.abrupt("return", _context3.sent);

                        case 3:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                })), function (e) {
                  _this2.logger.info('Retrying uploadTrackAudio', e);
                })]);

              case 13:
                _yield$Promise$all = _context4.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                coverArtResponse = _yield$Promise$all2[0];
                audioResponse = _yield$Promise$all2[1];
                // Update metadata to include uploaded CIDs
                updatedMetadata = this.trackUploadHelper.populateTrackMetadataWithUploadResponse(metadata, audioResponse, coverArtResponse); // Write metadata to chain

                _context4.next = 20;
                return this.trackUploadHelper.generateId('track');

              case 20:
                trackId = _context4.sent;
                _context4.next = 23;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.TRACK,
                  entityId: trackId,
                  action: Action.CREATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys(updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 23:
                response = _context4.sent;
                return _context4.abrupt("return", _objectSpread2(_objectSpread2({}, response), {}, {
                  trackId: encodeHashId(trackId)
                }));

              case 25:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function uploadTrack(_x2, _x3) {
        return _uploadTrack.apply(this, arguments);
      }

      return uploadTrack;
    }()
    /** @hidden
     * Update a track
     */

  }, {
    key: "updateTrack",
    value: function () {
      var _updateTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, advancedOptions) {
        var _this3 = this;

        var _yield$parseParams2, userId, trackId, coverArtFile, parsedMetadata, onProgress, transcodePreview, metadata, coverArtResp, updatedMetadata, editFileData, updatePreviewResp, previewKey;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('updateTrack', createUpdateTrackSchema())(params);

              case 2:
                _yield$parseParams2 = _context7.sent;
                userId = _yield$parseParams2.userId;
                trackId = _yield$parseParams2.trackId;
                coverArtFile = _yield$parseParams2.coverArtFile;
                parsedMetadata = _yield$parseParams2.metadata;
                onProgress = _yield$parseParams2.onProgress;
                transcodePreview = _yield$parseParams2.transcodePreview;
                // Transform metadata
                metadata = this.trackUploadHelper.transformTrackUploadMetadata(parsedMetadata, userId); // Upload track cover art to storage node

                _context7.t0 = coverArtFile;

                if (!_context7.t0) {
                  _context7.next = 15;
                  break;
                }

                _context7.next = 14;
                return retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
                  return regeneratorRuntime.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return _this3.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context5.abrupt("return", _context5.sent);

                        case 3:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                })), function (e) {
                  _this3.logger.info('Retrying uploadTrackCoverArt', e);
                });

              case 14:
                _context7.t0 = _context7.sent;

              case 15:
                coverArtResp = _context7.t0;
                // Update metadata to include uploaded CIDs
                updatedMetadata = _objectSpread2(_objectSpread2({}, metadata), coverArtResp ? {
                  coverArtSizes: coverArtResp.id
                } : {});

                if (!transcodePreview) {
                  _context7.next = 28;
                  break;
                }

                if (updatedMetadata.previewStartSeconds) {
                  _context7.next = 20;
                  break;
                }

                throw new Error('No track preview start time specified');

              case 20:
                if (updatedMetadata.audioUploadId) {
                  _context7.next = 22;
                  break;
                }

                throw new Error('Missing required audio_upload_id');

              case 22:
                // Transocde track preview
                editFileData = {
                  previewStartSeconds: updatedMetadata.previewStartSeconds.toString()
                };
                _context7.next = 25;
                return retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
                  return regeneratorRuntime.wrap(function _callee6$(_context6) {
                    while (1) {
                      switch (_context6.prev = _context6.next) {
                        case 0:
                          _context6.next = 2;
                          return _this3.storage.editFile({
                            uploadId: updatedMetadata.audioUploadId,
                            data: editFileData,
                            auth: _this3.auth
                          });

                        case 2:
                          return _context6.abrupt("return", _context6.sent);

                        case 3:
                        case "end":
                          return _context6.stop();
                      }
                    }
                  }, _callee6);
                })), function (e) {
                  _this3.logger.info('Retrying editFileV2', e);
                });

              case 25:
                updatePreviewResp = _context7.sent;
                // Update metadata to include updated preview CID
                previewKey = "320_preview|".concat(updatedMetadata.previewStartSeconds);
                updatedMetadata.previewCid = updatePreviewResp.results[previewKey];

              case 28:
                _context7.next = 30;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.TRACK,
                  entityId: trackId,
                  action: Action.UPDATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys(updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 30:
                return _context7.abrupt("return", _context7.sent);

              case 31:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function updateTrack(_x4, _x5) {
        return _updateTrack.apply(this, arguments);
      }

      return updateTrack;
    }()
    /** @hidden
     * Delete a track
     */

  }, {
    key: "deleteTrack",
    value: function () {
      var _deleteTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, advancedOptions) {
        var _yield$parseParams3, userId, trackId;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return parseParams('deleteTrack', DeleteTrackSchema)(params);

              case 2:
                _yield$parseParams3 = _context8.sent;
                userId = _yield$parseParams3.userId;
                trackId = _yield$parseParams3.trackId;
                _context8.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.TRACK,
                  entityId: trackId,
                  action: Action.DELETE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function deleteTrack(_x6, _x7) {
        return _deleteTrack.apply(this, arguments);
      }

      return deleteTrack;
    }()
    /** @hidden
     * Favorite a track
     */

  }, {
    key: "favoriteTrack",
    value: function () {
      var _favoriteTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, advancedOptions) {
        var _yield$parseParams4, userId, trackId, metadata;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return parseParams('favoriteTrack', FavoriteTrackSchema)(params);

              case 2:
                _yield$parseParams4 = _context9.sent;
                userId = _yield$parseParams4.userId;
                trackId = _yield$parseParams4.trackId;
                metadata = _yield$parseParams4.metadata;
                _context9.next = 8;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.TRACK,
                  entityId: trackId,
                  action: Action.SAVE,
                  metadata: metadata && JSON.stringify(snakecaseKeys(metadata)),
                  auth: this.auth
                }, advancedOptions));

              case 8:
                return _context9.abrupt("return", _context9.sent);

              case 9:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function favoriteTrack(_x8, _x9) {
        return _favoriteTrack.apply(this, arguments);
      }

      return favoriteTrack;
    }()
    /** @hidden
     * Unfavorite a track
     */

  }, {
    key: "unfavoriteTrack",
    value: function () {
      var _unfavoriteTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, advancedOptions) {
        var _yield$parseParams5, userId, trackId;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return parseParams('unfavoriteTrack', UnfavoriteTrackSchema)(params);

              case 2:
                _yield$parseParams5 = _context10.sent;
                userId = _yield$parseParams5.userId;
                trackId = _yield$parseParams5.trackId;
                _context10.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.TRACK,
                  entityId: trackId,
                  action: Action.UNSAVE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context10.abrupt("return", _context10.sent);

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function unfavoriteTrack(_x10, _x11) {
        return _unfavoriteTrack.apply(this, arguments);
      }

      return unfavoriteTrack;
    }()
    /** @hidden
     * Repost a track
     */

  }, {
    key: "repostTrack",
    value: function () {
      var _repostTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, advancedOptions) {
        var _yield$parseParams6, userId, trackId, metadata;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return parseParams('respostTrack', RepostTrackSchema)(params);

              case 2:
                _yield$parseParams6 = _context11.sent;
                userId = _yield$parseParams6.userId;
                trackId = _yield$parseParams6.trackId;
                metadata = _yield$parseParams6.metadata;
                _context11.next = 8;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.TRACK,
                  entityId: trackId,
                  action: Action.REPOST,
                  metadata: metadata && JSON.stringify(snakecaseKeys(metadata)),
                  auth: this.auth
                }, advancedOptions));

              case 8:
                return _context11.abrupt("return", _context11.sent);

              case 9:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function repostTrack(_x12, _x13) {
        return _repostTrack.apply(this, arguments);
      }

      return repostTrack;
    }()
    /** @hidden
     * Unrepost a track
     */

  }, {
    key: "unrepostTrack",
    value: function () {
      var _unrepostTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, advancedOptions) {
        var _yield$parseParams7, userId, trackId;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return parseParams('unrepostTrack', UnrepostTrackSchema)(params);

              case 2:
                _yield$parseParams7 = _context12.sent;
                userId = _yield$parseParams7.userId;
                trackId = _yield$parseParams7.trackId;
                _context12.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.TRACK,
                  entityId: trackId,
                  action: Action.UNREPOST,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context12.abrupt("return", _context12.sent);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function unrepostTrack(_x14, _x15) {
        return _unrepostTrack.apply(this, arguments);
      }

      return unrepostTrack;
    }()
  }]);

  return TracksApi;
}(TracksApi$2);

var UpdateProfileSchema = z.object({
  userId: HashId,
  profilePictureFile: z.optional(ImageFile),
  coverArtFile: z.optional(ImageFile),
  onProgress: z.optional(z["function"]().args(z.number())),
  metadata: z.object({
    name: z.optional(z.string()),
    bio: z.optional(z.string()),
    location: z.optional(z.string()),
    isDeactivated: z.optional(z["boolean"]()),
    artistPickTrackId: z.optional(HashId)
  }).strict()
}).strict();
var FollowUserSchema = z.object({
  userId: HashId,
  followeeUserId: HashId
}).strict();
var UnfollowUserSchema = z.object({
  userId: HashId,
  followeeUserId: HashId
}).strict();
var SubscribeToUserSchema = z.object({
  userId: HashId,
  subscribeeUserId: HashId
}).strict();
var UnsubscribeFromUserSchema = z.object({
  userId: HashId,
  subscribeeUserId: HashId
}).strict();

var UsersApi$1 = /*#__PURE__*/function (_GeneratedUsersApi) {
  _inherits(UsersApi, _GeneratedUsersApi);

  var _super = _createSuper(UsersApi);

  function UsersApi(configuration, storage, entityManager, auth, logger) {
    var _this;

    _classCallCheck(this, UsersApi);

    _this = _super.call(this, configuration);

    _defineProperty$1(_assertThisInitialized(_this), "storage", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "entityManager", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "logger", void 0);

    _this.storage = storage;
    _this.entityManager = entityManager;
    _this.auth = auth;
    _this.logger = logger;
    _this.logger = logger.createPrefixedLogger('[users-api]');
    return _this;
  }
  /** @hidden
   * Update a user profile
   */


  _createClass(UsersApi, [{
    key: "updateProfile",
    value: function () {
      var _updateProfile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, advancedOptions) {
        var _this2 = this;

        var _yield$parseParams, onProgress, profilePictureFile, coverArtFile, userId, metadata, _yield$Promise$all, _yield$Promise$all2, profilePictureResp, coverArtResp, updatedMetadata;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return parseParams('updateProfile', UpdateProfileSchema)(params);

              case 2:
                _yield$parseParams = _context3.sent;
                onProgress = _yield$parseParams.onProgress;
                profilePictureFile = _yield$parseParams.profilePictureFile;
                coverArtFile = _yield$parseParams.coverArtFile;
                userId = _yield$parseParams.userId;
                metadata = _yield$parseParams.metadata;
                _context3.next = 10;
                return Promise.all([profilePictureFile && retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.next = 2;
                          return _this2.storage.uploadFile({
                            file: profilePictureFile,
                            onProgress: onProgress,
                            template: 'img_square'
                          });

                        case 2:
                          return _context.abrupt("return", _context.sent);

                        case 3:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                })), function (e) {
                  _this2.logger.info('Retrying uploadProfilePicture', e);
                }), coverArtFile && retry3( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                  return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.next = 2;
                          return _this2.storage.uploadFile({
                            file: coverArtFile,
                            onProgress: onProgress,
                            template: 'img_backdrop'
                          });

                        case 2:
                          return _context2.abrupt("return", _context2.sent);

                        case 3:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                })), function (e) {
                  _this2.logger.info('Retrying uploadProfileCoverArt', e);
                })]);

              case 10:
                _yield$Promise$all = _context3.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                profilePictureResp = _yield$Promise$all2[0];
                coverArtResp = _yield$Promise$all2[1];
                updatedMetadata = _objectSpread2(_objectSpread2(_objectSpread2({}, metadata), profilePictureResp ? {
                  profilePicture: profilePictureResp === null || profilePictureResp === void 0 ? void 0 : profilePictureResp.id
                } : {}), coverArtResp ? {
                  coverPhoto: coverArtResp === null || coverArtResp === void 0 ? void 0 : coverArtResp.id
                } : {}); // Write metadata to chain

                _context3.next = 17;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.USER,
                  entityId: userId,
                  action: Action.UPDATE,
                  metadata: JSON.stringify({
                    cid: '',
                    data: snakecaseKeys(updatedMetadata)
                  }),
                  auth: this.auth
                }, advancedOptions));

              case 17:
                return _context3.abrupt("return", _context3.sent);

              case 18:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function updateProfile(_x, _x2) {
        return _updateProfile.apply(this, arguments);
      }

      return updateProfile;
    }()
    /** @hidden
     * Follow a user
     */

  }, {
    key: "followUser",
    value: function () {
      var _followUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, advancedOptions) {
        var _yield$parseParams2, userId, followeeUserId;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('followUser', FollowUserSchema)(params);

              case 2:
                _yield$parseParams2 = _context4.sent;
                userId = _yield$parseParams2.userId;
                followeeUserId = _yield$parseParams2.followeeUserId;
                _context4.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.USER,
                  entityId: followeeUserId,
                  action: Action.FOLLOW,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context4.abrupt("return", _context4.sent);

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function followUser(_x3, _x4) {
        return _followUser.apply(this, arguments);
      }

      return followUser;
    }()
    /** @hidden
     * Unfollow a user
     */

  }, {
    key: "unfollowUser",
    value: function () {
      var _unfollowUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, advancedOptions) {
        var _yield$parseParams3, userId, followeeUserId;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return parseParams('unfollowUser', UnfollowUserSchema)(params);

              case 2:
                _yield$parseParams3 = _context5.sent;
                userId = _yield$parseParams3.userId;
                followeeUserId = _yield$parseParams3.followeeUserId;
                _context5.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.USER,
                  entityId: followeeUserId,
                  action: Action.UNFOLLOW,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context5.abrupt("return", _context5.sent);

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function unfollowUser(_x5, _x6) {
        return _unfollowUser.apply(this, arguments);
      }

      return unfollowUser;
    }()
    /** @hidden
     * Subscribe to a user
     */

  }, {
    key: "subscribeToUser",
    value: function () {
      var _subscribeToUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, advancedOptions) {
        var _yield$parseParams4, userId, subscribeeUserId;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return parseParams('subscribeToUser', SubscribeToUserSchema)(params);

              case 2:
                _yield$parseParams4 = _context6.sent;
                userId = _yield$parseParams4.userId;
                subscribeeUserId = _yield$parseParams4.subscribeeUserId;
                _context6.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.USER,
                  entityId: subscribeeUserId,
                  action: Action.SUBSCRIBE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context6.abrupt("return", _context6.sent);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function subscribeToUser(_x7, _x8) {
        return _subscribeToUser.apply(this, arguments);
      }

      return subscribeToUser;
    }()
    /** @hidden
     * Unsubscribe from a user
     */

  }, {
    key: "unsubscribeFromUser",
    value: function () {
      var _unsubscribeFromUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, advancedOptions) {
        var _yield$parseParams5, userId, subscribeeUserId;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('unsubscribeFromUser', UnsubscribeFromUserSchema)(params);

              case 2:
                _yield$parseParams5 = _context7.sent;
                userId = _yield$parseParams5.userId;
                subscribeeUserId = _yield$parseParams5.subscribeeUserId;
                _context7.next = 7;
                return this.entityManager.manageEntity(_objectSpread2({
                  userId: userId,
                  entityType: EntityType.USER,
                  entityId: subscribeeUserId,
                  action: Action.UNSUBSCRIBE,
                  auth: this.auth
                }, advancedOptions));

              case 7:
                return _context7.abrupt("return", _context7.sent);

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function unsubscribeFromUser(_x9, _x10) {
        return _unsubscribeFromUser.apply(this, arguments);
      }

      return unsubscribeFromUser;
    }()
  }]);

  return UsersApi;
}(UsersApi$2);

var ResolveApi = /*#__PURE__*/function (_BaseAPI) {
  _inherits(ResolveApi, _BaseAPI);

  var _super = _createSuper(ResolveApi);

  function ResolveApi() {
    _classCallCheck(this, ResolveApi);

    return _super.apply(this, arguments);
  }

  _createClass(ResolveApi, [{
    key: "resolveRaw",
    value:
    /**
     * Resolves a provided Audius app URL to the API resource it represents
     */
    function () {
      var _resolveRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.url === null || params.url === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError$1('url', 'Required parameter params.url was null or undefined when calling resolve.');

              case 2:
                queryParameters = {};

                if (params.url !== undefined) {
                  queryParameters.url = params.url;
                }

                headerParameters = {};
                _context.next = 7;
                return this.request({
                  path: "/resolve",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                });

              case 7:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse$1(response, function (json) {
                  {
                    return TrackResponseFromJSON(json);
                  }
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function resolveRaw(_x) {
        return _resolveRaw.apply(this, arguments);
      }

      return resolveRaw;
    }()
  }, {
    key: "resolve",
    value: function () {
      var _resolve = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.resolveRaw(params);

              case 2:
                _context2.next = 4;
                return _context2.sent.value();

              case 4:
                return _context2.abrupt("return", _context2.sent);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function resolve(_x2) {
        return _resolve.apply(this, arguments);
      }

      return resolve;
    }()
  }]);

  return ResolveApi;
}(BaseAPI$1);

// NOTE: No imports allowed - quicktype is not yet able to track imports!

/**
 * Defines who the user allows to message them
 */
var ChatPermission;

(function (ChatPermission) {
  /**
   * Messages are allowed for everyone
   */
  ChatPermission["ALL"] = "all";
  /**
   * Messages are only allowed for users that have tipped me
   */

  ChatPermission["TIPPERS"] = "tippers";
  /**
   * Messages are only allowed for users I follow
   */

  ChatPermission["FOLLOWEES"] = "followees";
  /**
   * Messages are not allowed
   */

  ChatPermission["NONE"] = "none";
})(ChatPermission || (ChatPermission = {}));

var ChatListenRequestSchema = z.optional(z.object({
  currentUserId: z.optional(z.string())
}));
var ChatGetAllRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  limit: z.optional(z.number()),
  before: z.optional(z.string()),
  after: z.optional(z.string())
});
var ChatGetRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string()
});
var ChatGetMessagesRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  limit: z.optional(z.number()),
  before: z.optional(z.string()),
  after: z.optional(z.string())
});
var ChatGetUnreadCountRequestSchema = z.optional(z.object({
  currentUserId: z.optional(z.string())
}));
var ChatGetBlockersRequestSchema = z.optional(z.object({
  currentUserId: z.optional(z.string())
}));
var ChatCreateRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userId: z.string(),
  invitedUserIds: z.array(z.string()).min(1)
});
var ChatInviteRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  userId: z.string(),
  invitedUserIds: z.array(z.string()).min(1)
});
var ChatMessageRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  messageId: z.optional(z.string()),
  message: z.string()
});
var ChatReactRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  messageId: z.string(),
  reaction: z.nullable(z.string())
});
var ChatReadRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string()
});
var ChatBlockRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userId: z.string()
});
var ChatDeleteRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string()
});
var ChatPermitRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  permit: z.nativeEnum(ChatPermission)
});
var ChatValidateCanCreateRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userIds: z.array(z.string()).min(1)
});
var ChatGetPermissionRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userIds: z.array(z.string()).min(1)
});
var ChatUnfurlRequestSchema = z.object({
  urls: z.array(z.string()).min(1)
});

var GENERIC_MESSAGE_ERROR = 'Error: this message can not be displayed';
var ChatsApi = /*#__PURE__*/function (_BaseAPI) {
  _inherits(ChatsApi, _BaseAPI);

  var _super = _createSuper(ChatsApi);

  /**
   * A map of chatId => chatSecret so we don't have to repeatedly fetch it
   */

  /**
   * An event emitter that's used for consumers to listen for chat events
   */

  /**
   * The websocket currently in use
   */

  /**
   * The current user ID to use when connecting/reconnecting the websocket
   */

  /**
   * Proxy to the event emitter addListener
   */

  /**
   * Proxy to the event emitter removeListener
   */
  function ChatsApi(config, auth, discoveryNodeSelectorService, logger) {
    var _this;

    _classCallCheck(this, ChatsApi);

    _this = _super.call(this, config);

    _defineProperty$1(_assertThisInitialized(_this), "auth", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "discoveryNodeSelectorService", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "logger", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "chatSecrets", {});

    _defineProperty$1(_assertThisInitialized(_this), "eventEmitter", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "websocket", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "listenUserId", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "addEventListener", void 0);

    _defineProperty$1(_assertThisInitialized(_this), "removeEventListener", void 0);

    _this.auth = auth;
    _this.discoveryNodeSelectorService = discoveryNodeSelectorService;
    _this.logger = logger;
    _this.eventEmitter = new EventEmitter();
    _this.addEventListener = _this.eventEmitter.addListener.bind(_this.eventEmitter);
    _this.removeEventListener = _this.eventEmitter.removeListener.bind(_this.eventEmitter); // Listen for discovery node selection changes and reinit websocket

    _this.discoveryNodeSelectorService.addEventListener('change', function (endpoint) {
      if (_this.websocket) {
        _this.websocket.close();

        _this.createWebsocket(endpoint).then(function (ws) {
          _this.websocket = ws;
        });
      }
    });

    _this.logger = logger.createPrefixedLogger('[chats-api]');
    return _this;
  } // #region QUERY

  /**
   * Establishes a websocket connection for listening to chat events.
   * @param params.currentUserId the user to listen for chat events for
   */


  _createClass(ChatsApi, [{
    key: "listen",
    value: function () {
      var _listen = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        var parsedArgs, endpoint;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return parseParams('listen', ChatListenRequestSchema)(params);

              case 2:
                parsedArgs = _context.sent;
                this.listenUserId = parsedArgs === null || parsedArgs === void 0 ? void 0 : parsedArgs.currentUserId;
                _context.next = 6;
                return this.discoveryNodeSelectorService.getSelectedEndpoint();

              case 6:
                endpoint = _context.sent;

                if (!endpoint) {
                  _context.next = 13;
                  break;
                }

                _context.next = 10;
                return this.createWebsocket(endpoint);

              case 10:
                this.websocket = _context.sent;
                _context.next = 14;
                break;

              case 13:
                throw new Error('No services available to listen to');

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function listen(_x) {
        return _listen.apply(this, arguments);
      }

      return listen;
    }()
    /**
     * Gets a single chat
     * @param params.chatId the chat to get
     * @param params.currentUserId the user to act on behalf of
     * @returns the chat response
     */

  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        var _yield$parseParams, chatId, currentUserId, response;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return parseParams('get', ChatGetRequestSchema)(params);

              case 2:
                _yield$parseParams = _context2.sent;
                chatId = _yield$parseParams.chatId;
                currentUserId = _yield$parseParams.currentUserId;
                _context2.next = 7;
                return this.getRaw(chatId, currentUserId);

              case 7:
                response = _context2.sent;
                _context2.t0 = _objectSpread2;
                _context2.t1 = _objectSpread2({}, response);
                _context2.t2 = {};

                if (!response.data) {
                  _context2.next = 17;
                  break;
                }

                _context2.next = 14;
                return this.decryptLastChatMessage(response.data);

              case 14:
                _context2.t3 = _context2.sent;
                _context2.next = 18;
                break;

              case 17:
                _context2.t3 = response.data;

              case 18:
                _context2.t4 = _context2.t3;
                _context2.t5 = {
                  data: _context2.t4
                };
                return _context2.abrupt("return", (0, _context2.t0)(_context2.t1, _context2.t2, _context2.t5));

              case 21:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function get(_x2) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
    /**
     * Gets a list of chats
     * @param params.limit the max number of chats to get
     * @param params.before a timestamp cursor for pagination
     * @param params.after a timestamp cursor for pagination
     * @param params.currentUserId the user to act on behalf of
     * @returns the chat list response
     */

  }, {
    key: "getAll",
    value: function () {
      var _getAll = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params) {
        var _this2 = this;

        var _yield$parseParams2, currentUserId, limit, before, after, path, query, response, json, decrypted;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return parseParams('getAll', ChatGetAllRequestSchema)(params);

              case 2:
                _yield$parseParams2 = _context4.sent;
                currentUserId = _yield$parseParams2.currentUserId;
                limit = _yield$parseParams2.limit;
                before = _yield$parseParams2.before;
                after = _yield$parseParams2.after;
                path = "/comms/chats";
                query = {
                  timestamp: new Date().getTime()
                };

                if (limit) {
                  query['limit'] = limit;
                }

                if (before) {
                  query['before'] = before;
                }

                if (after) {
                  query['after'] = after;
                }

                if (currentUserId) {
                  query['current_user_id'] = currentUserId;
                }

                _context4.next = 15;
                return this.signAndSendRequest({
                  method: 'GET',
                  headers: {},
                  path: path,
                  query: query
                });

              case 15:
                response = _context4.sent;
                _context4.next = 18;
                return response.json();

              case 18:
                json = _context4.sent;
                _context4.next = 21;
                return Promise.all(json.data.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(c) {
                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.next = 2;
                            return _this2.decryptLastChatMessage(c);

                          case 2:
                            return _context3.abrupt("return", _context3.sent);

                          case 3:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function (_x4) {
                    return _ref.apply(this, arguments);
                  };
                }()));

              case 21:
                decrypted = _context4.sent;
                return _context4.abrupt("return", _objectSpread2(_objectSpread2({}, json), {}, {
                  data: decrypted
                }));

              case 23:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAll(_x3) {
        return _getAll.apply(this, arguments);
      }

      return getAll;
    }()
    /**
     * Gets a list of messages
     * @param params.chatId the chat to get messages for
     * @param params.before a timestamp cursor for pagination
     * @param params.after a timestamp cursor for pagination
     * @param params.currentUserId the user to act on behalf of
     * @returns the messages list response
     */

  }, {
    key: "getMessages",
    value: function () {
      var _getMessages = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params) {
        var _this3 = this;

        var _yield$parseParams3, currentUserId, chatId, limit, before, after, sharedSecret, path, query, response, json, decrypted;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return parseParams('getMessages', ChatGetMessagesRequestSchema)(params);

              case 2:
                _yield$parseParams3 = _context6.sent;
                currentUserId = _yield$parseParams3.currentUserId;
                chatId = _yield$parseParams3.chatId;
                limit = _yield$parseParams3.limit;
                before = _yield$parseParams3.before;
                after = _yield$parseParams3.after;
                _context6.prev = 8;
                _context6.next = 11;
                return this.getChatSecret(chatId);

              case 11:
                sharedSecret = _context6.sent;
                _context6.next = 18;
                break;

              case 14:
                _context6.prev = 14;
                _context6.t0 = _context6["catch"](8);
                this.logger.error("[audius-sdk] Couldn't get chat secret", _context6.t0);
                throw new Error("[audius-sdk] Couldn't get chat secret");

              case 18:
                path = "/comms/chats/".concat(chatId, "/messages");
                query = {
                  timestamp: new Date().getTime()
                };

                if (limit) {
                  query['limit'] = limit;
                }

                if (before) {
                  query['before'] = before;
                }

                if (after) {
                  query['after'] = after;
                }

                if (currentUserId) {
                  query['current_user_id'] = currentUserId;
                }

                _context6.next = 26;
                return this.signAndSendRequest({
                  method: 'GET',
                  headers: {},
                  path: path,
                  query: query
                });

              case 26:
                response = _context6.sent;
                _context6.next = 29;
                return response.json();

              case 29:
                json = _context6.sent;
                _context6.next = 32;
                return Promise.all(json.data.map( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(m) {
                    return regeneratorRuntime.wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            _context5.t0 = _objectSpread2;
                            _context5.t1 = _objectSpread2({}, m);
                            _context5.t2 = {};
                            _context5.next = 5;
                            return _this3.decryptString(sharedSecret, base64.decode(m.message))["catch"](function (e) {
                              _this3.logger.error("[audius-sdk]: Error: Couldn't decrypt chat message", m, e);

                              return GENERIC_MESSAGE_ERROR;
                            });

                          case 5:
                            _context5.t3 = _context5.sent;
                            _context5.t4 = {
                              message: _context5.t3
                            };
                            return _context5.abrupt("return", (0, _context5.t0)(_context5.t1, _context5.t2, _context5.t4));

                          case 8:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function (_x6) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 32:
                decrypted = _context6.sent;
                return _context6.abrupt("return", _objectSpread2(_objectSpread2({}, json), {}, {
                  data: decrypted
                }));

              case 34:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[8, 14]]);
      }));

      function getMessages(_x5) {
        return _getMessages.apply(this, arguments);
      }

      return getMessages;
    }()
    /**
     * Gets the total unread message count for a user
     * @param params.currentUserId the user to act on behalf of
     * @returns the unread count response
     */

  }, {
    key: "getUnreadCount",
    value: function () {
      var _getUnreadCount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params) {
        var parsedArgs, query, res;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return parseParams('getUnreadCount', ChatGetUnreadCountRequestSchema)(params);

              case 2:
                parsedArgs = _context7.sent;
                query = {
                  timestamp: new Date().getTime()
                };

                if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
                  query['current_user_id'] = parsedArgs.currentUserId;
                }

                _context7.next = 7;
                return this.signAndSendRequest({
                  method: 'GET',
                  path: "/comms/chats/unread",
                  headers: {},
                  query: query
                });

              case 7:
                res = _context7.sent;
                _context7.next = 10;
                return res.json();

              case 10:
                return _context7.abrupt("return", _context7.sent);

              case 11:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getUnreadCount(_x7) {
        return _getUnreadCount.apply(this, arguments);
      }

      return getUnreadCount;
    }()
    /**
     * Gets the permission settings of the given users
     * @param params.userIds the users to fetch permissions of
     * @param params.currentUserId the user to act on behalf of
     * @returns the permissions response
     */

  }, {
    key: "getPermissions",
    value: function () {
      var _getPermissions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params) {
        var query, _yield$parseParams4, userIds, currentUserId, res;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                query = {
                  timestamp: new Date().getTime()
                };
                _context8.next = 3;
                return parseParams('getPermissions', ChatGetPermissionRequestSchema)(params);

              case 3:
                _yield$parseParams4 = _context8.sent;
                userIds = _yield$parseParams4.userIds;
                currentUserId = _yield$parseParams4.currentUserId;
                query['id'] = userIds;

                if (currentUserId) {
                  query['current_user_id'] = currentUserId;
                }

                _context8.next = 10;
                return this.signAndSendRequest({
                  method: 'GET',
                  path: '/comms/chats/permissions',
                  headers: {},
                  query: query
                });

              case 10:
                res = _context8.sent;
                _context8.next = 13;
                return res.json();

              case 13:
                return _context8.abrupt("return", _context8.sent);

              case 14:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getPermissions(_x8) {
        return _getPermissions.apply(this, arguments);
      }

      return getPermissions;
    }()
    /**
     * Gets the user ids that have blocked the current user
     * @param params.currentUserId the user to act on behalf of
     * @returns the blockers response
     */

  }, {
    key: "getBlockers",
    value: function () {
      var _getBlockers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params) {
        var parsedArgs, query, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return parseParams('getBlockers', ChatGetBlockersRequestSchema)(params);

              case 2:
                parsedArgs = _context9.sent;
                query = {
                  timestamp: new Date().getTime()
                };

                if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
                  query['current_user_id'] = parsedArgs.currentUserId;
                }

                _context9.next = 7;
                return this.signAndSendRequest({
                  method: 'GET',
                  path: "/comms/chats/blockers",
                  headers: {},
                  query: query
                });

              case 7:
                response = _context9.sent;
                _context9.next = 10;
                return response.json();

              case 10:
                return _context9.abrupt("return", _context9.sent);

              case 11:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getBlockers(_x9) {
        return _getBlockers.apply(this, arguments);
      }

      return getBlockers;
    }()
    /**
     * Gets the user ids the current user has blocked
     * @param params.currentUserId the user to act on behalf of
     * @returns
     */

  }, {
    key: "getBlockees",
    value: function () {
      var _getBlockees = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params) {
        var parsedArgs, query, response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return parseParams('getBlockees', ChatGetBlockersRequestSchema)(params);

              case 2:
                parsedArgs = _context10.sent;
                query = {
                  timestamp: new Date().getTime()
                };

                if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
                  query['current_user_id'] = parsedArgs.currentUserId;
                }

                _context10.next = 7;
                return this.signAndSendRequest({
                  method: 'GET',
                  path: "/comms/chats/blockees",
                  headers: {},
                  query: query
                });

              case 7:
                response = _context10.sent;
                _context10.next = 10;
                return response.json();

              case 10:
                return _context10.abrupt("return", _context10.sent);

              case 11:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getBlockees(_x10) {
        return _getBlockees.apply(this, arguments);
      }

      return getBlockees;
    }()
    /**
     * Gets URL metadata useful for link previews
     * @param params.content the urls to get metadata for
     * @returns the unfurl response
     */

  }, {
    key: "unfurl",
    value: function () {
      var _unfurl = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params) {
        var _yield$parseParams5, urls, query, res;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return parseParams('unfurl', ChatUnfurlRequestSchema)(params);

              case 2:
                _yield$parseParams5 = _context11.sent;
                urls = _yield$parseParams5.urls;
                query = {
                  content: urls
                };
                _context11.next = 7;
                return this.request({
                  method: 'GET',
                  path: '/comms/unfurl',
                  query: query,
                  headers: {}
                });

              case 7:
                res = _context11.sent;
                _context11.next = 10;
                return res.json();

              case 10:
                return _context11.abrupt("return", _context11.sent);

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function unfurl(_x11) {
        return _unfurl.apply(this, arguments);
      }

      return unfurl;
    }() // #endregion
    // #region MUTATE

    /**
     * Creates a chat between users
     * @param params.userId the user id who is creating the chat
     * @param params.invitedUserIds the user ids to add to the chat
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "create",
    value: function () {
      var _create = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params) {
        var _yield$parseParams6, currentUserId, userId, invitedUserIds, chatId, chatSecret, invites;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return parseParams('create', ChatCreateRequestSchema)(params);

              case 2:
                _yield$parseParams6 = _context12.sent;
                currentUserId = _yield$parseParams6.currentUserId;
                userId = _yield$parseParams6.userId;
                invitedUserIds = _yield$parseParams6.invitedUserIds;
                chatId = [userId].concat(_toConsumableArray(invitedUserIds)).sort().join(':');
                chatSecret = secp.utils.randomPrivateKey();
                _context12.next = 10;
                return this.createInvites(userId, invitedUserIds, chatSecret);

              case 10:
                invites = _context12.sent;
                _context12.next = 13;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.create',
                  params: {
                    chat_id: chatId,
                    invites: invites
                  }
                });

              case 13:
                return _context12.abrupt("return", _context12.sent);

              case 14:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function create(_x12) {
        return _create.apply(this, arguments);
      }

      return create;
    }()
    /**
     * Invites other users to an existing chat
     * @param params.chatId the chat id of the chat to invite to
     * @param params.userId the user id who is creating the chat
     * @param params.invitedUserIds the user ids to add to the chat
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "invite",
    value: function () {
      var _invite = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params) {
        var _yield$parseParams7, currentUserId, chatId, userId, invitedUserIds, chatSecret, invites;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return parseParams('invite', ChatInviteRequestSchema)(params);

              case 2:
                _yield$parseParams7 = _context13.sent;
                currentUserId = _yield$parseParams7.currentUserId;
                chatId = _yield$parseParams7.chatId;
                userId = _yield$parseParams7.userId;
                invitedUserIds = _yield$parseParams7.invitedUserIds;
                _context13.next = 9;
                return this.getChatSecret(chatId);

              case 9:
                chatSecret = _context13.sent;
                _context13.next = 12;
                return this.createInvites(userId, invitedUserIds, chatSecret);

              case 12:
                invites = _context13.sent;
                _context13.next = 15;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.invite',
                  params: {
                    chat_id: chatId,
                    invites: invites
                  }
                });

              case 15:
                return _context13.abrupt("return", _context13.sent);

              case 16:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function invite(_x13) {
        return _invite.apply(this, arguments);
      }

      return invite;
    }()
    /**
     * Sends a message to a user in a chat
     * @param params.message the message
     * @param params.chatId the chat to send a message in
     * @param params.messageId the id of the message
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "message",
    value: function () {
      var _message = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params) {
        var _yield$parseParams8, currentUserId, chatId, message, messageId, chatSecret, encrypted, encodedMessage;

        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return parseParams('message', ChatMessageRequestSchema)(params);

              case 2:
                _yield$parseParams8 = _context14.sent;
                currentUserId = _yield$parseParams8.currentUserId;
                chatId = _yield$parseParams8.chatId;
                message = _yield$parseParams8.message;
                messageId = _yield$parseParams8.messageId;
                _context14.next = 9;
                return this.getChatSecret(chatId);

              case 9:
                chatSecret = _context14.sent;
                _context14.next = 12;
                return this.encryptString(chatSecret, message);

              case 12:
                encrypted = _context14.sent;
                encodedMessage = base64.encode(encrypted);
                _context14.next = 16;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.message',
                  params: {
                    chat_id: chatId,
                    message_id: messageId !== null && messageId !== void 0 ? messageId : ulid(),
                    message: encodedMessage
                  }
                });

              case 16:
                return _context14.abrupt("return", _context14.sent);

              case 17:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function message(_x14) {
        return _message.apply(this, arguments);
      }

      return message;
    }()
    /**
     * Reacts to a message
     * @param params.reaction the reaction
     * @param params.chatId the chat to send a reaction in
     * @param params.messageId the id of the message to react to
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "react",
    value: function () {
      var _react = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(params) {
        var _yield$parseParams9, currentUserId, chatId, messageId, reaction;

        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return parseParams('react', ChatReactRequestSchema)(params);

              case 2:
                _yield$parseParams9 = _context15.sent;
                currentUserId = _yield$parseParams9.currentUserId;
                chatId = _yield$parseParams9.chatId;
                messageId = _yield$parseParams9.messageId;
                reaction = _yield$parseParams9.reaction;
                _context15.next = 9;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.react',
                  params: {
                    chat_id: chatId,
                    message_id: messageId,
                    reaction: reaction
                  }
                });

              case 9:
                return _context15.abrupt("return", _context15.sent);

              case 10:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function react(_x15) {
        return _react.apply(this, arguments);
      }

      return react;
    }()
    /**
     * Marks a chat as read
     * @param params.chatId the chat to mark as read
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "read",
    value: function () {
      var _read = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(params) {
        var _yield$parseParams10, currentUserId, chatId;

        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return parseParams('read', ChatReadRequestSchema)(params);

              case 2:
                _yield$parseParams10 = _context16.sent;
                currentUserId = _yield$parseParams10.currentUserId;
                chatId = _yield$parseParams10.chatId;
                _context16.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.read',
                  params: {
                    chat_id: chatId
                  }
                });

              case 7:
                return _context16.abrupt("return", _context16.sent);

              case 8:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function read(_x16) {
        return _read.apply(this, arguments);
      }

      return read;
    }()
    /**
     * Blocks a user from sending messages to the current user
     * @param params.userId the user to block
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "block",
    value: function () {
      var _block = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(params) {
        var _yield$parseParams11, currentUserId, userId;

        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return parseParams('block', ChatBlockRequestSchema)(params);

              case 2:
                _yield$parseParams11 = _context17.sent;
                currentUserId = _yield$parseParams11.currentUserId;
                userId = _yield$parseParams11.userId;
                _context17.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.block',
                  params: {
                    user_id: userId
                  }
                });

              case 7:
                return _context17.abrupt("return", _context17.sent);

              case 8:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function block(_x17) {
        return _block.apply(this, arguments);
      }

      return block;
    }()
    /**
     * Unblocks a user from sending messages to the current user
     * @param params.userId the user to unblock
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "unblock",
    value: function () {
      var _unblock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(params) {
        var _yield$parseParams12, currentUserId, userId;

        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return parseParams('unblock', ChatBlockRequestSchema)(params);

              case 2:
                _yield$parseParams12 = _context18.sent;
                currentUserId = _yield$parseParams12.currentUserId;
                userId = _yield$parseParams12.userId;
                _context18.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.unblock',
                  params: {
                    user_id: userId
                  }
                });

              case 7:
                return _context18.abrupt("return", _context18.sent);

              case 8:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function unblock(_x18) {
        return _unblock.apply(this, arguments);
      }

      return unblock;
    }()
    /**
     * Clears a chat's history for the current user
     * @param params.chatId the chat to clear
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(params) {
        var _yield$parseParams13, currentUserId, chatId;

        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return parseParams('delete', ChatDeleteRequestSchema)(params);

              case 2:
                _yield$parseParams13 = _context19.sent;
                currentUserId = _yield$parseParams13.currentUserId;
                chatId = _yield$parseParams13.chatId;
                _context19.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.delete',
                  params: {
                    chat_id: chatId
                  }
                });

              case 7:
                return _context19.abrupt("return", _context19.sent);

              case 8:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function _delete(_x19) {
        return _delete2.apply(this, arguments);
      }

      return _delete;
    }()
    /**
     * Sets the inbox settings permissions of the current user
     * @param params.permit the permission to set
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */

  }, {
    key: "permit",
    value: function () {
      var _permit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(params) {
        var _yield$parseParams14, currentUserId, permit;

        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return parseParams('permit', ChatPermitRequestSchema)(params);

              case 2:
                _yield$parseParams14 = _context20.sent;
                currentUserId = _yield$parseParams14.currentUserId;
                permit = _yield$parseParams14.permit;
                _context20.next = 7;
                return this.sendRpc({
                  current_user_id: currentUserId,
                  method: 'chat.permit',
                  params: {
                    permit: permit
                  }
                });

              case 7:
                return _context20.abrupt("return", _context20.sent);

              case 8:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function permit(_x20) {
        return _permit.apply(this, arguments);
      }

      return permit;
    }() // #endregion
    // #region PRIVATE

  }, {
    key: "createInvites",
    value: function () {
      var _createInvites = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(userId, invitedUserIds, chatSecret) {
        var _this4 = this;

        var userPublicKey;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getPublicKey(userId);

              case 2:
                userPublicKey = _context22.sent;
                _context22.next = 5;
                return Promise.all([userId].concat(_toConsumableArray(invitedUserIds)).map( /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(userId) {
                    var inviteePublicKey, inviteCode;
                    return regeneratorRuntime.wrap(function _callee21$(_context21) {
                      while (1) {
                        switch (_context21.prev = _context21.next) {
                          case 0:
                            _context21.next = 2;
                            return _this4.getPublicKey(userId);

                          case 2:
                            inviteePublicKey = _context21.sent;
                            _context21.next = 5;
                            return _this4.createInviteCode(userPublicKey, inviteePublicKey, chatSecret);

                          case 5:
                            inviteCode = _context21.sent;
                            return _context21.abrupt("return", {
                              user_id: userId,
                              invite_code: base64.encode(inviteCode)
                            });

                          case 7:
                          case "end":
                            return _context21.stop();
                        }
                      }
                    }, _callee21);
                  }));

                  return function (_x24) {
                    return _ref3.apply(this, arguments);
                  };
                }()));

              case 5:
                return _context22.abrupt("return", _context22.sent);

              case 6:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function createInvites(_x21, _x22, _x23) {
        return _createInvites.apply(this, arguments);
      }

      return createInvites;
    }()
  }, {
    key: "createInviteCode",
    value: function () {
      var _createInviteCode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(userPublicKey, inviteePublicKey, chatSecret) {
        var sharedSecret, encryptedChatSecret, inviteCode;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.auth.getSharedSecret(inviteePublicKey);

              case 2:
                sharedSecret = _context23.sent;
                _context23.next = 5;
                return this.encrypt(sharedSecret, chatSecret);

              case 5:
                encryptedChatSecret = _context23.sent;
                inviteCode = new Uint8Array(65 + encryptedChatSecret.length);
                inviteCode.set(userPublicKey);
                inviteCode.set(encryptedChatSecret, 65);
                return _context23.abrupt("return", inviteCode);

              case 10:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function createInviteCode(_x25, _x26, _x27) {
        return _createInviteCode.apply(this, arguments);
      }

      return createInviteCode;
    }()
  }, {
    key: "readInviteCode",
    value: function () {
      var _readInviteCode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(inviteCode) {
        var friendPublicKey, chatSecretEncrypted, sharedSecret;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                friendPublicKey = inviteCode.slice(0, 65);
                chatSecretEncrypted = inviteCode.slice(65);
                _context24.next = 4;
                return this.auth.getSharedSecret(friendPublicKey);

              case 4:
                sharedSecret = _context24.sent;
                _context24.next = 7;
                return this.decrypt(sharedSecret, chatSecretEncrypted);

              case 7:
                return _context24.abrupt("return", _context24.sent);

              case 8:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function readInviteCode(_x28) {
        return _readInviteCode.apply(this, arguments);
      }

      return readInviteCode;
    }()
  }, {
    key: "encrypt",
    value: function () {
      var _encrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(secret, payload) {
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return aes.encrypt(secret.slice(secret.length - 32), payload);

              case 2:
                return _context25.abrupt("return", _context25.sent);

              case 3:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25);
      }));

      function encrypt(_x29, _x30) {
        return _encrypt.apply(this, arguments);
      }

      return encrypt;
    }()
  }, {
    key: "encryptString",
    value: function () {
      var _encryptString = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(secret, payload) {
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.encrypt(secret, new TextEncoder().encode(payload));

              case 2:
                return _context26.abrupt("return", _context26.sent);

              case 3:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function encryptString(_x31, _x32) {
        return _encryptString.apply(this, arguments);
      }

      return encryptString;
    }()
  }, {
    key: "decrypt",
    value: function () {
      var _decrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(secret, payload) {
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                _context27.next = 2;
                return aes.decrypt(secret.slice(secret.length - 32), payload);

              case 2:
                return _context27.abrupt("return", _context27.sent);

              case 3:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27);
      }));

      function decrypt(_x33, _x34) {
        return _decrypt.apply(this, arguments);
      }

      return decrypt;
    }()
  }, {
    key: "decryptString",
    value: function () {
      var _decryptString = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(secret, payload) {
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.t0 = new TextDecoder();
                _context28.next = 3;
                return this.decrypt(secret, payload);

              case 3:
                _context28.t1 = _context28.sent;
                return _context28.abrupt("return", _context28.t0.decode.call(_context28.t0, _context28.t1));

              case 5:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function decryptString(_x35, _x36) {
        return _decryptString.apply(this, arguments);
      }

      return decryptString;
    }()
  }, {
    key: "decryptLastChatMessage",
    value: function () {
      var _decryptLastChatMessage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(c) {
        var lastMessage, sharedSecret;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                lastMessage = '';
                _context29.prev = 1;
                _context29.next = 4;
                return this.getChatSecret(c.chat_id);

              case 4:
                sharedSecret = _context29.sent;

                if (!(c.last_message && c.last_message.length > 0)) {
                  _context29.next = 9;
                  break;
                }

                _context29.next = 8;
                return this.decryptString(sharedSecret, base64.decode(c.last_message));

              case 8:
                lastMessage = _context29.sent;

              case 9:
                _context29.next = 15;
                break;

              case 11:
                _context29.prev = 11;
                _context29.t0 = _context29["catch"](1);
                this.logger.error("[audius-sdk]: Error: Couldn't decrypt last chat message", c, _context29.t0);
                lastMessage = GENERIC_MESSAGE_ERROR;

              case 15:
                return _context29.abrupt("return", _objectSpread2(_objectSpread2({}, c), {}, {
                  last_message: lastMessage
                }));

              case 16:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this, [[1, 11]]);
      }));

      function decryptLastChatMessage(_x37) {
        return _decryptLastChatMessage.apply(this, arguments);
      }

      return decryptLastChatMessage;
    }()
  }, {
    key: "getRaw",
    value: function () {
      var _getRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(chatId, currentUserId) {
        var path, queryParameters, response;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                path = "/comms/chats/".concat(chatId);
                queryParameters = {
                  timestamp: new Date().getTime()
                };

                if (currentUserId) {
                  queryParameters['current_user_id'] = currentUserId;
                }

                _context30.next = 5;
                return this.signAndSendRequest({
                  method: 'GET',
                  headers: {},
                  path: path,
                  query: queryParameters
                });

              case 5:
                response = _context30.sent;
                _context30.next = 8;
                return response.json();

              case 8:
                return _context30.abrupt("return", _context30.sent);

              case 9:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getRaw(_x38, _x39) {
        return _getRaw.apply(this, arguments);
      }

      return getRaw;
    }()
  }, {
    key: "getChatSecret",
    value: function () {
      var _getChatSecret = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(chatId) {
        var existingChatSecret, response, chatSecret;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                existingChatSecret = this.chatSecrets[chatId];

                if (existingChatSecret) {
                  _context31.next = 10;
                  break;
                }

                _context31.next = 4;
                return this.getRaw(chatId);

              case 4:
                response = _context31.sent;
                _context31.next = 7;
                return this.readInviteCode(base64.decode(response.data.invite_code));

              case 7:
                chatSecret = _context31.sent;
                this.chatSecrets[chatId] = chatSecret;
                return _context31.abrupt("return", chatSecret);

              case 10:
                return _context31.abrupt("return", existingChatSecret);

              case 11:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getChatSecret(_x40) {
        return _getChatSecret.apply(this, arguments);
      }

      return getChatSecret;
    }()
  }, {
    key: "getPublicKey",
    value: function () {
      var _getPublicKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(userId) {
        var response, json;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.request({
                  path: "/comms/pubkey/".concat(userId),
                  method: 'GET',
                  headers: {}
                });

              case 2:
                response = _context32.sent;
                _context32.next = 5;
                return response.json();

              case 5:
                json = _context32.sent;
                return _context32.abrupt("return", base64.decode(json.data));

              case 7:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getPublicKey(_x41) {
        return _getPublicKey.apply(this, arguments);
      }

      return getPublicKey;
    }()
  }, {
    key: "getSignatureHeader",
    value: function () {
      var _getSignatureHeader = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(payload) {
        var _yield$this$auth$sign, _yield$this$auth$sign2, allSignatureBytes, recoveryByte, signatureBytes;

        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                _context33.next = 2;
                return this.auth.sign(payload);

              case 2:
                _yield$this$auth$sign = _context33.sent;
                _yield$this$auth$sign2 = _slicedToArray(_yield$this$auth$sign, 2);
                allSignatureBytes = _yield$this$auth$sign2[0];
                recoveryByte = _yield$this$auth$sign2[1];
                signatureBytes = new Uint8Array(65);
                signatureBytes.set(allSignatureBytes, 0);
                signatureBytes[64] = recoveryByte;
                return _context33.abrupt("return", {
                  'x-sig': base64.encode(signatureBytes)
                });

              case 10:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getSignatureHeader(_x42) {
        return _getSignatureHeader.apply(this, arguments);
      }

      return getSignatureHeader;
    }()
  }, {
    key: "signAndSendRequest",
    value: function () {
      var _signAndSendRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(request) {
        var payload;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                payload = request.method === 'GET' ? request.query ? "".concat(request.path, "?").concat(this.configuration.queryParamsStringify(request.query)) : request.path : request.body;
                _context34.t0 = this;
                _context34.t1 = _objectSpread2;
                _context34.t2 = _objectSpread2({}, request);
                _context34.t3 = {};
                _context34.t4 = _objectSpread2;
                _context34.t5 = _objectSpread2({}, request.headers);
                _context34.next = 9;
                return this.getSignatureHeader(payload);

              case 9:
                _context34.t6 = _context34.sent;
                _context34.t7 = (0, _context34.t4)(_context34.t5, _context34.t6);
                _context34.t8 = {
                  headers: _context34.t7
                };
                _context34.t9 = (0, _context34.t1)(_context34.t2, _context34.t3, _context34.t8);
                _context34.next = 15;
                return _context34.t0.request.call(_context34.t0, _context34.t9);

              case 15:
                return _context34.abrupt("return", _context34.sent);

              case 16:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function signAndSendRequest(_x43) {
        return _signAndSendRequest.apply(this, arguments);
      }

      return signAndSendRequest;
    }()
  }, {
    key: "sendRpc",
    value: function () {
      var _sendRpc = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(args) {
        var payload;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                payload = JSON.stringify(_objectSpread2(_objectSpread2({}, args), {}, {
                  timestamp: new Date().getTime()
                }));
                _context35.next = 3;
                return this.signAndSendRequest({
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  path: "/comms/mutate",
                  body: payload
                });

              case 3:
                return _context35.abrupt("return", args);

              case 4:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function sendRpc(_x44) {
        return _sendRpc.apply(this, arguments);
      }

      return sendRpc;
    }()
  }, {
    key: "createWebsocket",
    value: function () {
      var _createWebsocket = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(endpoint) {
        var _this5 = this;

        var timestamp, originalUrl, signatureHeader, host, url, ws;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                timestamp = new Date().getTime();
                originalUrl = "/comms/chats/ws?timestamp=".concat(timestamp);

                if (this.listenUserId) {
                  originalUrl = "".concat(originalUrl, "&current_user_id=").concat(this.listenUserId);
                }

                _context37.next = 5;
                return this.getSignatureHeader(originalUrl);

              case 5:
                signatureHeader = _context37.sent;
                host = endpoint.replace(/http(s?)/g, 'ws$1');
                url = "".concat(host).concat(originalUrl, "&signature=").concat(encodeURIComponent(signatureHeader['x-sig']));
                ws = new WebSocket(url);
                ws.addEventListener('message', function (messageEvent) {
                  var handleAsync = /*#__PURE__*/function () {
                    var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36() {
                      var data, sharedSecret;
                      return regeneratorRuntime.wrap(function _callee36$(_context36) {
                        while (1) {
                          switch (_context36.prev = _context36.next) {
                            case 0:
                              data = JSON.parse(messageEvent.data);

                              if (!(data.rpc.method === 'chat.message')) {
                                _context36.next = 19;
                                break;
                              }

                              _context36.next = 4;
                              return _this5.getChatSecret(data.rpc.params.chat_id);

                            case 4:
                              sharedSecret = _context36.sent;
                              _context36.t0 = _this5.eventEmitter;
                              _context36.t1 = data.rpc.params.chat_id;
                              _context36.t2 = data.rpc.params.message_id;
                              _context36.next = 10;
                              return _this5.decryptString(sharedSecret, base64.decode(data.rpc.params.message))["catch"](function (e) {
                                _this5.logger.error("[audius-sdk]: Error: Couldn't decrypt websocket chat message", data, e);

                                return GENERIC_MESSAGE_ERROR;
                              });

                            case 10:
                              _context36.t3 = _context36.sent;
                              _context36.t4 = data.metadata.userId;
                              _context36.t5 = data.metadata.timestamp;
                              _context36.t6 = [];
                              _context36.t7 = {
                                message_id: _context36.t2,
                                message: _context36.t3,
                                sender_user_id: _context36.t4,
                                created_at: _context36.t5,
                                reactions: _context36.t6
                              };
                              _context36.t8 = {
                                chatId: _context36.t1,
                                message: _context36.t7
                              };

                              _context36.t0.emit.call(_context36.t0, 'message', _context36.t8);

                              _context36.next = 20;
                              break;

                            case 19:
                              if (data.rpc.method === 'chat.react') {
                                _this5.eventEmitter.emit('reaction', {
                                  chatId: data.rpc.params.chat_id,
                                  messageId: data.rpc.params.message_id,
                                  reaction: {
                                    reaction: data.rpc.params.reaction,
                                    user_id: data.metadata.userId,
                                    created_at: data.metadata.timestamp
                                  }
                                });
                              }

                            case 20:
                            case "end":
                              return _context36.stop();
                          }
                        }
                      }, _callee36);
                    }));

                    return function handleAsync() {
                      return _ref4.apply(this, arguments);
                    };
                  }();

                  handleAsync();
                });
                ws.addEventListener('open', function () {
                  _this5.eventEmitter.emit('open');
                });
                ws.addEventListener('close', function () {
                  _this5.eventEmitter.emit('close');
                });
                ws.addEventListener('error', function (e) {
                  _this5.eventEmitter.emit('error', e);
                });
                return _context37.abrupt("return", ws);

              case 14:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function createWebsocket(_x45) {
        return _createWebsocket.apply(this, arguments);
      }

      return createWebsocket;
    }()
  }]);

  return ChatsApi;
}(BaseAPI$1);

/* tslint:disable */

/* eslint-disable */

/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var BASE_PATH = "/v1/full".replace(/\/+$/, "");
var Configuration = /*#__PURE__*/function () {
  function Configuration() {
    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Configuration);

    _defineProperty$1(this, "configuration", void 0);

    this.configuration = configuration;
  }

  _createClass(Configuration, [{
    key: "config",
    set: function set(configuration) {
      this.configuration = configuration;
    }
  }, {
    key: "basePath",
    get: function get() {
      return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }
  }, {
    key: "fetchApi",
    get: function get() {
      return this.configuration.fetchApi;
    }
  }, {
    key: "middleware",
    get: function get() {
      return this.configuration.middleware || [];
    }
  }, {
    key: "queryParamsStringify",
    get: function get() {
      return this.configuration.queryParamsStringify || querystring;
    }
  }, {
    key: "username",
    get: function get() {
      return this.configuration.username;
    }
  }, {
    key: "password",
    get: function get() {
      return this.configuration.password;
    }
  }, {
    key: "apiKey",
    get: function get() {
      var apiKey = this.configuration.apiKey;

      if (apiKey) {
        return typeof apiKey === 'function' ? apiKey : function () {
          return apiKey;
        };
      }

      return undefined;
    }
  }, {
    key: "accessToken",
    get: function get() {
      var accessToken = this.configuration.accessToken;

      if (accessToken) {
        return typeof accessToken === 'function' ? accessToken : /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", accessToken);

                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
      }

      return undefined;
    }
  }, {
    key: "headers",
    get: function get() {
      return this.configuration.headers;
    }
  }, {
    key: "credentials",
    get: function get() {
      return this.configuration.credentials;
    }
  }]);

  return Configuration;
}();
var DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */

var BaseAPI = /*#__PURE__*/function () {
  function BaseAPI() {
    var _this = this;

    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultConfig;

    _classCallCheck(this, BaseAPI);

    _defineProperty$1(this, "configuration", void 0);

    _defineProperty$1(this, "middleware", void 0);

    _defineProperty$1(this, "fetchApi", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url, init) {
        var fetchParams, _iterator, _step, _middleware, response, _iterator2, _step2, middleware, _iterator3, _step3, _middleware2;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                fetchParams = {
                  url: url,
                  init: init
                };
                _iterator = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 2;

                _iterator.s();

              case 4:
                if ((_step = _iterator.n()).done) {
                  _context2.next = 15;
                  break;
                }

                _middleware = _step.value;

                if (!_middleware.pre) {
                  _context2.next = 13;
                  break;
                }

                _context2.next = 9;
                return _middleware.pre(_objectSpread2({
                  fetch: _this.fetchApi
                }, fetchParams));

              case 9:
                _context2.t0 = _context2.sent;

                if (_context2.t0) {
                  _context2.next = 12;
                  break;
                }

                _context2.t0 = fetchParams;

              case 12:
                fetchParams = _context2.t0;

              case 13:
                _context2.next = 4;
                break;

              case 15:
                _context2.next = 20;
                break;

              case 17:
                _context2.prev = 17;
                _context2.t1 = _context2["catch"](2);

                _iterator.e(_context2.t1);

              case 20:
                _context2.prev = 20;

                _iterator.f();

                return _context2.finish(20);

              case 23:
                response = undefined;
                _context2.prev = 24;
                _context2.next = 27;
                return (_this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);

              case 27:
                response = _context2.sent;
                _context2.next = 60;
                break;

              case 30:
                _context2.prev = 30;
                _context2.t2 = _context2["catch"](24);
                _iterator2 = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 33;

                _iterator2.s();

              case 35:
                if ((_step2 = _iterator2.n()).done) {
                  _context2.next = 46;
                  break;
                }

                middleware = _step2.value;

                if (!middleware.onError) {
                  _context2.next = 44;
                  break;
                }

                _context2.next = 40;
                return middleware.onError({
                  fetch: _this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  error: _context2.t2,
                  response: response ? response.clone() : undefined
                });

              case 40:
                _context2.t3 = _context2.sent;

                if (_context2.t3) {
                  _context2.next = 43;
                  break;
                }

                _context2.t3 = response;

              case 43:
                response = _context2.t3;

              case 44:
                _context2.next = 35;
                break;

              case 46:
                _context2.next = 51;
                break;

              case 48:
                _context2.prev = 48;
                _context2.t4 = _context2["catch"](33);

                _iterator2.e(_context2.t4);

              case 51:
                _context2.prev = 51;

                _iterator2.f();

                return _context2.finish(51);

              case 54:
                if (!(response === undefined)) {
                  _context2.next = 60;
                  break;
                }

                if (!(_context2.t2 instanceof Error)) {
                  _context2.next = 59;
                  break;
                }

                throw new FetchError(_context2.t2, 'The request failed and the interceptors did not return an alternative response');

              case 59:
                throw _context2.t2;

              case 60:
                _iterator3 = _createForOfIteratorHelper(_this.middleware);
                _context2.prev = 61;

                _iterator3.s();

              case 63:
                if ((_step3 = _iterator3.n()).done) {
                  _context2.next = 74;
                  break;
                }

                _middleware2 = _step3.value;

                if (!_middleware2.post) {
                  _context2.next = 72;
                  break;
                }

                _context2.next = 68;
                return _middleware2.post({
                  fetch: _this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  response: response.clone()
                });

              case 68:
                _context2.t5 = _context2.sent;

                if (_context2.t5) {
                  _context2.next = 71;
                  break;
                }

                _context2.t5 = response;

              case 71:
                response = _context2.t5;

              case 72:
                _context2.next = 63;
                break;

              case 74:
                _context2.next = 79;
                break;

              case 76:
                _context2.prev = 76;
                _context2.t6 = _context2["catch"](61);

                _iterator3.e(_context2.t6);

              case 79:
                _context2.prev = 79;

                _iterator3.f();

                return _context2.finish(79);

              case 82:
                return _context2.abrupt("return", response);

              case 83:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[2, 17, 20, 23], [24, 30], [33, 48, 51, 54], [61, 76, 79, 82]]);
      }));

      return function (_x, _x2) {
        return _ref2.apply(this, arguments);
      };
    }());

    this.configuration = configuration;
    this.middleware = configuration.middleware;
  }
  /** @hidden */


  _createClass(BaseAPI, [{
    key: "withMiddleware",
    value: function withMiddleware() {
      var _next$middleware;

      var next = this.clone();
      next.middleware = (_next$middleware = next.middleware).concat.apply(_next$middleware, arguments);
      return next;
    }
    /** @hidden */

  }, {
    key: "withPreMiddleware",
    value: function withPreMiddleware() {
      for (var _len = arguments.length, preMiddlewares = new Array(_len), _key = 0; _key < _len; _key++) {
        preMiddlewares[_key] = arguments[_key];
      }

      var middlewares = preMiddlewares.map(function (pre) {
        return {
          pre: pre
        };
      });
      return this.withMiddleware.apply(this, _toConsumableArray(middlewares));
    }
    /** @hidden */

  }, {
    key: "withPostMiddleware",
    value: function withPostMiddleware() {
      for (var _len2 = arguments.length, postMiddlewares = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        postMiddlewares[_key2] = arguments[_key2];
      }

      var middlewares = postMiddlewares.map(function (post) {
        return {
          post: post
        };
      });
      return this.withMiddleware.apply(this, _toConsumableArray(middlewares));
    }
    /** @hidden */

  }, {
    key: "request",
    value: function () {
      var _request = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(context, initOverrides) {
        var _yield$this$createFet, url, init, response;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.createFetchParams(context, initOverrides);

              case 2:
                _yield$this$createFet = _context3.sent;
                url = _yield$this$createFet.url;
                init = _yield$this$createFet.init;
                _context3.next = 7;
                return this.fetchApi(url, init);

              case 7:
                response = _context3.sent;

                if (!(response && response.status >= 200 && response.status < 300)) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt("return", response);

              case 10:
                throw new ResponseError(response, 'Response returned an error code');

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function request(_x3, _x4) {
        return _request.apply(this, arguments);
      }

      return request;
    }()
  }, {
    key: "createFetchParams",
    value: function () {
      var _createFetchParams = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(context, initOverrides) {
        var url, headers, initOverrideFn, initParams, overriddenInit, init;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                url = this.configuration.basePath + context.path;

                if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                  // only add the querystring to the URL if there are query parameters.
                  // this is done to avoid urls ending with a "?" character which buggy webservers
                  // do not handle correctly sometimes.
                  url += '?' + this.configuration.queryParamsStringify(context.query);
                }

                headers = Object.assign({}, this.configuration.headers, context.headers);
                Object.keys(headers).forEach(function (key) {
                  return headers[key] === undefined ? delete headers[key] : {};
                });
                initOverrideFn = typeof initOverrides === "function" ? initOverrides : /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                  return regeneratorRuntime.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          return _context4.abrupt("return", initOverrides);

                        case 1:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                }));
                initParams = {
                  method: context.method,
                  headers: headers,
                  body: context.body,
                  credentials: this.configuration.credentials
                };
                _context5.t0 = _objectSpread2;
                _context5.t1 = _objectSpread2({}, initParams);
                _context5.next = 10;
                return initOverrideFn({
                  init: initParams,
                  context: context
                });

              case 10:
                _context5.t2 = _context5.sent;
                overriddenInit = (0, _context5.t0)(_context5.t1, _context5.t2);
                init = _objectSpread2(_objectSpread2({}, overriddenInit), {}, {
                  body: isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body) || isString(overriddenInit.body) ? overriddenInit.body : JSON.stringify(overriddenInit.body)
                });
                return _context5.abrupt("return", {
                  url: url,
                  init: init
                });

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function createFetchParams(_x5, _x6) {
        return _createFetchParams.apply(this, arguments);
      }

      return createFetchParams;
    }()
  }, {
    key: "clone",
    value:
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    function clone() {
      var constructor = this.constructor;
      var next = new constructor(this.configuration);
      next.middleware = this.middleware.slice();
      return next;
    }
  }]);

  return BaseAPI;
}();

function isBlob(value) {
  return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}

function isString(value) {
  return typeof value === 'string';
}

var ResponseError = /*#__PURE__*/function (_Error) {
  _inherits(ResponseError, _Error);

  var _super = _createSuper(ResponseError);

  function ResponseError(response, msg) {
    var _this2;

    _classCallCheck(this, ResponseError);

    _this2 = _super.call(this, msg);

    _defineProperty$1(_assertThisInitialized(_this2), "response", void 0);

    _defineProperty$1(_assertThisInitialized(_this2), "name", "ResponseError");

    _this2.response = response;
    return _this2;
  }

  return _createClass(ResponseError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var FetchError = /*#__PURE__*/function (_Error2) {
  _inherits(FetchError, _Error2);

  var _super2 = _createSuper(FetchError);

  function FetchError(cause, msg) {
    var _this3;

    _classCallCheck(this, FetchError);

    _this3 = _super2.call(this, msg);

    _defineProperty$1(_assertThisInitialized(_this3), "cause", void 0);

    _defineProperty$1(_assertThisInitialized(_this3), "name", "FetchError");

    _this3.cause = cause;
    return _this3;
  }

  return _createClass(FetchError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var RequiredError = /*#__PURE__*/function (_Error3) {
  _inherits(RequiredError, _Error3);

  var _super3 = _createSuper(RequiredError);

  function RequiredError(field, msg) {
    var _this4;

    _classCallCheck(this, RequiredError);

    _this4 = _super3.call(this, msg);

    _defineProperty$1(_assertThisInitialized(_this4), "field", void 0);

    _defineProperty$1(_assertThisInitialized(_this4), "name", "RequiredError");

    _this4.field = field;
    return _this4;
  }

  return _createClass(RequiredError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|"
};
function exists(json, key) {
  var value = json[key];
  return value !== null && value !== undefined;
}
function querystring(params) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return Object.keys(params).sort().map(function (key) {
    return querystringSingleKey(key, params[key], prefix);
  }).filter(function (part) {
    return part.length > 0;
  }).join('&');
}

function querystringSingleKey(key, value) {
  var keyPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);

  if (value instanceof Array) {
    var multiValue = value.map(function (singleValue) {
      return encodeURIComponent(String(singleValue));
    }).join("&".concat(encodeURIComponent(fullKey), "="));
    return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
  }

  if (value instanceof Set) {
    var valueAsArray = Array.from(value);
    return querystringSingleKey(key, valueAsArray, keyPrefix);
  }

  if (value instanceof Date) {
    return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
  }

  if (value instanceof Object) {
    return querystring(value, fullKey);
  }

  return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
}

function mapValues(data, fn) {
  return Object.keys(data).reduce(function (acc, key) {
    return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty$1({}, key, fn(data[key])));
  }, {});
}
function canConsumeForm(consumes) {
  var _iterator4 = _createForOfIteratorHelper(consumes),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var consume = _step4.value;

      if ('multipart/form-data' === consume.contentType) {
        return true;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return false;
}
var JSONApiResponse = /*#__PURE__*/function () {
  function JSONApiResponse(raw) {
    var transformer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (jsonValue) {
      return jsonValue;
    };

    _classCallCheck(this, JSONApiResponse);

    _defineProperty$1(this, "raw", void 0);

    _defineProperty$1(this, "transformer", void 0);

    this.raw = raw;
    this.transformer = transformer;
  }

  _createClass(JSONApiResponse, [{
    key: "value",
    value: function () {
      var _value = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.t0 = this;
                _context6.next = 3;
                return this.raw.json();

              case 3:
                _context6.t1 = _context6.sent;
                return _context6.abrupt("return", _context6.t0.transformer.call(_context6.t0, _context6.t1));

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function value() {
        return _value.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return JSONApiResponse;
}();
var VoidApiResponse = /*#__PURE__*/function () {
  function VoidApiResponse(raw) {
    _classCallCheck(this, VoidApiResponse);

    _defineProperty$1(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass(VoidApiResponse, [{
    key: "value",
    value: function () {
      var _value2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", undefined);

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function value() {
        return _value2.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return VoidApiResponse;
}();
var BlobApiResponse = /*#__PURE__*/function () {
  function BlobApiResponse(raw) {
    _classCallCheck(this, BlobApiResponse);

    _defineProperty$1(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass(BlobApiResponse, [{
    key: "value",
    value: function () {
      var _value3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.raw.blob();

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function value() {
        return _value3.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return BlobApiResponse;
}();
var TextApiResponse = /*#__PURE__*/function () {
  function TextApiResponse(raw) {
    _classCallCheck(this, TextApiResponse);

    _defineProperty$1(this, "raw", void 0);

    this.raw = raw;
  }

  _createClass(TextApiResponse, [{
    key: "value",
    value: function () {
      var _value4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.raw.text();

              case 2:
                return _context9.abrupt("return", _context9.sent);

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function value() {
        return _value4.apply(this, arguments);
      }

      return value;
    }()
  }]);

  return TextApiResponse;
}();

/* tslint:disable */
/**
 * Check if a given object implements the ActivityFull interface.
 */

function instanceOfActivityFull(value) {
  var isInstance = true;
  return isInstance;
}
function ActivityFullFromJSON(json) {
  return ActivityFullFromJSONTyped(json);
}
function ActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'timestamp': !exists(json, 'timestamp') ? undefined : json['timestamp'],
    'itemType': !exists(json, 'item_type') ? undefined : json['item_type'],
    'item': !exists(json, 'item') ? undefined : json['item']
  };
}
function ActivityFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': value.item
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Favorite interface.
 */

function instanceOfFavorite(value) {
  var isInstance = true;
  isInstance = isInstance && "favoriteItemId" in value;
  isInstance = isInstance && "favoriteType" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "createdAt" in value;
  return isInstance;
}
function FavoriteFromJSON(json) {
  return FavoriteFromJSONTyped(json);
}
function FavoriteFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'favoriteItemId': json['favorite_item_id'],
    'favoriteType': json['favorite_type'],
    'userId': json['user_id'],
    'createdAt': json['created_at']
  };
}
function FavoriteToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'favorite_item_id': value.favoriteItemId,
    'favorite_type': value.favoriteType,
    'user_id': value.userId,
    'created_at': value.createdAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistAddedTimestamp interface.
 */

function instanceOfPlaylistAddedTimestamp(value) {
  var isInstance = true;
  isInstance = isInstance && "metadataTimestamp" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "trackId" in value;
  return isInstance;
}
function PlaylistAddedTimestampFromJSON(json) {
  return PlaylistAddedTimestampFromJSONTyped(json);
}
function PlaylistAddedTimestampFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'metadataTimestamp': json['metadata_timestamp'],
    'timestamp': json['timestamp'],
    'trackId': json['track_id']
  };
}
function PlaylistAddedTimestampToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'metadata_timestamp': value.metadataTimestamp,
    'timestamp': value.timestamp,
    'track_id': value.trackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistArtwork interface.
 */

function instanceOfPlaylistArtwork(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistArtworkFromJSON(json) {
  return PlaylistArtworkFromJSONTyped(json);
}
function PlaylistArtworkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function PlaylistArtworkToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Repost interface.
 */

function instanceOfRepost(value) {
  var isInstance = true;
  isInstance = isInstance && "repostItemId" in value;
  isInstance = isInstance && "repostType" in value;
  isInstance = isInstance && "userId" in value;
  return isInstance;
}
function RepostFromJSON(json) {
  return RepostFromJSONTyped(json);
}
function RepostFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'repostItemId': json['repost_item_id'],
    'repostType': json['repost_type'],
    'userId': json['user_id']
  };
}
function RepostToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'repost_item_id': value.repostItemId,
    'repost_type': value.repostType,
    'user_id': value.userId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoverArt interface.
 */

function instanceOfCoverArt(value) {
  var isInstance = true;
  return isInstance;
}
function CoverArtFromJSON(json) {
  return CoverArtFromJSONTyped(json);
}
function CoverArtFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function CoverArtToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DownloadMetadata interface.
 */

function instanceOfDownloadMetadata(value) {
  var isInstance = true;
  isInstance = isInstance && "isDownloadable" in value;
  isInstance = isInstance && "requiresFollow" in value;
  return isInstance;
}
function DownloadMetadataFromJSON(json) {
  return DownloadMetadataFromJSONTyped(json);
}
function DownloadMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'cid': !exists(json, 'cid') ? undefined : json['cid'],
    'isDownloadable': json['is_downloadable'],
    'requiresFollow': json['requires_follow']
  };
}
function DownloadMetadataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'cid': value.cid,
    'is_downloadable': value.isDownloadable,
    'requires_follow': value.requiresFollow
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FieldVisibility interface.
 */

function instanceOfFieldVisibility(value) {
  var isInstance = true;
  return isInstance;
}
function FieldVisibilityFromJSON(json) {
  return FieldVisibilityFromJSONTyped(json);
}
function FieldVisibilityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'mood': !exists(json, 'mood') ? undefined : json['mood'],
    'tags': !exists(json, 'tags') ? undefined : json['tags'],
    'genre': !exists(json, 'genre') ? undefined : json['genre'],
    'share': !exists(json, 'share') ? undefined : json['share'],
    'playCount': !exists(json, 'play_count') ? undefined : json['play_count'],
    'remixes': !exists(json, 'remixes') ? undefined : json['remixes']
  };
}
function FieldVisibilityToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'mood': value.mood,
    'tags': value.tags,
    'genre': value.genre,
    'share': value.share,
    'play_count': value.playCount,
    'remixes': value.remixes
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoverPhoto interface.
 */

function instanceOfCoverPhoto(value) {
  var isInstance = true;
  return isInstance;
}
function CoverPhotoFromJSON(json) {
  return CoverPhotoFromJSONTyped(json);
}
function CoverPhotoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_640x': !exists(json, '640x') ? undefined : json['640x'],
    '_2000x': !exists(json, '2000x') ? undefined : json['2000x']
  };
}
function CoverPhotoToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '640x': value._640x,
    '2000x': value._2000x
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistLibrary interface.
 */

function instanceOfPlaylistLibrary(value) {
  var isInstance = true;
  return isInstance;
}
function PlaylistLibraryFromJSON(json) {
  return PlaylistLibraryFromJSONTyped(json);
}
function PlaylistLibraryFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'contents': !exists(json, 'contents') ? undefined : json['contents']
  };
}
function PlaylistLibraryToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'contents': value.contents
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ProfilePicture interface.
 */

function instanceOfProfilePicture(value) {
  var isInstance = true;
  return isInstance;
}
function ProfilePictureFromJSON(json) {
  return ProfilePictureFromJSONTyped(json);
}
function ProfilePictureFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function ProfilePictureToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserFull interface.
 */

function instanceOfUserFull(value) {
  var isInstance = true;
  isInstance = isInstance && "albumCount" in value;
  isInstance = isInstance && "followeeCount" in value;
  isInstance = isInstance && "followerCount" in value;
  isInstance = isInstance && "handle" in value;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isVerified" in value;
  isInstance = isInstance && "name" in value;
  isInstance = isInstance && "playlistCount" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "trackCount" in value;
  isInstance = isInstance && "isDeactivated" in value;
  isInstance = isInstance && "isAvailable" in value;
  isInstance = isInstance && "ercWallet" in value;
  isInstance = isInstance && "splWallet" in value;
  isInstance = isInstance && "supporterCount" in value;
  isInstance = isInstance && "supportingCount" in value;
  isInstance = isInstance && "totalAudioBalance" in value;
  isInstance = isInstance && "balance" in value;
  isInstance = isInstance && "associatedWalletsBalance" in value;
  isInstance = isInstance && "totalBalance" in value;
  isInstance = isInstance && "waudioBalance" in value;
  isInstance = isInstance && "associatedSolWalletsBalance" in value;
  isInstance = isInstance && "blocknumber" in value;
  isInstance = isInstance && "wallet" in value;
  isInstance = isInstance && "createdAt" in value;
  isInstance = isInstance && "isStorageV2" in value;
  isInstance = isInstance && "currentUserFolloweeFollowCount" in value;
  isInstance = isInstance && "doesCurrentUserFollow" in value;
  isInstance = isInstance && "handleLc" in value;
  isInstance = isInstance && "updatedAt" in value;
  isInstance = isInstance && "hasCollectibles" in value;
  isInstance = isInstance && "allowAiAttribution" in value;
  return isInstance;
}
function UserFullFromJSON(json) {
  return UserFullFromJSONTyped(json);
}
function UserFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'albumCount': json['album_count'],
    'artistPickTrackId': !exists(json, 'artist_pick_track_id') ? undefined : json['artist_pick_track_id'],
    'bio': !exists(json, 'bio') ? undefined : json['bio'],
    'coverPhoto': !exists(json, 'cover_photo') ? undefined : CoverPhotoFromJSON(json['cover_photo']),
    'followeeCount': json['followee_count'],
    'followerCount': json['follower_count'],
    'doesFollowCurrentUser': !exists(json, 'does_follow_current_user') ? undefined : json['does_follow_current_user'],
    'handle': json['handle'],
    'id': json['id'],
    'isVerified': json['is_verified'],
    'location': !exists(json, 'location') ? undefined : json['location'],
    'name': json['name'],
    'playlistCount': json['playlist_count'],
    'profilePicture': !exists(json, 'profile_picture') ? undefined : ProfilePictureFromJSON(json['profile_picture']),
    'repostCount': json['repost_count'],
    'trackCount': json['track_count'],
    'isDeactivated': json['is_deactivated'],
    'isAvailable': json['is_available'],
    'ercWallet': json['erc_wallet'],
    'splWallet': json['spl_wallet'],
    'supporterCount': json['supporter_count'],
    'supportingCount': json['supporting_count'],
    'totalAudioBalance': json['total_audio_balance'],
    'balance': json['balance'],
    'associatedWalletsBalance': json['associated_wallets_balance'],
    'totalBalance': json['total_balance'],
    'waudioBalance': json['waudio_balance'],
    'associatedSolWalletsBalance': json['associated_sol_wallets_balance'],
    'blocknumber': json['blocknumber'],
    'wallet': json['wallet'],
    'createdAt': json['created_at'],
    'isStorageV2': json['is_storage_v2'],
    'creatorNodeEndpoint': !exists(json, 'creator_node_endpoint') ? undefined : json['creator_node_endpoint'],
    'currentUserFolloweeFollowCount': json['current_user_followee_follow_count'],
    'doesCurrentUserFollow': json['does_current_user_follow'],
    'handleLc': json['handle_lc'],
    'updatedAt': json['updated_at'],
    'coverPhotoSizes': !exists(json, 'cover_photo_sizes') ? undefined : json['cover_photo_sizes'],
    'coverPhotoCids': !exists(json, 'cover_photo_cids') ? undefined : CoverPhotoFromJSON(json['cover_photo_cids']),
    'coverPhotoLegacy': !exists(json, 'cover_photo_legacy') ? undefined : json['cover_photo_legacy'],
    'profilePictureSizes': !exists(json, 'profile_picture_sizes') ? undefined : json['profile_picture_sizes'],
    'profilePictureCids': !exists(json, 'profile_picture_cids') ? undefined : ProfilePictureFromJSON(json['profile_picture_cids']),
    'profilePictureLegacy': !exists(json, 'profile_picture_legacy') ? undefined : json['profile_picture_legacy'],
    'metadataMultihash': !exists(json, 'metadata_multihash') ? undefined : json['metadata_multihash'],
    'hasCollectibles': json['has_collectibles'],
    'playlistLibrary': !exists(json, 'playlist_library') ? undefined : PlaylistLibraryFromJSON(json['playlist_library']),
    'allowAiAttribution': json['allow_ai_attribution']
  };
}
function UserFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'album_count': value.albumCount,
    'artist_pick_track_id': value.artistPickTrackId,
    'bio': value.bio,
    'cover_photo': CoverPhotoToJSON(value.coverPhoto),
    'followee_count': value.followeeCount,
    'follower_count': value.followerCount,
    'does_follow_current_user': value.doesFollowCurrentUser,
    'handle': value.handle,
    'id': value.id,
    'is_verified': value.isVerified,
    'location': value.location,
    'name': value.name,
    'playlist_count': value.playlistCount,
    'profile_picture': ProfilePictureToJSON(value.profilePicture),
    'repost_count': value.repostCount,
    'track_count': value.trackCount,
    'is_deactivated': value.isDeactivated,
    'is_available': value.isAvailable,
    'erc_wallet': value.ercWallet,
    'spl_wallet': value.splWallet,
    'supporter_count': value.supporterCount,
    'supporting_count': value.supportingCount,
    'total_audio_balance': value.totalAudioBalance,
    'balance': value.balance,
    'associated_wallets_balance': value.associatedWalletsBalance,
    'total_balance': value.totalBalance,
    'waudio_balance': value.waudioBalance,
    'associated_sol_wallets_balance': value.associatedSolWalletsBalance,
    'blocknumber': value.blocknumber,
    'wallet': value.wallet,
    'created_at': value.createdAt,
    'is_storage_v2': value.isStorageV2,
    'creator_node_endpoint': value.creatorNodeEndpoint,
    'current_user_followee_follow_count': value.currentUserFolloweeFollowCount,
    'does_current_user_follow': value.doesCurrentUserFollow,
    'handle_lc': value.handleLc,
    'updated_at': value.updatedAt,
    'cover_photo_sizes': value.coverPhotoSizes,
    'cover_photo_cids': CoverPhotoToJSON(value.coverPhotoCids),
    'cover_photo_legacy': value.coverPhotoLegacy,
    'profile_picture_sizes': value.profilePictureSizes,
    'profile_picture_cids': ProfilePictureToJSON(value.profilePictureCids),
    'profile_picture_legacy': value.profilePictureLegacy,
    'metadata_multihash': value.metadataMultihash,
    'has_collectibles': value.hasCollectibles,
    'playlist_library': PlaylistLibraryToJSON(value.playlistLibrary),
    'allow_ai_attribution': value.allowAiAttribution
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullRemix interface.
 */

function instanceOfFullRemix(value) {
  var isInstance = true;
  isInstance = isInstance && "parentTrackId" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "hasRemixAuthorReposted" in value;
  isInstance = isInstance && "hasRemixAuthorSaved" in value;
  return isInstance;
}
function FullRemixFromJSON(json) {
  return FullRemixFromJSONTyped(json);
}
function FullRemixFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'parentTrackId': json['parent_track_id'],
    'user': UserFullFromJSON(json['user']),
    'hasRemixAuthorReposted': json['has_remix_author_reposted'],
    'hasRemixAuthorSaved': json['has_remix_author_saved']
  };
}
function FullRemixToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'parent_track_id': value.parentTrackId,
    'user': UserFullToJSON(value.user),
    'has_remix_author_reposted': value.hasRemixAuthorReposted,
    'has_remix_author_saved': value.hasRemixAuthorSaved
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullRemixParent interface.
 */

function instanceOfFullRemixParent(value) {
  var isInstance = true;
  return isInstance;
}
function FullRemixParentFromJSON(json) {
  return FullRemixParentFromJSONTyped(json);
}
function FullRemixParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(FullRemixFromJSON)
  };
}
function FullRemixParentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(FullRemixToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PremiumContentSignature interface.
 */

function instanceOfPremiumContentSignature(value) {
  var isInstance = true;
  return isInstance;
}
function PremiumContentSignatureFromJSON(json) {
  return PremiumContentSignatureFromJSONTyped(json);
}
function PremiumContentSignatureFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists(json, 'data') ? undefined : json['data'],
    'signature': !exists(json, 'signature') ? undefined : json['signature']
  };
}
function PremiumContentSignatureToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': value.data,
    'signature': value.signature
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the StemParent interface.
 */

function instanceOfStemParent(value) {
  var isInstance = true;
  isInstance = isInstance && "category" in value;
  isInstance = isInstance && "parentTrackId" in value;
  return isInstance;
}
function StemParentFromJSON(json) {
  return StemParentFromJSONTyped(json);
}
function StemParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'category': json['category'],
    'parentTrackId': json['parent_track_id']
  };
}
function StemParentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'category': value.category,
    'parent_track_id': value.parentTrackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackArtwork interface.
 */

function instanceOfTrackArtwork(value) {
  var isInstance = true;
  return isInstance;
}
function TrackArtworkFromJSON(json) {
  return TrackArtworkFromJSONTyped(json);
}
function TrackArtworkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function TrackArtworkToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackSegment interface.
 */

function instanceOfTrackSegment(value) {
  var isInstance = true;
  isInstance = isInstance && "duration" in value;
  isInstance = isInstance && "multihash" in value;
  return isInstance;
}
function TrackSegmentFromJSON(json) {
  return TrackSegmentFromJSONTyped(json);
}
function TrackSegmentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'duration': json['duration'],
    'multihash': json['multihash']
  };
}
function TrackSegmentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'duration': value.duration,
    'multihash': value.multihash
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackFull interface.
 */

function instanceOfTrackFull(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "title" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "duration" in value;
  isInstance = isInstance && "playCount" in value;
  isInstance = isInstance && "blocknumber" in value;
  isInstance = isInstance && "followeeReposts" in value;
  isInstance = isInstance && "hasCurrentUserReposted" in value;
  isInstance = isInstance && "isUnlisted" in value;
  isInstance = isInstance && "hasCurrentUserSaved" in value;
  isInstance = isInstance && "followeeFavorites" in value;
  isInstance = isInstance && "routeId" in value;
  isInstance = isInstance && "userId" in value;
  return isInstance;
}
function TrackFullFromJSON(json) {
  return TrackFullFromJSONTyped(json);
}
function TrackFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists(json, 'artwork') ? undefined : TrackArtworkFromJSON(json['artwork']),
    'description': !exists(json, 'description') ? undefined : json['description'],
    'genre': !exists(json, 'genre') ? undefined : json['genre'],
    'id': json['id'],
    'trackCid': !exists(json, 'track_cid') ? undefined : json['track_cid'],
    'previewCid': !exists(json, 'preview_cid') ? undefined : json['preview_cid'],
    'mood': !exists(json, 'mood') ? undefined : json['mood'],
    'releaseDate': !exists(json, 'release_date') ? undefined : json['release_date'],
    'remixOf': !exists(json, 'remix_of') ? undefined : FullRemixParentFromJSON(json['remix_of']),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'tags': !exists(json, 'tags') ? undefined : json['tags'],
    'title': json['title'],
    'user': UserFullFromJSON(json['user']),
    'duration': json['duration'],
    'downloadable': !exists(json, 'downloadable') ? undefined : json['downloadable'],
    'playCount': json['play_count'],
    'permalink': !exists(json, 'permalink') ? undefined : json['permalink'],
    'isStreamable': !exists(json, 'is_streamable') ? undefined : json['is_streamable'],
    'blocknumber': json['blocknumber'],
    'createDate': !exists(json, 'create_date') ? undefined : json['create_date'],
    'coverArtSizes': !exists(json, 'cover_art_sizes') ? undefined : json['cover_art_sizes'],
    'coverArtCids': !exists(json, 'cover_art_cids') ? undefined : CoverArtFromJSON(json['cover_art_cids']),
    'createdAt': !exists(json, 'created_at') ? undefined : json['created_at'],
    'creditsSplits': !exists(json, 'credits_splits') ? undefined : json['credits_splits'],
    'download': !exists(json, 'download') ? undefined : DownloadMetadataFromJSON(json['download']),
    'isrc': !exists(json, 'isrc') ? undefined : json['isrc'],
    'license': !exists(json, 'license') ? undefined : json['license'],
    'iswc': !exists(json, 'iswc') ? undefined : json['iswc'],
    'fieldVisibility': !exists(json, 'field_visibility') ? undefined : FieldVisibilityFromJSON(json['field_visibility']),
    'followeeReposts': json['followee_reposts'].map(RepostFromJSON),
    'hasCurrentUserReposted': json['has_current_user_reposted'],
    'isUnlisted': json['is_unlisted'],
    'hasCurrentUserSaved': json['has_current_user_saved'],
    'followeeFavorites': json['followee_favorites'].map(FavoriteFromJSON),
    'routeId': json['route_id'],
    'stemOf': !exists(json, 'stem_of') ? undefined : StemParentFromJSON(json['stem_of']),
    'trackSegments': !exists(json, 'track_segments') ? undefined : json['track_segments'].map(TrackSegmentFromJSON),
    'updatedAt': !exists(json, 'updated_at') ? undefined : json['updated_at'],
    'userId': json['user_id'],
    'isDelete': !exists(json, 'is_delete') ? undefined : json['is_delete'],
    'coverArt': !exists(json, 'cover_art') ? undefined : json['cover_art'],
    'isAvailable': !exists(json, 'is_available') ? undefined : json['is_available'],
    'isPremium': !exists(json, 'is_premium') ? undefined : json['is_premium'],
    'premiumConditions': !exists(json, 'premium_conditions') ? undefined : json['premium_conditions'],
    'premiumContentSignature': !exists(json, 'premium_content_signature') ? undefined : PremiumContentSignatureFromJSON(json['premium_content_signature']),
    'aiAttributionUserId': !exists(json, 'ai_attribution_user_id') ? undefined : json['ai_attribution_user_id'],
    'audioUploadId': !exists(json, 'audio_upload_id') ? undefined : json['audio_upload_id'],
    'previewStartSeconds': !exists(json, 'preview_start_seconds') ? undefined : json['preview_start_seconds']
  };
}
function TrackFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': TrackArtworkToJSON(value.artwork),
    'description': value.description,
    'genre': value.genre,
    'id': value.id,
    'track_cid': value.trackCid,
    'preview_cid': value.previewCid,
    'mood': value.mood,
    'release_date': value.releaseDate,
    'remix_of': FullRemixParentToJSON(value.remixOf),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'tags': value.tags,
    'title': value.title,
    'user': UserFullToJSON(value.user),
    'duration': value.duration,
    'downloadable': value.downloadable,
    'play_count': value.playCount,
    'permalink': value.permalink,
    'is_streamable': value.isStreamable,
    'blocknumber': value.blocknumber,
    'create_date': value.createDate,
    'cover_art_sizes': value.coverArtSizes,
    'cover_art_cids': CoverArtToJSON(value.coverArtCids),
    'created_at': value.createdAt,
    'credits_splits': value.creditsSplits,
    'download': DownloadMetadataToJSON(value.download),
    'isrc': value.isrc,
    'license': value.license,
    'iswc': value.iswc,
    'field_visibility': FieldVisibilityToJSON(value.fieldVisibility),
    'followee_reposts': value.followeeReposts.map(RepostToJSON),
    'has_current_user_reposted': value.hasCurrentUserReposted,
    'is_unlisted': value.isUnlisted,
    'has_current_user_saved': value.hasCurrentUserSaved,
    'followee_favorites': value.followeeFavorites.map(FavoriteToJSON),
    'route_id': value.routeId,
    'stem_of': StemParentToJSON(value.stemOf),
    'track_segments': value.trackSegments === undefined ? undefined : value.trackSegments.map(TrackSegmentToJSON),
    'updated_at': value.updatedAt,
    'user_id': value.userId,
    'is_delete': value.isDelete,
    'cover_art': value.coverArt,
    'is_available': value.isAvailable,
    'is_premium': value.isPremium,
    'premium_conditions': value.premiumConditions,
    'premium_content_signature': PremiumContentSignatureToJSON(value.premiumContentSignature),
    'ai_attribution_user_id': value.aiAttributionUserId,
    'audio_upload_id': value.audioUploadId,
    'preview_start_seconds': value.previewStartSeconds
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistFullWithoutTracks interface.
 */

function instanceOfPlaylistFullWithoutTracks(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isAlbum" in value;
  isInstance = isInstance && "isImageAutogenerated" in value;
  isInstance = isInstance && "playlistName" in value;
  isInstance = isInstance && "playlistContents" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "totalPlayCount" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "blocknumber" in value;
  isInstance = isInstance && "followeeReposts" in value;
  isInstance = isInstance && "followeeFavorites" in value;
  isInstance = isInstance && "hasCurrentUserReposted" in value;
  isInstance = isInstance && "hasCurrentUserSaved" in value;
  isInstance = isInstance && "isDelete" in value;
  isInstance = isInstance && "isPrivate" in value;
  isInstance = isInstance && "addedTimestamps" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "trackCount" in value;
  return isInstance;
}
function PlaylistFullWithoutTracksFromJSON(json) {
  return PlaylistFullWithoutTracksFromJSONTyped(json);
}
function PlaylistFullWithoutTracksFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists(json, 'artwork') ? undefined : PlaylistArtworkFromJSON(json['artwork']),
    'description': !exists(json, 'description') ? undefined : json['description'],
    'permalink': !exists(json, 'permalink') ? undefined : json['permalink'],
    'id': json['id'],
    'isAlbum': json['is_album'],
    'isImageAutogenerated': json['is_image_autogenerated'],
    'playlistName': json['playlist_name'],
    'playlistContents': json['playlist_contents'].map(PlaylistAddedTimestampFromJSON),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'totalPlayCount': json['total_play_count'],
    'user': UserFullFromJSON(json['user']),
    'blocknumber': json['blocknumber'],
    'createdAt': !exists(json, 'created_at') ? undefined : json['created_at'],
    'followeeReposts': json['followee_reposts'].map(RepostFromJSON),
    'followeeFavorites': json['followee_favorites'].map(FavoriteFromJSON),
    'hasCurrentUserReposted': json['has_current_user_reposted'],
    'hasCurrentUserSaved': json['has_current_user_saved'],
    'isDelete': json['is_delete'],
    'isPrivate': json['is_private'],
    'updatedAt': !exists(json, 'updated_at') ? undefined : json['updated_at'],
    'addedTimestamps': json['added_timestamps'].map(PlaylistAddedTimestampFromJSON),
    'userId': json['user_id'],
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(TrackFullFromJSON),
    'coverArt': !exists(json, 'cover_art') ? undefined : json['cover_art'],
    'coverArtSizes': !exists(json, 'cover_art_sizes') ? undefined : json['cover_art_sizes'],
    'coverArtCids': !exists(json, 'cover_art_cids') ? undefined : PlaylistArtworkFromJSON(json['cover_art_cids']),
    'trackCount': json['track_count']
  };
}
function PlaylistFullWithoutTracksToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': PlaylistArtworkToJSON(value.artwork),
    'description': value.description,
    'permalink': value.permalink,
    'id': value.id,
    'is_album': value.isAlbum,
    'is_image_autogenerated': value.isImageAutogenerated,
    'playlist_name': value.playlistName,
    'playlist_contents': value.playlistContents.map(PlaylistAddedTimestampToJSON),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'total_play_count': value.totalPlayCount,
    'user': UserFullToJSON(value.user),
    'blocknumber': value.blocknumber,
    'created_at': value.createdAt,
    'followee_reposts': value.followeeReposts.map(RepostToJSON),
    'followee_favorites': value.followeeFavorites.map(FavoriteToJSON),
    'has_current_user_reposted': value.hasCurrentUserReposted,
    'has_current_user_saved': value.hasCurrentUserSaved,
    'is_delete': value.isDelete,
    'is_private': value.isPrivate,
    'updated_at': value.updatedAt,
    'added_timestamps': value.addedTimestamps.map(PlaylistAddedTimestampToJSON),
    'user_id': value.userId,
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackFullToJSON),
    'cover_art': value.coverArt,
    'cover_art_sizes': value.coverArtSizes,
    'cover_art_cids': PlaylistArtworkToJSON(value.coverArtCids),
    'track_count': value.trackCount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CollectionActivityFull interface.
 */

function instanceOfCollectionActivityFull(value) {
  var isInstance = true;
  return isInstance;
}
function CollectionActivityFullFromJSON(json) {
  return CollectionActivityFullFromJSONTyped(json);
}
function CollectionActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'timestamp': !exists(json, 'timestamp') ? undefined : json['timestamp'],
    'itemType': !exists(json, 'item_type') ? undefined : json['item_type'],
    'item': !exists(json, 'item') ? undefined : PlaylistFullWithoutTracksFromJSON(json['item'])
  };
}
function CollectionActivityFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': PlaylistFullWithoutTracksToJSON(value.item)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the VersionMetadata interface.
 */

function instanceOfVersionMetadata(value) {
  var isInstance = true;
  isInstance = isInstance && "service" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function VersionMetadataFromJSON(json) {
  return VersionMetadataFromJSONTyped(json);
}
function VersionMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'service': json['service'],
    'version': json['version']
  };
}
function VersionMetadataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'service': value.service,
    'version': value.version
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CollectionLibraryResponseFull interface.
 */

function instanceOfCollectionLibraryResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function CollectionLibraryResponseFullFromJSON(json) {
  return CollectionLibraryResponseFullFromJSONTyped(json);
}
function CollectionLibraryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(CollectionActivityFullFromJSON)
  };
}
function CollectionLibraryResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(CollectionActivityFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowingResponse interface.
 */

function instanceOfFollowingResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FollowingResponseFromJSON(json) {
  return FollowingResponseFromJSONTyped(json);
}
function FollowingResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FollowingResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowingResponseFull interface.
 */

function instanceOfFollowingResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FollowingResponseFullFromJSON(json) {
  return FollowingResponseFullFromJSONTyped(json);
}
function FollowingResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FollowingResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserSubscribers interface.
 */

function instanceOfUserSubscribers(value) {
  var isInstance = true;
  isInstance = isInstance && "userId" in value;
  return isInstance;
}
function UserSubscribersFromJSON(json) {
  return UserSubscribersFromJSONTyped(json);
}
function UserSubscribersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': json['user_id'],
    'subscriberIds': !exists(json, 'subscriber_ids') ? undefined : json['subscriber_ids']
  };
}
function UserSubscribersToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'user_id': value.userId,
    'subscriber_ids': value.subscriberIds
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullBulkSubscribersResponse interface.
 */

function instanceOfFullBulkSubscribersResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullBulkSubscribersResponseFromJSON(json) {
  return FullBulkSubscribersResponseFromJSONTyped(json);
}
function FullBulkSubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserSubscribersFromJSON)
  };
}
function FullBulkSubscribersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserSubscribersToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullFollowersResponse interface.
 */

function instanceOfFullFollowersResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullFollowersResponseFromJSON(json) {
  return FullFollowersResponseFromJSONTyped(json);
}
function FullFollowersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullFollowersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullSupporter interface.
 */

function instanceOfFullSupporter(value) {
  var isInstance = true;
  isInstance = isInstance && "rank" in value;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "sender" in value;
  return isInstance;
}
function FullSupporterFromJSON(json) {
  return FullSupporterFromJSONTyped(json);
}
function FullSupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'sender': UserFullFromJSON(json['sender'])
  };
}
function FullSupporterToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'rank': value.rank,
    'amount': value.amount,
    'sender': UserFullToJSON(value.sender)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullGetSupporter interface.
 */

function instanceOfFullGetSupporter(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullGetSupporterFromJSON(json) {
  return FullGetSupporterFromJSONTyped(json);
}
function FullGetSupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : FullSupporterFromJSON(json['data'])
  };
}
function FullGetSupporterToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': FullSupporterToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullGetSupporters interface.
 */

function instanceOfFullGetSupporters(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullGetSupportersFromJSON(json) {
  return FullGetSupportersFromJSONTyped(json);
}
function FullGetSupportersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(FullSupporterFromJSON)
  };
}
function FullGetSupportersToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(FullSupporterToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullSupporting interface.
 */

function instanceOfFullSupporting(value) {
  var isInstance = true;
  isInstance = isInstance && "rank" in value;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "receiver" in value;
  return isInstance;
}
function FullSupportingFromJSON(json) {
  return FullSupportingFromJSONTyped(json);
}
function FullSupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'receiver': UserFullFromJSON(json['receiver'])
  };
}
function FullSupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'rank': value.rank,
    'amount': value.amount,
    'receiver': UserFullToJSON(value.receiver)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullGetSupporting interface.
 */

function instanceOfFullGetSupporting(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullGetSupportingFromJSON(json) {
  return FullGetSupportingFromJSONTyped(json);
}
function FullGetSupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : FullSupportingFromJSON(json['data'])
  };
}
function FullGetSupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': FullSupportingToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistFull interface.
 */

function instanceOfPlaylistFull(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "isAlbum" in value;
  isInstance = isInstance && "isImageAutogenerated" in value;
  isInstance = isInstance && "playlistName" in value;
  isInstance = isInstance && "playlistContents" in value;
  isInstance = isInstance && "repostCount" in value;
  isInstance = isInstance && "favoriteCount" in value;
  isInstance = isInstance && "totalPlayCount" in value;
  isInstance = isInstance && "user" in value;
  isInstance = isInstance && "blocknumber" in value;
  isInstance = isInstance && "followeeReposts" in value;
  isInstance = isInstance && "followeeFavorites" in value;
  isInstance = isInstance && "hasCurrentUserReposted" in value;
  isInstance = isInstance && "hasCurrentUserSaved" in value;
  isInstance = isInstance && "isDelete" in value;
  isInstance = isInstance && "isPrivate" in value;
  isInstance = isInstance && "addedTimestamps" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "tracks" in value;
  isInstance = isInstance && "trackCount" in value;
  return isInstance;
}
function PlaylistFullFromJSON(json) {
  return PlaylistFullFromJSONTyped(json);
}
function PlaylistFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'artwork': !exists(json, 'artwork') ? undefined : PlaylistArtworkFromJSON(json['artwork']),
    'description': !exists(json, 'description') ? undefined : json['description'],
    'permalink': !exists(json, 'permalink') ? undefined : json['permalink'],
    'id': json['id'],
    'isAlbum': json['is_album'],
    'isImageAutogenerated': json['is_image_autogenerated'],
    'playlistName': json['playlist_name'],
    'playlistContents': json['playlist_contents'].map(PlaylistAddedTimestampFromJSON),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'totalPlayCount': json['total_play_count'],
    'user': UserFullFromJSON(json['user']),
    'blocknumber': json['blocknumber'],
    'createdAt': !exists(json, 'created_at') ? undefined : json['created_at'],
    'followeeReposts': json['followee_reposts'].map(RepostFromJSON),
    'followeeFavorites': json['followee_favorites'].map(FavoriteFromJSON),
    'hasCurrentUserReposted': json['has_current_user_reposted'],
    'hasCurrentUserSaved': json['has_current_user_saved'],
    'isDelete': json['is_delete'],
    'isPrivate': json['is_private'],
    'updatedAt': !exists(json, 'updated_at') ? undefined : json['updated_at'],
    'addedTimestamps': json['added_timestamps'].map(PlaylistAddedTimestampFromJSON),
    'userId': json['user_id'],
    'tracks': json['tracks'].map(TrackFullFromJSON),
    'coverArt': !exists(json, 'cover_art') ? undefined : json['cover_art'],
    'coverArtSizes': !exists(json, 'cover_art_sizes') ? undefined : json['cover_art_sizes'],
    'coverArtCids': !exists(json, 'cover_art_cids') ? undefined : PlaylistArtworkFromJSON(json['cover_art_cids']),
    'trackCount': json['track_count']
  };
}
function PlaylistFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'artwork': PlaylistArtworkToJSON(value.artwork),
    'description': value.description,
    'permalink': value.permalink,
    'id': value.id,
    'is_album': value.isAlbum,
    'is_image_autogenerated': value.isImageAutogenerated,
    'playlist_name': value.playlistName,
    'playlist_contents': value.playlistContents.map(PlaylistAddedTimestampToJSON),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'total_play_count': value.totalPlayCount,
    'user': UserFullToJSON(value.user),
    'blocknumber': value.blocknumber,
    'created_at': value.createdAt,
    'followee_reposts': value.followeeReposts.map(RepostToJSON),
    'followee_favorites': value.followeeFavorites.map(FavoriteToJSON),
    'has_current_user_reposted': value.hasCurrentUserReposted,
    'has_current_user_saved': value.hasCurrentUserSaved,
    'is_delete': value.isDelete,
    'is_private': value.isPrivate,
    'updated_at': value.updatedAt,
    'added_timestamps': value.addedTimestamps.map(PlaylistAddedTimestampToJSON),
    'user_id': value.userId,
    'tracks': value.tracks.map(TrackFullToJSON),
    'cover_art': value.coverArt,
    'cover_art_sizes': value.coverArtSizes,
    'cover_art_cids': PlaylistArtworkToJSON(value.coverArtCids),
    'track_count': value.trackCount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullPlaylistResponse interface.
 */

function instanceOfFullPlaylistResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullPlaylistResponseFromJSON(json) {
  return FullPlaylistResponseFromJSONTyped(json);
}
function FullPlaylistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(PlaylistFullFromJSON)
  };
}
function FullPlaylistResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(PlaylistFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullPlaylistTracksResponse interface.
 */

function instanceOfFullPlaylistTracksResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullPlaylistTracksResponseFromJSON(json) {
  return FullPlaylistTracksResponseFromJSONTyped(json);
}
function FullPlaylistTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function FullPlaylistTracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullReposts interface.
 */

function instanceOfFullReposts(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullRepostsFromJSON(json) {
  return FullRepostsFromJSONTyped(json);
}
function FullRepostsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(ActivityFullFromJSON)
  };
}
function FullRepostsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(ActivityFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullSubscribersResponse interface.
 */

function instanceOfFullSubscribersResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullSubscribersResponseFromJSON(json) {
  return FullSubscribersResponseFromJSONTyped(json);
}
function FullSubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullSubscribersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SupporterReference interface.
 */

function instanceOfSupporterReference(value) {
  var isInstance = true;
  isInstance = isInstance && "userId" in value;
  return isInstance;
}
function SupporterReferenceFromJSON(json) {
  return SupporterReferenceFromJSONTyped(json);
}
function SupporterReferenceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': json['user_id']
  };
}
function SupporterReferenceToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'user_id': value.userId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTip interface.
 */

function instanceOfFullTip(value) {
  var isInstance = true;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "sender" in value;
  isInstance = isInstance && "receiver" in value;
  isInstance = isInstance && "createdAt" in value;
  isInstance = isInstance && "slot" in value;
  isInstance = isInstance && "followeeSupporters" in value;
  isInstance = isInstance && "txSignature" in value;
  return isInstance;
}
function FullTipFromJSON(json) {
  return FullTipFromJSONTyped(json);
}
function FullTipFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'amount': json['amount'],
    'sender': UserFullFromJSON(json['sender']),
    'receiver': UserFullFromJSON(json['receiver']),
    'createdAt': json['created_at'],
    'slot': json['slot'],
    'followeeSupporters': json['followee_supporters'].map(SupporterReferenceFromJSON),
    'txSignature': json['tx_signature']
  };
}
function FullTipToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'amount': value.amount,
    'sender': UserFullToJSON(value.sender),
    'receiver': UserFullToJSON(value.receiver),
    'created_at': value.createdAt,
    'slot': value.slot,
    'followee_supporters': value.followeeSupporters.map(SupporterReferenceToJSON),
    'tx_signature': value.txSignature
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTrackResponse interface.
 */

function instanceOfFullTrackResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullTrackResponseFromJSON(json) {
  return FullTrackResponseFromJSONTyped(json);
}
function FullTrackResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : TrackFullFromJSON(json['data'])
  };
}
function FullTrackResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': TrackFullToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTracks interface.
 */

function instanceOfFullTracks(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullTracksFromJSON(json) {
  return FullTracksFromJSONTyped(json);
}
function FullTracksFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function FullTracksToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTracksResponse interface.
 */

function instanceOfFullTracksResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullTracksResponseFromJSON(json) {
  return FullTracksResponseFromJSONTyped(json);
}
function FullTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function FullTracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTrendingPlaylistsResponse interface.
 */

function instanceOfFullTrendingPlaylistsResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullTrendingPlaylistsResponseFromJSON(json) {
  return FullTrendingPlaylistsResponseFromJSONTyped(json);
}
function FullTrendingPlaylistsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(PlaylistFullFromJSON)
  };
}
function FullTrendingPlaylistsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(PlaylistFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullUserResponse interface.
 */

function instanceOfFullUserResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function FullUserResponseFromJSON(json) {
  return FullUserResponseFromJSONTyped(json);
}
function FullUserResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullUserResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetTipsResponse interface.
 */

function instanceOfGetTipsResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function GetTipsResponseFromJSON(json) {
  return GetTipsResponseFromJSONTyped(json);
}
function GetTipsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(FullTipFromJSON)
  };
}
function GetTipsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(FullTipToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the HistoryResponseFull interface.
 */

function instanceOfHistoryResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function HistoryResponseFullFromJSON(json) {
  return HistoryResponseFullFromJSONTyped(json);
}
function HistoryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(ActivityFullFromJSON)
  };
}
function HistoryResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(ActivityFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RelatedArtistResponseFull interface.
 */

function instanceOfRelatedArtistResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function RelatedArtistResponseFullFromJSON(json) {
  return RelatedArtistResponseFullFromJSONTyped(json);
}
function RelatedArtistResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function RelatedArtistResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixesResponse interface.
 */

function instanceOfRemixesResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "count" in value;
  return isInstance;
}
function RemixesResponseFromJSON(json) {
  return RemixesResponseFromJSONTyped(json);
}
function RemixesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'count': json['count'],
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(TrackFullFromJSON)
  };
}
function RemixesResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'count': value.count,
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixesResponseFull interface.
 */

function instanceOfRemixesResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function RemixesResponseFullFromJSON(json) {
  return RemixesResponseFullFromJSONTyped(json);
}
function RemixesResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : RemixesResponseFromJSON(json['data'])
  };
}
function RemixesResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': RemixesResponseToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixingResponse interface.
 */

function instanceOfRemixingResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function RemixingResponseFromJSON(json) {
  return RemixingResponseFromJSONTyped(json);
}
function RemixingResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function RemixingResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SearchModel interface.
 */

function instanceOfSearchModel(value) {
  var isInstance = true;
  isInstance = isInstance && "users" in value;
  isInstance = isInstance && "tracks" in value;
  isInstance = isInstance && "playlists" in value;
  isInstance = isInstance && "albums" in value;
  return isInstance;
}
function SearchModelFromJSON(json) {
  return SearchModelFromJSONTyped(json);
}
function SearchModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'users': json['users'].map(UserFullFromJSON),
    'followedUsers': !exists(json, 'followed_users') ? undefined : json['followed_users'].map(UserFullFromJSON),
    'tracks': json['tracks'].map(TrackFullFromJSON),
    'savedTracks': !exists(json, 'saved_tracks') ? undefined : json['saved_tracks'].map(TrackFullFromJSON),
    'playlists': json['playlists'].map(PlaylistFullFromJSON),
    'savedPlaylists': !exists(json, 'saved_playlists') ? undefined : json['saved_playlists'].map(PlaylistFullFromJSON),
    'albums': json['albums'].map(PlaylistFullFromJSON),
    'savedAlbums': !exists(json, 'saved_albums') ? undefined : json['saved_albums'].map(PlaylistFullFromJSON)
  };
}
function SearchModelToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'users': value.users.map(UserFullToJSON),
    'followed_users': value.followedUsers === undefined ? undefined : value.followedUsers.map(UserFullToJSON),
    'tracks': value.tracks.map(TrackFullToJSON),
    'saved_tracks': value.savedTracks === undefined ? undefined : value.savedTracks.map(TrackFullToJSON),
    'playlists': value.playlists.map(PlaylistFullToJSON),
    'saved_playlists': value.savedPlaylists === undefined ? undefined : value.savedPlaylists.map(PlaylistFullToJSON),
    'albums': value.albums.map(PlaylistFullToJSON),
    'saved_albums': value.savedAlbums === undefined ? undefined : value.savedAlbums.map(PlaylistFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SearchAutocompleteResponse interface.
 */

function instanceOfSearchAutocompleteResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function SearchAutocompleteResponseFromJSON(json) {
  return SearchAutocompleteResponseFromJSONTyped(json);
}
function SearchAutocompleteResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : SearchModelFromJSON(json['data'])
  };
}
function SearchAutocompleteResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': SearchModelToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SearchFullResponse interface.
 */

function instanceOfSearchFullResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function SearchFullResponseFromJSON(json) {
  return SearchFullResponseFromJSONTyped(json);
}
function SearchFullResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : SearchModelFromJSON(json['data'])
  };
}
function SearchFullResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': SearchModelToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the StemFull interface.
 */

function instanceOfStemFull(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  isInstance = isInstance && "parentId" in value;
  isInstance = isInstance && "category" in value;
  isInstance = isInstance && "cid" in value;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "blocknumber" in value;
  return isInstance;
}
function StemFullFromJSON(json) {
  return StemFullFromJSONTyped(json);
}
function StemFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'id': json['id'],
    'parentId': json['parent_id'],
    'category': json['category'],
    'cid': json['cid'],
    'userId': json['user_id'],
    'blocknumber': json['blocknumber']
  };
}
function StemFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'id': value.id,
    'parent_id': value.parentId,
    'category': value.category,
    'cid': value.cid,
    'user_id': value.userId,
    'blocknumber': value.blocknumber
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the StemsResponse interface.
 */

function instanceOfStemsResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function StemsResponseFromJSON(json) {
  return StemsResponseFromJSONTyped(json);
}
function StemsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(StemFullFromJSON)
  };
}
function StemsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(StemFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TopGenreUsersResponseFull interface.
 */

function instanceOfTopGenreUsersResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TopGenreUsersResponseFullFromJSON(json) {
  return TopGenreUsersResponseFullFromJSONTyped(json);
}
function TopGenreUsersResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TopGenreUsersResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TopUsersResponseFull interface.
 */

function instanceOfTopUsersResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TopUsersResponseFullFromJSON(json) {
  return TopUsersResponseFullFromJSONTyped(json);
}
function TopUsersResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TopUsersResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackActivityFull interface.
 */

function instanceOfTrackActivityFull(value) {
  var isInstance = true;
  return isInstance;
}
function TrackActivityFullFromJSON(json) {
  return TrackActivityFullFromJSONTyped(json);
}
function TrackActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'timestamp': !exists(json, 'timestamp') ? undefined : json['timestamp'],
    'itemType': !exists(json, 'item_type') ? undefined : json['item_type'],
    'item': !exists(json, 'item') ? undefined : TrackFullFromJSON(json['item'])
  };
}
function TrackActivityFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': TrackFullToJSON(value.item)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackFavoritesResponseFull interface.
 */

function instanceOfTrackFavoritesResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TrackFavoritesResponseFullFromJSON(json) {
  return TrackFavoritesResponseFullFromJSONTyped(json);
}
function TrackFavoritesResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TrackFavoritesResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackId interface.
 */

function instanceOfTrackId(value) {
  var isInstance = true;
  isInstance = isInstance && "id" in value;
  return isInstance;
}
function TrackIdFromJSON(json) {
  return TrackIdFromJSONTyped(json);
}
function TrackIdFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'id': json['id']
  };
}
function TrackIdToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'id': value.id
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackLibraryResponseFull interface.
 */

function instanceOfTrackLibraryResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TrackLibraryResponseFullFromJSON(json) {
  return TrackLibraryResponseFullFromJSONTyped(json);
}
function TrackLibraryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackActivityFullFromJSON)
  };
}
function TrackLibraryResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackActivityFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackRepostsResponseFull interface.
 */

function instanceOfTrackRepostsResponseFull(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TrackRepostsResponseFullFromJSON(json) {
  return TrackRepostsResponseFullFromJSONTyped(json);
}
function TrackRepostsResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TrackRepostsResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TransactionDetails interface.
 */

function instanceOfTransactionDetails(value) {
  var isInstance = true;
  isInstance = isInstance && "transactionDate" in value;
  isInstance = isInstance && "transactionType" in value;
  isInstance = isInstance && "method" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "userBank" in value;
  isInstance = isInstance && "change" in value;
  isInstance = isInstance && "balance" in value;
  isInstance = isInstance && "metadata" in value;
  return isInstance;
}
function TransactionDetailsFromJSON(json) {
  return TransactionDetailsFromJSONTyped(json);
}
function TransactionDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'transactionDate': json['transaction_date'],
    'transactionType': json['transaction_type'],
    'method': json['method'],
    'signature': json['signature'],
    'userBank': json['user_bank'],
    'change': json['change'],
    'balance': json['balance'],
    'metadata': json['metadata']
  };
}
function TransactionDetailsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'transaction_date': value.transactionDate,
    'transaction_type': value.transactionType,
    'method': value.method,
    'signature': value.signature,
    'user_bank': value.userBank,
    'change': value.change,
    'balance': value.balance,
    'metadata': value.metadata
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TransactionHistoryCountResponse interface.
 */

function instanceOfTransactionHistoryCountResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TransactionHistoryCountResponseFromJSON(json) {
  return TransactionHistoryCountResponseFromJSONTyped(json);
}
function TransactionHistoryCountResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data']
  };
}
function TransactionHistoryCountResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TransactionHistoryResponse interface.
 */

function instanceOfTransactionHistoryResponse(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function TransactionHistoryResponseFromJSON(json) {
  return TransactionHistoryResponseFromJSONTyped(json);
}
function TransactionHistoryResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TransactionDetailsFromJSON)
  };
}
function TransactionHistoryResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TransactionDetailsToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingTimesIds interface.
 */

function instanceOfTrendingTimesIds(value) {
  var isInstance = true;
  return isInstance;
}
function TrendingTimesIdsFromJSON(json) {
  return TrendingTimesIdsFromJSONTyped(json);
}
function TrendingTimesIdsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'week': !exists(json, 'week') ? undefined : json['week'].map(TrackIdFromJSON),
    'month': !exists(json, 'month') ? undefined : json['month'].map(TrackIdFromJSON),
    'year': !exists(json, 'year') ? undefined : json['year'].map(TrackIdFromJSON)
  };
}
function TrendingTimesIdsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'week': value.week === undefined ? undefined : value.week.map(TrackIdToJSON),
    'month': value.month === undefined ? undefined : value.month.map(TrackIdToJSON),
    'year': value.year === undefined ? undefined : value.year.map(TrackIdToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingIdsResponse interface.
 */

function instanceOfTrendingIdsResponse(value) {
  var isInstance = true;
  return isInstance;
}
function TrendingIdsResponseFromJSON(json) {
  return TrendingIdsResponseFromJSONTyped(json);
}
function TrendingIdsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'data': !exists(json, 'data') ? undefined : TrendingTimesIdsFromJSON(json['data'])
  };
}
function TrendingIdsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'data': TrendingTimesIdsToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserReplicaSet interface.
 */

function instanceOfUserReplicaSet(value) {
  var isInstance = true;
  isInstance = isInstance && "userId" in value;
  isInstance = isInstance && "wallet" in value;
  return isInstance;
}
function UserReplicaSetFromJSON(json) {
  return UserReplicaSetFromJSONTyped(json);
}
function UserReplicaSetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'userId': json['user_id'],
    'wallet': json['wallet'],
    'primary': !exists(json, 'primary') ? undefined : json['primary'],
    'secondary1': !exists(json, 'secondary1') ? undefined : json['secondary1'],
    'secondary2': !exists(json, 'secondary2') ? undefined : json['secondary2'],
    'primarySpID': !exists(json, 'primarySpID') ? undefined : json['primarySpID'],
    'secondary1SpID': !exists(json, 'secondary1SpID') ? undefined : json['secondary1SpID'],
    'secondary2SpID': !exists(json, 'secondary2SpID') ? undefined : json['secondary2SpID']
  };
}
function UserReplicaSetToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'user_id': value.userId,
    'wallet': value.wallet,
    'primary': value.primary,
    'secondary1': value.secondary1,
    'secondary2': value.secondary2,
    'primarySpID': value.primarySpID,
    'secondary1SpID': value.secondary1SpID,
    'secondary2SpID': value.secondary2SpID
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UsersByContentNode interface.
 */

function instanceOfUsersByContentNode(value) {
  var isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value;
  isInstance = isInstance && "latestIndexedBlock" in value;
  isInstance = isInstance && "latestChainSlotPlays" in value;
  isInstance = isInstance && "latestIndexedSlotPlays" in value;
  isInstance = isInstance && "signature" in value;
  isInstance = isInstance && "timestamp" in value;
  isInstance = isInstance && "version" in value;
  return isInstance;
}
function UsersByContentNodeFromJSON(json) {
  return UsersByContentNodeFromJSONTyped(json);
}
function UsersByContentNodeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }

  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : UserReplicaSetFromJSON(json['data'])
  };
}
function UsersByContentNodeToJSON(value) {
  if (value === undefined) {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': UserReplicaSetToJSON(value.data)
  };
}

/**
 *
 */

var PlaylistsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(PlaylistsApi, _runtime$BaseAPI);

  var _super = _createSuper(PlaylistsApi);

  function PlaylistsApi() {
    _classCallCheck(this, PlaylistsApi);

    return _super.apply(this, arguments);
  }

  _createClass(PlaylistsApi, [{
    key: "getPlaylistRaw",
    value:
    /** @hidden
     * Get a playlist by ID
     */
    function () {
      var _getPlaylistRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylist.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context.next = 7;
                return this.request({
                  path: "/playlists/{playlist_id}".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullPlaylistResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getPlaylistRaw(_x, _x2) {
        return _getPlaylistRaw.apply(this, arguments);
      }

      return getPlaylistRaw;
    }()
    /**
     * Get a playlist by ID
     */

  }, {
    key: "getPlaylist",
    value: function () {
      var _getPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getPlaylistRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getPlaylist(_x3, _x4) {
        return _getPlaylist.apply(this, arguments);
      }

      return getPlaylist;
    }()
    /** @hidden
     * Get a playlist by handle and slug
     */

  }, {
    key: "getPlaylistByHandleAndSlugRaw",
    value: function () {
      var _getPlaylistByHandleAndSlugRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getPlaylistByHandleAndSlug.');

              case 2:
                if (!(params.slug === null || params.slug === undefined)) {
                  _context3.next = 4;
                  break;
                }

                throw new RequiredError('slug', 'Required parameter params.slug was null or undefined when calling getPlaylistByHandleAndSlug.');

              case 4:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context3.next = 9;
                return this.request({
                  path: "/playlists/by_permalink/{handle}/{slug}".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))).replace("{".concat("slug", "}"), encodeURIComponent(String(params.slug))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullPlaylistResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getPlaylistByHandleAndSlugRaw(_x5, _x6) {
        return _getPlaylistByHandleAndSlugRaw.apply(this, arguments);
      }

      return getPlaylistByHandleAndSlugRaw;
    }()
    /**
     * Get a playlist by handle and slug
     */

  }, {
    key: "getPlaylistByHandleAndSlug",
    value: function () {
      var _getPlaylistByHandleAndSlug = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getPlaylistByHandleAndSlugRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getPlaylistByHandleAndSlug(_x7, _x8) {
        return _getPlaylistByHandleAndSlug.apply(this, arguments);
      }

      return getPlaylistByHandleAndSlug;
    }()
    /** @hidden
     * Fetch tracks within a playlist.
     */

  }, {
    key: "getPlaylistTracksRaw",
    value: function () {
      var _getPlaylistTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context5.next = 2;
                  break;
                }

                throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylistTracks.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context5.next = 6;
                return this.request({
                  path: "/playlists/{playlist_id}/tracks".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullPlaylistTracksResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getPlaylistTracksRaw(_x9, _x10) {
        return _getPlaylistTracksRaw.apply(this, arguments);
      }

      return getPlaylistTracksRaw;
    }()
    /**
     * Fetch tracks within a playlist.
     */

  }, {
    key: "getPlaylistTracks",
    value: function () {
      var _getPlaylistTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getPlaylistTracksRaw(params, initOverrides);

              case 2:
                response = _context6.sent;
                _context6.next = 5;
                return response.value();

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getPlaylistTracks(_x11, _x12) {
        return _getPlaylistTracks.apply(this, arguments);
      }

      return getPlaylistTracks;
    }()
    /** @hidden
     * Returns trending playlists for a time period
     */

  }, {
    key: "getTrendingPlaylistsRaw",
    value: function () {
      var _getTrendingPlaylistsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context7.next = 8;
                return this.request({
                  path: "/playlists/trending",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTrendingPlaylistsResponseFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getTrendingPlaylistsRaw(_x13, _x14) {
        return _getTrendingPlaylistsRaw.apply(this, arguments);
      }

      return getTrendingPlaylistsRaw;
    }()
    /**
     * Returns trending playlists for a time period
     */

  }, {
    key: "getTrendingPlaylists",
    value: function () {
      var _getTrendingPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var params,
            initOverrides,
            response,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                params = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};
                initOverrides = _args8.length > 1 ? _args8[1] : undefined;
                _context8.next = 4;
                return this.getTrendingPlaylistsRaw(params, initOverrides);

              case 4:
                response = _context8.sent;
                _context8.next = 7;
                return response.value();

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getTrendingPlaylists() {
        return _getTrendingPlaylists.apply(this, arguments);
      }

      return getTrendingPlaylists;
    }()
    /** @hidden
     * Returns trending playlists for a time period based on the given trending version
     */

  }, {
    key: "getTrendingPlaylistsWithVersionRaw",
    value: function () {
      var _getTrendingPlaylistsWithVersionRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getTrendingPlaylistsWithVersion.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context9.next = 10;
                return this.request({
                  path: "/playlists/trending/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 10:
                response = _context9.sent;
                return _context9.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTrendingPlaylistsResponseFromJSON(jsonValue);
                }));

              case 12:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getTrendingPlaylistsWithVersionRaw(_x15, _x16) {
        return _getTrendingPlaylistsWithVersionRaw.apply(this, arguments);
      }

      return getTrendingPlaylistsWithVersionRaw;
    }()
    /**
     * Returns trending playlists for a time period based on the given trending version
     */

  }, {
    key: "getTrendingPlaylistsWithVersion",
    value: function () {
      var _getTrendingPlaylistsWithVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getTrendingPlaylistsWithVersionRaw(params, initOverrides);

              case 2:
                response = _context10.sent;
                _context10.next = 5;
                return response.value();

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getTrendingPlaylistsWithVersion(_x17, _x18) {
        return _getTrendingPlaylistsWithVersion.apply(this, arguments);
      }

      return getTrendingPlaylistsWithVersion;
    }()
    /** @hidden
     * Get users that favorited a playlist
     */

  }, {
    key: "getUsersFromPlaylistFavoritesRaw",
    value: function () {
      var _getUsersFromPlaylistFavoritesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context11.next = 2;
                  break;
                }

                throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getUsersFromPlaylistFavorites.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context11.next = 9;
                return this.request({
                  path: "/playlists/{playlist_id}/favorites".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context11.sent;
                return _context11.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FollowingResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getUsersFromPlaylistFavoritesRaw(_x19, _x20) {
        return _getUsersFromPlaylistFavoritesRaw.apply(this, arguments);
      }

      return getUsersFromPlaylistFavoritesRaw;
    }()
    /**
     * Get users that favorited a playlist
     */

  }, {
    key: "getUsersFromPlaylistFavorites",
    value: function () {
      var _getUsersFromPlaylistFavorites = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getUsersFromPlaylistFavoritesRaw(params, initOverrides);

              case 2:
                response = _context12.sent;
                _context12.next = 5;
                return response.value();

              case 5:
                return _context12.abrupt("return", _context12.sent);

              case 6:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getUsersFromPlaylistFavorites(_x21, _x22) {
        return _getUsersFromPlaylistFavorites.apply(this, arguments);
      }

      return getUsersFromPlaylistFavorites;
    }()
    /** @hidden
     * Get users that reposted a playlist
     */

  }, {
    key: "getUsersFromPlaylistRepostsRaw",
    value: function () {
      var _getUsersFromPlaylistRepostsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!(params.playlistId === null || params.playlistId === undefined)) {
                  _context13.next = 2;
                  break;
                }

                throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getUsersFromPlaylistReposts.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context13.next = 9;
                return this.request({
                  path: "/playlists/{playlist_id}/reposts".replace("{".concat("playlist_id", "}"), encodeURIComponent(String(params.playlistId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context13.sent;
                return _context13.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FollowingResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getUsersFromPlaylistRepostsRaw(_x23, _x24) {
        return _getUsersFromPlaylistRepostsRaw.apply(this, arguments);
      }

      return getUsersFromPlaylistRepostsRaw;
    }()
    /**
     * Get users that reposted a playlist
     */

  }, {
    key: "getUsersFromPlaylistReposts",
    value: function () {
      var _getUsersFromPlaylistReposts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getUsersFromPlaylistRepostsRaw(params, initOverrides);

              case 2:
                response = _context14.sent;
                _context14.next = 5;
                return response.value();

              case 5:
                return _context14.abrupt("return", _context14.sent);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getUsersFromPlaylistReposts(_x25, _x26) {
        return _getUsersFromPlaylistReposts.apply(this, arguments);
      }

      return getUsersFromPlaylistReposts;
    }()
  }]);

  return PlaylistsApi;
}(BaseAPI);
/**
 * @export
 */

var GetTrendingPlaylistsTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetTrendingPlaylistsWithVersionTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};

/**
 *
 */

var ReactionsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(ReactionsApi, _runtime$BaseAPI);

  var _super = _createSuper(ReactionsApi);

  function ReactionsApi() {
    _classCallCheck(this, ReactionsApi);

    return _super.apply(this, arguments);
  }

  _createClass(ReactionsApi, [{
    key: "bulkGetReactionsRaw",
    value:
    /** @hidden
     * Gets reactions by reacted_to_id and type
     */
    function () {
      var _bulkGetReactionsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.reactedToIds === null || params.reactedToIds === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('reactedToIds', 'Required parameter params.reactedToIds was null or undefined when calling bulkGetReactions.');

              case 2:
                queryParameters = {};

                if (params.type !== undefined) {
                  queryParameters['type'] = params.type;
                }

                if (params.reactedToIds) {
                  queryParameters['reacted_to_ids'] = params.reactedToIds.join(COLLECTION_FORMATS["csv"]);
                }

                headerParameters = {};
                _context.next = 8;
                return this.request({
                  path: "/reactions",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context.sent;
                return _context.abrupt("return", new VoidApiResponse(response));

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function bulkGetReactionsRaw(_x, _x2) {
        return _bulkGetReactionsRaw.apply(this, arguments);
      }

      return bulkGetReactionsRaw;
    }()
    /**
     * Gets reactions by reacted_to_id and type
     */

  }, {
    key: "bulkGetReactions",
    value: function () {
      var _bulkGetReactions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.bulkGetReactionsRaw(params, initOverrides);

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function bulkGetReactions(_x3, _x4) {
        return _bulkGetReactions.apply(this, arguments);
      }

      return bulkGetReactions;
    }()
  }]);

  return ReactionsApi;
}(BaseAPI);

/**
 *
 */

var SearchApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(SearchApi, _runtime$BaseAPI);

  var _super = _createSuper(SearchApi);

  function SearchApi() {
    _classCallCheck(this, SearchApi);

    return _super.apply(this, arguments);
  }

  _createClass(SearchApi, [{
    key: "searchRaw",
    value:
    /** @hidden
     * Get Users/Tracks/Playlists/Albums that best match the search query
     */
    function () {
      var _searchRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('query', 'Required parameter params.query was null or undefined when calling search.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.kind !== undefined) {
                  queryParameters['kind'] = params.kind;
                }

                headerParameters = {};
                _context.next = 11;
                return this.request({
                  path: "/search/full",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return SearchFullResponseFromJSON(jsonValue);
                }));

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function searchRaw(_x, _x2) {
        return _searchRaw.apply(this, arguments);
      }

      return searchRaw;
    }()
    /**
     * Get Users/Tracks/Playlists/Albums that best match the search query
     */

  }, {
    key: "search",
    value: function () {
      var _search = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.searchRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function search(_x3, _x4) {
        return _search.apply(this, arguments);
      }

      return search;
    }()
    /** @hidden
     * Same as search but optimized for quicker response at the cost of some entity information.
     * Get Users/Tracks/Playlists/Albums that best match the search query
     */

  }, {
    key: "searchAutocompleteRaw",
    value: function () {
      var _searchAutocompleteRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.query === null || params.query === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError('query', 'Required parameter params.query was null or undefined when calling searchAutocomplete.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.kind !== undefined) {
                  queryParameters['kind'] = params.kind;
                }

                headerParameters = {};
                _context3.next = 11;
                return this.request({
                  path: "/search/autocomplete",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return SearchAutocompleteResponseFromJSON(jsonValue);
                }));

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function searchAutocompleteRaw(_x5, _x6) {
        return _searchAutocompleteRaw.apply(this, arguments);
      }

      return searchAutocompleteRaw;
    }()
    /**
     * Same as search but optimized for quicker response at the cost of some entity information.
     * Get Users/Tracks/Playlists/Albums that best match the search query
     */

  }, {
    key: "searchAutocomplete",
    value: function () {
      var _searchAutocomplete = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.searchAutocompleteRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function searchAutocomplete(_x7, _x8) {
        return _searchAutocomplete.apply(this, arguments);
      }

      return searchAutocomplete;
    }()
  }]);

  return SearchApi;
}(BaseAPI);
/**
 * @export
 */

var SearchKindEnum = {
  All: 'all',
  Users: 'users',
  Tracks: 'tracks',
  Playlists: 'playlists',
  Albums: 'albums'
};
/**
 * @export
 */

var SearchAutocompleteKindEnum = {
  All: 'all',
  Users: 'users',
  Tracks: 'tracks',
  Playlists: 'playlists',
  Albums: 'albums'
};

/**
 *
 */

var TipsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TipsApi, _runtime$BaseAPI);

  var _super = _createSuper(TipsApi);

  function TipsApi() {
    _classCallCheck(this, TipsApi);

    return _super.apply(this, arguments);
  }

  _createClass(TipsApi, [{
    key: "getTipsRaw",
    value:
    /** @hidden
     * Gets the most recent tips on the network
     */
    function () {
      var _getTipsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.receiverMinFollowers !== undefined) {
                  queryParameters['receiver_min_followers'] = params.receiverMinFollowers;
                }

                if (params.receiverIsVerified !== undefined) {
                  queryParameters['receiver_is_verified'] = params.receiverIsVerified;
                }

                if (params.currentUserFollows !== undefined) {
                  queryParameters['current_user_follows'] = params.currentUserFollows;
                }

                if (params.uniqueBy !== undefined) {
                  queryParameters['unique_by'] = params.uniqueBy;
                }

                if (params.minSlot !== undefined) {
                  queryParameters['min_slot'] = params.minSlot;
                }

                if (params.maxSlot !== undefined) {
                  queryParameters['max_slot'] = params.maxSlot;
                }

                if (params.txSignatures) {
                  queryParameters['tx_signatures'] = params.txSignatures.join(COLLECTION_FORMATS["csv"]);
                }

                headerParameters = {};
                _context.next = 14;
                return this.request({
                  path: "/tips",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return GetTipsResponseFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getTipsRaw(_x, _x2) {
        return _getTipsRaw.apply(this, arguments);
      }

      return getTipsRaw;
    }()
    /**
     * Gets the most recent tips on the network
     */

  }, {
    key: "getTips",
    value: function () {
      var _getTips = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var params,
            initOverrides,
            response,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                params = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                initOverrides = _args2.length > 1 ? _args2[1] : undefined;
                _context2.next = 4;
                return this.getTipsRaw(params, initOverrides);

              case 4:
                response = _context2.sent;
                _context2.next = 7;
                return response.value();

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getTips() {
        return _getTips.apply(this, arguments);
      }

      return getTips;
    }()
  }]);

  return TipsApi;
}(BaseAPI);
/**
 * @export
 */

var GetTipsCurrentUserFollowsEnum = {
  Sender: 'sender',
  Receiver: 'receiver',
  SenderOrReceiver: 'sender_or_receiver'
};
/**
 * @export
 */

var GetTipsUniqueByEnum = {
  Sender: 'sender',
  Receiver: 'receiver'
};

/**
 *
 */

var TracksApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TracksApi, _runtime$BaseAPI);

  var _super = _createSuper(TracksApi);

  function TracksApi() {
    _classCallCheck(this, TracksApi);

    return _super.apply(this, arguments);
  }

  _createClass(TracksApi, [{
    key: "bestNewReleasesRaw",
    value:
    /** @hidden
     * Gets the tracks found on the \"Best New Releases\" smart playlist
     */
    function () {
      var _bestNewReleasesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                queryParameters = {};
                headerParameters = {};
                _context.next = 4;
                return this.request({
                  path: "/tracks/best_new_releases",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 4:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function bestNewReleasesRaw(_x) {
        return _bestNewReleasesRaw.apply(this, arguments);
      }

      return bestNewReleasesRaw;
    }()
    /**
     * Gets the tracks found on the \"Best New Releases\" smart playlist
     */

  }, {
    key: "bestNewReleases",
    value: function () {
      var _bestNewReleases = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.bestNewReleasesRaw(initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function bestNewReleases(_x2) {
        return _bestNewReleases.apply(this, arguments);
      }

      return bestNewReleases;
    }()
    /** @hidden
     * Gets a list of tracks using their IDs or permalinks
     */

  }, {
    key: "getBulkTracksRaw",
    value: function () {
      var _getBulkTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.permalink) {
                  queryParameters['permalink'] = params.permalink;
                }

                if (params.id) {
                  queryParameters['id'] = params.id;
                }

                headerParameters = {};
                _context3.next = 7;
                return this.request({
                  path: "/tracks",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getBulkTracksRaw(_x3, _x4) {
        return _getBulkTracksRaw.apply(this, arguments);
      }

      return getBulkTracksRaw;
    }()
    /**
     * Gets a list of tracks using their IDs or permalinks
     */

  }, {
    key: "getBulkTracks",
    value: function () {
      var _getBulkTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var params,
            initOverrides,
            response,
            _args4 = arguments;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                params = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
                initOverrides = _args4.length > 1 ? _args4[1] : undefined;
                _context4.next = 4;
                return this.getBulkTracksRaw(params, initOverrides);

              case 4:
                response = _context4.sent;
                _context4.next = 7;
                return response.value();

              case 7:
                return _context4.abrupt("return", _context4.sent);

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getBulkTracks() {
        return _getBulkTracks.apply(this, arguments);
      }

      return getBulkTracks;
    }()
    /** @hidden
     * Gets random tracks found on the \"Feeling Lucky\" smart playlist
     */

  }, {
    key: "getFeelingLuckyTracksRaw",
    value: function () {
      var _getFeelingLuckyTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.withUsers !== undefined) {
                  queryParameters['with_users'] = params.withUsers;
                }

                if (params.minFollowers !== undefined) {
                  queryParameters['min_followers'] = params.minFollowers;
                }

                headerParameters = {};
                _context5.next = 8;
                return this.request({
                  path: "/tracks/feeling_lucky",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getFeelingLuckyTracksRaw(_x5, _x6) {
        return _getFeelingLuckyTracksRaw.apply(this, arguments);
      }

      return getFeelingLuckyTracksRaw;
    }()
    /**
     * Gets random tracks found on the \"Feeling Lucky\" smart playlist
     */

  }, {
    key: "getFeelingLuckyTracks",
    value: function () {
      var _getFeelingLuckyTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var params,
            initOverrides,
            response,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                params = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
                initOverrides = _args6.length > 1 ? _args6[1] : undefined;
                _context6.next = 4;
                return this.getFeelingLuckyTracksRaw(params, initOverrides);

              case 4:
                response = _context6.sent;
                _context6.next = 7;
                return response.value();

              case 7:
                return _context6.abrupt("return", _context6.sent);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getFeelingLuckyTracks() {
        return _getFeelingLuckyTracks.apply(this, arguments);
      }

      return getFeelingLuckyTracks;
    }()
    /** @hidden
     * Gets the tracks found on the \"Most Loved\" smart playlist
     */

  }, {
    key: "getMostLovedTracksRaw",
    value: function () {
      var _getMostLovedTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.withUsers !== undefined) {
                  queryParameters['with_users'] = params.withUsers;
                }

                headerParameters = {};
                _context7.next = 7;
                return this.request({
                  path: "/tracks/most_loved",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getMostLovedTracksRaw(_x7, _x8) {
        return _getMostLovedTracksRaw.apply(this, arguments);
      }

      return getMostLovedTracksRaw;
    }()
    /**
     * Gets the tracks found on the \"Most Loved\" smart playlist
     */

  }, {
    key: "getMostLovedTracks",
    value: function () {
      var _getMostLovedTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var params,
            initOverrides,
            response,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                params = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};
                initOverrides = _args8.length > 1 ? _args8[1] : undefined;
                _context8.next = 4;
                return this.getMostLovedTracksRaw(params, initOverrides);

              case 4:
                response = _context8.sent;
                _context8.next = 7;
                return response.value();

              case 7:
                return _context8.abrupt("return", _context8.sent);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getMostLovedTracks() {
        return _getMostLovedTracks.apply(this, arguments);
      }

      return getMostLovedTracks;
    }()
    /** @hidden
     * Gets premium track signatures for passed in premium track ids
     */

  }, {
    key: "getPremiumTrackSignaturesRaw",
    value: function () {
      var _getPremiumTrackSignaturesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.userId === null || params.userId === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError('userId', 'Required parameter params.userId was null or undefined when calling getPremiumTrackSignatures.');

              case 2:
                queryParameters = {};

                if (params.trackIds) {
                  queryParameters['track_ids'] = params.trackIds;
                }

                if (params.tokenIds) {
                  queryParameters['token_ids'] = params.tokenIds;
                }

                headerParameters = {};
                _context9.next = 8;
                return this.request({
                  path: "/tracks/{user_id}/nft-gated-signatures".replace("{".concat("user_id", "}"), encodeURIComponent(String(params.userId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 8:
                response = _context9.sent;
                return _context9.abrupt("return", new VoidApiResponse(response));

              case 10:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getPremiumTrackSignaturesRaw(_x9, _x10) {
        return _getPremiumTrackSignaturesRaw.apply(this, arguments);
      }

      return getPremiumTrackSignaturesRaw;
    }()
    /**
     * Gets premium track signatures for passed in premium track ids
     */

  }, {
    key: "getPremiumTrackSignatures",
    value: function () {
      var _getPremiumTrackSignatures = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getPremiumTrackSignaturesRaw(params, initOverrides);

              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getPremiumTrackSignatures(_x11, _x12) {
        return _getPremiumTrackSignatures.apply(this, arguments);
      }

      return getPremiumTrackSignatures;
    }()
    /** @hidden
     * Get recommended tracks
     */

  }, {
    key: "getRecommendedTracksRaw",
    value: function () {
      var _getRecommendedTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                queryParameters = {};

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                if (params.exclusionList) {
                  queryParameters['exclusion_list'] = params.exclusionList;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context11.next = 9;
                return this.request({
                  path: "/tracks/recommended",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context11.sent;
                return _context11.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getRecommendedTracksRaw(_x13, _x14) {
        return _getRecommendedTracksRaw.apply(this, arguments);
      }

      return getRecommendedTracksRaw;
    }()
    /**
     * Get recommended tracks
     */

  }, {
    key: "getRecommendedTracks",
    value: function () {
      var _getRecommendedTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var params,
            initOverrides,
            response,
            _args12 = arguments;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                params = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : {};
                initOverrides = _args12.length > 1 ? _args12[1] : undefined;
                _context12.next = 4;
                return this.getRecommendedTracksRaw(params, initOverrides);

              case 4:
                response = _context12.sent;
                _context12.next = 7;
                return response.value();

              case 7:
                return _context12.abrupt("return", _context12.sent);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getRecommendedTracks() {
        return _getRecommendedTracks.apply(this, arguments);
      }

      return getRecommendedTracks;
    }()
    /** @hidden
     * Get recommended tracks using the given trending strategy version
     */

  }, {
    key: "getRecommendedTracksWithVersionRaw",
    value: function () {
      var _getRecommendedTracksWithVersionRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context13.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getRecommendedTracksWithVersion.');

              case 2:
                queryParameters = {};

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                if (params.exclusionList) {
                  queryParameters['exclusion_list'] = params.exclusionList;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context13.next = 11;
                return this.request({
                  path: "/tracks/recommended/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context13.sent;
                return _context13.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 13:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getRecommendedTracksWithVersionRaw(_x15, _x16) {
        return _getRecommendedTracksWithVersionRaw.apply(this, arguments);
      }

      return getRecommendedTracksWithVersionRaw;
    }()
    /**
     * Get recommended tracks using the given trending strategy version
     */

  }, {
    key: "getRecommendedTracksWithVersion",
    value: function () {
      var _getRecommendedTracksWithVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getRecommendedTracksWithVersionRaw(params, initOverrides);

              case 2:
                response = _context14.sent;
                _context14.next = 5;
                return response.value();

              case 5:
                return _context14.abrupt("return", _context14.sent);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getRecommendedTracksWithVersion(_x17, _x18) {
        return _getRecommendedTracksWithVersion.apply(this, arguments);
      }

      return getRecommendedTracksWithVersion;
    }()
    /** @hidden
     * Gets a list of tracks that have stems available for remixing
     */

  }, {
    key: "getRemixableTracksRaw",
    value: function () {
      var _getRemixableTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                queryParameters = {};

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.withUsers !== undefined) {
                  queryParameters['with_users'] = params.withUsers;
                }

                headerParameters = {};
                _context15.next = 7;
                return this.request({
                  path: "/tracks/remixables",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context15.sent;
                return _context15.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTrackResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getRemixableTracksRaw(_x19, _x20) {
        return _getRemixableTracksRaw.apply(this, arguments);
      }

      return getRemixableTracksRaw;
    }()
    /**
     * Gets a list of tracks that have stems available for remixing
     */

  }, {
    key: "getRemixableTracks",
    value: function () {
      var _getRemixableTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
        var params,
            initOverrides,
            response,
            _args16 = arguments;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                params = _args16.length > 0 && _args16[0] !== undefined ? _args16[0] : {};
                initOverrides = _args16.length > 1 ? _args16[1] : undefined;
                _context16.next = 4;
                return this.getRemixableTracksRaw(params, initOverrides);

              case 4:
                response = _context16.sent;
                _context16.next = 7;
                return response.value();

              case 7:
                return _context16.abrupt("return", _context16.sent);

              case 8:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getRemixableTracks() {
        return _getRemixableTracks.apply(this, arguments);
      }

      return getRemixableTracks;
    }()
    /** @hidden
     * Gets a track by ID. If `show_unlisted` is true, then `handle` and `url_title` are required.
     */

  }, {
    key: "getTrackRaw",
    value: function () {
      var _getTrackRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context17.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrack.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.handle !== undefined) {
                  queryParameters['handle'] = params.handle;
                }

                if (params.urlTitle !== undefined) {
                  queryParameters['url_title'] = params.urlTitle;
                }

                if (params.showUnlisted !== undefined) {
                  queryParameters['show_unlisted'] = params.showUnlisted;
                }

                headerParameters = {};
                _context17.next = 10;
                return this.request({
                  path: "/tracks/{track_id}".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 10:
                response = _context17.sent;
                return _context17.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTrackResponseFromJSON(jsonValue);
                }));

              case 12:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getTrackRaw(_x21, _x22) {
        return _getTrackRaw.apply(this, arguments);
      }

      return getTrackRaw;
    }()
    /**
     * Gets a track by ID. If `show_unlisted` is true, then `handle` and `url_title` are required.
     */

  }, {
    key: "getTrack",
    value: function () {
      var _getTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.getTrackRaw(params, initOverrides);

              case 2:
                response = _context18.sent;
                _context18.next = 5;
                return response.value();

              case 5:
                return _context18.abrupt("return", _context18.sent);

              case 6:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getTrack(_x23, _x24) {
        return _getTrack.apply(this, arguments);
      }

      return getTrack;
    }()
    /** @hidden
     * Gets all the tracks that the given track remixes
     */

  }, {
    key: "getTrackRemixParentsRaw",
    value: function () {
      var _getTrackRemixParentsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context19.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackRemixParents.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context19.next = 9;
                return this.request({
                  path: "/tracks/{track_id}/remixing".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context19.sent;
                return _context19.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return RemixingResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getTrackRemixParentsRaw(_x25, _x26) {
        return _getTrackRemixParentsRaw.apply(this, arguments);
      }

      return getTrackRemixParentsRaw;
    }()
    /**
     * Gets all the tracks that the given track remixes
     */

  }, {
    key: "getTrackRemixParents",
    value: function () {
      var _getTrackRemixParents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getTrackRemixParentsRaw(params, initOverrides);

              case 2:
                response = _context20.sent;
                _context20.next = 5;
                return response.value();

              case 5:
                return _context20.abrupt("return", _context20.sent);

              case 6:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getTrackRemixParents(_x27, _x28) {
        return _getTrackRemixParents.apply(this, arguments);
      }

      return getTrackRemixParents;
    }()
    /** @hidden
     * Get all tracks that remix the given track
     */

  }, {
    key: "getTrackRemixesRaw",
    value: function () {
      var _getTrackRemixesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context21.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackRemixes.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context21.next = 9;
                return this.request({
                  path: "/tracks/{track_id}/remixes".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context21.sent;
                return _context21.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return RemixesResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getTrackRemixesRaw(_x29, _x30) {
        return _getTrackRemixesRaw.apply(this, arguments);
      }

      return getTrackRemixesRaw;
    }()
    /**
     * Get all tracks that remix the given track
     */

  }, {
    key: "getTrackRemixes",
    value: function () {
      var _getTrackRemixes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getTrackRemixesRaw(params, initOverrides);

              case 2:
                response = _context22.sent;
                _context22.next = 5;
                return response.value();

              case 5:
                return _context22.abrupt("return", _context22.sent);

              case 6:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getTrackRemixes(_x31, _x32) {
        return _getTrackRemixes.apply(this, arguments);
      }

      return getTrackRemixes;
    }()
    /** @hidden
     * Get the remixable stems of a track
     */

  }, {
    key: "getTrackStemsRaw",
    value: function () {
      var _getTrackStemsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context23.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackStems.');

              case 2:
                queryParameters = {};
                headerParameters = {};
                _context23.next = 6;
                return this.request({
                  path: "/tracks/{track_id}/stems".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 6:
                response = _context23.sent;
                return _context23.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return StemsResponseFromJSON(jsonValue);
                }));

              case 8:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getTrackStemsRaw(_x33, _x34) {
        return _getTrackStemsRaw.apply(this, arguments);
      }

      return getTrackStemsRaw;
    }()
    /**
     * Get the remixable stems of a track
     */

  }, {
    key: "getTrackStems",
    value: function () {
      var _getTrackStems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.getTrackStemsRaw(params, initOverrides);

              case 2:
                response = _context24.sent;
                _context24.next = 5;
                return response.value();

              case 5:
                return _context24.abrupt("return", _context24.sent);

              case 6:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getTrackStems(_x35, _x36) {
        return _getTrackStems.apply(this, arguments);
      }

      return getTrackStems;
    }()
    /** @hidden
     * Gets the track IDs of the top trending tracks on Audius
     */

  }, {
    key: "getTrendingTrackIDsRaw",
    value: function () {
      var _getTrendingTrackIDsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                queryParameters = {};

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                headerParameters = {};
                _context25.next = 5;
                return this.request({
                  path: "/tracks/trending/ids",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 5:
                response = _context25.sent;
                return _context25.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrendingIdsResponseFromJSON(jsonValue);
                }));

              case 7:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getTrendingTrackIDsRaw(_x37, _x38) {
        return _getTrendingTrackIDsRaw.apply(this, arguments);
      }

      return getTrendingTrackIDsRaw;
    }()
    /**
     * Gets the track IDs of the top trending tracks on Audius
     */

  }, {
    key: "getTrendingTrackIDs",
    value: function () {
      var _getTrendingTrackIDs = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26() {
        var params,
            initOverrides,
            response,
            _args26 = arguments;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                params = _args26.length > 0 && _args26[0] !== undefined ? _args26[0] : {};
                initOverrides = _args26.length > 1 ? _args26[1] : undefined;
                _context26.next = 4;
                return this.getTrendingTrackIDsRaw(params, initOverrides);

              case 4:
                response = _context26.sent;
                _context26.next = 7;
                return response.value();

              case 7:
                return _context26.abrupt("return", _context26.sent);

              case 8:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function getTrendingTrackIDs() {
        return _getTrendingTrackIDs.apply(this, arguments);
      }

      return getTrendingTrackIDs;
    }()
    /** @hidden
     * Gets the top 100 trending (most popular) tracks on Audius
     */

  }, {
    key: "getTrendingTracksRaw",
    value: function () {
      var _getTrendingTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context27.next = 9;
                return this.request({
                  path: "/tracks/trending",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context27.sent;
                return _context27.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getTrendingTracksRaw(_x39, _x40) {
        return _getTrendingTracksRaw.apply(this, arguments);
      }

      return getTrendingTracksRaw;
    }()
    /**
     * Gets the top 100 trending (most popular) tracks on Audius
     */

  }, {
    key: "getTrendingTracks",
    value: function () {
      var _getTrendingTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28() {
        var params,
            initOverrides,
            response,
            _args28 = arguments;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                params = _args28.length > 0 && _args28[0] !== undefined ? _args28[0] : {};
                initOverrides = _args28.length > 1 ? _args28[1] : undefined;
                _context28.next = 4;
                return this.getTrendingTracksRaw(params, initOverrides);

              case 4:
                response = _context28.sent;
                _context28.next = 7;
                return response.value();

              case 7:
                return _context28.abrupt("return", _context28.sent);

              case 8:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getTrendingTracks() {
        return _getTrendingTracks.apply(this, arguments);
      }

      return getTrendingTracks;
    }()
    /** @hidden
     * Gets the track IDs of the top trending tracks on Audius based on the given trending strategy version
     */

  }, {
    key: "getTrendingTracksIDsWithVersionRaw",
    value: function () {
      var _getTrendingTracksIDsWithVersionRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context29.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getTrendingTracksIDsWithVersion.');

              case 2:
                queryParameters = {};

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                headerParameters = {};
                _context29.next = 7;
                return this.request({
                  path: "/tracks/trending/ids/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context29.sent;
                return _context29.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrendingIdsResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getTrendingTracksIDsWithVersionRaw(_x41, _x42) {
        return _getTrendingTracksIDsWithVersionRaw.apply(this, arguments);
      }

      return getTrendingTracksIDsWithVersionRaw;
    }()
    /**
     * Gets the track IDs of the top trending tracks on Audius based on the given trending strategy version
     */

  }, {
    key: "getTrendingTracksIDsWithVersion",
    value: function () {
      var _getTrendingTracksIDsWithVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this.getTrendingTracksIDsWithVersionRaw(params, initOverrides);

              case 2:
                response = _context30.sent;
                _context30.next = 5;
                return response.value();

              case 5:
                return _context30.abrupt("return", _context30.sent);

              case 6:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getTrendingTracksIDsWithVersion(_x43, _x44) {
        return _getTrendingTracksIDsWithVersion.apply(this, arguments);
      }

      return getTrendingTracksIDsWithVersion;
    }()
    /** @hidden
     * Gets the top 100 trending (most popular tracks on Audius using a given trending strategy version
     */

  }, {
    key: "getTrendingTracksWithVersionRaw",
    value: function () {
      var _getTrendingTracksWithVersionRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context31.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getTrendingTracksWithVersion.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.genre !== undefined) {
                  queryParameters['genre'] = params.genre;
                }

                if (params.time !== undefined) {
                  queryParameters['time'] = params.time;
                }

                headerParameters = {};
                _context31.next = 11;
                return this.request({
                  path: "/tracks/trending/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context31.sent;
                return _context31.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 13:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getTrendingTracksWithVersionRaw(_x45, _x46) {
        return _getTrendingTracksWithVersionRaw.apply(this, arguments);
      }

      return getTrendingTracksWithVersionRaw;
    }()
    /**
     * Gets the top 100 trending (most popular tracks on Audius using a given trending strategy version
     */

  }, {
    key: "getTrendingTracksWithVersion",
    value: function () {
      var _getTrendingTracksWithVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.getTrendingTracksWithVersionRaw(params, initOverrides);

              case 2:
                response = _context32.sent;
                _context32.next = 5;
                return response.value();

              case 5:
                return _context32.abrupt("return", _context32.sent);

              case 6:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getTrendingTracksWithVersion(_x47, _x48) {
        return _getTrendingTracksWithVersion.apply(this, arguments);
      }

      return getTrendingTracksWithVersion;
    }()
    /** @hidden
     * Gets the tracks found on the \"Under the Radar\" smart playlist
     */

  }, {
    key: "getUnderTheRadarTracksRaw",
    value: function () {
      var _getUnderTheRadarTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.filter !== undefined) {
                  queryParameters['filter'] = params.filter;
                }

                if (params.tracksOnly !== undefined) {
                  queryParameters['tracks_only'] = params.tracksOnly;
                }

                if (params.withUsers !== undefined) {
                  queryParameters['with_users'] = params.withUsers;
                }

                headerParameters = {};
                _context33.next = 10;
                return this.request({
                  path: "/tracks/under_the_radar",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 10:
                response = _context33.sent;
                return _context33.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 12:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getUnderTheRadarTracksRaw(_x49, _x50) {
        return _getUnderTheRadarTracksRaw.apply(this, arguments);
      }

      return getUnderTheRadarTracksRaw;
    }()
    /**
     * Gets the tracks found on the \"Under the Radar\" smart playlist
     */

  }, {
    key: "getUnderTheRadarTracks",
    value: function () {
      var _getUnderTheRadarTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34() {
        var params,
            initOverrides,
            response,
            _args34 = arguments;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                params = _args34.length > 0 && _args34[0] !== undefined ? _args34[0] : {};
                initOverrides = _args34.length > 1 ? _args34[1] : undefined;
                _context34.next = 4;
                return this.getUnderTheRadarTracksRaw(params, initOverrides);

              case 4:
                response = _context34.sent;
                _context34.next = 7;
                return response.value();

              case 7:
                return _context34.abrupt("return", _context34.sent);

              case 8:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function getUnderTheRadarTracks() {
        return _getUnderTheRadarTracks.apply(this, arguments);
      }

      return getUnderTheRadarTracks;
    }()
    /** @hidden
     * Gets the top 100 trending underground tracks on Audius
     */

  }, {
    key: "getUndergroundTrendingTracksRaw",
    value: function () {
      var _getUndergroundTrendingTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context35.next = 7;
                return this.request({
                  path: "/tracks/trending/underground",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context35.sent;
                return _context35.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function getUndergroundTrendingTracksRaw(_x51, _x52) {
        return _getUndergroundTrendingTracksRaw.apply(this, arguments);
      }

      return getUndergroundTrendingTracksRaw;
    }()
    /**
     * Gets the top 100 trending underground tracks on Audius
     */

  }, {
    key: "getUndergroundTrendingTracks",
    value: function () {
      var _getUndergroundTrendingTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36() {
        var params,
            initOverrides,
            response,
            _args36 = arguments;
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                params = _args36.length > 0 && _args36[0] !== undefined ? _args36[0] : {};
                initOverrides = _args36.length > 1 ? _args36[1] : undefined;
                _context36.next = 4;
                return this.getUndergroundTrendingTracksRaw(params, initOverrides);

              case 4:
                response = _context36.sent;
                _context36.next = 7;
                return response.value();

              case 7:
                return _context36.abrupt("return", _context36.sent);

              case 8:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function getUndergroundTrendingTracks() {
        return _getUndergroundTrendingTracks.apply(this, arguments);
      }

      return getUndergroundTrendingTracks;
    }()
    /** @hidden
     * Gets the top 100 trending underground tracks on Audius using a given trending strategy version
     */

  }, {
    key: "getUndergroundTrendingTracksWithVersionRaw",
    value: function () {
      var _getUndergroundTrendingTracksWithVersionRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                if (!(params.version === null || params.version === undefined)) {
                  _context37.next = 2;
                  break;
                }

                throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getUndergroundTrendingTracksWithVersion.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context37.next = 9;
                return this.request({
                  path: "/tracks/trending/underground/{version}".replace("{".concat("version", "}"), encodeURIComponent(String(params.version))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context37.sent;
                return _context37.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function getUndergroundTrendingTracksWithVersionRaw(_x53, _x54) {
        return _getUndergroundTrendingTracksWithVersionRaw.apply(this, arguments);
      }

      return getUndergroundTrendingTracksWithVersionRaw;
    }()
    /**
     * Gets the top 100 trending underground tracks on Audius using a given trending strategy version
     */

  }, {
    key: "getUndergroundTrendingTracksWithVersion",
    value: function () {
      var _getUndergroundTrendingTracksWithVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                _context38.next = 2;
                return this.getUndergroundTrendingTracksWithVersionRaw(params, initOverrides);

              case 2:
                response = _context38.sent;
                _context38.next = 5;
                return response.value();

              case 5:
                return _context38.abrupt("return", _context38.sent);

              case 6:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function getUndergroundTrendingTracksWithVersion(_x55, _x56) {
        return _getUndergroundTrendingTracksWithVersion.apply(this, arguments);
      }

      return getUndergroundTrendingTracksWithVersion;
    }()
    /** @hidden
     * Get users that favorited a track
     */

  }, {
    key: "getUsersFromFavoritesRaw",
    value: function () {
      var _getUsersFromFavoritesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context39.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getUsersFromFavorites.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context39.next = 9;
                return this.request({
                  path: "/tracks/{track_id}/favorites".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context39.sent;
                return _context39.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrackFavoritesResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));

      function getUsersFromFavoritesRaw(_x57, _x58) {
        return _getUsersFromFavoritesRaw.apply(this, arguments);
      }

      return getUsersFromFavoritesRaw;
    }()
    /**
     * Get users that favorited a track
     */

  }, {
    key: "getUsersFromFavorites",
    value: function () {
      var _getUsersFromFavorites = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee40(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                _context40.next = 2;
                return this.getUsersFromFavoritesRaw(params, initOverrides);

              case 2:
                response = _context40.sent;
                _context40.next = 5;
                return response.value();

              case 5:
                return _context40.abrupt("return", _context40.sent);

              case 6:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));

      function getUsersFromFavorites(_x59, _x60) {
        return _getUsersFromFavorites.apply(this, arguments);
      }

      return getUsersFromFavorites;
    }()
    /** @hidden
     * Get the users that reposted a track
     */

  }, {
    key: "getUsersFromRepostsRaw",
    value: function () {
      var _getUsersFromRepostsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee41(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                if (!(params.trackId === null || params.trackId === undefined)) {
                  _context41.next = 2;
                  break;
                }

                throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getUsersFromReposts.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context41.next = 9;
                return this.request({
                  path: "/tracks/{track_id}/reposts".replace("{".concat("track_id", "}"), encodeURIComponent(String(params.trackId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context41.sent;
                return _context41.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrackRepostsResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this);
      }));

      function getUsersFromRepostsRaw(_x61, _x62) {
        return _getUsersFromRepostsRaw.apply(this, arguments);
      }

      return getUsersFromRepostsRaw;
    }()
    /**
     * Get the users that reposted a track
     */

  }, {
    key: "getUsersFromReposts",
    value: function () {
      var _getUsersFromReposts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee42(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                _context42.next = 2;
                return this.getUsersFromRepostsRaw(params, initOverrides);

              case 2:
                response = _context42.sent;
                _context42.next = 5;
                return response.value();

              case 5:
                return _context42.abrupt("return", _context42.sent);

              case 6:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this);
      }));

      function getUsersFromReposts(_x63, _x64) {
        return _getUsersFromReposts.apply(this, arguments);
      }

      return getUsersFromReposts;
    }()
  }]);

  return TracksApi;
}(BaseAPI);
/**
 * @export
 */

var GetRecommendedTracksTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetRecommendedTracksWithVersionTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetTrendingTracksTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetTrendingTracksWithVersionTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */

var GetUnderTheRadarTracksFilterEnum = {
  All: 'all',
  Repost: 'repost',
  Original: 'original'
};

/**
 *
 */

var TransactionsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(TransactionsApi, _runtime$BaseAPI);

  var _super = _createSuper(TransactionsApi);

  function TransactionsApi() {
    _classCallCheck(this, TransactionsApi);

    return _super.apply(this, arguments);
  }

  _createClass(TransactionsApi, [{
    key: "getAudioTransactionHistoryRaw",
    value:
    /** @hidden
     * Gets the user\'s $AUDIO transaction history within the App
     */
    function () {
      var _getAudioTransactionHistoryRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getAudioTransactionHistory.');

              case 2:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getAudioTransactionHistory.');

              case 4:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context.next = 14;
                return this.request({
                  path: "/transactions",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TransactionHistoryResponseFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAudioTransactionHistoryRaw(_x, _x2) {
        return _getAudioTransactionHistoryRaw.apply(this, arguments);
      }

      return getAudioTransactionHistoryRaw;
    }()
    /**
     * Gets the user\'s $AUDIO transaction history within the App
     */

  }, {
    key: "getAudioTransactionHistory",
    value: function () {
      var _getAudioTransactionHistory = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getAudioTransactionHistoryRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getAudioTransactionHistory(_x3, _x4) {
        return _getAudioTransactionHistory.apply(this, arguments);
      }

      return getAudioTransactionHistory;
    }()
    /** @hidden
     * Gets the count of the user\'s $AUDIO transaction history within the App
     */

  }, {
    key: "getAudioTransactionHistoryCountRaw",
    value: function () {
      var _getAudioTransactionHistoryCountRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getAudioTransactionHistoryCount.');

              case 2:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context3.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getAudioTransactionHistoryCount.');

              case 4:
                queryParameters = {};
                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context3.next = 10;
                return this.request({
                  path: "/transactions/count",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 10:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TransactionHistoryCountResponseFromJSON(jsonValue);
                }));

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getAudioTransactionHistoryCountRaw(_x5, _x6) {
        return _getAudioTransactionHistoryCountRaw.apply(this, arguments);
      }

      return getAudioTransactionHistoryCountRaw;
    }()
    /**
     * Gets the count of the user\'s $AUDIO transaction history within the App
     */

  }, {
    key: "getAudioTransactionHistoryCount",
    value: function () {
      var _getAudioTransactionHistoryCount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getAudioTransactionHistoryCountRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAudioTransactionHistoryCount(_x7, _x8) {
        return _getAudioTransactionHistoryCount.apply(this, arguments);
      }

      return getAudioTransactionHistoryCount;
    }()
  }]);

  return TransactionsApi;
}(BaseAPI);
/**
 * @export
 */

var GetAudioTransactionHistorySortMethodEnum = {
  Date: 'date',
  TransactionType: 'transaction_type'
};
/**
 * @export
 */

var GetAudioTransactionHistorySortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};

/**
 *
 */

var UsersApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  _inherits(UsersApi, _runtime$BaseAPI);

  var _super = _createSuper(UsersApi);

  function UsersApi() {
    _classCallCheck(this, UsersApi);

    return _super.apply(this, arguments);
  }

  _createClass(UsersApi, [{
    key: "bulkGetSubscribersRaw",
    value:
    /** @hidden
     * All users that subscribe to the provided users
     */
    function () {
      var _bulkGetSubscribersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(params.ids === null || params.ids === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new RequiredError('ids', 'Required parameter params.ids was null or undefined when calling bulkGetSubscribers.');

              case 2:
                queryParameters = {};

                if (params.ids) {
                  queryParameters['ids'] = params.ids.join(COLLECTION_FORMATS["csv"]);
                }

                headerParameters = {};
                _context.next = 7;
                return this.request({
                  path: "/users/subscribers",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context.sent;
                return _context.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullBulkSubscribersResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function bulkGetSubscribersRaw(_x, _x2) {
        return _bulkGetSubscribersRaw.apply(this, arguments);
      }

      return bulkGetSubscribersRaw;
    }()
    /**
     * All users that subscribe to the provided users
     */

  }, {
    key: "bulkGetSubscribers",
    value: function () {
      var _bulkGetSubscribers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.bulkGetSubscribersRaw(params, initOverrides);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.value();

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function bulkGetSubscribers(_x3, _x4) {
        return _bulkGetSubscribers.apply(this, arguments);
      }

      return bulkGetSubscribers;
    }()
    /** @hidden
     * Get all users that subscribe to the users listed in the JSON request
     */

  }, {
    key: "bulkGetSubscribersViaJSONRequestRaw",
    value: function () {
      var _bulkGetSubscribersViaJSONRequestRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(params.ids === null || params.ids === undefined)) {
                  _context3.next = 2;
                  break;
                }

                throw new RequiredError('ids', 'Required parameter params.ids was null or undefined when calling bulkGetSubscribersViaJSONRequest.');

              case 2:
                queryParameters = {};

                if (params.ids) {
                  queryParameters['ids'] = params.ids.join(COLLECTION_FORMATS["csv"]);
                }

                headerParameters = {};
                _context3.next = 7;
                return this.request({
                  path: "/users/subscribers",
                  method: 'POST',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context3.sent;
                return _context3.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullBulkSubscribersResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function bulkGetSubscribersViaJSONRequestRaw(_x5, _x6) {
        return _bulkGetSubscribersViaJSONRequestRaw.apply(this, arguments);
      }

      return bulkGetSubscribersViaJSONRequestRaw;
    }()
    /**
     * Get all users that subscribe to the users listed in the JSON request
     */

  }, {
    key: "bulkGetSubscribersViaJSONRequest",
    value: function () {
      var _bulkGetSubscribersViaJSONRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.bulkGetSubscribersViaJSONRequestRaw(params, initOverrides);

              case 2:
                response = _context4.sent;
                _context4.next = 5;
                return response.value();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function bulkGetSubscribersViaJSONRequest(_x7, _x8) {
        return _bulkGetSubscribersViaJSONRequest.apply(this, arguments);
      }

      return bulkGetSubscribersViaJSONRequest;
    }()
    /** @hidden
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */

  }, {
    key: "getAIAttributedTracksByUserHandleRaw",
    value: function () {
      var _getAIAttributedTracksByUserHandleRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context5.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getAIAttributedTracksByUserHandle.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context5.next = 14;
                return this.request({
                  path: "/users/handle/{handle}/tracks/ai_attributed".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context5.sent;
                return _context5.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getAIAttributedTracksByUserHandleRaw(_x9, _x10) {
        return _getAIAttributedTracksByUserHandleRaw.apply(this, arguments);
      }

      return getAIAttributedTracksByUserHandleRaw;
    }()
    /**
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */

  }, {
    key: "getAIAttributedTracksByUserHandle",
    value: function () {
      var _getAIAttributedTracksByUserHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getAIAttributedTracksByUserHandleRaw(params, initOverrides);

              case 2:
                response = _context6.sent;
                _context6.next = 5;
                return response.value();

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getAIAttributedTracksByUserHandle(_x11, _x12) {
        return _getAIAttributedTracksByUserHandle.apply(this, arguments);
      }

      return getAIAttributedTracksByUserHandle;
    }()
    /** @hidden
     * Gets a user\'s favorite tracks
     */

  }, {
    key: "getFavoritesRaw",
    value: function () {
      var _getFavoritesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context7.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getFavorites.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};
                _context7.next = 12;
                return this.request({
                  path: "/users/{id}/favorites/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 12:
                response = _context7.sent;
                return _context7.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrackLibraryResponseFullFromJSON(jsonValue);
                }));

              case 14:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getFavoritesRaw(_x13, _x14) {
        return _getFavoritesRaw.apply(this, arguments);
      }

      return getFavoritesRaw;
    }()
    /**
     * Gets a user\'s favorite tracks
     */

  }, {
    key: "getFavorites",
    value: function () {
      var _getFavorites = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getFavoritesRaw(params, initOverrides);

              case 2:
                response = _context8.sent;
                _context8.next = 5;
                return response.value();

              case 5:
                return _context8.abrupt("return", _context8.sent);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getFavorites(_x15, _x16) {
        return _getFavorites.apply(this, arguments);
      }

      return getFavorites;
    }()
    /** @hidden
     * All users that follow the provided user
     */

  }, {
    key: "getFollowersRaw",
    value: function () {
      var _getFollowersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context9.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getFollowers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context9.next = 9;
                return this.request({
                  path: "/users/{id}/followers".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context9.sent;
                return _context9.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullFollowersResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getFollowersRaw(_x17, _x18) {
        return _getFollowersRaw.apply(this, arguments);
      }

      return getFollowersRaw;
    }()
    /**
     * All users that follow the provided user
     */

  }, {
    key: "getFollowers",
    value: function () {
      var _getFollowers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getFollowersRaw(params, initOverrides);

              case 2:
                response = _context10.sent;
                _context10.next = 5;
                return response.value();

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getFollowers(_x19, _x20) {
        return _getFollowers.apply(this, arguments);
      }

      return getFollowers;
    }()
    /** @hidden
     * All users that the provided user follows
     */

  }, {
    key: "getFollowingRaw",
    value: function () {
      var _getFollowingRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context11.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getFollowing.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context11.next = 9;
                return this.request({
                  path: "/users/{id}/following".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context11.sent;
                return _context11.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FollowingResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getFollowingRaw(_x21, _x22) {
        return _getFollowingRaw.apply(this, arguments);
      }

      return getFollowingRaw;
    }()
    /**
     * All users that the provided user follows
     */

  }, {
    key: "getFollowing",
    value: function () {
      var _getFollowing = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getFollowingRaw(params, initOverrides);

              case 2:
                response = _context12.sent;
                _context12.next = 5;
                return response.value();

              case 5:
                return _context12.abrupt("return", _context12.sent);

              case 6:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getFollowing(_x23, _x24) {
        return _getFollowing.apply(this, arguments);
      }

      return getFollowing;
    }()
    /** @hidden
     * Gets the purchases the user has made
     */

  }, {
    key: "getPurchasesRaw",
    value: function () {
      var _getPurchasesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context13.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getPurchases.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};
                _context13.next = 11;
                return this.request({
                  path: "/users/{id}/purchases".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context13.sent;
                return _context13.abrupt("return", new VoidApiResponse(response));

              case 13:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getPurchasesRaw(_x25, _x26) {
        return _getPurchasesRaw.apply(this, arguments);
      }

      return getPurchasesRaw;
    }()
    /**
     * Gets the purchases the user has made
     */

  }, {
    key: "getPurchases",
    value: function () {
      var _getPurchases = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getPurchasesRaw(params, initOverrides);

              case 2:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getPurchases(_x27, _x28) {
        return _getPurchases.apply(this, arguments);
      }

      return getPurchases;
    }()
    /** @hidden
     * Gets a list of users that might be of interest to followers of this user.
     */

  }, {
    key: "getRelatedUsersRaw",
    value: function () {
      var _getRelatedUsersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context15.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getRelatedUsers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context15.next = 9;
                return this.request({
                  path: "/users/{id}/related".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context15.sent;
                return _context15.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return RelatedArtistResponseFullFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getRelatedUsersRaw(_x29, _x30) {
        return _getRelatedUsersRaw.apply(this, arguments);
      }

      return getRelatedUsersRaw;
    }()
    /**
     * Gets a list of users that might be of interest to followers of this user.
     */

  }, {
    key: "getRelatedUsers",
    value: function () {
      var _getRelatedUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.getRelatedUsersRaw(params, initOverrides);

              case 2:
                response = _context16.sent;
                _context16.next = 5;
                return response.value();

              case 5:
                return _context16.abrupt("return", _context16.sent);

              case 6:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getRelatedUsers(_x31, _x32) {
        return _getRelatedUsers.apply(this, arguments);
      }

      return getRelatedUsers;
    }()
    /** @hidden
     * Gets the given user\'s reposts
     */

  }, {
    key: "getRepostsRaw",
    value: function () {
      var _getRepostsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context17.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getReposts.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context17.next = 9;
                return this.request({
                  path: "/users/{id}/reposts".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context17.sent;
                return _context17.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullRepostsFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getRepostsRaw(_x33, _x34) {
        return _getRepostsRaw.apply(this, arguments);
      }

      return getRepostsRaw;
    }()
    /**
     * Gets the given user\'s reposts
     */

  }, {
    key: "getReposts",
    value: function () {
      var _getReposts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.getRepostsRaw(params, initOverrides);

              case 2:
                response = _context18.sent;
                _context18.next = 5;
                return response.value();

              case 5:
                return _context18.abrupt("return", _context18.sent);

              case 6:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getReposts(_x35, _x36) {
        return _getReposts.apply(this, arguments);
      }

      return getReposts;
    }()
    /** @hidden
     * Gets the user\'s reposts by the user handle
     */

  }, {
    key: "getRepostsByHandleRaw",
    value: function () {
      var _getRepostsByHandleRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context19.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getRepostsByHandle.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context19.next = 9;
                return this.request({
                  path: "/users/handle/{handle}/reposts".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context19.sent;
                return _context19.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullRepostsFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getRepostsByHandleRaw(_x37, _x38) {
        return _getRepostsByHandleRaw.apply(this, arguments);
      }

      return getRepostsByHandleRaw;
    }()
    /**
     * Gets the user\'s reposts by the user handle
     */

  }, {
    key: "getRepostsByHandle",
    value: function () {
      var _getRepostsByHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getRepostsByHandleRaw(params, initOverrides);

              case 2:
                response = _context20.sent;
                _context20.next = 5;
                return response.value();

              case 5:
                return _context20.abrupt("return", _context20.sent);

              case 6:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getRepostsByHandle(_x39, _x40) {
        return _getRepostsByHandle.apply(this, arguments);
      }

      return getRepostsByHandle;
    }()
    /** @hidden
     * Gets the sales the user has made
     */

  }, {
    key: "getSalesRaw",
    value: function () {
      var _getSalesRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context21.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSales.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};
                _context21.next = 11;
                return this.request({
                  path: "/users/{id}/sales".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 11:
                response = _context21.sent;
                return _context21.abrupt("return", new VoidApiResponse(response));

              case 13:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getSalesRaw(_x41, _x42) {
        return _getSalesRaw.apply(this, arguments);
      }

      return getSalesRaw;
    }()
    /**
     * Gets the sales the user has made
     */

  }, {
    key: "getSales",
    value: function () {
      var _getSales = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(params, initOverrides) {
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getSalesRaw(params, initOverrides);

              case 2:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getSales(_x43, _x44) {
        return _getSales.apply(this, arguments);
      }

      return getSales;
    }()
    /** @hidden
     * All users that subscribe to the provided user
     */

  }, {
    key: "getSubscribersRaw",
    value: function () {
      var _getSubscribersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context23.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSubscribers.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context23.next = 9;
                return this.request({
                  path: "/users/{id}/subscribers".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context23.sent;
                return _context23.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullSubscribersResponseFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getSubscribersRaw(_x45, _x46) {
        return _getSubscribersRaw.apply(this, arguments);
      }

      return getSubscribersRaw;
    }()
    /**
     * All users that subscribe to the provided user
     */

  }, {
    key: "getSubscribers",
    value: function () {
      var _getSubscribers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.getSubscribersRaw(params, initOverrides);

              case 2:
                response = _context24.sent;
                _context24.next = 5;
                return response.value();

              case 5:
                return _context24.abrupt("return", _context24.sent);

              case 6:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getSubscribers(_x47, _x48) {
        return _getSubscribers.apply(this, arguments);
      }

      return getSubscribers;
    }()
    /** @hidden
     * Gets the specified supporter of the given user
     */

  }, {
    key: "getSupporterRaw",
    value: function () {
      var _getSupporterRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context25.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupporter.');

              case 2:
                if (!(params.supporterUserId === null || params.supporterUserId === undefined)) {
                  _context25.next = 4;
                  break;
                }

                throw new RequiredError('supporterUserId', 'Required parameter params.supporterUserId was null or undefined when calling getSupporter.');

              case 4:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context25.next = 9;
                return this.request({
                  path: "/users/{id}/supporters/{supporter_user_id}".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))).replace("{".concat("supporter_user_id", "}"), encodeURIComponent(String(params.supporterUserId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context25.sent;
                return _context25.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullGetSupporterFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getSupporterRaw(_x49, _x50) {
        return _getSupporterRaw.apply(this, arguments);
      }

      return getSupporterRaw;
    }()
    /**
     * Gets the specified supporter of the given user
     */

  }, {
    key: "getSupporter",
    value: function () {
      var _getSupporter = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.getSupporterRaw(params, initOverrides);

              case 2:
                response = _context26.sent;
                _context26.next = 5;
                return response.value();

              case 5:
                return _context26.abrupt("return", _context26.sent);

              case 6:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function getSupporter(_x51, _x52) {
        return _getSupporter.apply(this, arguments);
      }

      return getSupporter;
    }()
    /** @hidden
     * Gets the supporters of the given user
     */

  }, {
    key: "getSupportersRaw",
    value: function () {
      var _getSupportersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context27.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupporters.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context27.next = 9;
                return this.request({
                  path: "/users/{id}/supporters".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context27.sent;
                return _context27.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullGetSupportersFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getSupportersRaw(_x53, _x54) {
        return _getSupportersRaw.apply(this, arguments);
      }

      return getSupportersRaw;
    }()
    /**
     * Gets the supporters of the given user
     */

  }, {
    key: "getSupporters",
    value: function () {
      var _getSupporters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.getSupportersRaw(params, initOverrides);

              case 2:
                response = _context28.sent;
                _context28.next = 5;
                return response.value();

              case 5:
                return _context28.abrupt("return", _context28.sent);

              case 6:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getSupporters(_x55, _x56) {
        return _getSupporters.apply(this, arguments);
      }

      return getSupporters;
    }()
    /** @hidden
     * Gets the support from the given user to the supported user
     */

  }, {
    key: "getSupportingRaw",
    value: function () {
      var _getSupportingRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context29.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupporting.');

              case 2:
                if (!(params.supportedUserId === null || params.supportedUserId === undefined)) {
                  _context29.next = 4;
                  break;
                }

                throw new RequiredError('supportedUserId', 'Required parameter params.supportedUserId was null or undefined when calling getSupporting.');

              case 4:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context29.next = 9;
                return this.request({
                  path: "/users/{id}/supporting/{supported_user_id}".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))).replace("{".concat("supported_user_id", "}"), encodeURIComponent(String(params.supportedUserId))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context29.sent;
                return _context29.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullGetSupportingFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getSupportingRaw(_x57, _x58) {
        return _getSupportingRaw.apply(this, arguments);
      }

      return getSupportingRaw;
    }()
    /**
     * Gets the support from the given user to the supported user
     */

  }, {
    key: "getSupporting",
    value: function () {
      var _getSupporting = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this.getSupportingRaw(params, initOverrides);

              case 2:
                response = _context30.sent;
                _context30.next = 5;
                return response.value();

              case 5:
                return _context30.abrupt("return", _context30.sent);

              case 6:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getSupporting(_x59, _x60) {
        return _getSupporting.apply(this, arguments);
      }

      return getSupporting;
    }()
    /** @hidden
     * Gets the users that the given user supports
     */

  }, {
    key: "getSupportingsRaw",
    value: function () {
      var _getSupportingsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context31.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupportings.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context31.next = 9;
                return this.request({
                  path: "/users/{id}/supporting".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 9:
                response = _context31.sent;
                return _context31.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullGetSupportingFromJSON(jsonValue);
                }));

              case 11:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getSupportingsRaw(_x61, _x62) {
        return _getSupportingsRaw.apply(this, arguments);
      }

      return getSupportingsRaw;
    }()
    /**
     * Gets the users that the given user supports
     */

  }, {
    key: "getSupportings",
    value: function () {
      var _getSupportings = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.getSupportingsRaw(params, initOverrides);

              case 2:
                response = _context32.sent;
                _context32.next = 5;
                return response.value();

              case 5:
                return _context32.abrupt("return", _context32.sent);

              case 6:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getSupportings(_x63, _x64) {
        return _getSupportings.apply(this, arguments);
      }

      return getSupportings;
    }()
    /** @hidden
     * Get the Top Users having at least one track by follower count
     */

  }, {
    key: "getTopUsersRaw",
    value: function () {
      var _getTopUsersRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context33.next = 7;
                return this.request({
                  path: "/users/top",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context33.sent;
                return _context33.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TopUsersResponseFullFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getTopUsersRaw(_x65, _x66) {
        return _getTopUsersRaw.apply(this, arguments);
      }

      return getTopUsersRaw;
    }()
    /**
     * Get the Top Users having at least one track by follower count
     */

  }, {
    key: "getTopUsers",
    value: function () {
      var _getTopUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34() {
        var params,
            initOverrides,
            response,
            _args34 = arguments;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                params = _args34.length > 0 && _args34[0] !== undefined ? _args34[0] : {};
                initOverrides = _args34.length > 1 ? _args34[1] : undefined;
                _context34.next = 4;
                return this.getTopUsersRaw(params, initOverrides);

              case 4:
                response = _context34.sent;
                _context34.next = 7;
                return response.value();

              case 7:
                return _context34.abrupt("return", _context34.sent);

              case 8:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function getTopUsers() {
        return _getTopUsers.apply(this, arguments);
      }

      return getTopUsers;
    }()
    /** @hidden
     * Get the Top Users for a Given Genre
     */

  }, {
    key: "getTopUsersInGenreRaw",
    value: function () {
      var _getTopUsersInGenreRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.genre) {
                  queryParameters['genre'] = params.genre;
                }

                headerParameters = {};
                _context35.next = 7;
                return this.request({
                  path: "/users/genre/top",
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context35.sent;
                return _context35.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TopGenreUsersResponseFullFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function getTopUsersInGenreRaw(_x67, _x68) {
        return _getTopUsersInGenreRaw.apply(this, arguments);
      }

      return getTopUsersInGenreRaw;
    }()
    /**
     * Get the Top Users for a Given Genre
     */

  }, {
    key: "getTopUsersInGenre",
    value: function () {
      var _getTopUsersInGenre = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36() {
        var params,
            initOverrides,
            response,
            _args36 = arguments;
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                params = _args36.length > 0 && _args36[0] !== undefined ? _args36[0] : {};
                initOverrides = _args36.length > 1 ? _args36[1] : undefined;
                _context36.next = 4;
                return this.getTopUsersInGenreRaw(params, initOverrides);

              case 4:
                response = _context36.sent;
                _context36.next = 7;
                return response.value();

              case 7:
                return _context36.abrupt("return", _context36.sent);

              case 8:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function getTopUsersInGenre() {
        return _getTopUsersInGenre.apply(this, arguments);
      }

      return getTopUsersInGenre;
    }()
    /** @hidden
     * Gets the tracks created by a user using their user ID
     */

  }, {
    key: "getTracksByUserRaw",
    value: function () {
      var _getTracksByUserRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context37.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getTracksByUser.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context37.next = 14;
                return this.request({
                  path: "/users/{id}/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context37.sent;
                return _context37.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function getTracksByUserRaw(_x69, _x70) {
        return _getTracksByUserRaw.apply(this, arguments);
      }

      return getTracksByUserRaw;
    }()
    /**
     * Gets the tracks created by a user using their user ID
     */

  }, {
    key: "getTracksByUser",
    value: function () {
      var _getTracksByUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                _context38.next = 2;
                return this.getTracksByUserRaw(params, initOverrides);

              case 2:
                response = _context38.sent;
                _context38.next = 5;
                return response.value();

              case 5:
                return _context38.abrupt("return", _context38.sent);

              case 6:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function getTracksByUser(_x71, _x72) {
        return _getTracksByUser.apply(this, arguments);
      }

      return getTracksByUser;
    }()
    /** @hidden
     * Gets the tracks created by a user using the user\'s handle
     */

  }, {
    key: "getTracksByUserHandleRaw",
    value: function () {
      var _getTracksByUserHandleRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context39.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getTracksByUserHandle.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.sort !== undefined) {
                  queryParameters['sort'] = params.sort;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.filterTracks !== undefined) {
                  queryParameters['filter_tracks'] = params.filterTracks;
                }

                headerParameters = {};
                _context39.next = 14;
                return this.request({
                  path: "/users/handle/{handle}/tracks".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 14:
                response = _context39.sent;
                return _context39.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullTracksFromJSON(jsonValue);
                }));

              case 16:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));

      function getTracksByUserHandleRaw(_x73, _x74) {
        return _getTracksByUserHandleRaw.apply(this, arguments);
      }

      return getTracksByUserHandleRaw;
    }()
    /**
     * Gets the tracks created by a user using the user\'s handle
     */

  }, {
    key: "getTracksByUserHandle",
    value: function () {
      var _getTracksByUserHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee40(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                _context40.next = 2;
                return this.getTracksByUserHandleRaw(params, initOverrides);

              case 2:
                response = _context40.sent;
                _context40.next = 5;
                return response.value();

              case 5:
                return _context40.abrupt("return", _context40.sent);

              case 6:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));

      function getTracksByUserHandle(_x75, _x76) {
        return _getTracksByUserHandle.apply(this, arguments);
      }

      return getTracksByUserHandle;
    }()
    /** @hidden
     * Gets a single user by their user ID
     */

  }, {
    key: "getUserRaw",
    value: function () {
      var _getUserRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee41(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context41.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUser.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context41.next = 7;
                return this.request({
                  path: "/users/{id}".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context41.sent;
                return _context41.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullUserResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this);
      }));

      function getUserRaw(_x77, _x78) {
        return _getUserRaw.apply(this, arguments);
      }

      return getUserRaw;
    }()
    /**
     * Gets a single user by their user ID
     */

  }, {
    key: "getUser",
    value: function () {
      var _getUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee42(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                _context42.next = 2;
                return this.getUserRaw(params, initOverrides);

              case 2:
                response = _context42.sent;
                _context42.next = 5;
                return response.value();

              case 5:
                return _context42.abrupt("return", _context42.sent);

              case 6:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this);
      }));

      function getUser(_x79, _x80) {
        return _getUser.apply(this, arguments);
      }

      return getUser;
    }()
    /** @hidden
     * Gets a single user by their handle
     */

  }, {
    key: "getUserByHandleRaw",
    value: function () {
      var _getUserByHandleRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee43(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee43$(_context43) {
          while (1) {
            switch (_context43.prev = _context43.next) {
              case 0:
                if (!(params.handle === null || params.handle === undefined)) {
                  _context43.next = 2;
                  break;
                }

                throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getUserByHandle.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context43.next = 7;
                return this.request({
                  path: "/users/handle/{handle}".replace("{".concat("handle", "}"), encodeURIComponent(String(params.handle))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context43.sent;
                return _context43.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return FullUserResponseFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context43.stop();
            }
          }
        }, _callee43, this);
      }));

      function getUserByHandleRaw(_x81, _x82) {
        return _getUserByHandleRaw.apply(this, arguments);
      }

      return getUserByHandleRaw;
    }()
    /**
     * Gets a single user by their handle
     */

  }, {
    key: "getUserByHandle",
    value: function () {
      var _getUserByHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee44(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee44$(_context44) {
          while (1) {
            switch (_context44.prev = _context44.next) {
              case 0:
                _context44.next = 2;
                return this.getUserByHandleRaw(params, initOverrides);

              case 2:
                response = _context44.sent;
                _context44.next = 5;
                return response.value();

              case 5:
                return _context44.abrupt("return", _context44.sent);

              case 6:
              case "end":
                return _context44.stop();
            }
          }
        }, _callee44, this);
      }));

      function getUserByHandle(_x83, _x84) {
        return _getUserByHandle.apply(this, arguments);
      }

      return getUserByHandle;
    }()
    /** @hidden
     * Gets a user\'s saved/reposted/purchased/all albums
     * Fetch a user\'s full library playlists
     */

  }, {
    key: "getUserLibraryAlbumsRaw",
    value: function () {
      var _getUserLibraryAlbumsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee45(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee45$(_context45) {
          while (1) {
            switch (_context45.prev = _context45.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context45.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserLibraryAlbums.');

              case 2:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context45.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getUserLibraryAlbums.');

              case 4:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context45.next = 6;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getUserLibraryAlbums.');

              case 6:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.type !== undefined) {
                  queryParameters['type'] = params.type;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context45.next = 19;
                return this.request({
                  path: "/users/{id}/library/albums".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 19:
                response = _context45.sent;
                return _context45.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return CollectionLibraryResponseFullFromJSON(jsonValue);
                }));

              case 21:
              case "end":
                return _context45.stop();
            }
          }
        }, _callee45, this);
      }));

      function getUserLibraryAlbumsRaw(_x85, _x86) {
        return _getUserLibraryAlbumsRaw.apply(this, arguments);
      }

      return getUserLibraryAlbumsRaw;
    }()
    /**
     * Gets a user\'s saved/reposted/purchased/all albums
     * Fetch a user\'s full library playlists
     */

  }, {
    key: "getUserLibraryAlbums",
    value: function () {
      var _getUserLibraryAlbums = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee46(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee46$(_context46) {
          while (1) {
            switch (_context46.prev = _context46.next) {
              case 0:
                _context46.next = 2;
                return this.getUserLibraryAlbumsRaw(params, initOverrides);

              case 2:
                response = _context46.sent;
                _context46.next = 5;
                return response.value();

              case 5:
                return _context46.abrupt("return", _context46.sent);

              case 6:
              case "end":
                return _context46.stop();
            }
          }
        }, _callee46, this);
      }));

      function getUserLibraryAlbums(_x87, _x88) {
        return _getUserLibraryAlbums.apply(this, arguments);
      }

      return getUserLibraryAlbums;
    }()
    /** @hidden
     * Gets a user\'s saved/reposted/purchased/all playlists
     * Fetch a user\'s full library playlists
     */

  }, {
    key: "getUserLibraryPlaylistsRaw",
    value: function () {
      var _getUserLibraryPlaylistsRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee47(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee47$(_context47) {
          while (1) {
            switch (_context47.prev = _context47.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context47.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserLibraryPlaylists.');

              case 2:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context47.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getUserLibraryPlaylists.');

              case 4:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context47.next = 6;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getUserLibraryPlaylists.');

              case 6:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.type !== undefined) {
                  queryParameters['type'] = params.type;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context47.next = 19;
                return this.request({
                  path: "/users/{id}/library/playlists".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 19:
                response = _context47.sent;
                return _context47.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return CollectionLibraryResponseFullFromJSON(jsonValue);
                }));

              case 21:
              case "end":
                return _context47.stop();
            }
          }
        }, _callee47, this);
      }));

      function getUserLibraryPlaylistsRaw(_x89, _x90) {
        return _getUserLibraryPlaylistsRaw.apply(this, arguments);
      }

      return getUserLibraryPlaylistsRaw;
    }()
    /**
     * Gets a user\'s saved/reposted/purchased/all playlists
     * Fetch a user\'s full library playlists
     */

  }, {
    key: "getUserLibraryPlaylists",
    value: function () {
      var _getUserLibraryPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee48(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee48$(_context48) {
          while (1) {
            switch (_context48.prev = _context48.next) {
              case 0:
                _context48.next = 2;
                return this.getUserLibraryPlaylistsRaw(params, initOverrides);

              case 2:
                response = _context48.sent;
                _context48.next = 5;
                return response.value();

              case 5:
                return _context48.abrupt("return", _context48.sent);

              case 6:
              case "end":
                return _context48.stop();
            }
          }
        }, _callee48, this);
      }));

      function getUserLibraryPlaylists(_x91, _x92) {
        return _getUserLibraryPlaylists.apply(this, arguments);
      }

      return getUserLibraryPlaylists;
    }()
    /** @hidden
     * Gets a user\'s saved/reposted/purchased/all tracks
     * Fetch a user\'s full library tracks
     */

  }, {
    key: "getUserLibraryTracksRaw",
    value: function () {
      var _getUserLibraryTracksRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee49(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee49$(_context49) {
          while (1) {
            switch (_context49.prev = _context49.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context49.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserLibraryTracks.');

              case 2:
                if (!(params.encodedDataMessage === null || params.encodedDataMessage === undefined)) {
                  _context49.next = 4;
                  break;
                }

                throw new RequiredError('encodedDataMessage', 'Required parameter params.encodedDataMessage was null or undefined when calling getUserLibraryTracks.');

              case 4:
                if (!(params.encodedDataSignature === null || params.encodedDataSignature === undefined)) {
                  _context49.next = 6;
                  break;
                }

                throw new RequiredError('encodedDataSignature', 'Required parameter params.encodedDataSignature was null or undefined when calling getUserLibraryTracks.');

              case 6:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                if (params.type !== undefined) {
                  queryParameters['type'] = params.type;
                }

                headerParameters = {};

                if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
                  headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
                }

                if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
                  headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
                }

                _context49.next = 19;
                return this.request({
                  path: "/users/{id}/library/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 19:
                response = _context49.sent;
                return _context49.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return TrackLibraryResponseFullFromJSON(jsonValue);
                }));

              case 21:
              case "end":
                return _context49.stop();
            }
          }
        }, _callee49, this);
      }));

      function getUserLibraryTracksRaw(_x93, _x94) {
        return _getUserLibraryTracksRaw.apply(this, arguments);
      }

      return getUserLibraryTracksRaw;
    }()
    /**
     * Gets a user\'s saved/reposted/purchased/all tracks
     * Fetch a user\'s full library tracks
     */

  }, {
    key: "getUserLibraryTracks",
    value: function () {
      var _getUserLibraryTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee50(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee50$(_context50) {
          while (1) {
            switch (_context50.prev = _context50.next) {
              case 0:
                _context50.next = 2;
                return this.getUserLibraryTracksRaw(params, initOverrides);

              case 2:
                response = _context50.sent;
                _context50.next = 5;
                return response.value();

              case 5:
                return _context50.abrupt("return", _context50.sent);

              case 6:
              case "end":
                return _context50.stop();
            }
          }
        }, _callee50, this);
      }));

      function getUserLibraryTracks(_x95, _x96) {
        return _getUserLibraryTracks.apply(this, arguments);
      }

      return getUserLibraryTracks;
    }()
    /** @hidden
     * Gets the user\'s replica set
     */

  }, {
    key: "getUserReplicaSetRaw",
    value: function () {
      var _getUserReplicaSetRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee51(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee51$(_context51) {
          while (1) {
            switch (_context51.prev = _context51.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context51.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserReplicaSet.');

              case 2:
                queryParameters = {};

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                headerParameters = {};
                _context51.next = 7;
                return this.request({
                  path: "/users/{id}/replica_set".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 7:
                response = _context51.sent;
                return _context51.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return UsersByContentNodeFromJSON(jsonValue);
                }));

              case 9:
              case "end":
                return _context51.stop();
            }
          }
        }, _callee51, this);
      }));

      function getUserReplicaSetRaw(_x97, _x98) {
        return _getUserReplicaSetRaw.apply(this, arguments);
      }

      return getUserReplicaSetRaw;
    }()
    /**
     * Gets the user\'s replica set
     */

  }, {
    key: "getUserReplicaSet",
    value: function () {
      var _getUserReplicaSet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee52(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee52$(_context52) {
          while (1) {
            switch (_context52.prev = _context52.next) {
              case 0:
                _context52.next = 2;
                return this.getUserReplicaSetRaw(params, initOverrides);

              case 2:
                response = _context52.sent;
                _context52.next = 5;
                return response.value();

              case 5:
                return _context52.abrupt("return", _context52.sent);

              case 6:
              case "end":
                return _context52.stop();
            }
          }
        }, _callee52, this);
      }));

      function getUserReplicaSet(_x99, _x100) {
        return _getUserReplicaSet.apply(this, arguments);
      }

      return getUserReplicaSet;
    }()
    /** @hidden
     * Get the tracks the user recently listened to.
     */

  }, {
    key: "getUsersTrackHistoryRaw",
    value: function () {
      var _getUsersTrackHistoryRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee53(params, initOverrides) {
        var queryParameters, headerParameters, response;
        return regeneratorRuntime.wrap(function _callee53$(_context53) {
          while (1) {
            switch (_context53.prev = _context53.next) {
              case 0:
                if (!(params.id === null || params.id === undefined)) {
                  _context53.next = 2;
                  break;
                }

                throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUsersTrackHistory.');

              case 2:
                queryParameters = {};

                if (params.offset !== undefined) {
                  queryParameters['offset'] = params.offset;
                }

                if (params.limit !== undefined) {
                  queryParameters['limit'] = params.limit;
                }

                if (params.userId !== undefined) {
                  queryParameters['user_id'] = params.userId;
                }

                if (params.query !== undefined) {
                  queryParameters['query'] = params.query;
                }

                if (params.sortMethod !== undefined) {
                  queryParameters['sort_method'] = params.sortMethod;
                }

                if (params.sortDirection !== undefined) {
                  queryParameters['sort_direction'] = params.sortDirection;
                }

                headerParameters = {};
                _context53.next = 12;
                return this.request({
                  path: "/users/{id}/history/tracks".replace("{".concat("id", "}"), encodeURIComponent(String(params.id))),
                  method: 'GET',
                  headers: headerParameters,
                  query: queryParameters
                }, initOverrides);

              case 12:
                response = _context53.sent;
                return _context53.abrupt("return", new JSONApiResponse(response, function (jsonValue) {
                  return HistoryResponseFullFromJSON(jsonValue);
                }));

              case 14:
              case "end":
                return _context53.stop();
            }
          }
        }, _callee53, this);
      }));

      function getUsersTrackHistoryRaw(_x101, _x102) {
        return _getUsersTrackHistoryRaw.apply(this, arguments);
      }

      return getUsersTrackHistoryRaw;
    }()
    /**
     * Get the tracks the user recently listened to.
     */

  }, {
    key: "getUsersTrackHistory",
    value: function () {
      var _getUsersTrackHistory = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee54(params, initOverrides) {
        var response;
        return regeneratorRuntime.wrap(function _callee54$(_context54) {
          while (1) {
            switch (_context54.prev = _context54.next) {
              case 0:
                _context54.next = 2;
                return this.getUsersTrackHistoryRaw(params, initOverrides);

              case 2:
                response = _context54.sent;
                _context54.next = 5;
                return response.value();

              case 5:
                return _context54.abrupt("return", _context54.sent);

              case 6:
              case "end":
                return _context54.stop();
            }
          }
        }, _callee54, this);
      }));

      function getUsersTrackHistory(_x103, _x104) {
        return _getUsersTrackHistory.apply(this, arguments);
      }

      return getUsersTrackHistory;
    }()
  }]);

  return UsersApi;
}(BaseAPI);
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortEnum = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetAIAttributedTracksByUserHandleFilterTracksEnum = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */

var GetFavoritesSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetFavoritesSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetPurchasesSortMethodEnum = {
  ContentTitle: 'content_title',
  ArtistName: 'artist_name',
  Date: 'date'
};
/**
 * @export
 */

var GetPurchasesSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetSalesSortMethodEnum = {
  ContentTitle: 'content_title',
  ArtistName: 'artist_name',
  Date: 'date'
};
/**
 * @export
 */

var GetSalesSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetTracksByUserSortEnum = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetTracksByUserSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetTracksByUserSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetTracksByUserFilterTracksEnum = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */

var GetTracksByUserHandleSortEnum = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */

var GetTracksByUserHandleSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetTracksByUserHandleSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetTracksByUserHandleFilterTracksEnum = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */

var GetUserLibraryAlbumsSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetUserLibraryAlbumsTypeEnum = {
  All: 'all',
  Repost: 'repost',
  Favorite: 'favorite',
  Purchase: 'purchase'
};
/**
 * @export
 */

var GetUserLibraryAlbumsSortMethodEnum = {
  AddedDate: 'added_date',
  Reposts: 'reposts',
  Saves: 'saves'
};
/**
 * @export
 */

var GetUserLibraryPlaylistsSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetUserLibraryPlaylistsTypeEnum = {
  All: 'all',
  Repost: 'repost',
  Favorite: 'favorite',
  Purchase: 'purchase'
};
/**
 * @export
 */

var GetUserLibraryPlaylistsSortMethodEnum = {
  AddedDate: 'added_date',
  Reposts: 'reposts',
  Saves: 'saves'
};
/**
 * @export
 */

var GetUserLibraryTracksSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetUserLibraryTracksSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */

var GetUserLibraryTracksTypeEnum = {
  All: 'all',
  Repost: 'repost',
  Favorite: 'favorite',
  Purchase: 'purchase'
};
/**
 * @export
 */

var GetUsersTrackHistorySortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */

var GetUsersTrackHistorySortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};

/* tslint:disable */

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BASE_PATH: BASE_PATH,
  Configuration: Configuration,
  DefaultConfig: DefaultConfig,
  BaseAPI: BaseAPI,
  ResponseError: ResponseError,
  FetchError: FetchError,
  RequiredError: RequiredError,
  COLLECTION_FORMATS: COLLECTION_FORMATS,
  exists: exists,
  querystring: querystring,
  mapValues: mapValues,
  canConsumeForm: canConsumeForm,
  JSONApiResponse: JSONApiResponse,
  VoidApiResponse: VoidApiResponse,
  BlobApiResponse: BlobApiResponse,
  TextApiResponse: TextApiResponse,
  PlaylistsApi: PlaylistsApi,
  GetTrendingPlaylistsTimeEnum: GetTrendingPlaylistsTimeEnum,
  GetTrendingPlaylistsWithVersionTimeEnum: GetTrendingPlaylistsWithVersionTimeEnum,
  ReactionsApi: ReactionsApi,
  SearchApi: SearchApi,
  SearchKindEnum: SearchKindEnum,
  SearchAutocompleteKindEnum: SearchAutocompleteKindEnum,
  TipsApi: TipsApi,
  GetTipsCurrentUserFollowsEnum: GetTipsCurrentUserFollowsEnum,
  GetTipsUniqueByEnum: GetTipsUniqueByEnum,
  TracksApi: TracksApi,
  GetRecommendedTracksTimeEnum: GetRecommendedTracksTimeEnum,
  GetRecommendedTracksWithVersionTimeEnum: GetRecommendedTracksWithVersionTimeEnum,
  GetTrendingTracksTimeEnum: GetTrendingTracksTimeEnum,
  GetTrendingTracksWithVersionTimeEnum: GetTrendingTracksWithVersionTimeEnum,
  GetUnderTheRadarTracksFilterEnum: GetUnderTheRadarTracksFilterEnum,
  TransactionsApi: TransactionsApi,
  GetAudioTransactionHistorySortMethodEnum: GetAudioTransactionHistorySortMethodEnum,
  GetAudioTransactionHistorySortDirectionEnum: GetAudioTransactionHistorySortDirectionEnum,
  UsersApi: UsersApi,
  GetAIAttributedTracksByUserHandleSortEnum: GetAIAttributedTracksByUserHandleSortEnum,
  GetAIAttributedTracksByUserHandleSortMethodEnum: GetAIAttributedTracksByUserHandleSortMethodEnum,
  GetAIAttributedTracksByUserHandleSortDirectionEnum: GetAIAttributedTracksByUserHandleSortDirectionEnum,
  GetAIAttributedTracksByUserHandleFilterTracksEnum: GetAIAttributedTracksByUserHandleFilterTracksEnum,
  GetFavoritesSortMethodEnum: GetFavoritesSortMethodEnum,
  GetFavoritesSortDirectionEnum: GetFavoritesSortDirectionEnum,
  GetPurchasesSortMethodEnum: GetPurchasesSortMethodEnum,
  GetPurchasesSortDirectionEnum: GetPurchasesSortDirectionEnum,
  GetSalesSortMethodEnum: GetSalesSortMethodEnum,
  GetSalesSortDirectionEnum: GetSalesSortDirectionEnum,
  GetTracksByUserSortEnum: GetTracksByUserSortEnum,
  GetTracksByUserSortMethodEnum: GetTracksByUserSortMethodEnum,
  GetTracksByUserSortDirectionEnum: GetTracksByUserSortDirectionEnum,
  GetTracksByUserFilterTracksEnum: GetTracksByUserFilterTracksEnum,
  GetTracksByUserHandleSortEnum: GetTracksByUserHandleSortEnum,
  GetTracksByUserHandleSortMethodEnum: GetTracksByUserHandleSortMethodEnum,
  GetTracksByUserHandleSortDirectionEnum: GetTracksByUserHandleSortDirectionEnum,
  GetTracksByUserHandleFilterTracksEnum: GetTracksByUserHandleFilterTracksEnum,
  GetUserLibraryAlbumsSortDirectionEnum: GetUserLibraryAlbumsSortDirectionEnum,
  GetUserLibraryAlbumsTypeEnum: GetUserLibraryAlbumsTypeEnum,
  GetUserLibraryAlbumsSortMethodEnum: GetUserLibraryAlbumsSortMethodEnum,
  GetUserLibraryPlaylistsSortDirectionEnum: GetUserLibraryPlaylistsSortDirectionEnum,
  GetUserLibraryPlaylistsTypeEnum: GetUserLibraryPlaylistsTypeEnum,
  GetUserLibraryPlaylistsSortMethodEnum: GetUserLibraryPlaylistsSortMethodEnum,
  GetUserLibraryTracksSortMethodEnum: GetUserLibraryTracksSortMethodEnum,
  GetUserLibraryTracksSortDirectionEnum: GetUserLibraryTracksSortDirectionEnum,
  GetUserLibraryTracksTypeEnum: GetUserLibraryTracksTypeEnum,
  GetUsersTrackHistorySortMethodEnum: GetUsersTrackHistorySortMethodEnum,
  GetUsersTrackHistorySortDirectionEnum: GetUsersTrackHistorySortDirectionEnum,
  instanceOfActivityFull: instanceOfActivityFull,
  ActivityFullFromJSON: ActivityFullFromJSON,
  ActivityFullFromJSONTyped: ActivityFullFromJSONTyped,
  ActivityFullToJSON: ActivityFullToJSON,
  instanceOfCollectionActivityFull: instanceOfCollectionActivityFull,
  CollectionActivityFullFromJSON: CollectionActivityFullFromJSON,
  CollectionActivityFullFromJSONTyped: CollectionActivityFullFromJSONTyped,
  CollectionActivityFullToJSON: CollectionActivityFullToJSON,
  instanceOfCollectionLibraryResponseFull: instanceOfCollectionLibraryResponseFull,
  CollectionLibraryResponseFullFromJSON: CollectionLibraryResponseFullFromJSON,
  CollectionLibraryResponseFullFromJSONTyped: CollectionLibraryResponseFullFromJSONTyped,
  CollectionLibraryResponseFullToJSON: CollectionLibraryResponseFullToJSON,
  instanceOfCoverArt: instanceOfCoverArt,
  CoverArtFromJSON: CoverArtFromJSON,
  CoverArtFromJSONTyped: CoverArtFromJSONTyped,
  CoverArtToJSON: CoverArtToJSON,
  instanceOfCoverPhoto: instanceOfCoverPhoto,
  CoverPhotoFromJSON: CoverPhotoFromJSON,
  CoverPhotoFromJSONTyped: CoverPhotoFromJSONTyped,
  CoverPhotoToJSON: CoverPhotoToJSON,
  instanceOfDownloadMetadata: instanceOfDownloadMetadata,
  DownloadMetadataFromJSON: DownloadMetadataFromJSON,
  DownloadMetadataFromJSONTyped: DownloadMetadataFromJSONTyped,
  DownloadMetadataToJSON: DownloadMetadataToJSON,
  instanceOfFavorite: instanceOfFavorite,
  FavoriteFromJSON: FavoriteFromJSON,
  FavoriteFromJSONTyped: FavoriteFromJSONTyped,
  FavoriteToJSON: FavoriteToJSON,
  instanceOfFieldVisibility: instanceOfFieldVisibility,
  FieldVisibilityFromJSON: FieldVisibilityFromJSON,
  FieldVisibilityFromJSONTyped: FieldVisibilityFromJSONTyped,
  FieldVisibilityToJSON: FieldVisibilityToJSON,
  instanceOfFollowingResponse: instanceOfFollowingResponse,
  FollowingResponseFromJSON: FollowingResponseFromJSON,
  FollowingResponseFromJSONTyped: FollowingResponseFromJSONTyped,
  FollowingResponseToJSON: FollowingResponseToJSON,
  instanceOfFollowingResponseFull: instanceOfFollowingResponseFull,
  FollowingResponseFullFromJSON: FollowingResponseFullFromJSON,
  FollowingResponseFullFromJSONTyped: FollowingResponseFullFromJSONTyped,
  FollowingResponseFullToJSON: FollowingResponseFullToJSON,
  instanceOfFullBulkSubscribersResponse: instanceOfFullBulkSubscribersResponse,
  FullBulkSubscribersResponseFromJSON: FullBulkSubscribersResponseFromJSON,
  FullBulkSubscribersResponseFromJSONTyped: FullBulkSubscribersResponseFromJSONTyped,
  FullBulkSubscribersResponseToJSON: FullBulkSubscribersResponseToJSON,
  instanceOfFullFollowersResponse: instanceOfFullFollowersResponse,
  FullFollowersResponseFromJSON: FullFollowersResponseFromJSON,
  FullFollowersResponseFromJSONTyped: FullFollowersResponseFromJSONTyped,
  FullFollowersResponseToJSON: FullFollowersResponseToJSON,
  instanceOfFullGetSupporter: instanceOfFullGetSupporter,
  FullGetSupporterFromJSON: FullGetSupporterFromJSON,
  FullGetSupporterFromJSONTyped: FullGetSupporterFromJSONTyped,
  FullGetSupporterToJSON: FullGetSupporterToJSON,
  instanceOfFullGetSupporters: instanceOfFullGetSupporters,
  FullGetSupportersFromJSON: FullGetSupportersFromJSON,
  FullGetSupportersFromJSONTyped: FullGetSupportersFromJSONTyped,
  FullGetSupportersToJSON: FullGetSupportersToJSON,
  instanceOfFullGetSupporting: instanceOfFullGetSupporting,
  FullGetSupportingFromJSON: FullGetSupportingFromJSON,
  FullGetSupportingFromJSONTyped: FullGetSupportingFromJSONTyped,
  FullGetSupportingToJSON: FullGetSupportingToJSON,
  instanceOfFullPlaylistResponse: instanceOfFullPlaylistResponse,
  FullPlaylistResponseFromJSON: FullPlaylistResponseFromJSON,
  FullPlaylistResponseFromJSONTyped: FullPlaylistResponseFromJSONTyped,
  FullPlaylistResponseToJSON: FullPlaylistResponseToJSON,
  instanceOfFullPlaylistTracksResponse: instanceOfFullPlaylistTracksResponse,
  FullPlaylistTracksResponseFromJSON: FullPlaylistTracksResponseFromJSON,
  FullPlaylistTracksResponseFromJSONTyped: FullPlaylistTracksResponseFromJSONTyped,
  FullPlaylistTracksResponseToJSON: FullPlaylistTracksResponseToJSON,
  instanceOfFullRemix: instanceOfFullRemix,
  FullRemixFromJSON: FullRemixFromJSON,
  FullRemixFromJSONTyped: FullRemixFromJSONTyped,
  FullRemixToJSON: FullRemixToJSON,
  instanceOfFullRemixParent: instanceOfFullRemixParent,
  FullRemixParentFromJSON: FullRemixParentFromJSON,
  FullRemixParentFromJSONTyped: FullRemixParentFromJSONTyped,
  FullRemixParentToJSON: FullRemixParentToJSON,
  instanceOfFullReposts: instanceOfFullReposts,
  FullRepostsFromJSON: FullRepostsFromJSON,
  FullRepostsFromJSONTyped: FullRepostsFromJSONTyped,
  FullRepostsToJSON: FullRepostsToJSON,
  instanceOfFullSubscribersResponse: instanceOfFullSubscribersResponse,
  FullSubscribersResponseFromJSON: FullSubscribersResponseFromJSON,
  FullSubscribersResponseFromJSONTyped: FullSubscribersResponseFromJSONTyped,
  FullSubscribersResponseToJSON: FullSubscribersResponseToJSON,
  instanceOfFullSupporter: instanceOfFullSupporter,
  FullSupporterFromJSON: FullSupporterFromJSON,
  FullSupporterFromJSONTyped: FullSupporterFromJSONTyped,
  FullSupporterToJSON: FullSupporterToJSON,
  instanceOfFullSupporting: instanceOfFullSupporting,
  FullSupportingFromJSON: FullSupportingFromJSON,
  FullSupportingFromJSONTyped: FullSupportingFromJSONTyped,
  FullSupportingToJSON: FullSupportingToJSON,
  instanceOfFullTip: instanceOfFullTip,
  FullTipFromJSON: FullTipFromJSON,
  FullTipFromJSONTyped: FullTipFromJSONTyped,
  FullTipToJSON: FullTipToJSON,
  instanceOfFullTrackResponse: instanceOfFullTrackResponse,
  FullTrackResponseFromJSON: FullTrackResponseFromJSON,
  FullTrackResponseFromJSONTyped: FullTrackResponseFromJSONTyped,
  FullTrackResponseToJSON: FullTrackResponseToJSON,
  instanceOfFullTracks: instanceOfFullTracks,
  FullTracksFromJSON: FullTracksFromJSON,
  FullTracksFromJSONTyped: FullTracksFromJSONTyped,
  FullTracksToJSON: FullTracksToJSON,
  instanceOfFullTracksResponse: instanceOfFullTracksResponse,
  FullTracksResponseFromJSON: FullTracksResponseFromJSON,
  FullTracksResponseFromJSONTyped: FullTracksResponseFromJSONTyped,
  FullTracksResponseToJSON: FullTracksResponseToJSON,
  instanceOfFullTrendingPlaylistsResponse: instanceOfFullTrendingPlaylistsResponse,
  FullTrendingPlaylistsResponseFromJSON: FullTrendingPlaylistsResponseFromJSON,
  FullTrendingPlaylistsResponseFromJSONTyped: FullTrendingPlaylistsResponseFromJSONTyped,
  FullTrendingPlaylistsResponseToJSON: FullTrendingPlaylistsResponseToJSON,
  instanceOfFullUserResponse: instanceOfFullUserResponse,
  FullUserResponseFromJSON: FullUserResponseFromJSON,
  FullUserResponseFromJSONTyped: FullUserResponseFromJSONTyped,
  FullUserResponseToJSON: FullUserResponseToJSON,
  instanceOfGetTipsResponse: instanceOfGetTipsResponse,
  GetTipsResponseFromJSON: GetTipsResponseFromJSON,
  GetTipsResponseFromJSONTyped: GetTipsResponseFromJSONTyped,
  GetTipsResponseToJSON: GetTipsResponseToJSON,
  instanceOfHistoryResponseFull: instanceOfHistoryResponseFull,
  HistoryResponseFullFromJSON: HistoryResponseFullFromJSON,
  HistoryResponseFullFromJSONTyped: HistoryResponseFullFromJSONTyped,
  HistoryResponseFullToJSON: HistoryResponseFullToJSON,
  instanceOfPlaylistAddedTimestamp: instanceOfPlaylistAddedTimestamp,
  PlaylistAddedTimestampFromJSON: PlaylistAddedTimestampFromJSON,
  PlaylistAddedTimestampFromJSONTyped: PlaylistAddedTimestampFromJSONTyped,
  PlaylistAddedTimestampToJSON: PlaylistAddedTimestampToJSON,
  instanceOfPlaylistArtwork: instanceOfPlaylistArtwork,
  PlaylistArtworkFromJSON: PlaylistArtworkFromJSON,
  PlaylistArtworkFromJSONTyped: PlaylistArtworkFromJSONTyped,
  PlaylistArtworkToJSON: PlaylistArtworkToJSON,
  instanceOfPlaylistFull: instanceOfPlaylistFull,
  PlaylistFullFromJSON: PlaylistFullFromJSON,
  PlaylistFullFromJSONTyped: PlaylistFullFromJSONTyped,
  PlaylistFullToJSON: PlaylistFullToJSON,
  instanceOfPlaylistFullWithoutTracks: instanceOfPlaylistFullWithoutTracks,
  PlaylistFullWithoutTracksFromJSON: PlaylistFullWithoutTracksFromJSON,
  PlaylistFullWithoutTracksFromJSONTyped: PlaylistFullWithoutTracksFromJSONTyped,
  PlaylistFullWithoutTracksToJSON: PlaylistFullWithoutTracksToJSON,
  instanceOfPlaylistLibrary: instanceOfPlaylistLibrary,
  PlaylistLibraryFromJSON: PlaylistLibraryFromJSON,
  PlaylistLibraryFromJSONTyped: PlaylistLibraryFromJSONTyped,
  PlaylistLibraryToJSON: PlaylistLibraryToJSON,
  instanceOfPremiumContentSignature: instanceOfPremiumContentSignature,
  PremiumContentSignatureFromJSON: PremiumContentSignatureFromJSON,
  PremiumContentSignatureFromJSONTyped: PremiumContentSignatureFromJSONTyped,
  PremiumContentSignatureToJSON: PremiumContentSignatureToJSON,
  instanceOfProfilePicture: instanceOfProfilePicture,
  ProfilePictureFromJSON: ProfilePictureFromJSON,
  ProfilePictureFromJSONTyped: ProfilePictureFromJSONTyped,
  ProfilePictureToJSON: ProfilePictureToJSON,
  instanceOfRelatedArtistResponseFull: instanceOfRelatedArtistResponseFull,
  RelatedArtistResponseFullFromJSON: RelatedArtistResponseFullFromJSON,
  RelatedArtistResponseFullFromJSONTyped: RelatedArtistResponseFullFromJSONTyped,
  RelatedArtistResponseFullToJSON: RelatedArtistResponseFullToJSON,
  instanceOfRemixesResponse: instanceOfRemixesResponse,
  RemixesResponseFromJSON: RemixesResponseFromJSON,
  RemixesResponseFromJSONTyped: RemixesResponseFromJSONTyped,
  RemixesResponseToJSON: RemixesResponseToJSON,
  instanceOfRemixesResponseFull: instanceOfRemixesResponseFull,
  RemixesResponseFullFromJSON: RemixesResponseFullFromJSON,
  RemixesResponseFullFromJSONTyped: RemixesResponseFullFromJSONTyped,
  RemixesResponseFullToJSON: RemixesResponseFullToJSON,
  instanceOfRemixingResponse: instanceOfRemixingResponse,
  RemixingResponseFromJSON: RemixingResponseFromJSON,
  RemixingResponseFromJSONTyped: RemixingResponseFromJSONTyped,
  RemixingResponseToJSON: RemixingResponseToJSON,
  instanceOfRepost: instanceOfRepost,
  RepostFromJSON: RepostFromJSON,
  RepostFromJSONTyped: RepostFromJSONTyped,
  RepostToJSON: RepostToJSON,
  instanceOfSearchAutocompleteResponse: instanceOfSearchAutocompleteResponse,
  SearchAutocompleteResponseFromJSON: SearchAutocompleteResponseFromJSON,
  SearchAutocompleteResponseFromJSONTyped: SearchAutocompleteResponseFromJSONTyped,
  SearchAutocompleteResponseToJSON: SearchAutocompleteResponseToJSON,
  instanceOfSearchFullResponse: instanceOfSearchFullResponse,
  SearchFullResponseFromJSON: SearchFullResponseFromJSON,
  SearchFullResponseFromJSONTyped: SearchFullResponseFromJSONTyped,
  SearchFullResponseToJSON: SearchFullResponseToJSON,
  instanceOfSearchModel: instanceOfSearchModel,
  SearchModelFromJSON: SearchModelFromJSON,
  SearchModelFromJSONTyped: SearchModelFromJSONTyped,
  SearchModelToJSON: SearchModelToJSON,
  instanceOfStemFull: instanceOfStemFull,
  StemFullFromJSON: StemFullFromJSON,
  StemFullFromJSONTyped: StemFullFromJSONTyped,
  StemFullToJSON: StemFullToJSON,
  instanceOfStemParent: instanceOfStemParent,
  StemParentFromJSON: StemParentFromJSON,
  StemParentFromJSONTyped: StemParentFromJSONTyped,
  StemParentToJSON: StemParentToJSON,
  instanceOfStemsResponse: instanceOfStemsResponse,
  StemsResponseFromJSON: StemsResponseFromJSON,
  StemsResponseFromJSONTyped: StemsResponseFromJSONTyped,
  StemsResponseToJSON: StemsResponseToJSON,
  instanceOfSupporterReference: instanceOfSupporterReference,
  SupporterReferenceFromJSON: SupporterReferenceFromJSON,
  SupporterReferenceFromJSONTyped: SupporterReferenceFromJSONTyped,
  SupporterReferenceToJSON: SupporterReferenceToJSON,
  instanceOfTopGenreUsersResponseFull: instanceOfTopGenreUsersResponseFull,
  TopGenreUsersResponseFullFromJSON: TopGenreUsersResponseFullFromJSON,
  TopGenreUsersResponseFullFromJSONTyped: TopGenreUsersResponseFullFromJSONTyped,
  TopGenreUsersResponseFullToJSON: TopGenreUsersResponseFullToJSON,
  instanceOfTopUsersResponseFull: instanceOfTopUsersResponseFull,
  TopUsersResponseFullFromJSON: TopUsersResponseFullFromJSON,
  TopUsersResponseFullFromJSONTyped: TopUsersResponseFullFromJSONTyped,
  TopUsersResponseFullToJSON: TopUsersResponseFullToJSON,
  instanceOfTrackActivityFull: instanceOfTrackActivityFull,
  TrackActivityFullFromJSON: TrackActivityFullFromJSON,
  TrackActivityFullFromJSONTyped: TrackActivityFullFromJSONTyped,
  TrackActivityFullToJSON: TrackActivityFullToJSON,
  instanceOfTrackArtwork: instanceOfTrackArtwork,
  TrackArtworkFromJSON: TrackArtworkFromJSON,
  TrackArtworkFromJSONTyped: TrackArtworkFromJSONTyped,
  TrackArtworkToJSON: TrackArtworkToJSON,
  instanceOfTrackFavoritesResponseFull: instanceOfTrackFavoritesResponseFull,
  TrackFavoritesResponseFullFromJSON: TrackFavoritesResponseFullFromJSON,
  TrackFavoritesResponseFullFromJSONTyped: TrackFavoritesResponseFullFromJSONTyped,
  TrackFavoritesResponseFullToJSON: TrackFavoritesResponseFullToJSON,
  instanceOfTrackFull: instanceOfTrackFull,
  TrackFullFromJSON: TrackFullFromJSON,
  TrackFullFromJSONTyped: TrackFullFromJSONTyped,
  TrackFullToJSON: TrackFullToJSON,
  instanceOfTrackId: instanceOfTrackId,
  TrackIdFromJSON: TrackIdFromJSON,
  TrackIdFromJSONTyped: TrackIdFromJSONTyped,
  TrackIdToJSON: TrackIdToJSON,
  instanceOfTrackLibraryResponseFull: instanceOfTrackLibraryResponseFull,
  TrackLibraryResponseFullFromJSON: TrackLibraryResponseFullFromJSON,
  TrackLibraryResponseFullFromJSONTyped: TrackLibraryResponseFullFromJSONTyped,
  TrackLibraryResponseFullToJSON: TrackLibraryResponseFullToJSON,
  instanceOfTrackRepostsResponseFull: instanceOfTrackRepostsResponseFull,
  TrackRepostsResponseFullFromJSON: TrackRepostsResponseFullFromJSON,
  TrackRepostsResponseFullFromJSONTyped: TrackRepostsResponseFullFromJSONTyped,
  TrackRepostsResponseFullToJSON: TrackRepostsResponseFullToJSON,
  instanceOfTrackSegment: instanceOfTrackSegment,
  TrackSegmentFromJSON: TrackSegmentFromJSON,
  TrackSegmentFromJSONTyped: TrackSegmentFromJSONTyped,
  TrackSegmentToJSON: TrackSegmentToJSON,
  instanceOfTransactionDetails: instanceOfTransactionDetails,
  TransactionDetailsFromJSON: TransactionDetailsFromJSON,
  TransactionDetailsFromJSONTyped: TransactionDetailsFromJSONTyped,
  TransactionDetailsToJSON: TransactionDetailsToJSON,
  instanceOfTransactionHistoryCountResponse: instanceOfTransactionHistoryCountResponse,
  TransactionHistoryCountResponseFromJSON: TransactionHistoryCountResponseFromJSON,
  TransactionHistoryCountResponseFromJSONTyped: TransactionHistoryCountResponseFromJSONTyped,
  TransactionHistoryCountResponseToJSON: TransactionHistoryCountResponseToJSON,
  instanceOfTransactionHistoryResponse: instanceOfTransactionHistoryResponse,
  TransactionHistoryResponseFromJSON: TransactionHistoryResponseFromJSON,
  TransactionHistoryResponseFromJSONTyped: TransactionHistoryResponseFromJSONTyped,
  TransactionHistoryResponseToJSON: TransactionHistoryResponseToJSON,
  instanceOfTrendingIdsResponse: instanceOfTrendingIdsResponse,
  TrendingIdsResponseFromJSON: TrendingIdsResponseFromJSON,
  TrendingIdsResponseFromJSONTyped: TrendingIdsResponseFromJSONTyped,
  TrendingIdsResponseToJSON: TrendingIdsResponseToJSON,
  instanceOfTrendingTimesIds: instanceOfTrendingTimesIds,
  TrendingTimesIdsFromJSON: TrendingTimesIdsFromJSON,
  TrendingTimesIdsFromJSONTyped: TrendingTimesIdsFromJSONTyped,
  TrendingTimesIdsToJSON: TrendingTimesIdsToJSON,
  instanceOfUserFull: instanceOfUserFull,
  UserFullFromJSON: UserFullFromJSON,
  UserFullFromJSONTyped: UserFullFromJSONTyped,
  UserFullToJSON: UserFullToJSON,
  instanceOfUserReplicaSet: instanceOfUserReplicaSet,
  UserReplicaSetFromJSON: UserReplicaSetFromJSON,
  UserReplicaSetFromJSONTyped: UserReplicaSetFromJSONTyped,
  UserReplicaSetToJSON: UserReplicaSetToJSON,
  instanceOfUserSubscribers: instanceOfUserSubscribers,
  UserSubscribersFromJSON: UserSubscribersFromJSON,
  UserSubscribersFromJSONTyped: UserSubscribersFromJSONTyped,
  UserSubscribersToJSON: UserSubscribersToJSON,
  instanceOfUsersByContentNode: instanceOfUsersByContentNode,
  UsersByContentNodeFromJSON: UsersByContentNodeFromJSON,
  UsersByContentNodeFromJSONTyped: UsersByContentNodeFromJSONTyped,
  UsersByContentNodeToJSON: UsersByContentNodeToJSON,
  instanceOfVersionMetadata: instanceOfVersionMetadata,
  VersionMetadataFromJSON: VersionMetadataFromJSON,
  VersionMetadataFromJSONTyped: VersionMetadataFromJSONTyped,
  VersionMetadataToJSON: VersionMetadataToJSON
});

var appName;
/**
 * Appends the configured app_name to the query string for tracking API usage
 * @param options the middleware options
 * @param {string} options.appName the name of the app using the SDK
 */

var addAppNameMiddleware = function addAppNameMiddleware(_ref) {
  var providedAppName = _ref.appName,
      services = _ref.services;
  appName = providedAppName;
  return {
    pre: function () {
      var _pre = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(context) {
        var _appName, _context$init;

        var _yield$developerApps$, middleware, apiClientConfig, developerApps;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (appName) {
                  _context.next = 21;
                  break;
                }

                middleware = [services.discoveryNodeSelector.createMiddleware()];
                apiClientConfig = new Configuration$1({
                  fetchApi: fetch$1,
                  middleware: middleware
                });
                developerApps = new DeveloperAppsApi(apiClientConfig, services.entityManager, services.auth);
                _context.t1 = developerApps;
                _context.next = 7;
                return services.auth.getAddress();

              case 7:
                _context.t2 = _context.sent;
                _context.t3 = {
                  address: _context.t2
                };
                _context.next = 11;
                return _context.t1.getDeveloperApp.call(_context.t1, _context.t3);

              case 11:
                _context.t4 = _yield$developerApps$ = _context.sent.data;
                _context.t0 = _context.t4 === null;

                if (_context.t0) {
                  _context.next = 15;
                  break;
                }

                _context.t0 = _yield$developerApps$ === void 0;

              case 15:
                if (!_context.t0) {
                  _context.next = 19;
                  break;
                }

                _context.t5 = void 0;
                _context.next = 20;
                break;

              case 19:
                _context.t5 = _yield$developerApps$.name;

              case 20:
                appName = _context.t5;

              case 21:
                return _context.abrupt("return", {
                  url: context.url + (context.url.includes('?') ? '&' : '?') + querystring$1({
                    app_name: (_appName = appName) !== null && _appName !== void 0 ? _appName : ''
                  }),
                  init: (_context$init = context.init) !== null && _context$init !== void 0 ? _context$init : {}
                });

              case 22:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function pre(_x) {
        return _pre.apply(this, arguments);
      }

      return pre;
    }()
  };
};

var DECISION_TREE_STATE;

(function (DECISION_TREE_STATE) {
  DECISION_TREE_STATE["CHECK_SHORT_CIRCUIT"] = "Check Short Circuit";
  DECISION_TREE_STATE["GET_ALL_SERVICES"] = "Get All Services";
  DECISION_TREE_STATE["FILTER_TO_WHITELIST"] = "Filter To Whitelist";
  DECISION_TREE_STATE["FILTER_FROM_BLACKLIST"] = "Filter From Blacklist";
  DECISION_TREE_STATE["FILTER_OUT_KNOWN_UNHEALTHY"] = "Filter Out Known Unhealthy";
  DECISION_TREE_STATE["GET_SELECTION_ROUND"] = "Get Selection Round";
  DECISION_TREE_STATE["NO_SERVICES_LEFT_TO_TRY"] = "No Services Left To Try";
  DECISION_TREE_STATE["SELECTED_FROM_BACKUP"] = "Selected From Backup";
  DECISION_TREE_STATE["FAILED_AND_RESETTING"] = "Failed Everything -- Resetting";
  DECISION_TREE_STATE["ROUND_FAILED_RETRY"] = "Round Failed Retry";
  DECISION_TREE_STATE["MADE_A_SELECTION"] = "Made A Selection";
  DECISION_TREE_STATE["RACED_AND_FOUND_BEST"] = "Raced And Found Best";
})(DECISION_TREE_STATE || (DECISION_TREE_STATE = {}));

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */

function baseClamp$2(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }

    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }

  return number;
}

var _baseClamp = baseClamp$2;

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */

function copyArray$2(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

var _copyArray = copyArray$2;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeRandom = Math.random;
/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */

function baseRandom$1(lower, upper) {
  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}

var _baseRandom = baseRandom$1;

var baseRandom = _baseRandom;
/**
 * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @param {number} [size=array.length] The size of `array`.
 * @returns {Array} Returns `array`.
 */

function shuffleSelf$2(array, size) {
  var index = -1,
      length = array.length,
      lastIndex = length - 1;
  size = size === undefined ? length : size;

  while (++index < size) {
    var rand = baseRandom(index, lastIndex),
        value = array[rand];
    array[rand] = array[index];
    array[index] = value;
  }

  array.length = size;
  return array;
}

var _shuffleSelf = shuffleSelf$2;

var baseClamp$1 = _baseClamp,
    copyArray$1 = _copyArray,
    shuffleSelf$1 = _shuffleSelf;
/**
 * A specialized version of `_.sampleSize` for arrays.
 *
 * @private
 * @param {Array} array The array to sample.
 * @param {number} n The number of elements to sample.
 * @returns {Array} Returns the random elements.
 */

function arraySampleSize$1(array, n) {
  return shuffleSelf$1(copyArray$1(array), baseClamp$1(n, 0, array.length));
}

var _arraySampleSize = arraySampleSize$1;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

function arrayMap$1(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

var _arrayMap = arrayMap$1;

var arrayMap = _arrayMap;
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */

function baseValues$1(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

var _baseValues = baseValues$1;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */

function baseTimes$1(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

var _baseTimes = baseTimes$1;

var freeGlobal$1 = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;

var freeGlobal = _freeGlobal;
/** Detect free variable `self`. */

var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root$4 = freeGlobal || freeSelf || Function('return this')();
var _root = root$4;

var root$3 = _root;
/** Built-in value references. */

var _Symbol2 = root$3.Symbol;
var _Symbol$2 = _Symbol2;

var _Symbol$1 = _Symbol$2;
/** Used for built-in method references. */

var objectProto$b = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString$1 = objectProto$b.toString;
/** Built-in value references. */

var symToStringTag$1 = _Symbol$1 ? _Symbol$1.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag$1(value) {
  var isOwn = hasOwnProperty$9.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }

  return result;
}

var _getRawTag = getRawTag$1;

/** Used for built-in method references. */
var objectProto$a = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto$a.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString$1(value) {
  return nativeObjectToString.call(value);
}

var _objectToString = objectToString$1;

var _Symbol = _Symbol$2,
    getRawTag = _getRawTag,
    objectToString = _objectToString;
/** `Object#toString` result references. */

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag$5(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

var _baseGetTag = baseGetTag$5;

function isObjectLike$6(value) {
  return value != null && _typeof(value) == 'object';
}

var isObjectLike_1 = isObjectLike$6;

var baseGetTag$4 = _baseGetTag,
    isObjectLike$5 = isObjectLike_1;
/** `Object#toString` result references. */

var argsTag$1 = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments$1(value) {
  return isObjectLike$5(value) && baseGetTag$4(value) == argsTag$1;
}

var _baseIsArguments = baseIsArguments$1;

var baseIsArguments = _baseIsArguments,
    isObjectLike$4 = isObjectLike_1;
/** Used for built-in method references. */

var objectProto$9 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto$9.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments$2 = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike$4(value) && hasOwnProperty$8.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
var isArguments_1 = isArguments$2;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$3 = Array.isArray;
var isArray_1 = isArray$3;

var isBuffer$2 = {exports: {}};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */

function stubFalse() {
  return false;
}

var stubFalse_1 = stubFalse;

(function (module, exports) {
  var root = _root,
      stubFalse = stubFalse_1;
  /** Detect free variable `exports`. */

  var freeExports = exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Built-in value references. */

  var Buffer = moduleExports ? root.Buffer : undefined;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */

  var isBuffer = nativeIsBuffer || stubFalse;
  module.exports = isBuffer;
})(isBuffer$2, isBuffer$2.exports);

var MAX_SAFE_INTEGER$1 = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex$2(value, length) {
  var type = _typeof(value);

  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

var _isIndex = isIndex$2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength$2(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

var isLength_1 = isLength$2;

var baseGetTag$3 = _baseGetTag,
    isLength$1 = isLength_1,
    isObjectLike$3 = isObjectLike_1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag$1 = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray$1(value) {
  return isObjectLike$3(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$3(value)];
}

var _baseIsTypedArray = baseIsTypedArray$1;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */

function baseUnary$1(func) {
  return function (value) {
    return func(value);
  };
}

var _baseUnary = baseUnary$1;

var _nodeUtil = {exports: {}};

(function (module, exports) {
  var freeGlobal = _freeGlobal;
  /** Detect free variable `exports`. */

  var freeExports = exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Detect free variable `process` from Node.js. */

  var freeProcess = moduleExports && freeGlobal.process;
  /** Used to access faster Node.js helpers. */

  var nodeUtil = function () {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      } // Legacy `process.binding('util')` for Node.js < 10.


      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();

  module.exports = nodeUtil;
})(_nodeUtil, _nodeUtil.exports);

var baseIsTypedArray = _baseIsTypedArray,
    baseUnary = _baseUnary,
    nodeUtil = _nodeUtil.exports;
/* Node.js helper references. */

var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;

var baseTimes = _baseTimes,
    isArguments$1 = isArguments_1,
    isArray$2 = isArray_1,
    isBuffer$1 = isBuffer$2.exports,
    isIndex$1 = _isIndex,
    isTypedArray$1 = isTypedArray_1;
/** Used for built-in method references. */

var objectProto$8 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$2(value),
      isArg = !isArr && isArguments$1(value),
      isBuff = !isArr && !isArg && isBuffer$1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex$1(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

var _arrayLikeKeys = arrayLikeKeys$2;

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype$3(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$7;
  return value === proto;
}

var _isPrototype = isPrototype$3;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */

function overArg$2(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

var _overArg = overArg$2;

var overArg$1 = _overArg;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;

var isPrototype$2 = _isPrototype,
    nativeKeys = _nativeKeys;
/** Used for built-in method references. */

var objectProto$6 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys$1(object) {
  if (!isPrototype$2(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty$6.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

var _baseKeys = baseKeys$1;

function isObject$8(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject$8;

var baseGetTag$2 = _baseGetTag,
    isObject$7 = isObject_1;
/** `Object#toString` result references. */

var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction$3(value) {
  if (!isObject$7(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag$2(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

var isFunction_1 = isFunction$3;

var isFunction$2 = isFunction_1,
    isLength = isLength_1;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike$4(value) {
  return value != null && isLength(value.length) && !isFunction$2(value);
}

var isArrayLike_1 = isArrayLike$4;

var arrayLikeKeys$1 = _arrayLikeKeys,
    baseKeys = _baseKeys,
    isArrayLike$3 = isArrayLike_1;
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */

function keys$1(object) {
  return isArrayLike$3(object) ? arrayLikeKeys$1(object) : baseKeys(object);
}

var keys_1 = keys$1;

var baseValues = _baseValues,
    keys = keys_1;
/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */

function values$1(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

var values_1 = values$1;

var baseClamp = _baseClamp,
    shuffleSelf = _shuffleSelf,
    values = values_1;
/**
 * The base implementation of `_.sampleSize` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to sample.
 * @param {number} n The number of elements to sample.
 * @returns {Array} Returns the random elements.
 */

function baseSampleSize$1(collection, n) {
  var array = values(collection);
  return shuffleSelf(array, baseClamp(n, 0, array.length));
}

var _baseSampleSize = baseSampleSize$1;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */

function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}

var eq_1 = eq$4;

var eq$3 = eq_1,
    isArrayLike$2 = isArrayLike_1,
    isIndex = _isIndex,
    isObject$6 = isObject_1;
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */

function isIterateeCall$2(value, index, object) {
  if (!isObject$6(object)) {
    return false;
  }

  var type = _typeof(index);

  if (type == 'number' ? isArrayLike$2(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq$3(object[index], value);
  }

  return false;
}

var _isIterateeCall = isIterateeCall$2;

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */

function trimmedEndIndex$1(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}

  return index;
}

var _trimmedEndIndex = trimmedEndIndex$1;

var trimmedEndIndex = _trimmedEndIndex;
/** Used to match leading whitespace. */

var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */

function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
}

var _baseTrim = baseTrim$1;

var baseGetTag$1 = _baseGetTag,
    isObjectLike$2 = isObjectLike_1;
/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol$1(value) {
  return _typeof(value) == 'symbol' || isObjectLike$2(value) && baseGetTag$1(value) == symbolTag;
}

var isSymbol_1 = isSymbol$1;

var baseTrim = _baseTrim,
    isObject$5 = isObject_1,
    isSymbol = isSymbol_1;
/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */

function toNumber$1(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject$5(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject$5(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

var toNumber_1 = toNumber$1;

var toNumber = toNumber_1;
/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */

function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }

  value = toNumber(value);

  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }

  return value === value ? value : 0;
}

var toFinite_1 = toFinite$1;

var toFinite = toFinite_1;
/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */

function toInteger$1(value) {
  var result = toFinite(value),
      remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}

var toInteger_1 = toInteger$1;

var arraySampleSize = _arraySampleSize,
    baseSampleSize = _baseSampleSize,
    isArray$1 = isArray_1,
    isIterateeCall$1 = _isIterateeCall,
    toInteger = toInteger_1;
/**
 * Gets `n` random elements at unique keys from `collection` up to the
 * size of `collection`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to sample.
 * @param {number} [n=1] The number of elements to sample.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the random elements.
 * @example
 *
 * _.sampleSize([1, 2, 3], 2);
 * // => [3, 1]
 *
 * _.sampleSize([1, 2, 3], 4);
 * // => [2, 3, 1]
 */

function sampleSize(collection, n, guard) {
  if (guard ? isIterateeCall$1(collection, n, guard) : n === undefined) {
    n = 1;
  } else {
    n = toInteger(n);
  }

  var func = isArray$1(collection) ? arraySampleSize : baseSampleSize;
  return func(collection, n);
}

var sampleSize_1 = sampleSize;

var HealthCheckStatus;

(function (HealthCheckStatus) {
  HealthCheckStatus["UNHEALTHY"] = "unhealthy";
  HealthCheckStatus["BEHIND"] = "behind";
  HealthCheckStatus["HEALTHY"] = "healthy";
})(HealthCheckStatus || (HealthCheckStatus = {}));

var servicesConfig$2 = {
  "minVersion": "0.0.0",
  "discoveryNodes": ["http://audius-protocol-discovery-provider-1"],
  "storageNodes": [{
    "delegateOwnerWallet": "0x0D38e653eC28bdea5A2296fD5940aaB2D0B8875c",
    "endpoint": "http://audius-protocol-creator-node-1"
  }],
  "entityManagerContractAddress": "0x254dffcd3277C0b1660F6d42EFbB754edaBAbC2B",
  "web3ProviderUrl": "http://audius-protocol-poa-ganache-1",
  "identityServiceUrl": "http://audius-protocol-identity-service-1"
};

var servicesConfig$1 = {
  "minVersion": "0.3.83",
  "discoveryNodes": ["https://discoveryprovider2.staging.audius.co", "https://discoveryprovider3.staging.audius.co", "https://discoveryprovider.staging.audius.co", "https://discoveryprovider5.staging.audius.co"],
  "storageNodes": [{
    "endpoint": "https://usermetadata.staging.audius.co",
    "delegateOwnerWallet": "0x671ddce7B4E676C9467F87e4031a917b5D6f75F0"
  }, {
    "endpoint": "https://creatornode5.staging.audius.co",
    "delegateOwnerWallet": "0xDC2BDF1F23381CA2eC9e9c70D4FD96CD8645D090"
  }, {
    "endpoint": "https://creatornode6.staging.audius.co",
    "delegateOwnerWallet": "0x68039d001D87E7A5E6B06fe0825EA7871C1Cd6C2"
  }, {
    "endpoint": "https://creatornode7.staging.audius.co",
    "delegateOwnerWallet": "0x1F8e7aF58086992Ef4c4fc0371446974BBbC0D9F"
  }, {
    "endpoint": "https://creatornode8.staging.audius.co",
    "delegateOwnerWallet": "0x8fcFA10Bd3808570987dbb5B1EF4AB74400FbfDA"
  }, {
    "endpoint": "https://creatornode9.staging.audius.co",
    "delegateOwnerWallet": "0x140eD283b33be2145ed7d9d15f1fE7bF1E0B2Ac3"
  }, {
    "endpoint": "https://creatornode10.staging.audius.co",
    "delegateOwnerWallet": "0xf7C96916bd37Ad76D4EEDd6536B81c29706C8056"
  }, {
    "endpoint": "https://creatornode11.staging.audius.co",
    "delegateOwnerWallet": "0x4c88d2c0f4c4586b41621aD6e98882ae904B98f6"
  }],
  "web3ProviderUrl": "https://poa-gateway.staging.audius.co",
  "entityManagerContractAddress": "0x1Cd8a543596D499B9b6E7a6eC15ECd2B7857Fd64",
  "identityServiceUrl": "https://identityservice.staging.audius.co"
};

var servicesConfig = {
  "minVersion": "0.3.85",
  "discoveryNodes": ["https://audius-metadata-1.figment.io", "https://audius-metadata-2.figment.io", "https://audius-discovery-1.altego.net", "https://audius-disco.ams-x01.nl.supercache.org", "https://dn-jpn.audius.metadata.fyi", "https://discoveryprovider3.audius.co", "https://discoveryprovider2.audius.co", "https://discoveryprovider.audius.co", "https://audius-metadata-3.figment.io", "https://audius-metadata-4.figment.io", "https://dn1.monophonic.digital", "https://dn-usa.audius.metadata.fyi", "https://discovery-us-01.audius.openplayer.org", "https://dn2.monophonic.digital", "https://audius-discovery-2.altego.net", "https://dn1.nodeoperator.io", "https://audius-disco.dfw-x02.us.supercache.org", "https://audius-discovery-3.altego.net", "https://dn1.matterlightblooming.xyz", "https://audius-dp.singapore.creatorseed.com", "https://discovery.grassfed.network", "https://audius-discovery-1.cultur3stake.com", "https://audius-discovery-3.cultur3stake.com", "https://audius-discovery-4.cultur3stake.com", "https://audius-discovery-5.cultur3stake.com", "https://audius-discovery-7.cultur3stake.com", "https://audius-discovery-8.cultur3stake.com", "https://audius-discovery-9.cultur3stake.com", "https://audius-discovery-10.cultur3stake.com", "https://discovery-au-02.audius.openplayer.org", "https://disc-lon01.audius.hashbeam.com", "https://audius-dp.amsterdam.creatorseed.com", "https://blockdaemon-audius-discovery-01.bdnodes.net", "https://blockdaemon-audius-discovery-02.bdnodes.net", "https://blockdaemon-audius-discovery-03.bdnodes.net", "https://blockdaemon-audius-discovery-04.bdnodes.net", "https://blockdaemon-audius-discovery-05.bdnodes.net", "https://blockdaemon-audius-discovery-06.bdnodes.net", "https://blockdaemon-audius-discovery-07.bdnodes.net", "https://blockchange-audius-discovery-01.bdnodes.net", "https://blockchange-audius-discovery-02.bdnodes.net", "https://blockchange-audius-discovery-03.bdnodes.net", "https://audius-discovery-11.cultur3stake.com", "https://audius-discovery-12.cultur3stake.com", "https://audius-discovery-13.cultur3stake.com", "https://audius-discovery-14.cultur3stake.com", "https://audius-discovery-16.cultur3stake.com", "https://audius-discovery-18.cultur3stake.com", "https://audius-discovery-17.cultur3stake.com", "https://audius-discovery-15.cultur3stake.com", "https://audius-discovery-6.cultur3stake.com", "https://audius-discovery-2.cultur3stake.com", "https://blockdaemon-audius-discovery-08.bdnodes.net", "https://audius-metadata-5.figment.io", "https://dn1.stuffisup.com", "https://audius-discovery-1.theblueprint.xyz", "https://audius-discovery-2.theblueprint.xyz", "https://audius-discovery-3.theblueprint.xyz", "https://audius-discovery-4.theblueprint.xyz", "https://audius.w3coins.io"],
  "storageNodes": [{
    "endpoint": "https://creatornode.audius.co",
    "delegateOwnerWallet": "0xc8d0C29B6d540295e8fc8ac72456F2f4D41088c8"
  }, {
    "endpoint": "https://creatornode2.audius.co",
    "delegateOwnerWallet": "0xf686647E3737d595C60c6DE2f5F90463542FE439"
  }, {
    "endpoint": "https://creatornode3.audius.co",
    "delegateOwnerWallet": "0x0C32BE6328578E99b6F06E0e7A6B385EB8FC13d1"
  }, {
    "endpoint": "https://content-node.audius.co",
    "delegateOwnerWallet": "0xC892c75Fa17e8b641a4843D0aa620792857d217A"
  }, {
    "endpoint": "https://audius-content-1.figment.io",
    "delegateOwnerWallet": "0xBfdE9a7DD3620CB6428463E9A9e9932B4d10fdc5"
  }, {
    "endpoint": "https://creatornode.audius.prod-us-west-2.staked.cloud",
    "delegateOwnerWallet": "0x675086B880260D217963cF14F503272AEb44b2E9"
  }, {
    "endpoint": "https://audius-content-2.figment.io",
    "delegateOwnerWallet": "0x6444212FFc23a4CcF7460f8Fe6D0e6074db59036"
  }, {
    "endpoint": "https://audius-content-3.figment.io",
    "delegateOwnerWallet": "0xECEDCaABecb40ef4bE733BA47FaD612aeA1F396F"
  }, {
    "endpoint": "https://audius-content-4.figment.io",
    "delegateOwnerWallet": "0x08fEF3884Db16E2E6211272cdC9Eee68E8b63b09"
  }, {
    "endpoint": "https://audius-content-5.figment.io",
    "delegateOwnerWallet": "0x10fF8197f2e94eF880d940D2414E0A14983c3bFE"
  }, {
    "endpoint": "https://creatornode.audius1.prod-us-west-2.staked.cloud",
    "delegateOwnerWallet": "0xC23Ee959E0B22a9B0F5dF18D7e7875cA4B6c4236"
  }, {
    "endpoint": "https://creatornode.audius2.prod-us-west-2.staked.cloud",
    "delegateOwnerWallet": "0x51a5575dc04c1f5f2e39390d090aaf78554F5f7B"
  }, {
    "endpoint": "https://creatornode.audius3.prod-us-west-2.staked.cloud",
    "delegateOwnerWallet": "0xe0b56BAe2276E016d3DB314Dd7374e596B0457ac"
  }, {
    "endpoint": "https://audius-content-6.figment.io",
    "delegateOwnerWallet": "0x68a4Bd6b4177ffB025AF9844cBE4Fe31348AEE1D"
  }, {
    "endpoint": "https://audius-content-7.figment.io",
    "delegateOwnerWallet": "0xf45a6DBf3ce0201F4012a19b1fB04D4f05B53a37"
  }, {
    "endpoint": "https://audius-content-8.figment.io",
    "delegateOwnerWallet": "0x9708Fb04DeA029212126255B311a21F1F884cCB4"
  }, {
    "endpoint": "https://usermetadata.audius.co",
    "delegateOwnerWallet": "0xD7E6Fe145874E6c2648F012379699c694b183A2c"
  }, {
    "endpoint": "https://audius-content-9.figment.io",
    "delegateOwnerWallet": "0x7c34c9709ed69513D55dF2020e799DA44fC52E6e"
  }, {
    "endpoint": "https://audius-content-10.figment.io",
    "delegateOwnerWallet": "0xff753331CEa586DD5B23bd21222a3c902909F2dd"
  }, {
    "endpoint": "https://audius-content-11.figment.io",
    "delegateOwnerWallet": "0xC9721F892BcC8822eb34237E875BE93904f11073"
  }, {
    "endpoint": "https://audius.prod.capturealpha.io",
    "delegateOwnerWallet": "0x0A5AEA27A7fB95b51056Df6AaD7fe7E9116eC9B4"
  }, {
    "endpoint": "https://content.grassfed.network",
    "delegateOwnerWallet": "0x33Ab85445c8A2690B9488e9fB5E6A9849d3a18d3"
  }, {
    "endpoint": "https://blockdaemon-audius-content-01.bdnodes.net",
    "delegateOwnerWallet": "0x807C0fba7405aeb8b6a37A974df6259C6aB9bB1e"
  }, {
    "endpoint": "https://audius-content-1.cultur3stake.com",
    "delegateOwnerWallet": "0xCEb6a23d6132Cfe329b3c8E3c45f9DDc28A62Bd4"
  }, {
    "endpoint": "https://audius-content-2.cultur3stake.com",
    "delegateOwnerWallet": "0x2e9e7A4e35C3136fB651a0dBF8f91c9f5C27BBf7"
  }, {
    "endpoint": "https://audius-content-3.cultur3stake.com",
    "delegateOwnerWallet": "0x742da6cAc2782FeA961bB7B9150a048F5167D1e1"
  }, {
    "endpoint": "https://audius-content-4.cultur3stake.com",
    "delegateOwnerWallet": "0xcbb0cE7481685587b0988195Ff0cD6AA1A701657"
  }, {
    "endpoint": "https://audius-content-5.cultur3stake.com",
    "delegateOwnerWallet": "0xFec4708155277D35d568aD6Ca322262577683584"
  }, {
    "endpoint": "https://audius-content-6.cultur3stake.com",
    "delegateOwnerWallet": "0x3Db0E61591063310eEd22fd57E6f7F1ab2Bb538E"
  }, {
    "endpoint": "https://audius-content-7.cultur3stake.com",
    "delegateOwnerWallet": "0xE6C00e7E8d582fD2856718a5439f1aeEB68e27E5"
  }, {
    "endpoint": "https://blockdaemon-audius-content-02.bdnodes.net",
    "delegateOwnerWallet": "0x4Ad694B3fC34b3cC245aF6AA7B43C52ddD0d7AAE"
  }, {
    "endpoint": "https://blockdaemon-audius-content-03.bdnodes.net",
    "delegateOwnerWallet": "0x8ea81225013719950E968DE0602c4Eca458fA9f4"
  }, {
    "endpoint": "https://blockdaemon-audius-content-04.bdnodes.net",
    "delegateOwnerWallet": "0xcfFA8ACF0b04d9278eEE13928be264b2E9aaab97"
  }, {
    "endpoint": "https://blockdaemon-audius-content-05.bdnodes.net",
    "delegateOwnerWallet": "0xB4Ff0cab630FB05a7fcEfec9E979a968b8f4fE55"
  }, {
    "endpoint": "https://blockdaemon-audius-content-06.bdnodes.net",
    "delegateOwnerWallet": "0x7449da7d1548C11c481b87667EC9b2A8F20C13A0"
  }, {
    "endpoint": "https://blockdaemon-audius-content-07.bdnodes.net",
    "delegateOwnerWallet": "0x00B1CA1A34257860f66e742eF163Ad30bF42d075"
  }, {
    "endpoint": "https://blockdaemon-audius-content-08.bdnodes.net",
    "delegateOwnerWallet": "0x16650eDB44C720ea627d5a59ff0b4f74c37fe419"
  }, {
    "endpoint": "https://blockdaemon-audius-content-09.bdnodes.net",
    "delegateOwnerWallet": "0xD5Cfcf4149c683516239fc653D5a470F3F4A606D"
  }, {
    "endpoint": "https://audius-content-8.cultur3stake.com",
    "delegateOwnerWallet": "0xff432F81D0eb77DA5973Cf55e24A897882fdd3E6"
  }, {
    "endpoint": "https://blockchange-audius-content-01.bdnodes.net",
    "delegateOwnerWallet": "0x8464c88502925a0076c381962F8B70b6EC892861"
  }, {
    "endpoint": "https://blockchange-audius-content-02.bdnodes.net",
    "delegateOwnerWallet": "0x5e0D0BeDC11F0B512457f6f707A35703b1447Fb5"
  }, {
    "endpoint": "https://blockchange-audius-content-03.bdnodes.net",
    "delegateOwnerWallet": "0xe3F1c416c3919bB2ffD78F1e38b9E81E8c80815F"
  }, {
    "endpoint": "https://audius-content-9.cultur3stake.com",
    "delegateOwnerWallet": "0xB6f506557B2e9026743FeA6157e52F204D26690F"
  }, {
    "endpoint": "https://audius-content-10.cultur3stake.com",
    "delegateOwnerWallet": "0x2AF4598D3CF95D8e76987c02BC8A8D71F58d49d5"
  }, {
    "endpoint": "https://audius-content-11.cultur3stake.com",
    "delegateOwnerWallet": "0xB2684Cca5281d2bA6D9Ce66Cca215635FF2Ba466"
  }, {
    "endpoint": "https://audius-content-12.cultur3stake.com",
    "delegateOwnerWallet": "0x28924C99822eA08bFCeDdE3a411308633948b349"
  }, {
    "endpoint": "https://audius-content-13.cultur3stake.com",
    "delegateOwnerWallet": "0xcb23908aa0dCDef762ebEaA38391D8fFC69E6e8F"
  }, {
    "endpoint": "https://audius-content-14.cultur3stake.com",
    "delegateOwnerWallet": "0xCbDa351492e52fdb2f0E7FBc440cA2047738b71C"
  }, {
    "endpoint": "https://audius-content-15.cultur3stake.com",
    "delegateOwnerWallet": "0x2fE2652296c40BB22D33C6379558Bf63A25b4f9a"
  }, {
    "endpoint": "https://audius-content-16.cultur3stake.com",
    "delegateOwnerWallet": "0x47367ED3Db5D9691d866cb09545DE7cccD571579"
  }, {
    "endpoint": "https://audius-content-17.cultur3stake.com",
    "delegateOwnerWallet": "0xb472c555Ab9eA1D33543383d6d1F8885c97eF83A"
  }, {
    "endpoint": "https://audius-content-18.cultur3stake.com",
    "delegateOwnerWallet": "0x4F62C17Dc54E58289354847974E1F246c8EAcf11"
  }, {
    "endpoint": "https://audius-content-12.figment.io",
    "delegateOwnerWallet": "0x780641e157621621658F118375dc1B36Ea514d46"
  }, {
    "endpoint": "https://cn0.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0xf9b373E223b73473C59034072263f52aEF60133B"
  }, {
    "endpoint": "https://cn1.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0x9b0D01bd7F01BD6916Ba139743Ce9C524B9375Dd"
  }, {
    "endpoint": "https://cn2.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0xf6e297203c0086dc229DAE17F5b61a15F42A1A00"
  }, {
    "endpoint": "https://cn3.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0x24C4b2cb6eC4c87a03F66723d8750dbe98Fa3e4f"
  }, {
    "endpoint": "https://audius-content-13.figment.io",
    "delegateOwnerWallet": "0x33a2da466B14990E0124383204b06F9196f62d8e"
  }, {
    "endpoint": "https://audius-content-14.figment.io",
    "delegateOwnerWallet": "0x817c513C1B702eA0BdD4F8C1204C60372f715006"
  }, {
    "endpoint": "https://cn4.mainnet.audiusindex.org",
    "delegateOwnerWallet": "0x69e749266C59757dA81F8C659Be6B07ce5Bac6C9"
  }, {
    "endpoint": "https://audius-content-1.jollyworld.xyz",
    "delegateOwnerWallet": "0x125A9f40CFB329266ef415b9510D4E716Dba8Da6"
  }, {
    "endpoint": "https://audius-creator-1.theblueprint.xyz",
    "delegateOwnerWallet": "0x0E0aF7035581C615d07372be16D99A9B64E5B2e9"
  }, {
    "endpoint": "https://audius-creator-2.theblueprint.xyz",
    "delegateOwnerWallet": "0x3D0dD2Cd46c2658d228769f4a394662946A28987"
  }, {
    "endpoint": "https://audius-creator-3.theblueprint.xyz",
    "delegateOwnerWallet": "0x292B0d5987a7DE879909C48a54f0853C211da5f3"
  }, {
    "endpoint": "https://audius-creator-4.theblueprint.xyz",
    "delegateOwnerWallet": "0xA815f8108C2772D24D7DCB866c861148f043224D"
  }, {
    "endpoint": "https://audius-creator-5.theblueprint.xyz",
    "delegateOwnerWallet": "0x65Fe5BEf65A0E0b0520d6beE7767ea6Da7f792f6"
  }, {
    "endpoint": "https://audius-creator-6.theblueprint.xyz",
    "delegateOwnerWallet": "0x19B026B0f0Dbf619DBf8C4Efb0190308ace56366"
  }, {
    "endpoint": "https://creatornode.audius8.prod-eks-ap-northeast-1.staked.cloud",
    "delegateOwnerWallet": "0xc69F344FCDbc9D747559c968562f682ABfBa442C"
  }],
  "web3ProviderUrl": "https://poa-gateway.audius.co",
  "entityManagerContractAddress": "0x1Cd8a543596D499B9b6E7a6eC15ECd2B7857Fd64",
  "identityServiceUrl": "https://identityservice.audius.co"
};

var DEFAULT_LOG_LEVEL = 'warn';
var DEFAULT_LOG_PREFIX = '[audius-sdk]';
var logLevels = ['debug', 'info', 'warn', 'error'];
var Logger = /*#__PURE__*/function () {
  function Logger(config) {
    var _config$logLevel, _config$logPrefix;

    _classCallCheck(this, Logger);

    _defineProperty$1(this, "logLevel", void 0);

    _defineProperty$1(this, "logPrefix", '[audius-sdk]');

    this.logLevel = (_config$logLevel = config === null || config === void 0 ? void 0 : config.logLevel) !== null && _config$logLevel !== void 0 ? _config$logLevel : DEFAULT_LOG_LEVEL;
    this.logPrefix = (_config$logPrefix = config === null || config === void 0 ? void 0 : config.logPrefix) !== null && _config$logPrefix !== void 0 ? _config$logPrefix : DEFAULT_LOG_PREFIX;
  }

  _createClass(Logger, [{
    key: "createPrefixedLogger",
    value: function createPrefixedLogger(logPrefix) {
      return new Logger({
        logLevel: this.logLevel,
        logPrefix: "".concat(this.logPrefix).concat(logPrefix)
      });
    }
  }, {
    key: "debug",
    value: function debug() {
      var _console;

      if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('debug')) {
        return;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_console = console).debug.apply(_console, [this.logPrefix].concat(args));
    }
  }, {
    key: "info",
    value: function info() {
      var _console2;

      if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('info')) {
        return;
      }

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      (_console2 = console).info.apply(_console2, [this.logPrefix].concat(args));
    }
  }, {
    key: "warn",
    value: function warn() {
      var _console3;

      if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('warn')) {
        return;
      }

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      (_console3 = console).warn.apply(_console3, [this.logPrefix].concat(args));
    }
  }, {
    key: "error",
    value: function error() {
      var _console4;

      if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('error')) {
        return;
      }

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      (_console4 = console).error.apply(_console4, [this.logPrefix].concat(args));
    }
  }]);

  return Logger;
}();

/**
 * The name of the service for Discovery Node
 */

var DISCOVERY_SERVICE_NAME = 'discovery-node';
var defaultDiscoveryNodeSelectorConfig = {
  initialSelectedNode: null,
  blocklist: null,
  allowlist: null,
  maxConcurrentRequests: 6,
  requestTimeout: 30000,
  unhealthyTTL: 3600000,
  backupsTTL: 120000,
  healthCheckThresholds: {
    minVersion: servicesConfig.minVersion,
    maxSlotDiffPlays: null,
    maxBlockDiff: 15
  },
  bootstrapServices: servicesConfig.discoveryNodes,
  logger: new Logger()
};

var isFullFlaskResponse = function isFullFlaskResponse(data) {
  return data.version !== undefined;
};
var isCommsResponse = function isCommsResponse(data) {
  return data.health !== undefined;
};

var isIndexerHealthy = function isIndexerHealthy(_ref) {
  var data = _ref.data,
      maxBlockDiff = _ref.maxBlockDiff;
  return data.block_difference === undefined || data.block_difference === null || data.block_difference <= maxBlockDiff;
};

var isApiIndexerHealthy = function isApiIndexerHealthy(_ref2) {
  var data = _ref2.data,
      maxBlockDiff = _ref2.maxBlockDiff;
  return data.latest_chain_block === null || data.latest_indexed_block === null || data.latest_chain_block === undefined || data.latest_indexed_block === undefined || data.latest_chain_block - data.latest_indexed_block <= maxBlockDiff;
};

var isSolanaIndexerHealthy = function isSolanaIndexerHealthy(_ref3) {
  var _data$plays, _data$rewards_manager, _data$spl_audio_info, _data$user_bank, _data$plays2, _data$plays2$tx_info, _data$plays3, _data$plays3$tx_info;

  var data = _ref3.data,
      maxSlotDiffPlays = _ref3.maxSlotDiffPlays;
  return !((_data$plays = data.plays) !== null && _data$plays !== void 0 && _data$plays.is_unhealthy) && !((_data$rewards_manager = data.rewards_manager) !== null && _data$rewards_manager !== void 0 && _data$rewards_manager.is_unhealthy) && !((_data$spl_audio_info = data.spl_audio_info) !== null && _data$spl_audio_info !== void 0 && _data$spl_audio_info.is_unhealthy) && !((_data$user_bank = data.user_bank) !== null && _data$user_bank !== void 0 && _data$user_bank.is_unhealthy) && (!((_data$plays2 = data.plays) !== null && _data$plays2 !== void 0 && (_data$plays2$tx_info = _data$plays2.tx_info) !== null && _data$plays2$tx_info !== void 0 && _data$plays2$tx_info.slot_diff) || maxSlotDiffPlays === null || ((_data$plays3 = data.plays) === null || _data$plays3 === void 0 ? void 0 : (_data$plays3$tx_info = _data$plays3.tx_info) === null || _data$plays3$tx_info === void 0 ? void 0 : _data$plays3$tx_info.slot_diff) <= maxSlotDiffPlays);
};

var isApiSolanaIndexerHealthy = function isApiSolanaIndexerHealthy(_ref4) {
  var data = _ref4.data,
      maxSlotDiffPlays = _ref4.maxSlotDiffPlays;
  return !maxSlotDiffPlays || !data.latest_chain_slot_plays || !data.latest_indexed_slot_plays || data.latest_chain_slot_plays - data.latest_indexed_slot_plays <= maxSlotDiffPlays;
}; // const isApiCommsHealthy = ({ data }: { data: CommsResponse }) => {
//   return data.health?.is_healthy
// }


var parseApiHealthStatusReason = function parseApiHealthStatusReason(_ref5) {
  var data = _ref5.data,
      _ref5$healthCheckThre = _ref5.healthCheckThresholds,
      minVersion = _ref5$healthCheckThre.minVersion,
      maxBlockDiff = _ref5$healthCheckThre.maxBlockDiff,
      maxSlotDiffPlays = _ref5$healthCheckThre.maxSlotDiffPlays;

  if (isFullFlaskResponse(data)) {
    var _data$version;

    if (((_data$version = data.version) === null || _data$version === void 0 ? void 0 : _data$version.service) !== DISCOVERY_SERVICE_NAME) {
      return {
        health: HealthCheckStatus.UNHEALTHY,
        reason: 'name'
      };
    }

    if (minVersion) {
      if (!data.version.version) {
        return {
          health: HealthCheckStatus.UNHEALTHY,
          reason: 'version'
        };
      }

      if (semver.lt(data.version.version, minVersion)) {
        return {
          health: HealthCheckStatus.BEHIND,
          reason: 'version'
        };
      }
    }

    if (!isApiIndexerHealthy({
      data: data,
      maxBlockDiff: maxBlockDiff
    })) {
      return {
        health: HealthCheckStatus.BEHIND,
        reason: 'block diff'
      };
    }

    if (!isApiSolanaIndexerHealthy({
      data: data,
      maxSlotDiffPlays: maxSlotDiffPlays
    })) {
      return {
        health: HealthCheckStatus.BEHIND,
        reason: 'slot diff'
      };
    }
  } else if (isCommsResponse(data)) ;

  return {
    health: HealthCheckStatus.HEALTHY
  };
};

var getHealthCheckData = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(endpoint, fetchOptions) {
    var healthCheckURL, data, comms, response, json;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            healthCheckURL = "".concat(endpoint, "/health_check");
            data = null;
            comms = null;
            _context.next = 5;
            return fetch$1(healthCheckURL, fetchOptions);

          case 5:
            response = _context.sent;

            if (response.ok) {
              _context.next = 8;
              break;
            }

            throw new Error(response.statusText);

          case 8:
            _context.next = 10;
            return response.json();

          case 10:
            json = _context.sent;
            data = json.data;
            comms = json.comms;

            if (data) {
              _context.next = 15;
              break;
            }

            throw new Error('data');

          case 15:
            if (comms) {
              _context.next = 17;
              break;
            }

            throw new Error('comms');

          case 17:
            return _context.abrupt("return", {
              data: data,
              comms: comms
            });

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getHealthCheckData(_x, _x2) {
    return _ref6.apply(this, arguments);
  };
}();

var parseHealthStatusReason = function parseHealthStatusReason(_ref7) {
  var data = _ref7.data,
      comms = _ref7.comms,
      _ref7$healthCheckThre = _ref7.healthCheckThresholds,
      minVersion = _ref7$healthCheckThre.minVersion,
      maxBlockDiff = _ref7$healthCheckThre.maxBlockDiff,
      maxSlotDiffPlays = _ref7$healthCheckThre.maxSlotDiffPlays;

  if (data === null) {
    return {
      health: HealthCheckStatus.UNHEALTHY,
      reason: 'data'
    };
  }

  if (data.service !== DISCOVERY_SERVICE_NAME) {
    return {
      health: HealthCheckStatus.UNHEALTHY,
      reason: 'name'
    };
  }

  if (!(comms !== null && comms !== void 0 && comms.healthy)) {
    return {
      health: HealthCheckStatus.UNHEALTHY,
      reason: 'comms'
    };
  }

  if (minVersion) {
    if (!data.version) {
      return {
        health: HealthCheckStatus.UNHEALTHY,
        reason: 'version'
      };
    }

    if (semver.lt(data.version, minVersion)) {
      return {
        health: HealthCheckStatus.BEHIND,
        reason: 'version'
      };
    }
  }

  if (!isIndexerHealthy({
    data: data,
    maxBlockDiff: maxBlockDiff
  })) {
    return {
      health: HealthCheckStatus.BEHIND,
      reason: 'block diff'
    };
  }

  if (!isSolanaIndexerHealthy({
    data: data,
    maxSlotDiffPlays: maxSlotDiffPlays
  })) {
    return {
      health: HealthCheckStatus.BEHIND,
      reason: 'slot diff'
    };
  }

  return {
    health: HealthCheckStatus.HEALTHY
  };
};
var getDiscoveryNodeHealthCheck = /*#__PURE__*/function () {
  var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref8) {
    var endpoint, healthCheckThresholds, fetchOptions, timeoutMs, timeoutPromises, timeoutPromise, _yield$Promise$race, data, comms, reason;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            endpoint = _ref8.endpoint, healthCheckThresholds = _ref8.healthCheckThresholds, fetchOptions = _ref8.fetchOptions, timeoutMs = _ref8.timeoutMs;
            timeoutPromises = [];

            if (timeoutMs !== undefined) {
              timeoutPromise = new Promise(function (_resolve, reject) {
                return setTimeout(function () {
                  return reject(new Error('timeout'));
                }, timeoutMs);
              });
              timeoutPromises.push(timeoutPromise);
            }

            _context2.prev = 3;
            _context2.next = 6;
            return Promise.race([getHealthCheckData(endpoint, fetchOptions)].concat(timeoutPromises));

          case 6:
            _yield$Promise$race = _context2.sent;
            data = _yield$Promise$race.data;
            comms = _yield$Promise$race.comms;
            reason = parseHealthStatusReason({
              data: data,
              comms: comms,
              healthCheckThresholds: healthCheckThresholds
            });
            return _context2.abrupt("return", _objectSpread2(_objectSpread2({}, reason), {}, {
              data: data
            }));

          case 13:
            _context2.prev = 13;
            _context2.t0 = _context2["catch"](3);
            return _context2.abrupt("return", {
              health: HealthCheckStatus.UNHEALTHY,
              reason: _context2.t0 === null || _context2.t0 === void 0 ? void 0 : _context2.t0.message,
              data: null
            });

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 13]]);
  }));

  return function getDiscoveryNodeHealthCheck(_x3) {
    return _ref9.apply(this, arguments);
  };
}();

/**
 * Polyfill for Promise.any
 * Adapted from Sergio Tskhovrebov's implementation:
 * https://dev.to/sinxwal/looking-for-promise-any-let-s-quickly-implement-a-polyfill-for-it-1kga
 */
var promiseAny = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(iterable) {
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!Promise.any) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt("return", Promise.any(iterable));

          case 2:
            _context4.next = 4;
            return Promise.all(_toConsumableArray(iterable).map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(promise) {
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return new Promise(function (resolve, reject) {
                          Promise.resolve(promise).then(reject, resolve);
                        });

                      case 2:
                        return _context.abrupt("return", _context.sent);

                      case 3:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x2) {
                return _ref2.apply(this, arguments);
              };
            }())).then( /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(errors) {
                return regeneratorRuntime.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return Promise.reject(errors);

                      case 2:
                        return _context2.abrupt("return", _context2.sent);

                      case 3:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));

              return function (_x3) {
                return _ref3.apply(this, arguments);
              };
            }(), /*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(value) {
                return regeneratorRuntime.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.next = 2;
                        return Promise.resolve(value);

                      case 2:
                        return _context3.abrupt("return", _context3.sent);

                      case 3:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function (_x4) {
                return _ref4.apply(this, arguments);
              };
            }());

          case 4:
            return _context4.abrupt("return", _context4.sent);

          case 5:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function promiseAny(_x) {
    return _ref.apply(this, arguments);
  };
}();

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */

function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}

var _listCacheClear = listCacheClear$1;

var eq$2 = eq_1;
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function assocIndexOf$4(array, key) {
  var length = array.length;

  while (length--) {
    if (eq$2(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

var _assocIndexOf = assocIndexOf$4;

var assocIndexOf$3 = _assocIndexOf;
/** Used for built-in method references. */

var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete$1(key) {
  var data = this.__data__,
      index = assocIndexOf$3(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

var _listCacheDelete = listCacheDelete$1;

var assocIndexOf$2 = _assocIndexOf;
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function listCacheGet$1(key) {
  var data = this.__data__,
      index = assocIndexOf$2(data, key);
  return index < 0 ? undefined : data[index][1];
}

var _listCacheGet = listCacheGet$1;

var assocIndexOf$1 = _assocIndexOf;
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}

var _listCacheHas = listCacheHas$1;

var assocIndexOf = _assocIndexOf;
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */

function listCacheSet$1(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

var _listCacheSet = listCacheSet$1;

var listCacheClear = _listCacheClear,
    listCacheDelete = _listCacheDelete,
    listCacheGet = _listCacheGet,
    listCacheHas = _listCacheHas,
    listCacheSet = _listCacheSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache$4(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype['delete'] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;

var ListCache$3 = _ListCache;
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */

function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}

var _stackClear = stackClear$1;

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function stackDelete$1(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

var _stackDelete = stackDelete$1;

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function stackGet$1(key) {
  return this.__data__.get(key);
}

var _stackGet = stackGet$1;

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function stackHas$1(key) {
  return this.__data__.has(key);
}

var _stackHas = stackHas$1;

var root$2 = _root;
/** Used to detect overreaching core-js shims. */

var coreJsData$1 = root$2['__core-js_shared__'];
var _coreJsData = coreJsData$1;

var coreJsData = _coreJsData;
/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

var _isMasked = isMasked$1;

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$2 = funcProto$2.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

var _toSource = toSource$1;

var isFunction$1 = isFunction_1,
    isMasked = _isMasked,
    isObject$4 = isObject_1,
    toSource = _toSource;
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto$1 = Function.prototype,
    objectProto$5 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$1 = funcProto$1.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$5).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative$1(value) {
  if (!isObject$4(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

var _baseIsNative = baseIsNative$1;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

function getValue$1(object, key) {
  return object == null ? undefined : object[key];
}

var _getValue = getValue$1;

var baseIsNative = _baseIsNative,
    getValue = _getValue;
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */

function getNative$3(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

var _getNative = getNative$3;

var getNative$2 = _getNative,
    root$1 = _root;
/* Built-in method references that are verified to be native. */

var Map$3 = getNative$2(root$1, 'Map');
var _Map = Map$3;

var getNative$1 = _getNative;
/* Built-in method references that are verified to be native. */

var nativeCreate$4 = getNative$1(Object, 'create');
var _nativeCreate = nativeCreate$4;

var nativeCreate$3 = _nativeCreate;
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */

function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}

var _hashClear = hashClear$1;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var _hashDelete = hashDelete$1;

var nativeCreate$2 = _nativeCreate;
/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto$4 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet$1(key) {
  var data = this.__data__;

  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }

  return hasOwnProperty$4.call(data, key) ? data[key] : undefined;
}

var _hashGet = hashGet$1;

var nativeCreate$1 = _nativeCreate;
/** Used for built-in method references. */

var objectProto$3 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$3.call(data, key);
}

var _hashHas = hashHas$1;

var nativeCreate = _nativeCreate;
/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

var _hashSet = hashSet$1;

var hashClear = _hashClear,
    hashDelete = _hashDelete,
    hashGet = _hashGet,
    hashHas = _hashHas,
    hashSet = _hashSet;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash$1(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash$1.prototype.clear = hashClear;
Hash$1.prototype['delete'] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;

var Hash = _Hash,
    ListCache$2 = _ListCache,
    Map$2 = _Map;
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */

function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map$2 || ListCache$2)(),
    'string': new Hash()
  };
}

var _mapCacheClear = mapCacheClear$1;

function isKeyable$1(value) {
  var type = _typeof(value);

  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

var _isKeyable = isKeyable$1;

var isKeyable = _isKeyable;
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */

function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

var _getMapData = getMapData$4;

var getMapData$3 = _getMapData;
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

var _mapCacheDelete = mapCacheDelete$1;

var getMapData$2 = _getMapData;
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}

var _mapCacheGet = mapCacheGet$1;

var getMapData$1 = _getMapData;
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}

var _mapCacheHas = mapCacheHas$1;

var getMapData = _getMapData;
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */

function mapCacheSet$1(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

var _mapCacheSet = mapCacheSet$1;

var mapCacheClear = _mapCacheClear,
    mapCacheDelete = _mapCacheDelete,
    mapCacheGet = _mapCacheGet,
    mapCacheHas = _mapCacheHas,
    mapCacheSet = _mapCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache$1(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache$1.prototype.clear = mapCacheClear;
MapCache$1.prototype['delete'] = mapCacheDelete;
MapCache$1.prototype.get = mapCacheGet;
MapCache$1.prototype.has = mapCacheHas;
MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1;

var ListCache$1 = _ListCache,
    Map$1 = _Map,
    MapCache = _MapCache;
/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet$1(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache$1) {
    var pairs = data.__data__;

    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

var _stackSet = stackSet$1;

var ListCache = _ListCache,
    stackClear = _stackClear,
    stackDelete = _stackDelete,
    stackGet = _stackGet,
    stackHas = _stackHas,
    stackSet = _stackSet;
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Stack$1(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack$1.prototype.clear = stackClear;
Stack$1.prototype['delete'] = stackDelete;
Stack$1.prototype.get = stackGet;
Stack$1.prototype.has = stackHas;
Stack$1.prototype.set = stackSet;
var _Stack = Stack$1;

var getNative = _getNative;

var defineProperty$2 = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

var _defineProperty = defineProperty$2;

var defineProperty$1 = _defineProperty;
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function baseAssignValue$3(object, key, value) {
  if (key == '__proto__' && defineProperty$1) {
    defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

var _baseAssignValue = baseAssignValue$3;

var baseAssignValue$2 = _baseAssignValue,
    eq$1 = eq_1;
/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignMergeValue$2(object, key, value) {
  if (value !== undefined && !eq$1(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}

var _assignMergeValue = assignMergeValue$2;

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

function createBaseFor$1(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

var _createBaseFor = createBaseFor$1;

var createBaseFor = _createBaseFor;
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */

var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;

var _cloneBuffer = {exports: {}};

(function (module, exports) {
  var root = _root;
  /** Detect free variable `exports`. */

  var freeExports = exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Built-in value references. */

  var Buffer = moduleExports ? root.Buffer : undefined,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */

  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }

    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }

  module.exports = cloneBuffer;
})(_cloneBuffer, _cloneBuffer.exports);

var root = _root;
/** Built-in value references. */

var Uint8Array$2 = root.Uint8Array;
var _Uint8Array = Uint8Array$2;

var Uint8Array$1 = _Uint8Array;
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */

function cloneArrayBuffer$1(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}

var _cloneArrayBuffer = cloneArrayBuffer$1;

var cloneArrayBuffer = _cloneArrayBuffer;
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */

function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

var _cloneTypedArray = cloneTypedArray$1;

var isObject$3 = isObject_1;
/** Built-in value references. */

var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate$1 = function () {
  function object() {}

  return function (proto) {
    if (!isObject$3(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

var _baseCreate = baseCreate$1;

var overArg = _overArg;
/** Built-in value references. */

var getPrototype$2 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$2;

var baseCreate = _baseCreate,
    getPrototype$1 = _getPrototype,
    isPrototype$1 = _isPrototype;
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneObject$1(object) {
  return typeof object.constructor == 'function' && !isPrototype$1(object) ? baseCreate(getPrototype$1(object)) : {};
}

var _initCloneObject = initCloneObject$1;

var isArrayLike$1 = isArrayLike_1,
    isObjectLike$1 = isObjectLike_1;
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */

function isArrayLikeObject$1(value) {
  return isObjectLike$1(value) && isArrayLike$1(value);
}

var isArrayLikeObject_1 = isArrayLikeObject$1;

var baseGetTag = _baseGetTag,
    getPrototype = _getPrototype,
    isObjectLike = isObjectLike_1;
/** `Object#toString` result references. */

var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto$2 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject$1(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty$2.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

var isPlainObject_1 = isPlainObject$1;

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

function safeGet$2(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

var _safeGet = safeGet$2;

var baseAssignValue$1 = _baseAssignValue,
    eq = eq_1;
/** Used for built-in method references. */

var objectProto$1 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue$1(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty$1.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue$1(object, key, value);
  }
}

var _assignValue = assignValue$1;

var assignValue = _assignValue,
    baseAssignValue = _baseAssignValue;
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */

function copyObject$1(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

var _copyObject = copyObject$1;

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function nativeKeysIn$1(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

var _nativeKeysIn = nativeKeysIn$1;

var isObject$2 = isObject_1,
    isPrototype = _isPrototype,
    nativeKeysIn = _nativeKeysIn;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn$1(object) {
  if (!isObject$2(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

var _baseKeysIn = baseKeysIn$1;

var arrayLikeKeys = _arrayLikeKeys,
    baseKeysIn = _baseKeysIn,
    isArrayLike = isArrayLike_1;
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */

function keysIn$2(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

var keysIn_1 = keysIn$2;

var copyObject = _copyObject,
    keysIn$1 = keysIn_1;
/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */

function toPlainObject$1(value) {
  return copyObject(value, keysIn$1(value));
}

var toPlainObject_1 = toPlainObject$1;

var assignMergeValue$1 = _assignMergeValue,
    cloneBuffer = _cloneBuffer.exports,
    cloneTypedArray = _cloneTypedArray,
    copyArray = _copyArray,
    initCloneObject = _initCloneObject,
    isArguments = isArguments_1,
    isArray = isArray_1,
    isArrayLikeObject = isArrayLikeObject_1,
    isBuffer = isBuffer$2.exports,
    isFunction = isFunction_1,
    isObject$1 = isObject_1,
    isPlainObject = isPlainObject_1,
    isTypedArray = isTypedArray_1,
    safeGet$1 = _safeGet,
    toPlainObject = toPlainObject_1;
/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key),
      srcValue = safeGet$1(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$1(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue$1(object, key, newValue);
}

var _baseMergeDeep = baseMergeDeep$1;

var Stack = _Stack,
    assignMergeValue = _assignMergeValue,
    baseFor = _baseFor,
    baseMergeDeep = _baseMergeDeep,
    isObject = isObject_1,
    keysIn = keysIn_1,
    safeGet = _safeGet;
/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    stack || (stack = new Stack());

    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

var _baseMerge = baseMerge$1;

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */

function identity$2(value) {
  return value;
}

var identity_1 = identity$2;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */

function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

var _apply = apply$1;

var apply = _apply;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest$1(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

var _overRest = overRest$1;

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */

function constant$1(value) {
  return function () {
    return value;
  };
}

var constant_1 = constant$1;

var constant = constant_1,
    defineProperty = _defineProperty,
    identity$1 = identity_1;
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var baseSetToString$1 = !defineProperty ? identity$1 : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
var _baseSetToString = baseSetToString$1;

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut$1(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

var _shortOut = shortOut$1;

var baseSetToString = _baseSetToString,
    shortOut = _shortOut;
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var setToString$1 = shortOut(baseSetToString);
var _setToString = setToString$1;

var identity = identity_1,
    overRest = _overRest,
    setToString = _setToString;
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */

function baseRest$1(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

var _baseRest = baseRest$1;

var baseRest = _baseRest,
    isIterateeCall = _isIterateeCall;
/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */

function createAssigner$1(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

var _createAssigner = createAssigner$1;

var baseMerge = _baseMerge,
    createAssigner = _createAssigner;
/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */

var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});
var mergeWith_1 = mergeWith;

/**
 * Gets the config with any undefined properties replaced by the defaults
 * @param config the config
 * @param defaults the defaults
 * @returns the merged config with defaults
 */

var mergeConfigWithDefaults = function mergeConfigWithDefaults(config, defaults) {
  return mergeWith_1({}, defaults, config, function (_a, b) {
    if (Array.isArray(b)) {
      return b;
    }

    return undefined;
  });
};

var getPathFromUrl = function getPathFromUrl(url) {
  var pathRegex = /^([a-z]+:\/\/)?(?:www\.)?([^/]+)?(.*)$/;
  var match = url.match(pathRegex);

  if (match !== null && match !== void 0 && match[3]) {
    var path = match[3];
    return path;
  } else {
    throw new Error("Invalid URL, couldn't get path.");
  }
};

var DiscoveryNodeSelector = /*#__PURE__*/function () {
  function DiscoveryNodeSelector(config) {
    var _this$config$allowlis, _this$config$blocklis;

    _classCallCheck(this, DiscoveryNodeSelector);

    _defineProperty$1(this, "services", void 0);

    _defineProperty$1(this, "selectedNode", void 0);

    _defineProperty$1(this, "config", void 0);

    _defineProperty$1(this, "_isBehind", void 0);

    _defineProperty$1(this, "unhealthyServices", void 0);

    _defineProperty$1(this, "backupServices", void 0);

    _defineProperty$1(this, "unhealthyCleanupTimeout", null);

    _defineProperty$1(this, "backupCleanupTimeout", null);

    _defineProperty$1(this, "reselectLock", false);

    _defineProperty$1(this, "eventEmitter", void 0);

    _defineProperty$1(this, "addEventListener", void 0);

    _defineProperty$1(this, "removeEventListener", void 0);

    _defineProperty$1(this, "logger", void 0);

    this.config = mergeConfigWithDefaults(config, defaultDiscoveryNodeSelectorConfig);
    this.services = this.config.bootstrapServices;
    this._isBehind = false;
    this.unhealthyServices = new Set([]);
    this.backupServices = {};
    this.selectedNode = this.config.initialSelectedNode && (!this.config.allowlist || (_this$config$allowlis = this.config.allowlist) !== null && _this$config$allowlis !== void 0 && _this$config$allowlis.has(this.config.initialSelectedNode)) && !((_this$config$blocklis = this.config.blocklist) !== null && _this$config$blocklis !== void 0 && _this$config$blocklis.has(this.config.initialSelectedNode)) ? this.config.initialSelectedNode : null;
    this.eventEmitter = new EventEmitter(); // Potentially need many event listeners for discovery reselection (to prevent race condition)

    this.eventEmitter.setMaxListeners(1000);
    this.addEventListener = this.eventEmitter.addListener.bind(this.eventEmitter);
    this.removeEventListener = this.eventEmitter.removeListener.bind(this.eventEmitter);
    this.logger = this.config.logger.createPrefixedLogger('[discovery-node-selector]');
  }
  /**
   * Updates the config.
   * Note that setting the initial node or bootstrap nodes here does nothing as the service is already initialized.
   * Will force reselections if health check thresholds change (as that might cause the current node to be considered unhealthy)
   * or if the selected node is excluded per allow/blocklists
   */


  _createClass(DiscoveryNodeSelector, [{
    key: "isBehind",
    get:
    /**
     * List of services to select from
     */

    /**
     * Currently selected discovery node
     */

    /**
     * Configuration passed in by consumer (with defaults)
     */

    /**
     * Whether or not we are using a backup, meaning we were
     * unable to select a discovery node that was up-to-date and healthy.
     * Clients may want to consider blocking writes as service may be degraded
     */
    function get() {
      return this._isBehind;
    },
    set: function set(isBehind) {
      if (isBehind && !this._isBehind) {
        this.logger.warn('using behind discovery node', this.selectedNode);
      } else if (!isBehind && this._isBehind) {
        this.logger.info('discovery node no longer behind', this.selectedNode);
      }

      this._isBehind = isBehind;
    }
    /**
     * During selection, services that fail health check will be put in this list
     * so that we try different nodes on new rounds of selection
     */

  }, {
    key: "updateConfig",
    value: function updateConfig(config) {
      this.config = mergeConfigWithDefaults(config, this.config);

      if (this.selectedNode) {
        var _config$blocklist;

        if (config.healthCheckThresholds) {
          this.selectedNode = null;
        } else if (config.allowlist && !config.allowlist.has(this.selectedNode)) {
          this.selectedNode = null;
        } else if ((_config$blocklist = config.blocklist) !== null && _config$blocklist !== void 0 && _config$blocklist.has(this.selectedNode)) {
          this.selectedNode = null;
        }
      }
    }
    /**
     * Returns a middleware that reselects if the current discovery node is behind
     * @returns the middleware
     */

  }, {
    key: "createMiddleware",
    value: function createMiddleware() {
      var _this = this;

      return {
        pre: function () {
          var _pre = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(context) {
            var url, endpoint;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    url = context.url;

                    if (url.startsWith('http')) {
                      _context.next = 6;
                      break;
                    }

                    _context.next = 4;
                    return _this.getSelectedEndpoint();

                  case 4:
                    endpoint = _context.sent;
                    url = "".concat(endpoint).concat(context.url);

                  case 6:
                    return _context.abrupt("return", {
                      url: url,
                      init: context.init
                    });

                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function pre(_x) {
            return _pre.apply(this, arguments);
          }

          return pre;
        }(),
        post: function () {
          var _post = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(context) {
            var response, endpoint, _data$latest_chain_bl, _data$latest_indexed_, _data$version$version, _data$version, responseClone, data, _parseApiHealthStatus, health, reason, blockDiff, version;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    response = context.response;
                    _context2.next = 3;
                    return _this.getSelectedEndpoint();

                  case 3:
                    endpoint = _context2.sent;

                    if (endpoint) {
                      _context2.next = 9;
                      break;
                    }

                    _context2.next = 7;
                    return _this.select(endpoint);

                  case 7:
                    _context2.next = 24;
                    break;

                  case 9:
                    if (!response.ok) {
                      _context2.next = 21;
                      break;
                    }

                    // Even when successful, copy response to read JSON body to
                    // check for signs the DN is unhealthy and reselect if necessary.
                    // This will get the client to pick new discovery providers
                    // if the selected one falls behind, even if requests are succeeding
                    responseClone = response.clone();
                    _context2.next = 13;
                    return responseClone.json();

                  case 13:
                    data = _context2.sent;
                    _parseApiHealthStatus = parseApiHealthStatusReason({
                      data: data,
                      healthCheckThresholds: _this.config.healthCheckThresholds
                    }), health = _parseApiHealthStatus.health, reason = _parseApiHealthStatus.reason;
                    blockDiff = isFullFlaskResponse(data) ? ((_data$latest_chain_bl = data.latest_chain_block) !== null && _data$latest_chain_bl !== void 0 ? _data$latest_chain_bl : 0) - ((_data$latest_indexed_ = data.latest_indexed_block) !== null && _data$latest_indexed_ !== void 0 ? _data$latest_indexed_ : 0) : 0;
                    version = isFullFlaskResponse(data) ? (_data$version$version = (_data$version = data.version) === null || _data$version === void 0 ? void 0 : _data$version.version) !== null && _data$version$version !== void 0 ? _data$version$version : '' : '';
                    _context2.next = 19;
                    return _this.reselectIfNecessary({
                      endpoint: endpoint,
                      health: health,
                      reason: reason,
                      data: {
                        block_difference: blockDiff,
                        version: version
                      }
                    });

                  case 19:
                    _context2.next = 24;
                    break;

                  case 21:
                    _context2.next = 23;
                    return _this.reselectAndRetry({
                      context: context,
                      endpoint: endpoint
                    });

                  case 23:
                    return _context2.abrupt("return", _context2.sent);

                  case 24:
                    return _context2.abrupt("return", response);

                  case 25:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function post(_x2) {
            return _post.apply(this, arguments);
          }

          return post;
        }(),
        onError: function () {
          var _onError = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(context) {
            var endpoint, response;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return _this.getSelectedEndpoint();

                  case 2:
                    endpoint = _context3.sent;
                    response = context.response;

                    if (endpoint) {
                      _context3.next = 9;
                      break;
                    }

                    _context3.next = 7;
                    return _this.select(endpoint);

                  case 7:
                    _context3.next = 12;
                    break;

                  case 9:
                    _context3.next = 11;
                    return _this.reselectAndRetry({
                      context: context,
                      endpoint: endpoint
                    });

                  case 11:
                    return _context3.abrupt("return", _context3.sent);

                  case 12:
                    return _context3.abrupt("return", response);

                  case 13:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));

          function onError(_x3) {
            return _onError.apply(this, arguments);
          }

          return onError;
        }()
      };
    }
    /**
     * Selects a discovery node or returns the existing selection
     * @returns a discovery node endpoint
     */

  }, {
    key: "getSelectedEndpoint",
    value: function () {
      var _getSelectedEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(this.selectedNode !== null)) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return", this.selectedNode);

              case 2:
                _context4.next = 4;
                return this.select(null);

              case 4:
                return _context4.abrupt("return", _context4.sent);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getSelectedEndpoint() {
        return _getSelectedEndpoint.apply(this, arguments);
      }

      return getSelectedEndpoint;
    }()
    /**
     * Gets the list of services
     */

  }, {
    key: "getServices",
    value: function getServices() {
      return this.services;
    }
    /**
     * Finds a healthy discovery node
     * @returns a healthy discovery node endpoint
     */

  }, {
    key: "select",
    value: function () {
      var _select = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(prevSelectedNode) {
        var _this2 = this;

        var decisionTree, services, selectedService, attemptedServicesCount, filteredServices, backup, round;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.reselectLock) {
                  _context5.next = 3;
                  break;
                }

                _context5.next = 3;
                return new Promise(function (resolve) {
                  _this2.eventEmitter.once('reselectAttemptComplete', function () {
                    resolve();
                  });
                });

              case 3:
                if (!(prevSelectedNode !== this.selectedNode && this.selectedNode != null)) {
                  _context5.next = 5;
                  break;
                }

                return _context5.abrupt("return", this.selectedNode);

              case 5:
                this.reselectLock = true;
                _context5.prev = 6;
                this.logger.debug('Selecting new discovery node...');
                decisionTree = []; // Get all the services we have

                services = _toConsumableArray(this.services);
                decisionTree.push({
                  stage: DECISION_TREE_STATE.GET_ALL_SERVICES,
                  val: services
                }); // If a whitelist is provided, filter down to it

                if (this.config.allowlist) {
                  services = services.filter(function (s) {
                    var _this2$config$allowli;

                    return (_this2$config$allowli = _this2.config.allowlist) === null || _this2$config$allowli === void 0 ? void 0 : _this2$config$allowli.has(s);
                  });
                  decisionTree.push({
                    stage: DECISION_TREE_STATE.FILTER_TO_WHITELIST,
                    val: services
                  });
                } // if a blacklist is provided, filter out services in the list


                if (this.config.blocklist) {
                  services = services.filter(function (s) {
                    var _this2$config$blockli;

                    return !((_this2$config$blockli = _this2.config.blocklist) !== null && _this2$config$blockli !== void 0 && _this2$config$blockli.has(s));
                  });
                  decisionTree.push({
                    stage: DECISION_TREE_STATE.FILTER_FROM_BLACKLIST,
                    val: services
                  });
                }

                selectedService = null;
                attemptedServicesCount = 0; // Loop until a healthy node is found, batching health_check requests by maxConcurrentRequests

              case 15:
                if (!(selectedService === null)) {
                  _context5.next = 44;
                  break;
                }

                // Filter out anything we know is already unhealthy
                filteredServices = services.filter(function (s) {
                  return !_this2.unhealthyServices.has(s);
                });
                decisionTree.push({
                  stage: DECISION_TREE_STATE.FILTER_OUT_KNOWN_UNHEALTHY,
                  val: filteredServices
                }); // If there are no services left to try, either pick a backup or return null

                if (!(filteredServices.length === 0)) {
                  _context5.next = 35;
                  break;
                }

                decisionTree.push({
                  stage: DECISION_TREE_STATE.NO_SERVICES_LEFT_TO_TRY
                });

                if (!(Object.keys(this.backupServices).length > 0)) {
                  _context5.next = 30;
                  break;
                }

                _context5.next = 23;
                return this.selectFromBackups();

              case 23:
                backup = _context5.sent;
                decisionTree.push({
                  stage: DECISION_TREE_STATE.SELECTED_FROM_BACKUP,
                  val: backup
                });
                this.selectedNode = backup;
                this.isBehind = true;
                return _context5.abrupt("return", backup);

              case 30:
                // Nothing could be found that was healthy.
                // Reset everything we know so that we might try again.
                this.unhealthyServices = new Set([]);
                this.backupServices = {};
                decisionTree.push({
                  stage: DECISION_TREE_STATE.FAILED_AND_RESETTING
                });
                this.logger.error('Failed to select discovery node', decisionTree);
                return _context5.abrupt("return", null);

              case 35:
                // Randomly sample a "round" to test
                round = sampleSize_1(filteredServices, this.config.maxConcurrentRequests);
                decisionTree.push({
                  stage: DECISION_TREE_STATE.GET_SELECTION_ROUND,
                  val: round
                }); // Race this "round" of services to find the quickest healthy node

                _context5.next = 39;
                return this.anyHealthyEndpoint(round);

              case 39:
                selectedService = _context5.sent;
                attemptedServicesCount += round.length; // Retry if none were found

                if (!selectedService) {
                  decisionTree.push({
                    stage: DECISION_TREE_STATE.ROUND_FAILED_RETRY
                  });
                  this.logger.debug('No healthy services found. Attempting another round...', {
                    attemptedServicesCount: attemptedServicesCount
                  });
                }

                _context5.next = 15;
                break;

              case 44:
                // Trigger a cleanup event for all of the unhealthy and backup services,
                // so they can get retried in the future
                this.triggerCleanup();
                decisionTree.push({
                  stage: DECISION_TREE_STATE.MADE_A_SELECTION,
                  val: selectedService
                }); // If we made it this far, we found the best service! (of the rounds we tried)

                if (selectedService) {
                  this.selectedNode = selectedService;
                  this.eventEmitter.emit('change', selectedService);
                }

                this.logger.info("Selected discprov ".concat(selectedService), decisionTree, {
                  attemptedServicesCount: attemptedServicesCount
                });
                this.isBehind = false;
                return _context5.abrupt("return", this.selectedNode);

              case 50:
                _context5.prev = 50;
                this.reselectLock = false;
                this.eventEmitter.emit('reselectAttemptComplete');
                return _context5.finish(50);

              case 54:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[6,, 50, 54]]);
      }));

      function select(_x4) {
        return _select.apply(this, arguments);
      }

      return select;
    }()
    /**
     * Checks to see if any of the endpoints are healthy, returning the first one that is.
     * Cancels the remaining promises.
     * Uses the configured timeout.
     * Any unhealthy or behind services found are placed into the unhealthy and backup lists respectively
     *
     * @param endpoints the endpoints to race
     * @returns the fastest healthy endpoint or null if none are healthy
     */

  }, {
    key: "anyHealthyEndpoint",
    value: function () {
      var _anyHealthyEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(endpoints) {
        var _this3 = this;

        var abortController, requestPromises;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                abortController = new AbortController();
                requestPromises = endpoints.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(endpoint) {
                    var _yield$getDiscoveryNo, health, data, reason, _data$network;

                    return regeneratorRuntime.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.next = 2;
                            return getDiscoveryNodeHealthCheck({
                              endpoint: endpoint,
                              fetchOptions: {
                                signal: abortController.signal
                              },
                              timeoutMs: _this3.config.requestTimeout,
                              healthCheckThresholds: _this3.config.healthCheckThresholds
                            });

                          case 2:
                            _yield$getDiscoveryNo = _context6.sent;
                            health = _yield$getDiscoveryNo.health;
                            data = _yield$getDiscoveryNo.data;
                            reason = _yield$getDiscoveryNo.reason;

                            if (!(health !== HealthCheckStatus.HEALTHY)) {
                              _context6.next = 11;
                              break;
                            }

                            if (reason !== null && reason !== void 0 && reason.toLowerCase().includes('aborted')) {
                              // Ignore aborted requests
                              _this3.logger.debug('health_check', endpoint, health, reason);
                            } else if (health === HealthCheckStatus.UNHEALTHY) {
                              _this3.unhealthyServices.add(endpoint);

                              _this3.logger.debug('health_check', endpoint, health, reason);
                            } else if (health === HealthCheckStatus.BEHIND) {
                              _this3.unhealthyServices.add(endpoint);

                              if (data) {
                                _this3.backupServices[endpoint] = {
                                  endpoint: endpoint,
                                  block_difference: data.block_difference,
                                  version: data.version
                                };
                              }

                              _this3.logger.debug('health_check', endpoint, health, reason);
                            }

                            throw new Error("".concat(endpoint, " ").concat(health, ": ").concat(reason));

                          case 11:
                            // We're healthy!
                            _this3.logger.debug('health_check', endpoint, health); // Cancel any existing requests from other promises


                            abortController.abort(); // Refresh service list with the healthy list from DN

                            if (data !== null && data !== void 0 && (_data$network = data.network) !== null && _data$network !== void 0 && _data$network.discovery_nodes && data.network.discovery_nodes.length > 0) {
                              _this3.services = data.network.discovery_nodes;
                            } else {
                              _this3.logger.warn("Couldn't load new service list from healthy service", endpoint);
                            }

                            return _context6.abrupt("return", endpoint);

                          case 15:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6);
                  }));

                  return function (_x6) {
                    return _ref.apply(this, arguments);
                  };
                }());
                _context7.prev = 2;
                _context7.next = 5;
                return promiseAny(requestPromises);

              case 5:
                return _context7.abrupt("return", _context7.sent);

              case 8:
                _context7.prev = 8;
                _context7.t0 = _context7["catch"](2);
                this.logger.error('No healthy nodes', _context7.t0);
                return _context7.abrupt("return", null);

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[2, 8]]);
      }));

      function anyHealthyEndpoint(_x5) {
        return _anyHealthyEndpoint.apply(this, arguments);
      }

      return anyHealthyEndpoint;
    }()
    /**
     * Checks the given endpoint's health check and reselects if necessary.
     * @param endpoint the endpoint to health_check
     * @returns a new discovery node if reselect was necessary, or the existing endpoint if reselect unnecessary
     */

  }, {
    key: "reselectIfNecessary",
    value: function () {
      var _reselectIfNecessary = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(_ref2) {
        var endpoint, health, reason, data;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                endpoint = _ref2.endpoint, health = _ref2.health, reason = _ref2.reason, data = _ref2.data;

                if (!(health === HealthCheckStatus.HEALTHY)) {
                  _context8.next = 6;
                  break;
                }

                this.isBehind = false;
                return _context8.abrupt("return", endpoint);

              case 6:
                if (!(this.isBehind && HealthCheckStatus.BEHIND)) {
                  _context8.next = 10;
                  break;
                }

                return _context8.abrupt("return", endpoint);

              case 10:
                if (health === HealthCheckStatus.UNHEALTHY || !data) {
                  this.unhealthyServices.add(endpoint);
                } else if (health === HealthCheckStatus.BEHIND) {
                  this.backupServices[endpoint] = {
                    endpoint: endpoint,
                    block_difference: data.block_difference,
                    version: data.version
                  };
                }

                this.logger.warn('api_health_check failed, reselecting', endpoint, health, reason);
                _context8.next = 14;
                return this.select(endpoint);

              case 14:
                return _context8.abrupt("return", _context8.sent);

              case 15:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function reselectIfNecessary(_x7) {
        return _reselectIfNecessary.apply(this, arguments);
      }

      return reselectIfNecessary;
    }()
    /**
     * Sets (or resets) a setTimeout to reset the backup and unhealthy service lists
     */

  }, {
    key: "triggerCleanup",
    value: function triggerCleanup() {
      var _this4 = this;

      if (this.unhealthyCleanupTimeout) {
        clearTimeout(this.unhealthyCleanupTimeout);
      }

      if (this.backupCleanupTimeout) {
        clearTimeout(this.backupCleanupTimeout);
      }

      this.unhealthyCleanupTimeout = setTimeout(function () {
        _this4.unhealthyServices = new Set([]);
      }, this.config.unhealthyTTL);
      this.backupCleanupTimeout = setTimeout(function () {
        _this4.backupServices = {};
      }, this.config.backupsTTL);
    }
    /**
     * First try to get a node that's got a healthy blockdiff, but a behind version.
     * If that fails, get the node with the lowest blockdiff on the most up to date version
     */

  }, {
    key: "selectFromBackups",
    value: function () {
      var _selectFromBackups = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var _this5 = this,
            _goodBlockdiffBadVers;

        var sortedBackups, goodBlockdiffBadVersion, nextBest;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                sortedBackups = Object.values(this.backupServices).sort(function (a, b) {
                  var versionSort = semver.rcompare(a.version, b.version);

                  if (versionSort === 0) {
                    return a.block_difference - b.block_difference;
                  }

                  return versionSort;
                });
                goodBlockdiffBadVersion = sortedBackups.find(function (s) {
                  return s.block_difference <= _this5.config.healthCheckThresholds.maxBlockDiff;
                });
                nextBest = sortedBackups[0];

                if (!(!goodBlockdiffBadVersion && nextBest)) {
                  _context9.next = 5;
                  break;
                }

                return _context9.abrupt("return", nextBest.endpoint);

              case 5:
                return _context9.abrupt("return", (_goodBlockdiffBadVers = goodBlockdiffBadVersion === null || goodBlockdiffBadVersion === void 0 ? void 0 : goodBlockdiffBadVersion.endpoint) !== null && _goodBlockdiffBadVers !== void 0 ? _goodBlockdiffBadVers : null);

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function selectFromBackups() {
        return _selectFromBackups.apply(this, arguments);
      }

      return selectFromBackups;
    }()
  }, {
    key: "reselectAndRetry",
    value: function () {
      var _reselectAndRetry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(_ref3) {
        var _data$block_differenc, _data$version2;

        var context, endpoint, _yield$getDiscoveryNo2, health, data, reason, newEndpoint, path;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                context = _ref3.context, endpoint = _ref3.endpoint;
                // On request failure, check health_check and reselect if unhealthy
                this.logger.warn('request failed', endpoint, context);
                _context10.next = 4;
                return getDiscoveryNodeHealthCheck({
                  endpoint: endpoint,
                  healthCheckThresholds: this.config.healthCheckThresholds
                });

              case 4:
                _yield$getDiscoveryNo2 = _context10.sent;
                health = _yield$getDiscoveryNo2.health;
                data = _yield$getDiscoveryNo2.data;
                reason = _yield$getDiscoveryNo2.reason;
                _context10.next = 10;
                return this.reselectIfNecessary({
                  endpoint: endpoint,
                  health: health,
                  reason: reason,
                  data: {
                    block_difference: (_data$block_differenc = data === null || data === void 0 ? void 0 : data.block_difference) !== null && _data$block_differenc !== void 0 ? _data$block_differenc : 0,
                    version: (_data$version2 = data === null || data === void 0 ? void 0 : data.version) !== null && _data$version2 !== void 0 ? _data$version2 : ''
                  }
                });

              case 10:
                newEndpoint = _context10.sent;

                if (!(newEndpoint && newEndpoint !== endpoint)) {
                  _context10.next = 22;
                  break;
                }

                _context10.prev = 12;
                path = getPathFromUrl(context.url); // Retry once on new endpoint

                _context10.next = 16;
                return context.fetch("".concat(newEndpoint).concat(path), context.init);

              case 16:
                return _context10.abrupt("return", _context10.sent);

              case 19:
                _context10.prev = 19;
                _context10.t0 = _context10["catch"](12);
                this.logger.error('Retry on new node failed', newEndpoint);

              case 22:
                return _context10.abrupt("return", undefined);

              case 23:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[12, 19]]);
      }));

      function reselectAndRetry(_x8) {
        return _reselectAndRetry.apply(this, arguments);
      }

      return reselectAndRetry;
    }()
  }]);

  return DiscoveryNodeSelector;
}();

var Web3;

if (typeof window !== 'undefined' && window && window.Web3) {
  Web3 = window.Web3;
} else {
  Web3 = require$$0;
}

var LibsWeb3 = Web3;

var getSendMethod = function getSendMethod(provider) {
  if ('sendAsync' in provider) {
    return provider.sendAsync;
  }

  return provider.send;
};
/**
 * web3 consumes a provider object on initialization
 * ref: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3/types/index.d.ts#L31
 * which references: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3-core/types/index.d.ts#L436
 * MultiProvider implements HttpProvider which can be consumed by web3
 * ref for HttpProvider: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3-providers-http/types/index.d.ts#L46-L66
 */


var MultiProvider = /*#__PURE__*/function (_Web3$providers$HttpP) {
  _inherits(MultiProvider, _Web3$providers$HttpP);

  var _super = _createSuper(MultiProvider);

  /**
   * Creates a MultiProvider
   * @param {Array<string | Provider> | string} - The providers to use.
   */
  function MultiProvider(providers) {
    var _web3ProviderInstance;

    var _this;

    _classCallCheck(this, MultiProvider);

    var web3Providers;

    if (typeof providers === 'string') {
      web3Providers = providers.split(',');
    } else if (!Array.isArray(providers)) {
      web3Providers = [providers];
    } else {
      web3Providers = providers;
    } // The below line ensures that we support different types of providers i.e. comma separated strings, an array of strings or an array of providers.


    var web3ProviderInstances = web3Providers.map(function (provider) {
      return new LibsWeb3(provider).eth.currentProvider;
    });
    _this = _super.call(this, (_web3ProviderInstance = web3ProviderInstances[0]) === null || _web3ProviderInstance === void 0 ? void 0 : _web3ProviderInstance.host);

    _defineProperty$1(_assertThisInitialized(_this), "providers", void 0);

    if (!web3ProviderInstances.every(getSendMethod)) {
      throw new Error('Some providers do not have a send method to use.');
    }

    _this.providers = web3ProviderInstances; // We replace HttpProvider.send with a custom function that supports fallback providers.

    _this.send = callbackify(_this._send.bind(_assertThisInitialized(_this))); // web3 only supports callback functions and not async

    return _this;
  }
  /**
   * @method _send
   * @param {Object} payload
   */


  _createClass(MultiProvider, [{
    key: "_send",
    value: function () {
      var _send2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(payload) {
        var _iterator, _step, provider, send, result;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _iterator = _createForOfIteratorHelper(shuffle(this.providers));
                _context.prev = 1;

                _iterator.s();

              case 3:
                if ((_step = _iterator.n()).done) {
                  _context.next = 18;
                  break;
                }

                provider = _step.value;
                _context.prev = 5;
                send = promisify(getSendMethod(provider).bind(provider));
                _context.next = 9;
                return send(payload);

              case 9:
                result = _context.sent;
                return _context.abrupt("return", result);

              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](5);
                console.log(_context.t0);

              case 16:
                _context.next = 3;
                break;

              case 18:
                _context.next = 23;
                break;

              case 20:
                _context.prev = 20;
                _context.t1 = _context["catch"](1);

                _iterator.e(_context.t1);

              case 23:
                _context.prev = 23;

                _iterator.f();

                return _context.finish(23);

              case 26:
                throw new Error('All requests failed');

              case 27:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 20, 23, 26], [5, 13]]);
      }));

      function _send(_x) {
        return _send2.apply(this, arguments);
      }

      return _send;
    }()
  }]);

  return MultiProvider;
}(LibsWeb3.providers.HttpProvider);

var uuid = function uuid() {
  // https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/873856#873856
  var s = [];
  var hexDigits = '0123456789abcdef';

  for (var i = 0; i < 36; i++) {
    s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
  }

  s[14] = '4'; // bits 12-15 of the time_hi_and_version field to 0010

  s[19] = hexDigits.substr(s[19] | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01

  s[8] = s[13] = s[18] = s[23] = '-';
  var uuid = s.join('');
  return uuid;
};

var encode_1 = encode$1;
var MSB = 128,
    REST = 127,
    MSBALL = ~REST,
    INT = Math.pow(2, 31);

function encode$1(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;

  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }

  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }

  out[offset] = num | 0;
  encode$1.bytes = offset - oldOffset + 1;
  return out;
}

var decode$2 = read;
var MSB$1 = 128,
    REST$1 = 127;

function read(buf, offset) {
  var res = 0,
      offset = offset || 0,
      shift = 0,
      counter = offset,
      b,
      l = buf.length;

  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError('Could not decode varint');
    }

    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);

  read.bytes = counter - offset;
  return res;
}

var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);

var length = function length(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};

var varint = {
  encode: encode_1,
  decode: decode$2,
  encodingLength: length
};
var _brrp_varint = varint;

var decode$1 = function decode(data) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var code = _brrp_varint.decode(data, offset);
  return [code, _brrp_varint.decode.bytes];
};
var encodeTo = function encodeTo(_int, target) {
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  _brrp_varint.encode(_int, target, offset);
  return target;
};
var encodingLength = function encodingLength(_int2) {
  return _brrp_varint.encodingLength(_int2);
};

var equals$1 = function equals(aa, bb) {
  if (aa === bb) return true;

  if (aa.byteLength !== bb.byteLength) {
    return false;
  }

  for (var ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }

  return true;
};

var coerce = function coerce(o) {
  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o;
  if (o instanceof ArrayBuffer) return new Uint8Array(o);

  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }

  throw new Error('Unknown type, must be binary type');
};

var create = function create(code, digest) {
  var size = digest.byteLength;
  var sizeOffset = encodingLength(code);
  var digestOffset = sizeOffset + encodingLength(size);
  var bytes = new Uint8Array(digestOffset + size);
  encodeTo(code, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest(code, size, digest, bytes);
};
var decode = function decode(multihash) {
  var bytes = coerce(multihash);

  var _varint$decode = decode$1(bytes),
      _varint$decode2 = _slicedToArray(_varint$decode, 2),
      code = _varint$decode2[0],
      sizeOffset = _varint$decode2[1];

  var _varint$decode3 = decode$1(bytes.subarray(sizeOffset)),
      _varint$decode4 = _slicedToArray(_varint$decode3, 2),
      size = _varint$decode4[0],
      digestOffset = _varint$decode4[1];

  var digest = bytes.subarray(sizeOffset + digestOffset);

  if (digest.byteLength !== size) {
    throw new Error('Incorrect length');
  }

  return new Digest(code, size, digest, bytes);
};
var equals = function equals(a, b) {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && equals$1(a.bytes, b.bytes);
  }
};
var Digest = /*#__PURE__*/_createClass(function Digest(code, size, digest, bytes) {
  _classCallCheck(this, Digest);

  this.code = code;
  this.size = size;
  this.digest = digest;
  this.bytes = bytes;
});

function base(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError('Alphabet too long');
  }

  var BASE_MAP = new Uint8Array(256);

  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }

  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);

    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + ' is ambiguous');
    }

    BASE_MAP[xc] = i;
  }

  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);

  function encode(source) {
    if (source instanceof Uint8Array) ;else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }

    if (!(source instanceof Uint8Array)) {
      throw new TypeError('Expected Uint8Array');
    }

    if (source.length === 0) {
      return '';
    }

    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;

    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }

    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);

    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i = 0;

      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }

      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }

      length = i;
      pbegin++;
    }

    var it2 = size - length;

    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }

    var str = LEADER.repeat(zeroes);

    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }

    return str;
  }

  function decodeUnsafe(source) {
    if (typeof source !== 'string') {
      throw new TypeError('Expected String');
    }

    if (source.length === 0) {
      return new Uint8Array();
    }

    var psz = 0;

    if (source[psz] === ' ') {
      return;
    }

    var zeroes = 0;
    var length = 0;

    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }

    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);

    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];

      if (carry === 255) {
        return;
      }

      var i = 0;

      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }

      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }

      length = i;
      psz++;
    }

    if (source[psz] === ' ') {
      return;
    }

    var it4 = size - length;

    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }

    var vch = new Uint8Array(zeroes + (size - it4));
    var j = zeroes;

    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }

    return vch;
  }

  function decode(string) {
    var buffer = decodeUnsafe(string);

    if (buffer) {
      return buffer;
    }

    throw new Error("Non-".concat(name, " character"));
  }

  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  };
}

var src = base;
var _brrp__multiformats_scope_baseX = src;

var Encoder = /*#__PURE__*/function () {
  function Encoder(name, prefix, baseEncode) {
    _classCallCheck(this, Encoder);

    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }

  _createClass(Encoder, [{
    key: "encode",
    value: function encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return "".concat(this.prefix).concat(this.baseEncode(bytes));
      } else {
        throw Error('Unknown type, must be binary type');
      }
    }
  }]);

  return Encoder;
}();

var Decoder = /*#__PURE__*/function () {
  function Decoder(name, prefix, baseDecode) {
    _classCallCheck(this, Decoder);

    this.name = name;
    this.prefix = prefix;

    if (prefix.codePointAt(0) === undefined) {
      throw new Error('Invalid prefix character');
    }

    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }

  _createClass(Decoder, [{
    key: "decode",
    value: function decode(text) {
      if (typeof text === 'string') {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error("Unable to decode multibase string ".concat(JSON.stringify(text), ", ").concat(this.name, " decoder only supports inputs prefixed with ").concat(this.prefix));
        }

        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error('Can only multibase decode strings');
      }
    }
  }, {
    key: "or",
    value: function or(decoder) {
      return _or(this, decoder);
    }
  }]);

  return Decoder;
}();

var ComposedDecoder = /*#__PURE__*/function () {
  function ComposedDecoder(decoders) {
    _classCallCheck(this, ComposedDecoder);

    this.decoders = decoders;
  }

  _createClass(ComposedDecoder, [{
    key: "or",
    value: function or(decoder) {
      return _or(this, decoder);
    }
  }, {
    key: "decode",
    value: function decode(input) {
      var prefix = input[0];
      var decoder = this.decoders[prefix];

      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(input), ", only inputs prefixed with ").concat(Object.keys(this.decoders), " are supported"));
      }
    }
  }]);

  return ComposedDecoder;
}();

var _or = function _or(left, right) {
  return new ComposedDecoder(_objectSpread2(_objectSpread2({}, left.decoders || _defineProperty$1({}, left.prefix, left)), right.decoders || _defineProperty$1({}, right.prefix, right)));
};
var Codec = /*#__PURE__*/function () {
  function Codec(name, prefix, baseEncode, baseDecode) {
    _classCallCheck(this, Codec);

    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix, baseEncode);
    this.decoder = new Decoder(name, prefix, baseDecode);
  }

  _createClass(Codec, [{
    key: "encode",
    value: function encode(input) {
      return this.encoder.encode(input);
    }
  }, {
    key: "decode",
    value: function decode(input) {
      return this.decoder.decode(input);
    }
  }]);

  return Codec;
}();
var from$1 = function from(_ref3) {
  var name = _ref3.name,
      prefix = _ref3.prefix,
      encode = _ref3.encode,
      decode = _ref3.decode;
  return new Codec(name, prefix, encode, decode);
};
var baseX = function baseX(_ref4) {
  var prefix = _ref4.prefix,
      name = _ref4.name,
      alphabet = _ref4.alphabet;

  var _basex = _brrp__multiformats_scope_baseX(alphabet, name),
      encode = _basex.encode,
      _decode = _basex.decode;

  return from$1({
    prefix: prefix,
    name: name,
    encode: encode,
    decode: function decode(text) {
      return coerce(_decode(text));
    }
  });
};

var _decode2 = function decode(string, alphabet, bitsPerChar, name) {
  var codes = {};

  for (var i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i;
  }

  var end = string.length;

  while (string[end - 1] === '=') {
    --end;
  }

  var out = new Uint8Array(end * bitsPerChar / 8 | 0);
  var bits = 0;
  var buffer = 0;
  var written = 0;

  for (var _i = 0; _i < end; ++_i) {
    var value = codes[string[_i]];

    if (value === undefined) {
      throw new SyntaxError("Non-".concat(name, " character"));
    }

    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;

    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }

  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError('Unexpected end of data');
  }

  return out;
};

var _encode = function encode(data, alphabet, bitsPerChar) {
  var pad = alphabet[alphabet.length - 1] === '=';
  var mask = (1 << bitsPerChar) - 1;
  var out = '';
  var bits = 0;
  var buffer = 0;

  for (var i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;

    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet[mask & buffer >> bits];
    }
  }

  if (bits) {
    out += alphabet[mask & buffer << bitsPerChar - bits];
  }

  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += '=';
    }
  }

  return out;
};

var rfc4648 = function rfc4648(_ref5) {
  var name = _ref5.name,
      prefix = _ref5.prefix,
      bitsPerChar = _ref5.bitsPerChar,
      alphabet = _ref5.alphabet;
  return from$1({
    prefix: prefix,
    name: name,
    encode: function encode(input) {
      return _encode(input, alphabet, bitsPerChar);
    },
    decode: function decode(input) {
      return _decode2(input, alphabet, bitsPerChar, name);
    }
  });
};

var base58btc = baseX({
  name: 'base58btc',
  prefix: 'z',
  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
});
baseX({
  name: 'base58flickr',
  prefix: 'Z',
  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
});

var base32 = rfc4648({
  prefix: 'b',
  name: 'base32',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'B',
  name: 'base32upper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'c',
  name: 'base32pad',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'C',
  name: 'base32padupper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'v',
  name: 'base32hex',
  alphabet: '0123456789abcdefghijklmnopqrstuv',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'V',
  name: 'base32hexupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
  bitsPerChar: 5
});
rfc4648({
  prefix: 't',
  name: 'base32hexpad',
  alphabet: '0123456789abcdefghijklmnopqrstuv=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'T',
  name: 'base32hexpadupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'h',
  name: 'base32z',
  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
  bitsPerChar: 5
});

var CID = /*#__PURE__*/function (_Symbol$toStringTag, _Symbol$for) {
  function CID(version, code, multihash, bytes) {
    _classCallCheck(this, CID);

    this.code = code;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }

  _createClass(CID, [{
    key: "toV0",
    value: function toV0() {
      switch (this.version) {
        case 0:
          {
            return this;
          }

        default:
          {
            var code = this.code,
                multihash = this.multihash;

            if (code !== DAG_PB_CODE) {
              throw new Error('Cannot convert a non dag-pb CID to CIDv0');
            }

            if (multihash.code !== SHA_256_CODE) {
              throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
            }

            return CID.createV0(multihash);
          }
      }
    }
  }, {
    key: "toV1",
    value: function toV1() {
      switch (this.version) {
        case 0:
          {
            var _this$multihash = this.multihash,
                code = _this$multihash.code,
                digest = _this$multihash.digest;
            var multihash = create(code, digest);
            return CID.createV1(this.code, multihash);
          }

        case 1:
          {
            return this;
          }

        default:
          {
            throw Error("Can not convert CID version ".concat(this.version, " to version 0. This is a bug please report"));
          }
      }
    }
  }, {
    key: "equals",
    value: function equals$1(other) {
      return other && this.code === other.code && this.version === other.version && equals(this.multihash, other.multihash);
    }
  }, {
    key: "toString",
    value: function toString(base) {
      var bytes = this.bytes,
          version = this.version,
          _baseCache = this._baseCache;

      switch (version) {
        case 0:
          return toStringV0(bytes, _baseCache, base || base58btc.encoder);

        default:
          return toStringV1(bytes, _baseCache, base || base32.encoder);
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        code: this.code,
        version: this.version,
        hash: this.multihash.bytes
      };
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return 'CID';
    }
  }, {
    key: _Symbol$for,
    value: function value() {
      return 'CID(' + this.toString() + ')';
    }
  }, {
    key: "toBaseEncodedString",
    get: function get() {
      throw new Error('Deprecated, use .toString()');
    }
  }, {
    key: "codec",
    get: function get() {
      throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
  }, {
    key: "buffer",
    get: function get() {
      throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');
    }
  }, {
    key: "multibaseName",
    get: function get() {
      throw new Error('"multibaseName" property is deprecated');
    }
  }, {
    key: "prefix",
    get: function get() {
      throw new Error('"prefix" property is deprecated');
    }
  }], [{
    key: "isCID",
    value: function isCID(value) {
      deprecate(/^0\.0/, IS_CID_DEPRECATION);
      return !!(value && (value[cidSymbol] || value.asCID === value));
    }
  }, {
    key: "asCID",
    value: function asCID(value) {
      if (value instanceof CID) {
        return value;
      } else if (value != null && value.asCID === value) {
        var _version = value.version,
            code = value.code,
            multihash = value.multihash,
            bytes = value.bytes;
        return new CID(_version, code, multihash, bytes || encodeCID(_version, code, multihash.bytes));
      } else if (value != null && value[cidSymbol] === true) {
        var _version2 = value.version,
            _multihash = value.multihash,
            _code = value.code;
        var digest = decode(_multihash);
        return CID.create(_version2, _code, digest);
      } else {
        return null;
      }
    }
  }, {
    key: "create",
    value: function create(version, code, digest) {
      if (typeof code !== 'number') {
        throw new Error('String codecs are no longer supported');
      }

      switch (version) {
        case 0:
          {
            if (code !== DAG_PB_CODE) {
              throw new Error("Version 0 CID must use dag-pb (code: ".concat(DAG_PB_CODE, ") block encoding"));
            } else {
              return new CID(version, code, digest, digest.bytes);
            }
          }

        case 1:
          {
            var bytes = encodeCID(version, code, digest.bytes);
            return new CID(version, code, digest, bytes);
          }

        default:
          {
            throw new Error('Invalid version');
          }
      }
    }
  }, {
    key: "createV0",
    value: function createV0(digest) {
      return CID.create(0, DAG_PB_CODE, digest);
    }
  }, {
    key: "createV1",
    value: function createV1(code, digest) {
      return CID.create(1, code, digest);
    }
  }, {
    key: "decode",
    value: function decode(bytes) {
      var _CID$decodeFirst = CID.decodeFirst(bytes),
          _CID$decodeFirst2 = _slicedToArray(_CID$decodeFirst, 2),
          cid = _CID$decodeFirst2[0],
          remainder = _CID$decodeFirst2[1];

      if (remainder.length) {
        throw new Error('Incorrect length');
      }

      return cid;
    }
  }, {
    key: "decodeFirst",
    value: function decodeFirst(bytes) {
      var specs = CID.inspectBytes(bytes);
      var prefixSize = specs.size - specs.multihashSize;
      var multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));

      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error('Incorrect length');
      }

      var digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      var digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      var cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
      return [cid, bytes.subarray(specs.size)];
    }
  }, {
    key: "inspectBytes",
    value: function inspectBytes(initialBytes) {
      var offset = 0;

      var next = function next() {
        var _varint$decode = decode$1(initialBytes.subarray(offset)),
            _varint$decode2 = _slicedToArray(_varint$decode, 2),
            i = _varint$decode2[0],
            length = _varint$decode2[1];

        offset += length;
        return i;
      };

      var version = next();
      var codec = DAG_PB_CODE;

      if (version === 18) {
        version = 0;
        offset = 0;
      } else if (version === 1) {
        codec = next();
      }

      if (version !== 0 && version !== 1) {
        throw new RangeError("Invalid CID version ".concat(version));
      }

      var prefixSize = offset;
      var multihashCode = next();
      var digestSize = next();
      var size = offset + digestSize;
      var multihashSize = size - prefixSize;
      return {
        version: version,
        codec: codec,
        multihashCode: multihashCode,
        digestSize: digestSize,
        multihashSize: multihashSize,
        size: size
      };
    }
  }, {
    key: "parse",
    value: function parse(source, base) {
      var _parseCIDtoBytes = parseCIDtoBytes(source, base),
          _parseCIDtoBytes2 = _slicedToArray(_parseCIDtoBytes, 2),
          prefix = _parseCIDtoBytes2[0],
          bytes = _parseCIDtoBytes2[1];

      var cid = CID.decode(bytes);

      cid._baseCache.set(prefix, source);

      return cid;
    }
  }]);

  return CID;
}(Symbol.toStringTag, Symbol["for"]('nodejs.util.inspect.custom'));

var parseCIDtoBytes = function parseCIDtoBytes(source, base) {
  switch (source[0]) {
    case 'Q':
      {
        var decoder = base || base58btc;
        return [base58btc.prefix, decoder.decode("".concat(base58btc.prefix).concat(source))];
      }

    case base58btc.prefix:
      {
        var _decoder = base || base58btc;

        return [base58btc.prefix, _decoder.decode(source)];
      }

    case base32.prefix:
      {
        var _decoder2 = base || base32;

        return [base32.prefix, _decoder2.decode(source)];
      }

    default:
      {
        if (base == null) {
          throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');
        }

        return [source[0], base.decode(source)];
      }
  }
};

var toStringV0 = function toStringV0(bytes, cache, base) {
  var prefix = base.prefix;

  if (prefix !== base58btc.prefix) {
    throw Error("Cannot string encode V0 in ".concat(base.name, " encoding"));
  }

  var cid = cache.get(prefix);

  if (cid == null) {
    var _cid = base.encode(bytes).slice(1);

    cache.set(prefix, _cid);
    return _cid;
  } else {
    return cid;
  }
};

var toStringV1 = function toStringV1(bytes, cache, base) {
  var prefix = base.prefix;
  var cid = cache.get(prefix);

  if (cid == null) {
    var _cid2 = base.encode(bytes);

    cache.set(prefix, _cid2);
    return _cid2;
  } else {
    return cid;
  }
};

var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;

var encodeCID = function encodeCID(version, code, multihash) {
  var codeOffset = encodingLength(version);
  var hashOffset = codeOffset + encodingLength(code);
  var bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version, bytes, 0);
  encodeTo(code, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};

var cidSymbol = Symbol["for"]('@ipld/js-cid/CID');
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version = '0.0.0-dev';

var deprecate = function deprecate(range, message) {
  if (range.test(version)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};

var IS_CID_DEPRECATION = "CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n";

var textEncoder = new TextEncoder();
new TextDecoder();
var code = 512;
var encode = function encode(node) {
  return textEncoder.encode(JSON.stringify(node));
};

var from = function from(_ref) {
  var name = _ref.name,
      code = _ref.code,
      encode = _ref.encode;
  return new Hasher(name, code, encode);
};
var Hasher = /*#__PURE__*/function () {
  function Hasher(name, code, encode) {
    _classCallCheck(this, Hasher);

    this.name = name;
    this.code = code;
    this.encode = encode;
  }

  _createClass(Hasher, [{
    key: "digest",
    value: function digest(input) {
      var _this = this;

      if (input instanceof Uint8Array) {
        var result = this.encode(input);
        return result instanceof Uint8Array ? create(this.code, result) : result.then(function (digest) {
          return create(_this.code, digest);
        });
      } else {
        throw Error('Unknown type, must be binary type');
      }
    }
  }]);

  return Hasher;
}();

var sha256 = from({
  name: 'sha2-256',
  code: 18,
  encode: function encode(input) {
    return coerce(crypto.createHash('sha256').update(input).digest());
  }
});
from({
  name: 'sha2-512',
  code: 19,
  encode: function encode(input) {
    return coerce(crypto.createHash('sha512').update(input).digest());
  }
});

var block = {
  get: function () {
    var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key, _options) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              throw new Error("unexpected block API get for ".concat(key));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function get(_x, _x2) {
      return _get.apply(this, arguments);
    }

    return get;
  }(),
  put: function () {
    var _put = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_key, _val, _options) {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              throw new Error('unexpected block API put');

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function put(_x3, _x4, _x5) {
      return _put.apply(this, arguments);
    }

    return put;
  }(),
  open: function () {
    var _open = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function open() {
      return _open.apply(this, arguments);
    }

    return open;
  }(),
  close: function () {
    var _close = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function close() {
      return _close.apply(this, arguments);
    }

    return close;
  }(),
  has: function () {
    var _has = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_key, _options) {
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    function has(_x6, _x7) {
      return _has.apply(this, arguments);
    }

    return has;
  }(),
  "delete": function () {
    var _delete2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_key, _options) {
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    function _delete(_x8, _x9) {
      return _delete2.apply(this, arguments);
    }

    return _delete;
  }(),
  putMany: function putMany(_source, _options) {
    throw new Error('Function not implemented.');
  },
  getMany: function getMany(_source, _options) {
    throw new Error('Function not implemented.');
  },
  deleteMany: function deleteMany(_source, _options) {
    throw new Error('Function not implemented.');
  },
  batch: function batch() {
    throw new Error('Function not implemented.');
  },
  query: function query(_query, _options) {
    throw new Error('Function not implemented.');
  },
  queryKeys: function queryKeys(_query, _options) {
    throw new Error('Function not implemented.');
  }
};
var fileHasher = {
  convertNanosToMillis: function convertNanosToMillis(nanoSeconds) {
    return nanoSeconds / BigInt(1000000);
  },

  /**
   * Used to initalize the only hash fns. See Alan Shaw's reference code for more context.
   */
  initImageHasher: function initImageHasher(content, options) {
    options = options || {};
    options.onlyHash = true;
    options.cidVersion = 0;
    return {
      options: options,
      content: content
    };
  },

  /**
   * Used to iniitalize the only hash fns. See Alan Shaw's reference code for more context.
   */
  initNonImageHasher: function initNonImageHasher(content, options) {
    options = options || {};
    options.onlyHash = true;
    options.cidVersion = 0;
    return {
      options: options,
      content: content
    };
  },

  /**
   * Convert content to a buffer; used in `generateNonImageCid()`.
   * @param {ReadStream|Buffer|string} content if string, should be file path
   * @param {Object} logger
   * @returns buffer version of content
   */
  convertToBuffer: function convertToBuffer(content, logger) {
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
      var buffer, fsReadFile, errMsg;
      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!Buffer.isBuffer(content)) {
                _context7.next = 2;
                break;
              }

              return _context7.abrupt("return", content);

            case 2:
              _context7.prev = 2;

              if (!(content instanceof Stream.Readable)) {
                _context7.next = 8;
                break;
              }

              _context7.next = 6;
              return new Promise(function (resolve, reject) {
                content.on('data', function (chunk) {
                  return buffer.push(chunk);
                });
                content.on('end', function () {
                  return resolve(Buffer.concat(buffer));
                });
                content.on('error', function (err) {
                  return reject(err);
                });
              });

            case 6:
              _context7.next = 12;
              break;

            case 8:
              fsReadFile = promisify(fs.readFile);
              _context7.next = 11;
              return fsReadFile(content);

            case 11:
              buffer = _context7.sent;

            case 12:
              _context7.next = 19;
              break;

            case 14:
              _context7.prev = 14;
              _context7.t0 = _context7["catch"](2);
              errMsg = "[fileHasher - convertToBuffer()] Could not convert content into buffer: ".concat(_context7.t0.toString());
              logger.error(errMsg);
              throw new Error(errMsg);

            case 19:
              return _context7.abrupt("return", buffer);

            case 20:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, null, [[2, 14]]);
    }))();
  },

  /**
   * Custom fn to generate the content-hashing logic
   * @param content a buffer of the content
   * @param options options for importer
   * @returns the V0 CID from content addressing logic
   */
  hashNonImages: function hashNonImages(content) {
    var _arguments = arguments;
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
      var options, _fileHasher$initNonIm, lastCid, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, cid;

      return regeneratorRuntime.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              options = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};
              _fileHasher$initNonIm = fileHasher.initNonImageHasher(content, options);
              options = _fileHasher$initNonIm.options;
              content = _fileHasher$initNonIm.content;
              lastCid = '';
              _iteratorAbruptCompletion = false;
              _didIteratorError = false;
              _context8.prev = 8;
              _iterator = _asyncIterator(importer([{
                content: content
              }], block, options));

            case 10:
              _context8.next = 12;
              return _iterator.next();

            case 12:
              if (!(_iteratorAbruptCompletion = !(_step = _context8.sent).done)) {
                _context8.next = 18;
                break;
              }

              cid = _step.value.cid;
              lastCid = "".concat(cid);

            case 15:
              _iteratorAbruptCompletion = false;
              _context8.next = 10;
              break;

            case 18:
              _context8.next = 24;
              break;

            case 20:
              _context8.prev = 20;
              _context8.t0 = _context8["catch"](8);
              _didIteratorError = true;
              _iteratorError = _context8.t0;

            case 24:
              _context8.prev = 24;
              _context8.prev = 25;

              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                _context8.next = 29;
                break;
              }

              _context8.next = 29;
              return _iterator["return"]();

            case 29:
              _context8.prev = 29;

              if (!_didIteratorError) {
                _context8.next = 32;
                break;
              }

              throw _iteratorError;

            case 32:
              return _context8.finish(29);

            case 33:
              return _context8.finish(24);

            case 34:
              return _context8.abrupt("return", lastCid);

            case 35:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, null, [[8, 20, 24, 34], [25,, 29, 33]]);
    }))();
  },

  /**
   * Custom fn to generate the content-hashing logic
   * @param content an Object[] with the structure [{ path: string, content: buffer }, ...]
   * @param options options for importer
   * @returns an Object[] with the structure [{path: <string>, cid: <string>, size: <number>}]
   *
   * Example with adding a profile picture:
   * [
      {
        "cid": "QmSRyKvnXwoxPZ9UxqxXPR8NXjcPYBEf1qbNrXyo5USqLL",
        "path": "blob/150x150.jpg",
        "size": 3091
      },
      {
        "cid": "QmQQMV9TXxRmDKafZiRvMVkqUNtUu9WGAfukUBS1yCk2ht",
        "path": "blob/480x480.jpg",
        "size": 20743
      },
      {
        "cid": "Qmd8cDdDGcWVaLEoJPVFtkKhYMqvHXZTvXcisYjubFxv1F",
        "path": "blob/1000x1000.jpg",
        "size": 72621
      },
      {
        "cid": "QmaYCPUH8G14yxetsMgW5J5tpTqPaTp3HMd3EAyffZKSvm",
        "path": "blob/original.jpg",
        "size": 185844
      },
      {
        "cid": "QmW8FUFhvaxv1MZmVcUcmR7Tg9WZhGf8xDNBesT9XepwrK",
        "path": "blob",
        "size": 282525
      }
    ]
  */
  hashImages: function hashImages(content) {
    var _arguments2 = arguments;
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
      var options, _fileHasher$initImage, result, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, file;

      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              options = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};
              _fileHasher$initImage = fileHasher.initImageHasher(content, options);
              options = _fileHasher$initImage.options;
              content = _fileHasher$initImage.content;
              result = [];
              _iteratorAbruptCompletion2 = false;
              _didIteratorError2 = false;
              _context9.prev = 8;
              _iterator2 = _asyncIterator(importer(content, block, options));

            case 10:
              _context9.next = 12;
              return _iterator2.next();

            case 12:
              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context9.sent).done)) {
                _context9.next = 18;
                break;
              }

              file = _step2.value;
              result.push({
                path: file.path,
                cid: "".concat(file.cid),
                size: file.size
              });

            case 15:
              _iteratorAbruptCompletion2 = false;
              _context9.next = 10;
              break;

            case 18:
              _context9.next = 24;
              break;

            case 20:
              _context9.prev = 20;
              _context9.t0 = _context9["catch"](8);
              _didIteratorError2 = true;
              _iteratorError2 = _context9.t0;

            case 24:
              _context9.prev = 24;
              _context9.prev = 25;

              if (!(_iteratorAbruptCompletion2 && _iterator2["return"] != null)) {
                _context9.next = 29;
                break;
              }

              _context9.next = 29;
              return _iterator2["return"]();

            case 29:
              _context9.prev = 29;

              if (!_didIteratorError2) {
                _context9.next = 32;
                break;
              }

              throw _iteratorError2;

            case 32:
              return _context9.finish(29);

            case 33:
              return _context9.finish(24);

            case 34:
              return _context9.abrupt("return", result);

            case 35:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, null, [[8, 20, 24, 34], [25,, 29, 33]]);
    }))();
  },

  /**
   * Generates CID V0 (46-char string starting with "Qm") for a non-image file (track segment, track transcode, metadata)
   * @param {Buffer|ReadStream|string} content a single Buffer, a ReadStream, or path to an existing file
   * @param {Object?} logger
   * @returns {string} only hash response cid
   */
  generateNonImageCid: function generateNonImageCid(content) {
    var _arguments3 = arguments;
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
      var logger, buffer;
      return regeneratorRuntime.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              logger = _arguments3.length > 1 && _arguments3[1] !== undefined ? _arguments3[1] : console;
              _context10.next = 3;
              return fileHasher.convertToBuffer(content, logger);

            case 3:
              buffer = _context10.sent;
              _context10.next = 6;
              return fileHasher.hashNonImages(buffer);

            case 6:
              return _context10.abrupt("return", _context10.sent);

            case 7:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }))();
  },

  /**
   * Generates CID V1 for a JSON metadata object (NOT the string of the metadata - must be an object).
   * CID<T, 512, SHA_256, 1> represents CID with json codec (512) and sha256 hash using CID V1.
   * Call toString() on the result to get the CID V1 string.
   */
  generateMetadataCidV1: function generateMetadataCidV1(metadata) {
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
      var bytes, hash;
      return regeneratorRuntime.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              bytes = encode(metadata);
              _context11.next = 3;
              return sha256.digest(bytes);

            case 3:
              hash = _context11.sent;
              return _context11.abrupt("return", CID.create(1, code, hash));

            case 5:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }))();
  },

  /**
   * Wrapper that generates multihashes for image files
   * @param {Object[]} content an Object[] with the structure [{ path: string, content: buffer }, ...]
   * @param {Object?} logger
   * @returns {HashedImage[]} only hash responses with the structure [{path: <string>, cid: <string>, size: <number>}]
   */
  generateImageCids: function generateImageCids(content) {
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {

      return regeneratorRuntime.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 3;
              return fileHasher.hashImages(content);

            case 3:
              return _context12.abrupt("return", _context12.sent);

            case 4:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }))();
  }
};

var HASH_SALT = 'azowernasdfoia';
var MIN_LENGTH = 5;
var hashids = new Hashids(HASH_SALT, MIN_LENGTH);
var ZeroAddress = '0x0000000000000000000000000000000000000000'; // eslint-disable-next-line @typescript-eslint/no-extraneous-class -- this should just be esm

var Utils = /*#__PURE__*/function () {
  function Utils() {
    _classCallCheck(this, Utils);
  }

  _createClass(Utils, null, [{
    key: "utf8ToHex",
    value: function utf8ToHex(utf8Str) {
      return LibsWeb3.utils.utf8ToHex(utf8Str);
    }
  }, {
    key: "padRight",
    value: function padRight(hexStr, size) {
      return LibsWeb3.utils.padRight(hexStr, size);
    }
  }, {
    key: "hexToUtf8",
    value: function hexToUtf8(hexStr) {
      return LibsWeb3.utils.hexToUtf8(hexStr);
    }
  }, {
    key: "keccak256",
    value: function keccak256(utf8Str) {
      return LibsWeb3.utils.keccak256(utf8Str);
    }
  }, {
    key: "isBN",
    value: function isBN(number) {
      return LibsWeb3.utils.isBN(number);
    }
  }, {
    key: "toBN",
    value: function toBN(number, base) {
      return new LibsWeb3.utils.BN(number, base);
    }
  }, {
    key: "BN",
    value: function BN() {
      return LibsWeb3.utils.BN;
    }
  }, {
    key: "checkStrLen",
    value: function checkStrLen(str, maxLen) {
      var minLen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

      if (str === undefined || str === null || str.length > maxLen || str.length < minLen) {
        throw new Error("String '".concat(str, "' must be between ").concat(minLen, "-").concat(maxLen, " characters"));
      }
    }
  }, {
    key: "wait",
    value: function () {
      var _wait = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(milliseconds) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, milliseconds);
                });

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function wait(_x) {
        return _wait.apply(this, arguments);
      }

      return wait;
    }() // Regular expression to check if endpoint is a FQDN. https://regex101.com/r/kIowvx/2

  }, {
    key: "isFQDN",
    value: function isFQDN(url) {
      var FQDN = /(?:^|[ \t])((https?:\/\/)?(?:localhost|[\w-]+(?:\.[\w-]+)+)(:\d+)?(\/\S*)?)/gm;
      return FQDN.test(url);
    }
  }, {
    key: "isHttps",
    value: function isHttps(url) {
      var https = /^https:\/\//;
      return https.test(url);
    } // Function to check if the endpont/health_check returns JSON object [ {'healthy':true} ]

  }, {
    key: "isHealthy",
    value: function () {
      var _isHealthy = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url) {
        var _yield$axios$get, body;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return axios.get(url + '/health_check');

              case 3:
                _yield$axios$get = _context2.sent;
                body = _yield$axios$get.data;
                return _context2.abrupt("return", body.data.healthy);

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](0);
                return _context2.abrupt("return", false);

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[0, 8]]);
      }));

      function isHealthy(_x2) {
        return _isHealthy.apply(this, arguments);
      }

      return isHealthy;
    }()
  }, {
    key: "formatOptionalMultihash",
    value: function formatOptionalMultihash(multihash) {
      if (multihash) {
        return this.decodeMultihash(multihash).digest;
      } else {
        return this.utf8ToHex('');
      }
    }
  }, {
    key: "decodeMultihash",
    value: function decodeMultihash(multihash) {
      var base16Multihash = bs58.decode(multihash);
      return {
        digest: "0x".concat(base16Multihash.slice(2).toString('hex')),
        hashFn: parseInt(base16Multihash[0]),
        size: parseInt(base16Multihash[1])
      };
    }
    /**
     * Given a digest value (written on chain, obtained through AudiusABIDecoder.decodeMethod),
     * convert back to a IFPS CIDv0
     * @param multihashDigest digest value from decodeMultihash
     * @returns String CID value
     */

  }, {
    key: "encodeMultihash",
    value: function encodeMultihash(multihashDigest) {
      // the 1220 is from reconstructing the hashFn and size with digest, the opposite of decodeMultihash
      // since IPFS CIDv0 has a fixed hashFn and size, the first two values are always 12 and 20
      // concat them together with digest and encode back to base58
      var digestStr = "1220".concat(multihashDigest.replace('0x', '')); // convert digestStr from hex to base 58

      return bs58.encode(Buffer.from(digestStr, 'hex'));
    }
  }, {
    key: "parseDataFromResponse",
    value: function parseDataFromResponse(response) {
      if (!response || !response.data) return null;
      var obj = response.data; // adapted from https://github.com/jashkenas/underscore/blob/master/underscore.js _.isEmpty function

      if (obj == null) return null;
      if ((Array.isArray(obj) || typeof obj === 'string') && obj.length === 0) return null;
      if (Object.keys(obj).length === 0) return null;
      return obj;
    }
  }, {
    key: "configureWeb3",
    value: function () {
      var _configureWeb = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(web3Provider, chainNetworkId) {
        var requiresAccount,
            web3Instance,
            networkId,
            accounts,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                requiresAccount = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : true;
                // Initializing web3 with a HttpProvider wrapper for multiple providers
                // ref: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3/types/index.d.ts#L31.
                web3Instance = new LibsWeb3(new MultiProvider(web3Provider));
                _context3.prev = 2;
                _context3.next = 5;
                return web3Instance.eth.net.getId();

              case 5:
                networkId = _context3.sent;

                if (!(chainNetworkId && networkId.toString() !== chainNetworkId)) {
                  _context3.next = 8;
                  break;
                }

                return _context3.abrupt("return", false);

              case 8:
                if (!requiresAccount) {
                  _context3.next = 14;
                  break;
                }

                _context3.next = 11;
                return web3Instance.eth.getAccounts();

              case 11:
                accounts = _context3.sent;

                if (!(!accounts || accounts.length < 1)) {
                  _context3.next = 14;
                  break;
                }

                return _context3.abrupt("return", false);

              case 14:
                _context3.next = 19;
                break;

              case 16:
                _context3.prev = 16;
                _context3.t0 = _context3["catch"](2);
                return _context3.abrupt("return", false);

              case 19:
                return _context3.abrupt("return", web3Instance);

              case 20:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[2, 16]]);
      }));

      function configureWeb3(_x3, _x4) {
        return _configureWeb.apply(this, arguments);
      }

      return configureWeb3;
    }()
  }, {
    key: "zeroAddress",
    get: function get() {
      return ZeroAddress;
    }
  }, {
    key: "isZeroAddress",
    value: function isZeroAddress(address) {
      return address === Utils.zeroAddress;
    }
  }, {
    key: "makeUuid",
    value: function makeUuid() {
      return uuid();
    }
    /**
     * Decodes a string id into an int. Returns null if an invalid ID.
     */

  }, {
    key: "decodeHashId",
    value: function decodeHashId(id) {
      try {
        var ids = hashids.decode(id);
        if (!ids.length) return null;
        var num = Number(ids[0]);
        if (isNaN(num)) return null;
        return num;
      } catch (e) {
        console.error("Failed to decode ".concat(id), e);
        return null;
      }
    }
    /**
     * Encodes an int to a string based hashid
     */

  }, {
    key: "encodeHashId",
    value: function encodeHashId(id) {
      try {
        if (id === null) return null;
        var encodedId = hashids.encode(id);
        return encodedId;
      } catch (e) {
        console.error("Failed to encode ".concat(id), e);
        return null;
      }
    }
    /**
     * If `promise` responds before `timeoutMs`,
     * this function returns its response; else rejects with `timeoutMessage`
     */

  }, {
    key: "racePromiseWithTimeout",
    value: function () {
      var _racePromiseWithTimeout = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(promise, timeoutMs, timeoutMessage) {
        var timeoutPromise;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                // eslint-disable-next-line promise/param-names
                timeoutPromise = new Promise(function (_promise, reject) {
                  setTimeout(function () {
                    return reject(new Error(timeoutMessage));
                  }, timeoutMs);
                });
                _context4.next = 3;
                return Promise.race([promise, timeoutPromise]);

              case 3:
                return _context4.abrupt("return", _context4.sent);

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function racePromiseWithTimeout(_x5, _x6, _x7) {
        return _racePromiseWithTimeout.apply(this, arguments);
      }

      return racePromiseWithTimeout;
    }()
  }, {
    key: "getRandomInt",
    value: function getRandomInt(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min) + min);
    }
  }]);

  return Utils;
}();

_defineProperty$1(Utils, "fileHasher", fileHasher);

new LibsWeb3(); // From https://github.com/AudiusProject/sig/blob/main/node/index.js

Keypair.generate();

var crc32c = {};

/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */

(function (exports) {

  (function (factory) {
    /*jshint ignore:start */

    /*eslint-disable */
    if (typeof DO_NOT_EXPORT_CRC === 'undefined') {
      {
        factory(exports);
      }
    } else {
      factory({});
    }
    /*eslint-enable */

    /*jshint ignore:end */

  })(function (CRC32C) {
    CRC32C.version = '1.2.2';
    /*global Int32Array */

    function signed_crc_table() {
      var c = 0,
          table = new Array(256);

      for (var n = 0; n != 256; ++n) {
        c = n;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -2097792136 ^ c >>> 1 : c >>> 1;
        table[n] = c;
      }

      return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
    }

    var T0 = signed_crc_table();

    function slice_by_16_tables(T) {
      var c = 0,
          v = 0,
          n = 0,
          table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096);

      for (n = 0; n != 256; ++n) {
        table[n] = T[n];
      }

      for (n = 0; n != 256; ++n) {
        v = T[n];

        for (c = 256 + n; c < 4096; c += 256) {
          v = table[c] = v >>> 8 ^ T[v & 0xFF];
        }
      }

      var out = [];

      for (n = 1; n != 16; ++n) {
        out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
      }

      return out;
    }

    var TT = slice_by_16_tables(T0);
    var T1 = TT[0],
        T2 = TT[1],
        T3 = TT[2],
        T4 = TT[3],
        T5 = TT[4];
    var T6 = TT[5],
        T7 = TT[6],
        T8 = TT[7],
        T9 = TT[8],
        Ta = TT[9];
    var Tb = TT[10],
        Tc = TT[11],
        Td = TT[12],
        Te = TT[13],
        Tf = TT[14];

    function crc32_bstr(bstr, seed) {
      var C = seed ^ -1;

      for (var i = 0, L = bstr.length; i < L;) {
        C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 0xFF];
      }

      return ~C;
    }

    function crc32_buf(B, seed) {
      var C = seed ^ -1,
          L = B.length - 15,
          i = 0;

      for (; i < L;) {
        C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
      }

      L += 15;

      while (i < L) {
        C = C >>> 8 ^ T0[(C ^ B[i++]) & 0xFF];
      }

      return ~C;
    }

    function crc32_str(str, seed) {
      var C = seed ^ -1;

      for (var i = 0, L = str.length, c = 0, d = 0; i < L;) {
        c = str.charCodeAt(i++);

        if (c < 0x80) {
          C = C >>> 8 ^ T0[(C ^ c) & 0xFF];
        } else if (c < 0x800) {
          C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 0xFF];
        } else if (c >= 0xD800 && c < 0xE000) {
          c = (c & 1023) + 64;
          d = str.charCodeAt(i++) & 1023;
          C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 0xFF];
        } else {
          C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 0xFF];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 0xFF];
        }
      }

      return ~C;
    }

    CRC32C.table = T0; // $FlowIgnore

    CRC32C.bstr = crc32_bstr; // $FlowIgnore

    CRC32C.buf = crc32_buf; // $FlowIgnore

    CRC32C.str = crc32_str;
  });
})(crc32c);

var NodeScore = /*#__PURE__*/_createClass(function NodeScore(node) {
  _classCallCheck(this, NodeScore);

  _defineProperty$1(this, "node", void 0);

  _defineProperty$1(this, "score", void 0);

  this.node = node;
  this.score = 0;
});
/**
 * TypeScript equivalent of https://github.com/tysonmote/rendezvous/blob/be0258dbbd3d/rendezvous.go
 */


var RendezvousHash = /*#__PURE__*/function () {
  function RendezvousHash() {
    _classCallCheck(this, RendezvousHash);

    _defineProperty$1(this, "nodes", []);

    this.add.apply(this, arguments);
  }

  _createClass(RendezvousHash, [{
    key: "add",
    value: function add() {
      for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
        nodes[_key] = arguments[_key];
      }

      for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {
        var node = _nodes[_i];
        this.nodes.push(new NodeScore(Buffer$1.from(node)));
      }
    }
  }, {
    key: "get",
    value: function get(key) {
      var _maxNode$toString, _maxNode;

      var maxScore = 0;
      var maxNode = null;
      var keyBytes = Buffer$1.from(key);

      var _iterator = _createForOfIteratorHelper(this.nodes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var node = _step.value;
          var score = this.hash(node.node, keyBytes);

          if (score > maxScore || score === maxScore && node.node.compare(maxNode) < 0) {
            maxScore = score;
            maxNode = node.node;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return (_maxNode$toString = (_maxNode = maxNode) === null || _maxNode === void 0 ? void 0 : _maxNode.toString()) !== null && _maxNode$toString !== void 0 ? _maxNode$toString : '';
    }
  }, {
    key: "getN",
    value: function getN(n, key) {
      var keyBytes = Buffer$1.from(key);

      var _iterator2 = _createForOfIteratorHelper(this.nodes),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var node = _step2.value;
          node.score = this.hash(node.node, keyBytes);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.nodes.sort(function (a, b) {
        if (a.score === b.score) {
          return a.node.compare(b.node);
        }

        return b.score - a.score;
      });

      if (n > this.nodes.length) {
        n = this.nodes.length;
      }

      var nodes = [];

      for (var i = 0; i < n; i++) {
        nodes.push(this.nodes[i].node.toString());
      }

      return nodes;
    }
  }, {
    key: "getNodes",
    value: function getNodes() {
      return this.nodes.map(function (nodeScore) {
        return nodeScore.node.toString();
      });
    }
  }, {
    key: "hash",
    value: function hash(node, key) {
      var combined = Buffer$1.concat([key, node]); // Convert to unsigned 32-bit integer to match go implementation, which is uint32 here:
      // https://github.com/tysonmote/rendezvous/blob/be0258dbbd3d/rendezvous.go#L92

      return crc32c.buf(combined, 0) >>> 0;
    }
  }]);

  return RendezvousHash;
}();

var isNodeHealthy = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(endpoint) {
    var logger,
        resp,
        _args3 = arguments;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            logger = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : console;
            _context3.prev = 1;
            _context3.next = 4;
            return axios({
              baseURL: endpoint,
              url: "/health_check",
              method: 'get',
              timeout: 3000
            });

          case 4:
            resp = _context3.sent;

            if (!(resp.status === 200)) {
              _context3.next = 9;
              break;
            }

            return _context3.abrupt("return", true);

          case 9:
            logger.warn("isNodeHealthy: ".concat(endpoint, " returned non-200 status ").concat(resp.status));
            return _context3.abrupt("return", false);

          case 11:
            _context3.next = 17;
            break;

          case 13:
            _context3.prev = 13;
            _context3.t0 = _context3["catch"](1);
            logger.error("isNodeHealthy: Error checking health: ".concat(_context3.t0));
            return _context3.abrupt("return", false);

          case 17:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[1, 13]]);
  }));

  return function isNodeHealthy(_x3) {
    return _ref3.apply(this, arguments);
  };
}();

var defaultStorageNodeSelectorConfig = {
  bootstrapNodes: servicesConfig.storageNodes,
  logger: new Logger()
};

var DISCOVERY_RESPONSE_TIMEOUT = 15000;
var StorageNodeSelector = /*#__PURE__*/function () {
  // endpoints (lowercase)
  function StorageNodeSelector(config) {
    var _this$config$bootstra,
        _this$discoveryNodeSe,
        _this = this;

    _classCallCheck(this, StorageNodeSelector);

    _defineProperty$1(this, "config", void 0);

    _defineProperty$1(this, "auth", void 0);

    _defineProperty$1(this, "logger", void 0);

    _defineProperty$1(this, "nodes", void 0);

    _defineProperty$1(this, "orderedNodes", void 0);

    _defineProperty$1(this, "selectedNode", void 0);

    _defineProperty$1(this, "selectedDiscoveryNode", void 0);

    _defineProperty$1(this, "discoveryNodeSelector", void 0);

    _defineProperty$1(this, "initialDiscoveryFetchPromise", void 0);

    _defineProperty$1(this, "resolveInitialDiscoveryFetchPromise", function () {});

    this.config = mergeConfigWithDefaults(config, defaultStorageNodeSelectorConfig);
    this.discoveryNodeSelector = config.discoveryNodeSelector;
    this.auth = config.auth;
    this.logger = this.config.logger.createPrefixedLogger('[storage-node-selector]');
    this.nodes = (_this$config$bootstra = this.config.bootstrapNodes) !== null && _this$config$bootstra !== void 0 ? _this$config$bootstra : [];
    (_this$discoveryNodeSe = this.discoveryNodeSelector) === null || _this$discoveryNodeSe === void 0 ? void 0 : _this$discoveryNodeSe.addEventListener('change', this.onChangeDiscoveryNode.bind(this));
    this.checkIfDiscoveryNodeAlreadyAvailable();
    this.initialDiscoveryFetchPromise = new Promise(function (resolve) {
      _this.resolveInitialDiscoveryFetchPromise = resolve;
    });
  }

  _createClass(StorageNodeSelector, [{
    key: "checkIfDiscoveryNodeAlreadyAvailable",
    value: function () {
      var _checkIfDiscoveryNodeAlreadyAvailable = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this$discoveryNodeSe2;

        var endpoint;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return (_this$discoveryNodeSe2 = this.discoveryNodeSelector) === null || _this$discoveryNodeSe2 === void 0 ? void 0 : _this$discoveryNodeSe2.getSelectedEndpoint();

              case 2:
                endpoint = _context.sent;

                if (endpoint) {
                  this.onChangeDiscoveryNode(endpoint);
                }

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function checkIfDiscoveryNodeAlreadyAvailable() {
        return _checkIfDiscoveryNodeAlreadyAvailable.apply(this, arguments);
      }

      return checkIfDiscoveryNodeAlreadyAvailable;
    }()
  }, {
    key: "onChangeDiscoveryNode",
    value: function () {
      var _onChangeDiscoveryNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(endpoint) {
        var _responseData$data$ne;

        var healthCheckEndpoint, discoveryHealthCheckResponse, responseData, contentNodes;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.logger.info('Updating list of available content nodes');

                if (!(this.selectedDiscoveryNode === endpoint)) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return");

              case 3:
                this.selectedDiscoveryNode = endpoint;
                healthCheckEndpoint = "".concat(endpoint, "/health_check");
                _context2.next = 7;
                return fetch$1(healthCheckEndpoint);

              case 7:
                discoveryHealthCheckResponse = _context2.sent;

                if (discoveryHealthCheckResponse.ok) {
                  _context2.next = 11;
                  break;
                }

                this.logger.warn('Discovery provider health check did not respond successfully');
                return _context2.abrupt("return");

              case 11:
                _context2.next = 13;
                return discoveryHealthCheckResponse.json();

              case 13:
                responseData = _context2.sent;
                contentNodes = (_responseData$data$ne = responseData.data.network) === null || _responseData$data$ne === void 0 ? void 0 : _responseData$data$ne.content_nodes;

                if (contentNodes) {
                  _context2.next = 18;
                  break;
                }

                this.logger.warn('Discovery provider health check did not contain any available content nodes');
                return _context2.abrupt("return");

              case 18:
                this.nodes = contentNodes;
                this.resolveInitialDiscoveryFetchPromise();

              case 20:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function onChangeDiscoveryNode(_x) {
        return _onChangeDiscoveryNode.apply(this, arguments);
      }

      return onChangeDiscoveryNode;
    }()
  }, {
    key: "getSelectedNode",
    value: function () {
      var _getSelectedNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var _this2 = this;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.selectedNode) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return", this.selectedNode);

              case 2:
                if (this.nodes.length) {
                  _context3.next = 5;
                  break;
                }

                _context3.next = 5;
                return Promise.race([this.initialDiscoveryFetchPromise, new Promise(function (resolve) {
                  return setTimeout(function () {
                    _this2.logger.warn('List of storage nodes could not be fetched');

                    resolve();
                  }, DISCOVERY_RESPONSE_TIMEOUT);
                })]);

              case 5:
                _context3.next = 7;
                return this.select();

              case 7:
                return _context3.abrupt("return", _context3.sent);

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getSelectedNode() {
        return _getSelectedNode.apply(this, arguments);
      }

      return getSelectedNode;
    }()
  }, {
    key: "getNodes",
    value: function getNodes(cid) {
      return this.orderNodes(cid);
    }
  }, {
    key: "select",
    value: function () {
      var _select = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _this$selectedNode;

        var currentNodeIndex, selectedNode, nextNodeIndex, nextNode;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (this.orderedNodes) {
                  _context4.next = 8;
                  break;
                }

                _context4.t0 = this;
                _context4.next = 4;
                return this.auth.getAddress();

              case 4:
                _context4.t1 = _context4.sent.toLowerCase();
                _context4.next = 7;
                return _context4.t0.orderNodes.call(_context4.t0, _context4.t1);

              case 7:
                this.orderedNodes = _context4.sent;

              case 8:
                if (!(this.orderedNodes.length === 0)) {
                  _context4.next = 10;
                  break;
                }

                return _context4.abrupt("return", null);

              case 10:
                currentNodeIndex = this.selectedNode ? this.orderedNodes.indexOf(this.selectedNode) : -1;
                nextNodeIndex = currentNodeIndex;

              case 12:
                if (selectedNode) {
                  _context4.next = 25;
                  break;
                }

                nextNodeIndex = (nextNodeIndex + 1) % this.orderedNodes.length;

                if (!(nextNodeIndex === currentNodeIndex)) {
                  _context4.next = 16;
                  break;
                }

                return _context4.abrupt("break", 25);

              case 16:
                nextNode = this.orderedNodes[nextNodeIndex];

                if (nextNode) {
                  _context4.next = 19;
                  break;
                }

                return _context4.abrupt("continue", 12);

              case 19:
                _context4.next = 21;
                return isNodeHealthy(nextNode);

              case 21:
                if (!_context4.sent) {
                  _context4.next = 23;
                  break;
                }

                selectedNode = nextNode;

              case 23:
                _context4.next = 12;
                break;

              case 25:
                this.selectedNode = selectedNode;
                this.logger.info('Selected content node', this.selectedNode);
                return _context4.abrupt("return", (_this$selectedNode = this.selectedNode) !== null && _this$selectedNode !== void 0 ? _this$selectedNode : null);

              case 28:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function select() {
        return _select.apply(this, arguments);
      }

      return select;
    }()
  }, {
    key: "orderNodes",
    value: function orderNodes(key) {
      var endpoints = this.nodes.map(function (node) {
        return node.endpoint.toLowerCase();
      });

      var hash = _construct(RendezvousHash, _toConsumableArray(endpoints));

      return hash.getN(this.nodes.length, key);
    }
  }]);

  return StorageNodeSelector;
}();

/**
 * This file includes schemas for use in EIP-712 compliant signature generation and
 * signature validation, generator functions for generating data
 * in the form needed by eth_personalSign / eth-sig-util's signTypedData functions,
 * generators for contract signing domains, and a helper function for generating
 * cryptographically secure nonces in nodejs or in the browser.
 * modeled off: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md
 */
var domains = {};

function getDomainData(contractName, signatureVersion, chainId, contractAddress) {
  return {
    name: contractName,
    version: signatureVersion,
    chainId: chainId,
    verifyingContract: contractAddress
  };
}

domains.getEntityManagerDomain = function (chainId, contractAddress) {
  return getDomainData('Entity Manager', '1', chainId, contractAddress);
};

var schemas = {};
/* contract signing domain */

schemas.domain = [{
  name: 'name',
  type: 'string'
}, {
  name: 'version',
  type: 'string'
}, {
  name: 'chainId',
  type: 'uint256'
}, {
  name: 'verifyingContract',
  type: 'address'
}];
schemas.manageEntity = [{
  name: 'userId',
  type: 'uint'
}, {
  name: 'entityType',
  type: 'string'
}, {
  name: 'entityId',
  type: 'uint'
}, {
  name: 'action',
  type: 'string'
}, {
  name: 'metadata',
  type: 'string'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
var generators = {};

function getRequestData(domainDataFn, chainId, contractAddress, messageTypeName, messageSchema, message) {
  var domainData = domainDataFn(chainId, contractAddress);
  var types = {
    EIP712Domain: schemas.domain
  };
  types[messageTypeName] = messageSchema;
  return {
    types: types,
    domain: domainData,
    primaryType: messageTypeName,
    message: message
  };
}
/* User Factory Generators */


generators.getAddUserRequestData = function (chainId, contractAddress, handle, nonce) {
  var message = {
    handle: handle,
    nonce: nonce
  };
  return getRequestData(domains.getUserFactoryDomain, chainId, contractAddress, 'AddUserRequest', schemas.addUserRequest, message);
};

generators.getManageEntityData = function (chainId, contractAddress, userId, entityType, entityId, action, metadata, nonce) {
  var message = {
    userId: userId,
    entityType: entityType,
    entityId: entityId,
    action: action,
    metadata: metadata,
    nonce: nonce
  };
  return getRequestData(domains.getEntityManagerDomain, chainId, contractAddress, 'ManageEntity', schemas.manageEntity, message);
};
/** Return a secure random hex string of nChar length in a browser-compatible way
 *  Taken from https://stackoverflow.com/questions/37378237/how-to-generate-a-random-token-of-32-bit-in-javascript
 */


function browserRandomHash(nChar) {
  // convert number of characters to number of bytes
  var nBytes = Math.ceil(nChar = (+nChar || 8) / 2); // create a typed array of that many bytes

  var u = new Uint8Array(nBytes); // populate it wit crypto-random values

  window.crypto.getRandomValues(u); // convert it to an Array of Strings (e.g. '01', 'AF', ..)

  var zpad = function zpad(str) {
    return '00'.slice(str.length) + str;
  };

  var a = Array.prototype.map.call(u, function (x) {
    return zpad(x.toString(16));
  }); // Array of String to String

  var str = a.join('').toLowerCase(); // and snip off the excess digit if we want an odd number

  if (nChar % 2) str = str.slice(1); // return what we made

  return str;
} // We need to detect whether the nodejs crypto module is available to determine how to
// generate secure random numbers below


var nodeCrypto;

try {
  nodeCrypto = require('crypto');
} catch (e) {
  nodeCrypto = null;
}

function getNonce() {
  // detect whether we are in browser or in nodejs, and use the correct csprng
  if (typeof window === 'undefined' || window === null) {
    return '0x' + nodeCrypto.randomBytes(32).toString('hex');
  } else {
    return '0x' + browserRandomHash(64);
  }
}

var signatureSchemas = {
  domains: domains,
  schemas: schemas,
  generators: generators,
  getNonce: getNonce
};

var abi = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_signer",
				type: "address"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_entityType",
				type: "string"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_entityId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_metadata",
				type: "string"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_action",
				type: "string"
			}
		],
		name: "ManageEntity",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "_isVerified",
				type: "bool"
			}
		],
		name: "ManageIsVerified",
		type: "event"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "usedSignatures",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "string",
				name: "name",
				type: "string"
			},
			{
				internalType: "string",
				name: "version",
				type: "string"
			},
			{
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_verifierAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_networkId",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_userId",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "_entityType",
				type: "string"
			},
			{
				internalType: "uint256",
				name: "_entityId",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "_action",
				type: "string"
			},
			{
				internalType: "string",
				name: "_metadata",
				type: "string"
			},
			{
				internalType: "bytes32",
				name: "_nonce",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "manageEntity",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_userId",
				type: "uint256"
			},
			{
				internalType: "bool",
				name: "_isVerified",
				type: "bool"
			}
		],
		name: "manageIsVerified",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];

var defaultEntityManagerConfig = {
  contractAddress: servicesConfig.entityManagerContractAddress,
  web3ProviderUrl: servicesConfig.web3ProviderUrl,
  identityServiceUrl: servicesConfig.identityServiceUrl,
  useDiscoveryRelay: false,
  logger: new Logger()
};
var DEFAULT_GAS_LIMIT = 2000000;
var CONFIRMATION_POLLING_INTERVAL = 2000;
var CONFIRMATION_TIMEOUT = 45000;

var EntityManager = /*#__PURE__*/function () {
  /**
   * Configuration passed in by consumer (with defaults)
   */
  function EntityManager(config) {
    _classCallCheck(this, EntityManager);

    _defineProperty$1(this, "config", void 0);

    _defineProperty$1(this, "discoveryNodeSelector", void 0);

    _defineProperty$1(this, "contract", void 0);

    _defineProperty$1(this, "web3", void 0);

    _defineProperty$1(this, "logger", void 0);

    this.config = mergeConfigWithDefaults(config, defaultEntityManagerConfig);
    this.discoveryNodeSelector = config.discoveryNodeSelector;
    this.web3 = new Web3$1(new Web3$1.providers.HttpProvider(this.config.web3ProviderUrl, {
      timeout: 10000
    }));
    this.contract = new this.web3.eth.Contract(abi, this.config.contractAddress);
    this.logger = this.config.logger.createPrefixedLogger('[entity-manager]');
  }
  /**
   * Calls the manage entity method on chain to update some data
   */


  _createClass(EntityManager, [{
    key: "manageEntity",
    value: function () {
      var _manageEntity = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
        var userId, entityType, entityId, action, _ref$metadata, metadata, auth, _ref$confirmationTime, confirmationTimeout, _ref$skipConfirmation, skipConfirmation, nonce, chainId, signatureData, senderAddress, signature, method, response, jsonResponse, _jsonResponse$error;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                userId = _ref.userId, entityType = _ref.entityType, entityId = _ref.entityId, action = _ref.action, _ref$metadata = _ref.metadata, metadata = _ref$metadata === void 0 ? '' : _ref$metadata, auth = _ref.auth, _ref$confirmationTime = _ref.confirmationTimeout, confirmationTimeout = _ref$confirmationTime === void 0 ? CONFIRMATION_TIMEOUT : _ref$confirmationTime, _ref$skipConfirmation = _ref.skipConfirmation, skipConfirmation = _ref$skipConfirmation === void 0 ? false : _ref$skipConfirmation;
                nonce = signatureSchemas.getNonce();
                _context.next = 4;
                return this.web3.eth.net.getId();

              case 4:
                chainId = _context.sent;
                signatureData = signatureSchemas.generators.getManageEntityData(chainId, this.config.contractAddress, userId, entityType, entityId, action, metadata, nonce);
                _context.next = 8;
                return auth.getAddress();

              case 8:
                senderAddress = _context.sent;
                _context.next = 11;
                return auth.signTransaction(signatureData);

              case 11:
                signature = _context.sent;
                _context.next = 14;
                return this.contract.methods.manageEntity(userId, entityType, entityId, action, metadata, nonce, signature);

              case 14:
                method = _context.sent;
                _context.t0 = fetch$1;
                _context.t1 = "";
                _context.next = 19;
                return this.getRelayEndpoint();

              case 19:
                _context.t2 = _context.sent;
                _context.t3 = _context.t1.concat.call(_context.t1, _context.t2, "/relay");
                _context.t4 = {
                  method: 'POST',
                  headers: new Headers({
                    'Content-Type': 'application/json'
                  }),
                  body: JSON.stringify({
                    contractAddress: this.config.contractAddress,
                    contractRegistryKey: 'EntityManager',
                    encodedABI: method.encodeABI(),
                    // Gas limit not really needed with ACDC
                    gasLimit: DEFAULT_GAS_LIMIT,
                    senderAddress: senderAddress
                  })
                };
                _context.next = 24;
                return (0, _context.t0)(_context.t3, _context.t4);

              case 24:
                response = _context.sent;
                _context.next = 27;
                return response.json();

              case 27:
                jsonResponse = _context.sent;

                if (!response.ok) {
                  _context.next = 35;
                  break;
                }

                if (skipConfirmation) {
                  _context.next = 32;
                  break;
                }

                _context.next = 32;
                return this.confirmWrite({
                  blockHash: jsonResponse.receipt.blockHash,
                  blockNumber: jsonResponse.receipt.blockNumber,
                  confirmationTimeout: confirmationTimeout
                });

              case 32:
                return _context.abrupt("return", {
                  blockHash: jsonResponse.receipt.blockHash,
                  blockNumber: jsonResponse.receipt.blockNumber
                });

              case 35:
                if (!(response.status === 429)) {
                  _context.next = 40;
                  break;
                }

                this.logger.error('API Rate Limit Exceeded: You have exceeded the allowed number of requests for this action. Please wait and try again later. If you require a higher rate limit, please send an email to api@audius.co with your request, detailing the reasons and expected usage.');
                throw new Error('Error making relay request: API Rate Limit Exceeded. If you require a higher rate limit, please send an email to api@audius.co with your request.');

              case 40:
                throw new Error("Error making relay request".concat(jsonResponse !== null && jsonResponse !== void 0 && (_jsonResponse$error = jsonResponse.error) !== null && _jsonResponse$error !== void 0 && _jsonResponse$error.message ? ": ".concat(jsonResponse.error.message) : '.'));

              case 41:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function manageEntity(_x) {
        return _manageEntity.apply(this, arguments);
      }

      return manageEntity;
    }()
    /**
     * Confirms a write by polling for the block to be indexed by the selected
     * discovery node
     */

  }, {
    key: "confirmWrite",
    value: function () {
      var _confirmWrite = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref2) {
        var _this = this;

        var blockHash, blockNumber, _ref2$confirmationTim, confirmationTimeout, _ref2$confirmationPol, confirmationPollingInterval, confirmBlock, confirmation, start;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                blockHash = _ref2.blockHash, blockNumber = _ref2.blockNumber, _ref2$confirmationTim = _ref2.confirmationTimeout, confirmationTimeout = _ref2$confirmationTim === void 0 ? CONFIRMATION_TIMEOUT : _ref2$confirmationTim, _ref2$confirmationPol = _ref2.confirmationPollingInterval, confirmationPollingInterval = _ref2$confirmationPol === void 0 ? CONFIRMATION_POLLING_INTERVAL : _ref2$confirmationPol;

                confirmBlock = /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                    var endpoint, _yield$yield$fetch$js, block_passed;

                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return _this.discoveryNodeSelector.getSelectedEndpoint();

                          case 2:
                            endpoint = _context2.sent;
                            _context2.next = 5;
                            return fetch$1("".concat(endpoint, "/block_confirmation?blocknumber=").concat(blockNumber, "&blockhash=").concat(blockHash));

                          case 5:
                            _context2.next = 7;
                            return _context2.sent.json();

                          case 7:
                            _yield$yield$fetch$js = _context2.sent;
                            block_passed = _yield$yield$fetch$js.data.block_passed;
                            return _context2.abrupt("return", block_passed ? BlockConfirmation.CONFIRMED : BlockConfirmation.UNKNOWN);

                          case 10:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function confirmBlock() {
                    return _ref3.apply(this, arguments);
                  };
                }();

                _context3.next = 4;
                return confirmBlock();

              case 4:
                confirmation = _context3.sent;
                start = Date.now();

              case 6:
                if (!(confirmation === BlockConfirmation.UNKNOWN)) {
                  _context3.next = 16;
                  break;
                }

                if (!(Date.now() - start > confirmationTimeout)) {
                  _context3.next = 9;
                  break;
                }

                throw new Error("Could not confirm write within ".concat(confirmationTimeout, "ms"));

              case 9:
                _context3.next = 11;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, confirmationPollingInterval);
                });

              case 11:
                _context3.next = 13;
                return confirmBlock();

              case 13:
                confirmation = _context3.sent;
                _context3.next = 6;
                break;

              case 16:
                return _context3.abrupt("return", true);

              case 17:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function confirmWrite(_x2) {
        return _confirmWrite.apply(this, arguments);
      }

      return confirmWrite;
    }()
  }, {
    key: "getCurrentBlock",
    value: function () {
      var _getCurrentBlock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var currentBlockNumber;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.web3.eth.getBlockNumber();

              case 2:
                currentBlockNumber = _context4.sent;
                _context4.next = 5;
                return this.web3.eth.getBlock(currentBlockNumber);

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getCurrentBlock() {
        return _getCurrentBlock.apply(this, arguments);
      }

      return getCurrentBlock;
    }()
  }, {
    key: "getRelayEndpoint",
    value: function () {
      var _getRelayEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var useDiscoveryRelay, discoveryEndpoint;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                useDiscoveryRelay = this.config.useDiscoveryRelay;

                if (!(useDiscoveryRelay === undefined || !useDiscoveryRelay)) {
                  _context5.next = 3;
                  break;
                }

                return _context5.abrupt("return", this.config.identityServiceUrl);

              case 3:
                _context5.next = 5;
                return this.discoveryNodeSelector.getSelectedEndpoint();

              case 5:
                discoveryEndpoint = _context5.sent;

                if (!(discoveryEndpoint === null)) {
                  _context5.next = 8;
                  break;
                }

                return _context5.abrupt("return", this.config.identityServiceUrl);

              case 8:
                return _context5.abrupt("return", discoveryEndpoint);

              case 9:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getRelayEndpoint() {
        return _getRelayEndpoint.apply(this, arguments);
      }

      return getRelayEndpoint;
    }()
  }]);

  return EntityManager;
}();

var wait = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(milliseconds) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return new Promise(function (resolve) {
              return setTimeout(resolve, milliseconds);
            });

          case 2:
            return _context.abrupt("return", _context.sent);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function wait(_x) {
    return _ref.apply(this, arguments);
  };
}();

var defaultStorageServiceConfig = {
  logger: new Logger()
};
var MAX_TRACK_TRANSCODE_TIMEOUT = 3600000; // 1 hour

var MAX_IMAGE_RESIZE_TIMEOUT_MS = 5 * 60000; // 5 minutes

var POLL_STATUS_INTERVAL = 3000; // 3s

/**
 * Recursively sorts object keys alphabetically
 */
function sortObjectKeys(x) {
  if (_typeof(x) !== 'object' || !x) {
    return x;
  }

  if (Array.isArray(x)) {
    return x.map(sortObjectKeys);
  }

  return Object.keys(x).sort().reduce(function (o, k) {
    return _objectSpread2(_objectSpread2({}, o), {}, _defineProperty$1({}, k, sortObjectKeys(x[k])));
  }, {});
}

var Storage = /*#__PURE__*/function () {
  /**
   * Configuration passed in by consumer (with defaults)
   */
  function Storage(config) {
    _classCallCheck(this, Storage);

    _defineProperty$1(this, "config", void 0);

    _defineProperty$1(this, "storageNodeSelector", void 0);

    _defineProperty$1(this, "logger", void 0);

    this.config = mergeConfigWithDefaults(config, defaultStorageServiceConfig);
    this.storageNodeSelector = config.storageNodeSelector;
    this.logger = this.config.logger.createPrefixedLogger('[storage]');
  }
  /**
   * Upload a file on content nodes
   * @param uploadId
   * @param data
   * @param auth
   * @returns
   */


  _createClass(Storage, [{
    key: "editFile",
    value: function () {
      var _editFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
        var uploadId, data, auth, signatureData, signature, signatureEnvelope, contentNodeEndpoint, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                uploadId = _ref.uploadId, data = _ref.data, auth = _ref.auth;
                // Generate signature
                signatureData = {
                  upload_id: uploadId,
                  timestamp: Date.now()
                };
                _context.next = 4;
                return auth.hashAndSign(JSON.stringify(sortObjectKeys(signatureData)));

              case 4:
                signature = _context.sent;
                signatureEnvelope = {
                  data: JSON.stringify(signatureData),
                  signature: signature
                };
                _context.next = 8;
                return this.storageNodeSelector.getSelectedNode();

              case 8:
                contentNodeEndpoint = _context.sent;

                if (contentNodeEndpoint) {
                  _context.next = 11;
                  break;
                }

                throw new Error('No content node available for upload');

              case 11:
                _context.next = 13;
                return axios({
                  method: 'post',
                  url: "".concat(contentNodeEndpoint, "/uploads/").concat(uploadId),
                  maxContentLength: Infinity,
                  data: data,
                  params: {
                    signature: JSON.stringify(signatureEnvelope)
                  }
                });

              case 13:
                response = _context.sent;
                _context.next = 16;
                return this.pollProcessingStatus(uploadId, response.data.template === 'audio' ? MAX_TRACK_TRANSCODE_TIMEOUT : MAX_IMAGE_RESIZE_TIMEOUT_MS);

              case 16:
                return _context.abrupt("return", _context.sent);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function editFile(_x) {
        return _editFile.apply(this, arguments);
      }

      return editFile;
    }()
    /**
     * Upload a file to a content node
     * @param file
     * @param onProgress
     * @param template
     * @param options
     * @returns
     */

  }, {
    key: "uploadFile",
    value: function () {
      var _uploadFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {
        var _file$name;

        var file, onProgress, template, _ref2$options, options, formData, contentNodeEndpoint, response;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                file = _ref2.file, onProgress = _ref2.onProgress, template = _ref2.template, _ref2$options = _ref2.options, options = _ref2$options === void 0 ? {} : _ref2$options;
                formData = new FormData$1();
                formData.append('template', template);
                Object.keys(options).forEach(function (key) {
                  formData.append(key, "".concat(options[key]));
                });
                formData.append('files', isNodeFile(file) ? file.buffer : file, (_file$name = file.name) !== null && _file$name !== void 0 ? _file$name : 'blob');
                _context2.next = 7;
                return this.storageNodeSelector.getSelectedNode();

              case 7:
                contentNodeEndpoint = _context2.sent;

                if (contentNodeEndpoint) {
                  _context2.next = 10;
                  break;
                }

                throw new Error('No content node available for upload');

              case 10:
                _context2.next = 12;
                return axios({
                  method: 'post',
                  url: "".concat(contentNodeEndpoint, "/uploads"),
                  maxContentLength: Infinity,
                  data: formData,
                  headers: formData.getBoundary ? {
                    'Content-Type': "multipart/form-data; boundary=".concat(formData.getBoundary())
                  } : undefined,
                  onUploadProgress: function onUploadProgress(progressEvent) {
                    return onProgress === null || onProgress === void 0 ? void 0 : onProgress(progressEvent.loaded, progressEvent.total);
                  }
                });

              case 12:
                response = _context2.sent;
                _context2.next = 15;
                return this.pollProcessingStatus(response.data[0].id, template === 'audio' ? MAX_TRACK_TRANSCODE_TIMEOUT : MAX_IMAGE_RESIZE_TIMEOUT_MS);

              case 15:
                return _context2.abrupt("return", _context2.sent);

              case 16:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function uploadFile(_x2) {
        return _uploadFile.apply(this, arguments);
      }

      return uploadFile;
    }()
    /**
     * Works for both track transcode and image resize jobs
     * @param id ID of the transcode/resize job
     * @param maxPollingMs millis to stop polling and error if job is not done
     * @returns successful job info, or throws error if job fails / times out
     */

  }, {
    key: "pollProcessingStatus",
    value: function () {
      var _pollProcessingStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(id, maxPollingMs) {
        var start, resp, _e$message, _e$response;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                start = Date.now();

              case 1:
                if (!(Date.now() - start < maxPollingMs)) {
                  _context3.next = 21;
                  break;
                }

                _context3.prev = 2;
                _context3.next = 5;
                return this.getProcessingStatus(id);

              case 5:
                resp = _context3.sent;

                if (!((resp === null || resp === void 0 ? void 0 : resp.status) === 'done')) {
                  _context3.next = 8;
                  break;
                }

                return _context3.abrupt("return", resp);

              case 8:
                if (!((resp === null || resp === void 0 ? void 0 : resp.status) === 'error' || (resp === null || resp === void 0 ? void 0 : resp.status) === 'error_retranscode_preview')) {
                  _context3.next = 10;
                  break;
                }

                throw new Error("Upload failed: id=".concat(id, ", resp=").concat(JSON.stringify(resp)));

              case 10:
                _context3.next = 17;
                break;

              case 12:
                _context3.prev = 12;
                _context3.t0 = _context3["catch"](2);

                if (!((_e$message = _context3.t0.message) !== null && _e$message !== void 0 && _e$message.startsWith('Upload failed') || _context3.t0.response && ((_e$response = _context3.t0.response) === null || _e$response === void 0 ? void 0 : _e$response.status) === 422)) {
                  _context3.next = 16;
                  break;
                }

                throw _context3.t0;

              case 16:
                // Swallow errors caused by failure to establish connection to node so we can retry polling
                this.logger.error("Failed to poll for processing status, ".concat(_context3.t0));

              case 17:
                _context3.next = 19;
                return wait(POLL_STATUS_INTERVAL);

              case 19:
                _context3.next = 1;
                break;

              case 21:
                throw new Error("Upload took over ".concat(maxPollingMs, "ms. id=").concat(id));

              case 22:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 12]]);
      }));

      function pollProcessingStatus(_x3, _x4) {
        return _pollProcessingStatus.apply(this, arguments);
      }

      return pollProcessingStatus;
    }()
    /**
     * Gets the task progress given the task type and id associated with the job
     * @param id the id of the transcoding or resizing job
     * @returns the status, and the success or failed response if the job is complete
     */

  }, {
    key: "getProcessingStatus",
    value: function () {
      var _getProcessingStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(id) {
        var contentNodeEndpoint, response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.storageNodeSelector.getSelectedNode();

              case 2:
                contentNodeEndpoint = _context4.sent;
                _context4.next = 5;
                return fetch$1("".concat(contentNodeEndpoint, "/uploads/").concat(id));

              case 5:
                response = _context4.sent;
                _context4.next = 8;
                return response.json();

              case 8:
                return _context4.abrupt("return", _context4.sent);

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getProcessingStatus(_x5) {
        return _getProcessingStatus.apply(this, arguments);
      }

      return getProcessingStatus;
    }()
  }]);

  return Storage;
}();

var NOT_INITIALIZED = 'Auth not initialized - Please provide an apiKey and apiSecret, or a custom implementation of Auth';
var Auth = /*#__PURE__*/_createClass(function Auth() {
  _classCallCheck(this, Auth);

  _defineProperty$1(this, "getSharedSecret", function () {
    throw new Error(NOT_INITIALIZED);
  });

  _defineProperty$1(this, "sign", function () {
    throw new Error(NOT_INITIALIZED);
  });

  _defineProperty$1(this, "hashAndSign", function () {
    throw new Error('Auth not initialized');
  });

  _defineProperty$1(this, "signTransaction", function () {
    throw new Error(NOT_INITIALIZED);
  });

  _defineProperty$1(this, "getAddress", function () {
    throw new Error(NOT_INITIALIZED);
  });
});

/**
 * AuthService for Developer Apps wishing to write on a user's behalf
 */

var AppAuth = /*#__PURE__*/_createClass(function AppAuth(apiKey, apiSecret) {
  var _this = this;

  _classCallCheck(this, AppAuth);

  _defineProperty$1(this, "apiKey", void 0);

  _defineProperty$1(this, "apiSecret", void 0);

  _defineProperty$1(this, "getSharedSecret", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            throw new Error('AppAuth does not support getSharedSecret');

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));

  _defineProperty$1(this, "sign", function () {
    throw new Error('AppAuth does not support sign');
  });

  _defineProperty$1(this, "hashAndSign", function () {
    throw new Error('AppAuth does not support hashAndSign');
  });

  _defineProperty$1(this, "signTransaction", /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(data) {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (_this.apiSecret) {
                _context2.next = 2;
                break;
              }

              throw new Error('AppAuth cannot `signTransaction` because apiSecret was not provided when initializing the SDK.');

            case 2:
              return _context2.abrupt("return", signTypedData(Buffer.from(_this.apiSecret, 'hex'), {
                data: data
              }));

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }());

  _defineProperty$1(this, "getAddress", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", "0x".concat(_this.apiKey));

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  })));

  this.apiKey = apiKey.replace(/^0x/, '');

  if (apiSecret) {
    this.apiSecret = apiSecret.replace(/^0x/, '');
  } else {
    this.apiSecret = null;
  }
});

var DevAppSchema = z.object({
  /**
   * Your app name
   */
  appName: z.optional(z.string()),

  /**
   * Services injection
   */
  services: z.optional(z.custom()),

  /**
   * API key, required for writes
   */
  apiKey: z.string().min(1),

  /**
   * API secret, required for writes
   */
  apiSecret: z.optional(z.string().min(1))
});
var CustomAppSchema = z.object({
  /**
   * Your app name
   */
  appName: z.string().min(1),

  /**
   * Services injection
   */
  services: z.optional(z.custom()),

  /**
   * API key, required for writes
   */
  apiKey: z.optional(z.string().min(1)),

  /**
   * API secret, required for writes
   */
  apiSecret: z.optional(z.string().min(1))
});
var SdkConfigSchema = z.union([DevAppSchema, CustomAppSchema]);

/**
 * The Audius SDK
 */

var sdk = function sdk(config) {
  SdkConfigSchema.parse(config);
  var appName = config.appName,
      apiKey = config.apiKey; // Initialize services

  var services = initializeServices(config); // Initialize APIs

  var apis = initializeApis({
    appName: appName,
    services: services
  }); // Initialize OAuth

  var oauth = typeof window !== 'undefined' ? new OAuth({
    appName: appName,
    apiKey: apiKey,
    usersApi: apis.users,
    logger: services.logger
  }) : undefined;
  return _objectSpread2({
    oauth: oauth
  }, apis);
};

var initializeServices = function initializeServices(config) {
  var _config$services$logg, _config$services, _config$services$stor, _config$services2, _config$services$auth, _config$services3, _config$services$disc, _config$services4, _config$services$disc2, _config$services5;

  var defaultLogger = new Logger();
  var logger = (_config$services$logg = (_config$services = config.services) === null || _config$services === void 0 ? void 0 : _config$services.logger) !== null && _config$services$logg !== void 0 ? _config$services$logg : defaultLogger;

  if (config.apiSecret && isBrowser) {
    logger.warn("apiSecret should only be provided server side so that it isn't exposed");
  }

  var defaultAuthService = config.apiKey ? new AppAuth(config.apiKey, config.apiSecret) : new Auth();
  var defaultDiscoveryNodeSelector = new DiscoveryNodeSelector({
    logger: logger
  });
  var storageNodeSelector = (_config$services$stor = (_config$services2 = config.services) === null || _config$services2 === void 0 ? void 0 : _config$services2.storageNodeSelector) !== null && _config$services$stor !== void 0 ? _config$services$stor : new StorageNodeSelector({
    auth: (_config$services$auth = (_config$services3 = config.services) === null || _config$services3 === void 0 ? void 0 : _config$services3.auth) !== null && _config$services$auth !== void 0 ? _config$services$auth : defaultAuthService,
    discoveryNodeSelector: (_config$services$disc = (_config$services4 = config.services) === null || _config$services4 === void 0 ? void 0 : _config$services4.discoveryNodeSelector) !== null && _config$services$disc !== void 0 ? _config$services$disc : defaultDiscoveryNodeSelector,
    logger: logger
  });
  var defaultEntityManager = new EntityManager(_objectSpread2(_objectSpread2({}, defaultEntityManagerConfig), {}, {
    discoveryNodeSelector: (_config$services$disc2 = (_config$services5 = config.services) === null || _config$services5 === void 0 ? void 0 : _config$services5.discoveryNodeSelector) !== null && _config$services$disc2 !== void 0 ? _config$services$disc2 : defaultDiscoveryNodeSelector
  }));
  var defaultStorage = new Storage({
    storageNodeSelector: storageNodeSelector,
    logger: logger
  });
  var defaultServices = {
    storageNodeSelector: storageNodeSelector,
    discoveryNodeSelector: defaultDiscoveryNodeSelector,
    entityManager: defaultEntityManager,
    storage: defaultStorage,
    auth: defaultAuthService,
    logger: logger
  };
  return _objectSpread2(_objectSpread2({}, defaultServices), config.services);
};

var initializeApis = function initializeApis(_ref) {
  var appName = _ref.appName,
      services = _ref.services;
  var middleware = [addAppNameMiddleware({
    appName: appName,
    services: services
  }), services.discoveryNodeSelector.createMiddleware()];
  var generatedApiClientConfig = new Configuration$1({
    fetchApi: fetch$1,
    middleware: middleware
  });
  var tracks = new TracksApi$1(generatedApiClientConfig, services.discoveryNodeSelector, services.storage, services.entityManager, services.auth, services.logger);
  var users = new UsersApi$1(generatedApiClientConfig, services.storage, services.entityManager, services.auth, services.logger);
  var albums = new AlbumsApi(generatedApiClientConfig, services.storage, services.entityManager, services.auth, services.logger);
  var playlists = new PlaylistsApi$1(generatedApiClientConfig, services.storage, services.entityManager, services.auth, services.logger);
  var tips = new TipsApi$1(generatedApiClientConfig);

  var _ResolveApi = new ResolveApi(generatedApiClientConfig),
      resolve = _ResolveApi.resolve;

  var chats = new ChatsApi(new Configuration$1({
    fetchApi: fetch$1,
    basePath: '',
    middleware: middleware
  }), services.auth, services.discoveryNodeSelector, services.logger);
  var grants = new GrantsApi(generatedApiClientConfig, services.entityManager, services.auth);
  var developerApps = new DeveloperAppsApi(generatedApiClientConfig, services.entityManager, services.auth);
  var generatedApiClientConfigFull = new Configuration({
    fetchApi: fetch$1,
    middleware: middleware
  });
  var full = {
    tracks: new TracksApi(generatedApiClientConfigFull),
    users: new UsersApi(generatedApiClientConfigFull),
    search: new SearchApi(generatedApiClientConfigFull),
    playlists: new PlaylistsApi(generatedApiClientConfigFull),
    reactions: new ReactionsApi(generatedApiClientConfigFull),
    tips: new TipsApi(generatedApiClientConfigFull),
    transactions: new TransactionsApi(generatedApiClientConfigFull)
  };
  return {
    tracks: tracks,
    users: users,
    albums: albums,
    playlists: playlists,
    tips: tips,
    resolve: resolve,
    full: full,
    chats: chats,
    grants: grants,
    developerApps: developerApps
  };
};

export { ALLOWED_AUDIO_MIME_TYPES, ALLOWED_IMAGE_MIME_TYPES, ActivityFromJSON, ActivityFromJSONTyped, ActivityToJSON, AddTrackToPlaylistSchema, AlbumsApi, AppAuth, AudioFile, Auth, AuthorizedAppFromJSON, AuthorizedAppFromJSONTyped, AuthorizedAppToJSON, AuthorizedAppsFromJSON, AuthorizedAppsFromJSONTyped, AuthorizedAppsToJSON, BASE_PATH$1 as BASE_PATH, BaseAPI$1 as BaseAPI, BlobApiResponse$1 as BlobApiResponse, COLLECTION_FORMATS$1 as COLLECTION_FORMATS, ChatBlockRequestSchema, ChatCreateRequestSchema, ChatDeleteRequestSchema, ChatGetAllRequestSchema, ChatGetBlockersRequestSchema, ChatGetMessagesRequestSchema, ChatGetPermissionRequestSchema, ChatGetRequestSchema, ChatGetUnreadCountRequestSchema, ChatInviteRequestSchema, ChatListenRequestSchema, ChatMessageRequestSchema, ChatPermission, ChatPermitRequestSchema, ChatReactRequestSchema, ChatReadRequestSchema, ChatUnfurlRequestSchema, ChatValidateCanCreateRequestSchema, Configuration$1 as Configuration, ConnectedWalletsFromJSON, ConnectedWalletsFromJSONTyped, ConnectedWalletsResponseFromJSON, ConnectedWalletsResponseFromJSONTyped, ConnectedWalletsResponseToJSON, ConnectedWalletsToJSON, CoverPhotoFromJSON$1 as CoverPhotoFromJSON, CoverPhotoFromJSONTyped$1 as CoverPhotoFromJSONTyped, CoverPhotoToJSON$1 as CoverPhotoToJSON, CreateDeveloperAppSchema, CreateGrantSchema, CreatePlaylistSchema, CrossPlatformFileSchema, DECISION_TREE_STATE, DecodedUserTokenFromJSON, DecodedUserTokenFromJSONTyped, DecodedUserTokenToJSON, DefaultConfig$1 as DefaultConfig, DeleteAlbumSchema, DeleteDeveloperAppSchema, DeletePlaylistSchema, DeleteTrackSchema, DeveloperAppFromJSON, DeveloperAppFromJSONTyped, DeveloperAppResponseFromJSON, DeveloperAppResponseFromJSONTyped, DeveloperAppResponseToJSON, DeveloperAppToJSON, DeveloperAppsApi, DeveloperAppsFromJSON, DeveloperAppsFromJSONTyped, DeveloperAppsToJSON, DiscoveryNodeSelector, EncodedUserIdFromJSON, EncodedUserIdFromJSONTyped, EncodedUserIdToJSON, EntityManager, FavoriteAlbumSchema, FavoriteFromJSON$1 as FavoriteFromJSON, FavoriteFromJSONTyped$1 as FavoriteFromJSONTyped, FavoritePlaylistSchema, FavoriteToJSON$1 as FavoriteToJSON, FavoriteTrackSchema, FavoritesResponseFromJSON, FavoritesResponseFromJSONTyped, FavoritesResponseToJSON, FetchError$1 as FetchError, FollowUserSchema, FollowersResponseFromJSON, FollowersResponseFromJSONTyped, FollowersResponseToJSON, FollowingResponseFromJSON$1 as FollowingResponseFromJSON, FollowingResponseFromJSONTyped$1 as FollowingResponseFromJSONTyped, FollowingResponseToJSON$1 as FollowingResponseToJSON, Genre, GetAIAttributedTracksByUserHandleFilterTracksEnum$1 as GetAIAttributedTracksByUserHandleFilterTracksEnum, GetAIAttributedTracksByUserHandleSortDirectionEnum$1 as GetAIAttributedTracksByUserHandleSortDirectionEnum, GetAIAttributedTracksByUserHandleSortEnum$1 as GetAIAttributedTracksByUserHandleSortEnum, GetAIAttributedTracksByUserHandleSortMethodEnum$1 as GetAIAttributedTracksByUserHandleSortMethodEnum, GetAudioTransactionHistorySortDirectionEnum, GetAudioTransactionHistorySortMethodEnum, GetSupportersFromJSON, GetSupportersFromJSONTyped, GetSupportersToJSON, GetSupportingFromJSON, GetSupportingFromJSONTyped, GetSupportingToJSON, GetTipsCurrentUserFollowsEnum$1 as GetTipsCurrentUserFollowsEnum, GetTipsResponseFromJSON$1 as GetTipsResponseFromJSON, GetTipsResponseFromJSONTyped$1 as GetTipsResponseFromJSONTyped, GetTipsResponseToJSON$1 as GetTipsResponseToJSON, GetTipsUniqueByEnum$1 as GetTipsUniqueByEnum, GetTracksByUserFilterTracksEnum$1 as GetTracksByUserFilterTracksEnum, GetTracksByUserSortDirectionEnum$1 as GetTracksByUserSortDirectionEnum, GetTracksByUserSortEnum$1 as GetTracksByUserSortEnum, GetTracksByUserSortMethodEnum$1 as GetTracksByUserSortMethodEnum, GetTrendingPlaylistsTimeEnum$1 as GetTrendingPlaylistsTimeEnum, GetTrendingTracksTimeEnum$1 as GetTrendingTracksTimeEnum, GrantsApi, HashId, ImageFile, JSONApiResponse$1 as JSONApiResponse, Logger, Mood, ParseRequestError, PlaylistAddedTimestampFromJSON$1 as PlaylistAddedTimestampFromJSON, PlaylistAddedTimestampFromJSONTyped$1 as PlaylistAddedTimestampFromJSONTyped, PlaylistAddedTimestampToJSON$1 as PlaylistAddedTimestampToJSON, PlaylistArtworkFromJSON$1 as PlaylistArtworkFromJSON, PlaylistArtworkFromJSONTyped$1 as PlaylistArtworkFromJSONTyped, PlaylistArtworkToJSON$1 as PlaylistArtworkToJSON, PlaylistFromJSON, PlaylistFromJSONTyped, PlaylistResponseFromJSON, PlaylistResponseFromJSONTyped, PlaylistResponseToJSON, PlaylistSearchResultFromJSON, PlaylistSearchResultFromJSONTyped, PlaylistSearchResultToJSON, PlaylistToJSON, PlaylistTracksResponseFromJSON, PlaylistTracksResponseFromJSONTyped, PlaylistTracksResponseToJSON, PlaylistsApi$1 as PlaylistsApi, PremiumConditionsEthNFTCollection, PremiumConditionsFollowUserId, PremiumConditionsNFTCollection, PremiumConditionsSolNFTCollection, PremiumConditionsTipUserId, ProfilePictureFromJSON$1 as ProfilePictureFromJSON, ProfilePictureFromJSONTyped$1 as ProfilePictureFromJSONTyped, ProfilePictureToJSON$1 as ProfilePictureToJSON, PublishPlaylistSchema, RelatedArtistResponseFromJSON, RelatedArtistResponseFromJSONTyped, RelatedArtistResponseToJSON, RemixParentFromJSON, RemixParentFromJSONTyped, RemixParentToJSON, RemoveTrackFromPlaylistSchema, RendezvousHash, RepostAlbumSchema, RepostPlaylistSchema, RepostTrackSchema, RepostsFromJSON, RepostsFromJSONTyped, RepostsToJSON, RequiredError$1 as RequiredError, ResolveApi, ResponseError$1 as ResponseError, RevokeGrantSchema, Storage, StorageNodeSelector, SubscribeToUserSchema, SubscribersResponseFromJSON, SubscribersResponseFromJSONTyped, SubscribersResponseToJSON, SupporterFromJSON, SupporterFromJSONTyped, SupporterToJSON, SupportingFromJSON, SupportingFromJSONTyped, SupportingToJSON, TagsResponseFromJSON, TagsResponseFromJSONTyped, TagsResponseToJSON, TextApiResponse$1 as TextApiResponse, TipFromJSON, TipFromJSONTyped, TipToJSON, TipsApi$1 as TipsApi, TrackArtworkFromJSON$1 as TrackArtworkFromJSON, TrackArtworkFromJSONTyped$1 as TrackArtworkFromJSONTyped, TrackArtworkToJSON$1 as TrackArtworkToJSON, TrackElementFromJSON, TrackElementFromJSONTyped, TrackElementToJSON, TrackFromJSON, TrackFromJSONTyped, TrackResponseFromJSON, TrackResponseFromJSONTyped, TrackResponseToJSON, TrackSearchFromJSON, TrackSearchFromJSONTyped, TrackSearchToJSON, TrackToJSON, TracksApi$1 as TracksApi, TracksResponseFromJSON, TracksResponseFromJSONTyped, TracksResponseToJSON, TrendingPlaylistsResponseFromJSON, TrendingPlaylistsResponseFromJSONTyped, TrendingPlaylistsResponseToJSON, UnfavoriteAlbumSchema, UnfavoritePlaylistSchema, UnfavoriteTrackSchema, UnfollowUserSchema, UnrepostAlbumSchema, UnrepostPlaylistSchema, UnrepostTrackSchema, UnsubscribeFromUserSchema, UpdateProfileSchema, UserAssociatedWalletResponseFromJSON, UserAssociatedWalletResponseFromJSONTyped, UserAssociatedWalletResponseToJSON, UserFromJSON, UserFromJSONTyped, UserResponseFromJSON, UserResponseFromJSONTyped, UserResponseToJSON, UserSearchFromJSON, UserSearchFromJSONTyped, UserSearchToJSON, UserToJSON, UsersApi$1 as UsersApi, VerifyTokenFromJSON, VerifyTokenFromJSONTyped, VerifyTokenToJSON, VoidApiResponse$1 as VoidApiResponse, canConsumeForm$1 as canConsumeForm, createUpdateAlbumSchema, createUpdatePlaylistMetadataSchema, createUpdatePlaylistSchema, createUpdateTrackSchema, createUploadAlbumMetadataSchema, createUploadAlbumSchema, createUploadPlaylistSchema, createUploadTrackMetadataSchema, createUploadTrackSchema, servicesConfig$2 as developmentConfig, exists$1 as exists, index as full, getAlbumSchema, getAlbumTracksSchema, instanceOfActivity, instanceOfAuthorizedApp, instanceOfAuthorizedApps, instanceOfConnectedWallets, instanceOfConnectedWalletsResponse, instanceOfCoverPhoto$1 as instanceOfCoverPhoto, instanceOfDecodedUserToken, instanceOfDeveloperApp, instanceOfDeveloperAppResponse, instanceOfDeveloperApps, instanceOfEncodedUserId, instanceOfFavorite$1 as instanceOfFavorite, instanceOfFavoritesResponse, instanceOfFollowersResponse, instanceOfFollowingResponse$1 as instanceOfFollowingResponse, instanceOfGetSupporters, instanceOfGetSupporting, instanceOfGetTipsResponse$1 as instanceOfGetTipsResponse, instanceOfPlaylist, instanceOfPlaylistAddedTimestamp$1 as instanceOfPlaylistAddedTimestamp, instanceOfPlaylistArtwork$1 as instanceOfPlaylistArtwork, instanceOfPlaylistResponse, instanceOfPlaylistSearchResult, instanceOfPlaylistTracksResponse, instanceOfProfilePicture$1 as instanceOfProfilePicture, instanceOfRelatedArtistResponse, instanceOfRemixParent, instanceOfReposts, instanceOfSubscribersResponse, instanceOfSupporter, instanceOfSupporting, instanceOfTagsResponse, instanceOfTip, instanceOfTrack, instanceOfTrackArtwork$1 as instanceOfTrackArtwork, instanceOfTrackElement, instanceOfTrackResponse, instanceOfTrackSearch, instanceOfTracksResponse, instanceOfTrendingPlaylistsResponse, instanceOfUser, instanceOfUserAssociatedWalletResponse, instanceOfUserResponse, instanceOfUserSearch, instanceOfVerifyToken, isNodeFile, mapValues$1 as mapValues, servicesConfig as productionConfig, querystring$1 as querystring, sdk, servicesConfig$1 as stagingConfig };
//# sourceMappingURL=index.native.js.map
